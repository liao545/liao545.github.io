{"title":"南京大学软件分析--介绍","uid":"d82e0720104dc3bfe88e058fc58082b0","slug":"南京大学软件分析-介绍","date":"2022-12-20T07:58:53.000Z","updated":"2022-12-20T08:06:19.185Z","comments":true,"path":"api/articles/南京大学软件分析-介绍.json","keywords":null,"cover":[],"content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<p>B站教程地址：<a href=\"https://www.bilibili.com/video/BV1b7411K7P4/?spm_id_from=333.999.0.0&amp;vd_source=6632b385bcaaeb6eb7c62e69b2587a3e\">https://www.bilibili.com/video/BV1b7411K7P4/?spm_id_from=333.999.0.0&amp;vd_source=6632b385bcaaeb6eb7c62e69b2587a3e</a></p>\n<p>英文文档地址：<a href=\"https://pascal-group.bitbucket.io/lectures/introduction.pdf\">https://pascal-group.bitbucket.io/lectures/introduction.pdf</a></p>\n<p>Tai-e作业文档地址：<a href=\"https://tai-e.pascal-lab.net/intro/overview.html\">https://tai-e.pascal-lab.net/intro/overview.html</a></p>\n<p><strong>PL：Programming Languages</strong></p>\n<h2 id=\"Why-we-need-static-analysis？\"><a href=\"#Why-we-need-static-analysis？\" class=\"headerlink\" title=\"Why we need static analysis？\"></a>Why we need static analysis？</h2><p>• Program Reliability Null pointer dereference, memory leak, etc. </p>\n<p>• Program Security Private information leak, injection attack, etc. </p>\n<p>• Compiler Optimization Dead code elimination, code motion, etc. </p>\n<p>• Program Understanding IDE call hierarchy, type indication, etc.  </p>\n<h2 id=\"Pice’s-Theorem：\"><a href=\"#Pice’s-Theorem：\" class=\"headerlink\" title=\"Pice’s Theorem：\"></a>Pice’s Theorem：</h2><p>目前编程语言写的程序，是不存在完美的静态分析方法的。</p>\n<p> non-trivial properties </p>\n<p>~= interesting properties </p>\n<p>~= the properties related with run-time behaviors of programs  </p>\n<p>也就是说，用静态分析方法去分析程序，可能分析结果超过（sound）真正的漏洞结果数目（truth），但是sound内的结果一定包含truth的结果，也就是在检测所有漏洞的基础上还存在多余的误报。也可能分析结果低于（complete）真正的漏洞结果数目（truth），但是complete的结果一定是truth里面的，也就是complete的检测结果都是正确的，可还是存在未能检测的漏洞。</p>\n<h3 id=\"Perfect-static-analysis：\"><a href=\"#Perfect-static-analysis：\" class=\"headerlink\" title=\"Perfect static analysis：\"></a>Perfect static analysis：</h3><p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/91.png\"></p>\n<h3 id=\"Useful-static-analysis：\"><a href=\"#Useful-static-analysis：\" class=\"headerlink\" title=\"Useful static analysis：\"></a>Useful static analysis：</h3><p>前面Pice’s Theorem说了，不存在完美的静态分析。所以出现了useful static analysis（有用的静态分析）。</p>\n<p>分为两种，是or（或）关系：</p>\n<ol>\n<li>Compromise soundness（false negatives）妥协/损害 sound，存在漏报。也就是不再是全部包含正确漏洞结果并且多了。而是不完全包含正确漏洞存在错误的漏洞。</li>\n<li>Compromise completeness（false positives）妥协/损害 complete，存在误报。也就是结果不在全是正确的漏洞并且少了。而是不全是正确的漏洞存在错误的漏洞。</li>\n</ol>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/92.png\"></p>\n<p>注：这个图没有画出误报和漏报的范围</p>\n<p><strong>在实际静态分析中，都是损害completeness。</strong></p>\n<h3 id=\"为什么实际分析都是Compromise-completeness（存在误报）？\"><a href=\"#为什么实际分析都是Compromise-completeness（存在误报）？\" class=\"headerlink\" title=\"为什么实际分析都是Compromise completeness（存在误报）？\"></a>为什么实际分析都是Compromise completeness（存在误报）？</h3><p>在实际检测中如果不满足sound的检测是不完全的检测就可能会得出错误的结果：</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/93.png\"></p>\n<p>当只看蓝色路径会得出下面的类型转换是安全的，但是当将蓝色和绿色路径一起看也就是满足sound就会得出类型转换是不安全的。</p>\n<p>所以soundness在实际的静态分析中是及其重要的。满足soundness也就代表者存在误报的可能。</p>\n<h2 id=\"静态and动态：\"><a href=\"#静态and动态：\" class=\"headerlink\" title=\"静态and动态：\"></a>静态and动态：</h2><p>用实际例子来描述什么是静态分析思维，什么是动态分析思维。</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/94.png\"></p>\n<p>给图中那段程序，现在要求分析的结果是1还是2？</p>\n<p>静态思维：只要要将所有结果列出不需要满足每个结果的条件，也就是2。</p>\n<p>动态思维：满足什么条件得到什么结果，也就是按照程序的行走路径得出结果，就是1。</p>\n<p>再有两种结果：</p>\n<ol>\n<li>x=1 or x=2 or x=….</li>\n<li>x=-1 or x=1 </li>\n</ol>\n<p>按照静态分析的角度，满足sound的就是正确的结果。所以3是正确的，4是错误的。</p>\n<p>图中的两种结果按照静态分析来看都是正确的，但是1的结果明显是更加精确，却会耗费更多的资源也就是更加昂贵。2的结果虽然不精确却不会耗费太多资源也就是更便宜。</p>\n<p>所以真实的静态分析就是在确保sound的情况下，对精度和速度做好有效的平衡。</p>\n<h2 id=\"Two-Key-Words：\"><a href=\"#Two-Key-Words：\" class=\"headerlink\" title=\"Two Key Words：\"></a>Two Key Words：</h2><h3 id=\"Abstraction：\"><a href=\"#Abstraction：\" class=\"headerlink\" title=\"Abstraction：\"></a>Abstraction：</h3><p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/95.png\"></p>\n<p>这个例子要分析代码中所有变量的符号。既然有代码，必然存在具体的符号相关代码，也就是具体域。而静态分析的Abstraction则是将代码中的具体域变成如图的抽象域。</p>\n<p>静态分析需要满足sound。前面的+，-，0都可以理解，后面的T符号表示未知，也就是在实际代码中v变量存在+或-两种情况，这两种情况都在正常符号范围内，所以定义成T。而最下面的变量v的表达式是w/0，这种表达式是错误的，所以其符号未定义，所以将其在抽象域中用undefined表示。这样就满足了静态分析的sound。</p>\n<h3 id=\"Over-appproximation：\"><a href=\"#Over-appproximation：\" class=\"headerlink\" title=\"Over-appproximation：\"></a>Over-appproximation：</h3><h4 id=\"Transfer-Functions：\"><a href=\"#Transfer-Functions：\" class=\"headerlink\" title=\"Transfer Functions：\"></a>Transfer Functions：</h4><p>这时近似的第一步，根据分析的问题定义传递函数，列出可能的表达式。最后将其运用到实际的代码中。</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/96.png\"></p>\n<p>按照上面的表达式，运用到实际的代码中：</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/97.png\"></p>\n<p>其中q是undefined，按照弹幕的说法是：错误就是bottom的。</p>\n<p>找出其中的漏洞，也就是存在问题的地方。为图上的1，2，3。其中1，2在验证后发现是正确的漏洞。而3在验证后是错误的漏洞，也就是误报。符合静态分析的定义。</p>\n<h4 id=\"Control-Flows：\"><a href=\"#Control-Flows：\" class=\"headerlink\" title=\"Control Flows：\"></a>Control Flows：</h4><p>所有程序流汇聚的点要将其抽象。</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/98.png\"></p>\n<p>用的是最前面的那个列子。其中z=x+y是程序控制流的汇聚点，要将其抽象。它有两种可能，都是正确的符号，所以其抽象为T。</p>\n<p>因为实际情况下不可能枚举所有的可能，所以采用流合并的方式。</p>\n","text":" B站教程地址：https://www.bilibili.com/video/BV1b7411K7P4/?spm_id_from=333.999.0.0&amp;vd_source=6632b385bcaaeb6eb7c62e69b2587a3e 英文文档地址：https://p...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"软件分析","slug":"软件分析","count":1,"path":"api/categories/软件分析.json"}],"tags":[{"name":"软件分析","slug":"软件分析","count":1,"path":"api/tags/软件分析.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Why-we-need-static-analysis%EF%BC%9F\"><span class=\"toc-text\">Why we need static analysis？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pice%E2%80%99s-Theorem%EF%BC%9A\"><span class=\"toc-text\">Pice’s Theorem：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Perfect-static-analysis%EF%BC%9A\"><span class=\"toc-text\">Perfect static analysis：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Useful-static-analysis%EF%BC%9A\"><span class=\"toc-text\">Useful static analysis：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%9E%E9%99%85%E5%88%86%E6%9E%90%E9%83%BD%E6%98%AFCompromise-completeness%EF%BC%88%E5%AD%98%E5%9C%A8%E8%AF%AF%E6%8A%A5%EF%BC%89%EF%BC%9F\"><span class=\"toc-text\">为什么实际分析都是Compromise completeness（存在误报）？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81and%E5%8A%A8%E6%80%81%EF%BC%9A\"><span class=\"toc-text\">静态and动态：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Two-Key-Words%EF%BC%9A\"><span class=\"toc-text\">Two Key Words：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Abstraction%EF%BC%9A\"><span class=\"toc-text\">Abstraction：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Over-appproximation%EF%BC%9A\"><span class=\"toc-text\">Over-appproximation：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Transfer-Functions%EF%BC%9A\"><span class=\"toc-text\">Transfer Functions：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Control-Flows%EF%BC%9A\"><span class=\"toc-text\">Control Flows：</span></a></li></ol></li></ol></li></ol>","author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"V2board-1.6.1-提权漏洞","uid":"012af26b8a1c40c6035cf47689fa91dd","slug":"V2board-1-6-1-提权漏洞复现","date":"2022-12-19T05:27:27.000Z","updated":"2022-12-19T08:26:31.537Z","comments":true,"path":"api/articles/V2board-1-6-1-提权漏洞复现.json","keywords":null,"cover":[],"text":" vulhub靶场文章：https://github.com/vulhub/vulhub/blob/master/v2board/1.6-privilege-escalation/README.zh-cn.md PHP写的机场，就复现看看。 原理就是认证使用了缓存里的信息，但是没...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"逻辑漏洞","slug":"逻辑漏洞","count":1,"path":"api/categories/逻辑漏洞.json"}],"tags":[{"name":"PHP","slug":"PHP","count":7,"path":"api/tags/PHP.json"}],"author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}