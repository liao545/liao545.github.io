{"title":"Java反射笔记","uid":"a87dfbaadf5431aac0df9631c18a8ee5","slug":"Java反射笔记","date":"2022-09-05T11:36:43.000Z","updated":"2022-09-05T12:22:46.244Z","comments":true,"path":"api/articles/Java反射笔记.json","keywords":null,"cover":null,"content":"<p>参考资料：</p>\n<p>廖雪峰老师Java教程   反射</p>\n<p><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1255945147512512\">https://www.liaoxuefeng.com/wiki/1252599548343744/1255945147512512</a></p>\n<p>p牛Java安全漫谈  反射篇1，2，3</p>\n<p><a href=\"https://t.zsxq.com/056qbMzVV\">https://t.zsxq.com/056qbMzVV</a></p>\n<p><a href=\"https://t.zsxq.com/05BiAyF6Y\">https://t.zsxq.com/05BiAyF6Y</a></p>\n<p><a href=\"https://t.zsxq.com/05yrbEQVb\">https://t.zsxq.com/05yrbEQVb</a></p>\n<h1 id=\"常见的两种可以通过反射执行命令的类\"><a href=\"#常见的两种可以通过反射执行命令的类\" class=\"headerlink\" title=\"常见的两种可以通过反射执行命令的类\"></a>常见的两种可以通过反射执行命令的类</h1><ol>\n<li>java.lang.Runtime</li>\n<li>java.lang.ProcessBuilder</li>\n</ol>\n<h2 id=\"正常反射调用public方法-无参构造方法\"><a href=\"#正常反射调用public方法-无参构造方法\" class=\"headerlink\" title=\"正常反射调用public方法   无参构造方法\"></a>正常反射调用public方法   无参构造方法</h2><p>通过Method调用，能获取所有public方法，和父类中的方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.lang.reflect.Method;\n\nClass clazz &#x3D; Class.forName(&quot;java.lang.Runtime&quot;);\n\nMethod execMethod &#x3D; clazz.getMethod(&quot;exec&quot;, String.class);\n\nMethod getRuntimeMethod &#x3D; clazz.getMethod(&quot;getRuntime&quot;);\n\nObject runtime &#x3D; getRuntimeMethod.invoke(clazz);\n\nexecMethod.invoke(runtime, &quot;calc.exe&quot;);</code></pre>\n\n<p>按照反射原理，正常创建类实例，之后通过类实例获取类方法，再通过获取到的类方法执行命令，通过invoke()进行执行。</p>\n<p>反射其实在编译时，就是正常的类的实例化和正常的方法调用</p>\n<h2 id=\"通过反射调用ProcessBuilder执行命令-有参构造方法\"><a href=\"#通过反射调用ProcessBuilder执行命令-有参构造方法\" class=\"headerlink\" title=\"通过反射调用ProcessBuilder执行命令    有参构造方法\"></a>通过反射调用ProcessBuilder执行命令    有参构造方法</h2><h3 id=\"使用public-ProcessBuilder-List-command\"><a href=\"#使用public-ProcessBuilder-List-command\" class=\"headerlink\" title=\"使用public ProcessBuilder(List command)\"></a>使用public ProcessBuilder(List<String> command)</h3><p>这里使用Constructor进行反射调用，Constructor接收的参数为构造方法，通过Constructor可以实例化带参数的构造方法的类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Method;\n\nimport java.util.Arrays;\n\nimport java.util.List;\n\nClass clazz &#x3D; Class.forName(&quot;java.lang.ProcessBuilder&quot;);\n\n   \t\t&#x2F;&#x2F;强制转换类型调用\n\n    \t((ProcessBuilder)clazz.getConstructor(List.class).newInstance(\n\n    \t\t\tArrays.asList(&quot;calc.exe&quot;))).start();\n\n    \tclazz.getMethod(&quot;start&quot;).invoke(clazz.getConstructor(List.class).newInstance(\n\n   \t\t\tArrays.asList(&quot;calc.exe&quot;)));</code></pre>\n\n<h3 id=\"public-ProcessBuilder-String…-command\"><a href=\"#public-ProcessBuilder-String…-command\" class=\"headerlink\" title=\"public ProcessBuilder(String… command)\"></a>public ProcessBuilder(String… command)</h3><p>这里调用该类中另一种构造方法进行类实例</p>\n<p>该构造方法采用可变长参数（varargs）  </p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Method;\n\nimport java.util.Arrays;\n\nimport java.util.List;\n\nClass clazz &#x3D; Class.forName(&quot;java.lang.ProcessBuilder&quot;);\n\n​    \t((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(\n\n​    \t\t\tnew String[][]&#123;&#123;&quot;cmd&quot;,&quot;calc.exe&quot;&#125;&#125;)).start();\n\n​    \tclazz.getMethod(&quot;start&quot;).invoke(clazz.getConstructor(String[].class).newInstance(\n\n​    \tnew String[][] &#123;&#123;&quot;calc.exe&quot;&#125;&#125;));\n\n​    \t&#x2F;&#x2F;球友写的，完全反射，但是一样的问题\n\n​    \t&#x2F;&#x2F;Class clazz &#x3D; Class.forName(&quot;java.lang.ProcessBuilder&quot;);\n\n​    \t&#x2F;&#x2F;Constructor constructor &#x3D; clazz.getConstructor(String[].class);\n\n​    \t&#x2F;&#x2F;Object o &#x3D; constructor.newInstance(new String[][]&#123;&#123;&quot;calc.exe&quot;&#125;&#125;);\n\n​    \t&#x2F;&#x2F;clazz.getMethod(&quot;start&quot;).invoke(o);</code></pre>\n\n\n\n<p>其中复现执行命令，发现 java.lang.ProcessBuilder 在进行</p>\n<p> public ProcessBuilder(String… command）   有错误，无法复现</p>\n<p>构造函数调用时，会爆出 </p>\n<p>Exception in thread “main” java.lang.IllegalArgumentException: argument type mismatch</p>\n<h4 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h4><p>参考文章：<a href=\"https://blog.csdn.net/qq_21383435/article/details/108277906\">https://blog.csdn.net/qq_21383435/article/details/108277906</a></p>\n<p>文章参考的是：<a href=\"https://www.cnblogs.com/huqingchen/p/5979936.html\">https://www.cnblogs.com/huqingchen/p/5979936.html</a></p>\n<p>文中提到反射调用可变参数方法是，必须要保证输入参数的数组长度为1</p>\n<p>原文：//可变参数必须这样封装，因为java反射内部实现做了参数个数为1的判断，如果参数长度不为1，则会抛出异常</p>\n<p>所以要按照下面这么写</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String[] a &#x3D; &#123;&quot;calc.exe&quot;&#125;;\n\n​    \tObject[] b &#x3D; &#123;a&#125;;\n\n​    \tclazz.getMethod(&quot;start&quot;).invoke(clazz.getConstructor(String[].class).newInstance(\n\n​    \t b));</code></pre>\n\n\n\n<h2 id=\"使用getDeclaredConstructor-反射调用私有的方法\"><a href=\"#使用getDeclaredConstructor-反射调用私有的方法\" class=\"headerlink\" title=\"使用getDeclaredConstructor()反射调用私有的方法\"></a>使用getDeclaredConstructor()反射调用私有的方法</h2><p> getDeclaredMethod 系列方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私有的方法，但从父类里继承来的就不包含了     </p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Method;\n\nimport java.util.Arrays;\n\nimport java.util.List;\n\n​    \tClass clazz &#x3D; Class.forName(&quot;java.lang.Runtime&quot;);\n\n​    \tConstructor m &#x3D; clazz.getDeclaredConstructor();\n\n​    \tm.setAccessible(true);\n\n​    \tclazz.getMethod(&quot;exec&quot;, String.class).invoke(m.newInstance(), &quot;calc.exe&quot;);</code></pre>\n\n<p>这里又有问题，虽然设置了setAccessible为true，但是运行的时候还是报错，私有方法不可被调用</p>\n<p>在廖雪峰老师的教程中提到过虽然设置了setAccessible为true，但可能还是会有问题，就是不能访问</p>\n<p>原文：此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。</p>\n<h4 id=\"解决方法-1\"><a href=\"#解决方法-1\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h4><p>查看本机java版本是1.8- 3.2.1猜测可能是java版本过高</p>\n<p>去采用虚拟机里的1.8-2.x.x编译执行，成功执行命令</p>\n<p>测试本机命令行执行时发现，提示找不到主类</p>\n<p>再去除包名后重新编译，发现主机还是不能执行</p>\n<p>测试得出结论就是环境问题，同一个class文件，虚拟机能执行，主机不能执行</p>\n","text":"参考资料： 廖雪峰老师Java教程 反射 https://www.liaoxuefeng.com/wiki/1252599548343744/1255945147512512 p牛Java安全漫谈 反射篇1，2，3 https://t.zsxq.com/056qbMzVV htt...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"Java安全","slug":"Java安全","count":11,"path":"api/categories/Java安全.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84%E7%B1%BB\"><span class=\"toc-text\">常见的两种可以通过反射执行命令的类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AD%A3%E5%B8%B8%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8public%E6%96%B9%E6%B3%95-%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">正常反射调用public方法   无参构造方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8ProcessBuilder%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4-%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">通过反射调用ProcessBuilder执行命令    有参构造方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8public-ProcessBuilder-List-command\"><span class=\"toc-text\">使用public ProcessBuilder(List command)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#public-ProcessBuilder-String%E2%80%A6-command\"><span class=\"toc-text\">public ProcessBuilder(String… command)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">解决方法</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8getDeclaredConstructor-%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E7%A7%81%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">使用getDeclaredConstructor()反射调用私有的方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-1\"><span class=\"toc-text\">解决方法</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Java RMI笔记","uid":"fb61931117f747252b543f33903e3e6d","slug":"Java-RMI笔记","date":"2022-09-05T11:38:51.000Z","updated":"2022-09-05T11:52:31.086Z","comments":true,"path":"api/articles/Java-RMI笔记.json","keywords":null,"cover":null,"text":"参考资料：廖雪峰老师 Java教程 RMI https://www.liaoxuefeng.com/wiki/1252599548343744/1323711850348577 p牛 Java安全漫谈456 RMI https://t.zsxq.com/052Nj62Jq htt...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"Java安全","slug":"Java安全","count":11,"path":"api/categories/Java安全.json"}],"tags":[{"name":"Java","slug":"Java","count":21,"path":"api/tags/Java.json"}],"author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"免杀入门-小迪笔记","uid":"170904693726acf3c72f07df195a2a4e","slug":"免杀入门-小迪笔记","date":"2022-09-05T11:23:50.000Z","updated":"2022-09-05T11:32:27.989Z","comments":true,"path":"api/articles/免杀入门-小迪笔记.json","keywords":null,"cover":null,"text":"杀软检测方式在shellcode代码中包含了服务器的IP及监听端口，直接使用shellcode上线会被杀软检测到 免杀常见初始思路加载方式修改各种shellcode加载方式达到免杀效果 如常见加载器项目：Callback_Shellcode_Injection https://g...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"python","slug":"python","count":2,"path":"api/categories/python.json"}],"tags":[{"name":"免杀","slug":"免杀","count":2,"path":"api/tags/免杀.json"}],"author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}